var YV = Object.defineProperty;
var zV = (e, t, n) => t in e ? YV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Gu = (e, t, n) => (zV(e, typeof t != "symbol" ? t + "" : t, n), n);
var Lp, Xt, O7, Pl, mS, x7, Tx, v7, hd = {}, _7 = [], qV = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, w2 = Array.isArray;
function Yo(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}
function k7(e) {
  var t = e.parentNode;
  t && t.removeChild(e);
}
function bs(e, t, n) {
  var r, i, s, o = {};
  for (s in t)
    s == "key" ? r = t[s] : s == "ref" ? i = t[s] : o[s] = t[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? Lp.call(arguments, 2) : n), typeof e == "function" && e.defaultProps != null)
    for (s in e.defaultProps)
      o[s] === void 0 && (o[s] = e.defaultProps[s]);
  return Bf(e, o, r, i, null);
}
function Bf(e, t, n, r, i) {
  var s = { type: e, props: t, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: i == null ? ++O7 : i, __i: -1, __u: 0 };
  return i == null && Xt.vnode != null && Xt.vnode(s), s;
}
function WV() {
  return { current: null };
}
function ia(e) {
  return e.children;
}
function so(e, t) {
  this.props = e, this.context = t;
}
function Ph(e, t) {
  if (t == null)
    return e.__ ? Ph(e.__, e.__i + 1) : null;
  for (var n; t < e.__k.length; t++)
    if ((n = e.__k[t]) != null && n.__e != null)
      return n.__e;
  return typeof e.type == "function" ? Ph(e) : null;
}
function w7(e) {
  var t, n;
  if ((e = e.__) != null && e.__c != null) {
    for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)
      if ((n = e.__k[t]) != null && n.__e != null) {
        e.__e = e.__c.base = n.__e;
        break;
      }
    return w7(e);
  }
}
function Ex(e) {
  (!e.__d && (e.__d = !0) && Pl.push(e) && !kg.__r++ || mS !== Xt.debounceRendering) && ((mS = Xt.debounceRendering) || x7)(kg);
}
function kg() {
  var e, t, n, r, i, s, o, a, l;
  for (Pl.sort(Tx); e = Pl.shift(); )
    e.__d && (t = Pl.length, r = void 0, s = (i = (n = e).__v).__e, a = [], l = [], (o = n.__P) && ((r = Yo({}, i)).__v = i.__v + 1, Xt.vnode && Xt.vnode(r), Zk(o, r, i, n.__n, o.ownerSVGElement !== void 0, 32 & i.__u ? [s] : null, a, s == null ? Ph(i) : s, !!(32 & i.__u), l), r.__.__k[r.__i] = r, T7(a, r, l), r.__e != s && w7(r)), Pl.length > t && Pl.sort(Tx));
  kg.__r = 0;
}
function S7(e, t, n, r, i, s, o, a, l, h, u) {
  var f, d, p, g, m, y = r && r.__k || _7, O = t.length;
  for (n.__d = l, UV(n, t, y), l = n.__d, f = 0; f < O; f++)
    (p = n.__k[f]) != null && typeof p != "boolean" && typeof p != "function" && (d = p.__i === -1 ? hd : y[p.__i] || hd, p.__i = f, Zk(e, p, d, i, s, o, a, l, h, u), g = p.__e, p.ref && d.ref != p.ref && (d.ref && Vk(d.ref, null, p), u.push(p.ref, p.__c || g, p)), m == null && g != null && (m = g), 65536 & p.__u || d.__k === p.__k ? l = C7(p, l, e) : typeof p.type == "function" && p.__d !== void 0 ? l = p.__d : g && (l = g.nextSibling), p.__d = void 0, p.__u &= -196609);
  n.__d = l, n.__e = m;
}
function UV(e, t, n) {
  var r, i, s, o, a, l = t.length, h = n.length, u = h, f = 0;
  for (e.__k = [], r = 0; r < l; r++)
    (i = e.__k[r] = (i = t[r]) == null || typeof i == "boolean" || typeof i == "function" ? null : typeof i == "string" || typeof i == "number" || typeof i == "bigint" || i.constructor == String ? Bf(null, i, null, null, i) : w2(i) ? Bf(ia, { children: i }, null, null, null) : i.constructor === void 0 && i.__b > 0 ? Bf(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) != null ? (i.__ = e, i.__b = e.__b + 1, a = jV(i, n, o = r + f, u), i.__i = a, s = null, a !== -1 && (u--, (s = n[a]) && (s.__u |= 131072)), s == null || s.__v === null ? (a == -1 && f--, typeof i.type != "function" && (i.__u |= 65536)) : a !== o && (a === o + 1 ? f++ : a > o ? u > l - o ? f += a - o : f-- : f = a < o && a == o - 1 ? a - o : 0, a !== r + f && (i.__u |= 65536))) : (s = n[r]) && s.key == null && s.__e && (s.__e == e.__d && (e.__d = Ph(s)), Ax(s, s, !1), n[r] = null, u--);
  if (u)
    for (r = 0; r < h; r++)
      (s = n[r]) != null && (131072 & s.__u) == 0 && (s.__e == e.__d && (e.__d = Ph(s)), Ax(s, s));
}
function C7(e, t, n) {
  var r, i;
  if (typeof e.type == "function") {
    for (r = e.__k, i = 0; r && i < r.length; i++)
      r[i] && (r[i].__ = e, t = C7(r[i], t, n));
    return t;
  }
  return e.__e != t && (n.insertBefore(e.__e, t || null), t = e.__e), t && t.nextSibling;
}
function Ho(e, t) {
  return t = t || [], e == null || typeof e == "boolean" || (w2(e) ? e.some(function(n) {
    Ho(n, t);
  }) : t.push(e)), t;
}
function jV(e, t, n, r) {
  var i = e.key, s = e.type, o = n - 1, a = n + 1, l = t[n];
  if (l === null || l && i == l.key && s === l.type)
    return n;
  if (r > (l != null && (131072 & l.__u) == 0 ? 1 : 0))
    for (; o >= 0 || a < t.length; ) {
      if (o >= 0) {
        if ((l = t[o]) && (131072 & l.__u) == 0 && i == l.key && s === l.type)
          return o;
        o--;
      }
      if (a < t.length) {
        if ((l = t[a]) && (131072 & l.__u) == 0 && i == l.key && s === l.type)
          return a;
        a++;
      }
    }
  return -1;
}
function yS(e, t, n) {
  t[0] === "-" ? e.setProperty(t, n == null ? "" : n) : e[t] = n == null ? "" : typeof n != "number" || qV.test(t) ? n : n + "px";
}
function g0(e, t, n, r, i) {
  var s;
  t:
    if (t === "style")
      if (typeof n == "string")
        e.style.cssText = n;
      else {
        if (typeof r == "string" && (e.style.cssText = r = ""), r)
          for (t in r)
            n && t in n || yS(e.style, t, "");
        if (n)
          for (t in n)
            r && n[t] === r[t] || yS(e.style, t, n[t]);
      }
    else if (t[0] === "o" && t[1] === "n")
      s = t !== (t = t.replace(/(PointerCapture)$|Capture$/, "$1")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + s] = n, n ? r ? n.u = r.u : (n.u = Date.now(), e.addEventListener(t, s ? OS : bS, s)) : e.removeEventListener(t, s ? OS : bS, s);
    else {
      if (i)
        t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (t !== "width" && t !== "height" && t !== "href" && t !== "list" && t !== "form" && t !== "tabIndex" && t !== "download" && t !== "rowSpan" && t !== "colSpan" && t !== "role" && t in e)
        try {
          e[t] = n == null ? "" : n;
          break t;
        } catch {
        }
      typeof n == "function" || (n == null || n === !1 && t[4] !== "-" ? e.removeAttribute(t) : e.setAttribute(t, n));
    }
}
function bS(e) {
  var t = this.l[e.type + !1];
  if (e.t) {
    if (e.t <= t.u)
      return;
  } else
    e.t = Date.now();
  return t(Xt.event ? Xt.event(e) : e);
}
function OS(e) {
  return this.l[e.type + !0](Xt.event ? Xt.event(e) : e);
}
function Zk(e, t, n, r, i, s, o, a, l, h) {
  var u, f, d, p, g, m, y, O, x, _, w, E, T, S, R, A = t.type;
  if (t.constructor !== void 0)
    return null;
  128 & n.__u && (l = !!(32 & n.__u), s = [a = t.__e = n.__e]), (u = Xt.__b) && u(t);
  t:
    if (typeof A == "function")
      try {
        if (O = t.props, x = (u = A.contextType) && r[u.__c], _ = u ? x ? x.props.value : u.__ : r, n.__c ? y = (f = t.__c = n.__c).__ = f.__E : ("prototype" in A && A.prototype.render ? t.__c = f = new A(O, _) : (t.__c = f = new so(O, _), f.constructor = A, f.render = GV), x && x.sub(f), f.props = O, f.state || (f.state = {}), f.context = _, f.__n = r, d = f.__d = !0, f.__h = [], f._sb = []), f.__s == null && (f.__s = f.state), A.getDerivedStateFromProps != null && (f.__s == f.state && (f.__s = Yo({}, f.__s)), Yo(f.__s, A.getDerivedStateFromProps(O, f.__s))), p = f.props, g = f.state, f.__v = t, d)
          A.getDerivedStateFromProps == null && f.componentWillMount != null && f.componentWillMount(), f.componentDidMount != null && f.__h.push(f.componentDidMount);
        else {
          if (A.getDerivedStateFromProps == null && O !== p && f.componentWillReceiveProps != null && f.componentWillReceiveProps(O, _), !f.__e && (f.shouldComponentUpdate != null && f.shouldComponentUpdate(O, f.__s, _) === !1 || t.__v === n.__v)) {
            for (t.__v !== n.__v && (f.props = O, f.state = f.__s, f.__d = !1), t.__e = n.__e, t.__k = n.__k, t.__k.forEach(function(P) {
              P && (P.__ = t);
            }), w = 0; w < f._sb.length; w++)
              f.__h.push(f._sb[w]);
            f._sb = [], f.__h.length && o.push(f);
            break t;
          }
          f.componentWillUpdate != null && f.componentWillUpdate(O, f.__s, _), f.componentDidUpdate != null && f.__h.push(function() {
            f.componentDidUpdate(p, g, m);
          });
        }
        if (f.context = _, f.props = O, f.__P = e, f.__e = !1, E = Xt.__r, T = 0, "prototype" in A && A.prototype.render) {
          for (f.state = f.__s, f.__d = !1, E && E(t), u = f.render(f.props, f.state, f.context), S = 0; S < f._sb.length; S++)
            f.__h.push(f._sb[S]);
          f._sb = [];
        } else
          do
            f.__d = !1, E && E(t), u = f.render(f.props, f.state, f.context), f.state = f.__s;
          while (f.__d && ++T < 25);
        f.state = f.__s, f.getChildContext != null && (r = Yo(Yo({}, r), f.getChildContext())), d || f.getSnapshotBeforeUpdate == null || (m = f.getSnapshotBeforeUpdate(p, g)), S7(e, w2(R = u != null && u.type === ia && u.key == null ? u.props.children : u) ? R : [R], t, n, r, i, s, o, a, l, h), f.base = t.__e, t.__u &= -161, f.__h.length && o.push(f), y && (f.__E = f.__ = null);
      } catch (P) {
        t.__v = null, l || s != null ? (t.__e = a, t.__u |= l ? 160 : 32, s[s.indexOf(a)] = null) : (t.__e = n.__e, t.__k = n.__k), Xt.__e(P, t, n);
      }
    else
      s == null && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = XV(n.__e, t, n, r, i, s, o, l, h);
  (u = Xt.diffed) && u(t);
}
function T7(e, t, n) {
  t.__d = void 0;
  for (var r = 0; r < n.length; r++)
    Vk(n[r], n[++r], n[++r]);
  Xt.__c && Xt.__c(t, e), e.some(function(i) {
    try {
      e = i.__h, i.__h = [], e.some(function(s) {
        s.call(i);
      });
    } catch (s) {
      Xt.__e(s, i.__v);
    }
  });
}
function XV(e, t, n, r, i, s, o, a, l) {
  var h, u, f, d, p, g, m, y = n.props, O = t.props, x = t.type;
  if (x === "svg" && (i = !0), s != null) {
    for (h = 0; h < s.length; h++)
      if ((p = s[h]) && "setAttribute" in p == !!x && (x ? p.localName === x : p.nodeType === 3)) {
        e = p, s[h] = null;
        break;
      }
  }
  if (e == null) {
    if (x === null)
      return document.createTextNode(O);
    e = i ? document.createElementNS("http://www.w3.org/2000/svg", x) : document.createElement(x, O.is && O), s = null, a = !1;
  }
  if (x === null)
    y === O || a && e.data === O || (e.data = O);
  else {
    if (s = s && Lp.call(e.childNodes), y = n.props || hd, !a && s != null)
      for (y = {}, h = 0; h < e.attributes.length; h++)
        y[(p = e.attributes[h]).name] = p.value;
    for (h in y)
      p = y[h], h == "children" || (h == "dangerouslySetInnerHTML" ? f = p : h === "key" || h in O || g0(e, h, null, p, i));
    for (h in O)
      p = O[h], h == "children" ? d = p : h == "dangerouslySetInnerHTML" ? u = p : h == "value" ? g = p : h == "checked" ? m = p : h === "key" || a && typeof p != "function" || y[h] === p || g0(e, h, p, y[h], i);
    if (u)
      a || f && (u.__html === f.__html || u.__html === e.innerHTML) || (e.innerHTML = u.__html), t.__k = [];
    else if (f && (e.innerHTML = ""), S7(e, w2(d) ? d : [d], t, n, r, i && x !== "foreignObject", s, o, s ? s[0] : n.__k && Ph(n, 0), a, l), s != null)
      for (h = s.length; h--; )
        s[h] != null && k7(s[h]);
    a || (h = "value", g !== void 0 && (g !== e[h] || x === "progress" && !g || x === "option" && g !== y[h]) && g0(e, h, g, y[h], !1), h = "checked", m !== void 0 && m !== e[h] && g0(e, h, m, y[h], !1));
  }
  return e;
}
function Vk(e, t, n) {
  try {
    typeof e == "function" ? e(t) : e.current = t;
  } catch (r) {
    Xt.__e(r, n);
  }
}
function Ax(e, t, n) {
  var r, i;
  if (Xt.unmount && Xt.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || Vk(r, null, t)), (r = e.__c) != null) {
    if (r.componentWillUnmount)
      try {
        r.componentWillUnmount();
      } catch (s) {
        Xt.__e(s, t);
      }
    r.base = r.__P = null, e.__c = void 0;
  }
  if (r = e.__k)
    for (i = 0; i < r.length; i++)
      r[i] && Ax(r[i], t, n || typeof e.type != "function");
  n || e.__e == null || k7(e.__e), e.__ = e.__e = e.__d = void 0;
}
function GV(e, t, n) {
  return this.constructor(e, n);
}
function ud(e, t, n) {
  var r, i, s, o;
  Xt.__ && Xt.__(e, t), i = (r = typeof n == "function") ? null : n && n.__k || t.__k, s = [], o = [], Zk(t, e = (!r && n || t).__k = bs(ia, null, [e]), i || hd, hd, t.ownerSVGElement !== void 0, !r && n ? [n] : i ? null : t.firstChild ? Lp.call(t.childNodes) : null, s, !r && n ? n : i ? i.__e : t.firstChild, r, o), T7(s, e, o);
}
function E7(e, t) {
  ud(e, t, E7);
}
function HV(e, t, n) {
  var r, i, s, o, a = Yo({}, e.props);
  for (s in e.type && e.type.defaultProps && (o = e.type.defaultProps), t)
    s == "key" ? r = t[s] : s == "ref" ? i = t[s] : a[s] = t[s] === void 0 && o !== void 0 ? o[s] : t[s];
  return arguments.length > 2 && (a.children = arguments.length > 3 ? Lp.call(arguments, 2) : n), Bf(e.type, a, r || e.key, i || e.ref, null);
}
function KV(e, t) {
  var n = { __c: t = "__cC" + v7++, __: e, Consumer: function(r, i) {
    return r.children(i);
  }, Provider: function(r) {
    var i, s;
    return this.getChildContext || (i = [], (s = {})[t] = this, this.getChildContext = function() {
      return s;
    }, this.shouldComponentUpdate = function(o) {
      this.props.value !== o.value && i.some(function(a) {
        a.__e = !0, Ex(a);
      });
    }, this.sub = function(o) {
      i.push(o);
      var a = o.componentWillUnmount;
      o.componentWillUnmount = function() {
        i.splice(i.indexOf(o), 1), a && a.call(o);
      };
    }), r.children;
  } };
  return n.Provider.__ = n.Consumer.contextType = n;
}
Lp = _7.slice, Xt = { __e: function(e, t, n, r) {
  for (var i, s, o; t = t.__; )
    if ((i = t.__c) && !i.__)
      try {
        if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(e)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(e, r || {}), o = i.__d), o)
          return i.__E = i;
      } catch (a) {
        e = a;
      }
  throw e;
} }, O7 = 0, so.prototype.setState = function(e, t) {
  var n;
  n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Yo({}, this.state), typeof e == "function" && (e = e(Yo({}, n), this.props)), e && Yo(n, e), e != null && this.__v && (t && this._sb.push(t), Ex(this));
}, so.prototype.forceUpdate = function(e) {
  this.__v && (this.__e = !0, e && this.__h.push(e), Ex(this));
}, so.prototype.render = ia, Pl = [], x7 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Tx = function(e, t) {
  return e.__v.__b - t.__v.__b;
}, kg.__r = 0, v7 = 0;
var Ka, on, ub, xS, Dh = 0, A7 = [], k1 = [], vS = Xt.__b, _S = Xt.__r, kS = Xt.diffed, wS = Xt.__c, SS = Xt.unmount;
function wu(e, t) {
  Xt.__h && Xt.__h(on, e, Dh || t), Dh = 0;
  var n = on.__H || (on.__H = { __: [], __h: [] });
  return e >= n.__.length && n.__.push({ __V: k1 }), n.__[e];
}
function mn(e) {
  return Dh = 1, S2(D7, e);
}
function S2(e, t, n) {
  var r = wu(Ka++, 2);
  if (r.t = e, !r.__c && (r.__ = [n ? n(t) : D7(void 0, t), function(a) {
    var l = r.__N ? r.__N[0] : r.__[0], h = r.t(l, a);
    l !== h && (r.__N = [h, r.__[1]], r.__c.setState({}));
  }], r.__c = on, !on.u)) {
    var i = function(a, l, h) {
      if (!r.__c.__H)
        return !0;
      var u = r.__c.__H.__.filter(function(d) {
        return d.__c;
      });
      if (u.every(function(d) {
        return !d.__N;
      }))
        return !s || s.call(this, a, l, h);
      var f = !1;
      return u.forEach(function(d) {
        if (d.__N) {
          var p = d.__[0];
          d.__ = d.__N, d.__N = void 0, p !== d.__[0] && (f = !0);
        }
      }), !(!f && r.__c.props === a) && (!s || s.call(this, a, l, h));
    };
    on.u = !0;
    var s = on.shouldComponentUpdate, o = on.componentWillUpdate;
    on.componentWillUpdate = function(a, l, h) {
      if (this.__e) {
        var u = s;
        s = void 0, i(a, l, h), s = u;
      }
      o && o.call(this, a, l, h);
    }, on.shouldComponentUpdate = i;
  }
  return r.__N || r.__;
}
function lr(e, t) {
  var n = wu(Ka++, 3);
  !Xt.__s && zk(n.__H, t) && (n.__ = e, n.i = t, on.__H.__h.push(n));
}
function C2(e, t) {
  var n = wu(Ka++, 4);
  !Xt.__s && zk(n.__H, t) && (n.__ = e, n.i = t, on.__h.push(n));
}
function us(e) {
  return Dh = 5, Dn(function() {
    return { current: e };
  }, []);
}
function JV(e, t, n) {
  Dh = 6, C2(function() {
    return typeof e == "function" ? (e(t()), function() {
      return e(null);
    }) : e ? (e.current = t(), function() {
      return e.current = null;
    }) : void 0;
  }, n == null ? n : n.concat(e));
}
function Dn(e, t) {
  var n = wu(Ka++, 7);
  return zk(n.__H, t) ? (n.__V = e(), n.i = t, n.__h = e, n.__V) : n.__;
}
function Yk(e, t) {
  return Dh = 8, Dn(function() {
    return e;
  }, t);
}
function P7(e) {
  var t = on.context[e.__c], n = wu(Ka++, 9);
  return n.c = e, t ? (n.__ == null && (n.__ = !0, t.sub(on)), t.props.value) : e.__;
}
function Px(e, t) {
  Xt.useDebugValue && Xt.useDebugValue(t ? t(e) : e);
}
function tY() {
  var e = wu(Ka++, 11);
  if (!e.__) {
    for (var t = on.__v; t !== null && !t.__m && t.__ !== null; )
      t = t.__;
    var n = t.__m || (t.__m = [0, 0]);
    e.__ = "P" + n[0] + "-" + n[1]++;
  }
  return e.__;
}
function eY() {
  for (var e; e = A7.shift(); )
    if (e.__P && e.__H)
      try {
        e.__H.__h.forEach(w1), e.__H.__h.forEach(Dx), e.__H.__h = [];
      } catch (t) {
        e.__H.__h = [], Xt.__e(t, e.__v);
      }
}
Xt.__b = function(e) {
  on = null, vS && vS(e);
}, Xt.__r = function(e) {
  _S && _S(e), Ka = 0;
  var t = (on = e.__c).__H;
  t && (ub === on ? (t.__h = [], on.__h = [], t.__.forEach(function(n) {
    n.__N && (n.__ = n.__N), n.__V = k1, n.__N = n.i = void 0;
  })) : (t.__h.forEach(w1), t.__h.forEach(Dx), t.__h = [], Ka = 0)), ub = on;
}, Xt.diffed = function(e) {
  kS && kS(e);
  var t = e.__c;
  t && t.__H && (t.__H.__h.length && (A7.push(t) !== 1 && xS === Xt.requestAnimationFrame || ((xS = Xt.requestAnimationFrame) || nY)(eY)), t.__H.__.forEach(function(n) {
    n.i && (n.__H = n.i), n.__V !== k1 && (n.__ = n.__V), n.i = void 0, n.__V = k1;
  })), ub = on = null;
}, Xt.__c = function(e, t) {
  t.some(function(n) {
    try {
      n.__h.forEach(w1), n.__h = n.__h.filter(function(r) {
        return !r.__ || Dx(r);
      });
    } catch (r) {
      t.some(function(i) {
        i.__h && (i.__h = []);
      }), t = [], Xt.__e(r, n.__v);
    }
  }), wS && wS(e, t);
}, Xt.unmount = function(e) {
  SS && SS(e);
  var t, n = e.__c;
  n && n.__H && (n.__H.__.forEach(function(r) {
    try {
      w1(r);
    } catch (i) {
      t = i;
    }
  }), n.__H = void 0, t && Xt.__e(t, n.__v));
};
var CS = typeof requestAnimationFrame == "function";
function nY(e) {
  var t, n = function() {
    clearTimeout(r), CS && cancelAnimationFrame(t), setTimeout(e);
  }, r = setTimeout(n, 100);
  CS && (t = requestAnimationFrame(n));
}
function w1(e) {
  var t = on, n = e.__c;
  typeof n == "function" && (e.__c = void 0, n()), on = t;
}
function Dx(e) {
  var t = on;
  e.__c = e.__(), on = t;
}
function zk(e, t) {
  return !e || e.length !== t.length || t.some(function(n, r) {
    return n !== e[r];
  });
}
function D7(e, t) {
  return typeof t == "function" ? t(e) : t;
}
var L7 = function(e, t, n, r) {
  var i;
  t[0] = 0;
  for (var s = 1; s < t.length; s++) {
    var o = t[s++], a = t[s] ? (t[0] |= o ? 1 : 2, n[t[s++]]) : t[++s];
    o === 3 ? r[0] = a : o === 4 ? r[1] = Object.assign(r[1] || {}, a) : o === 5 ? (r[1] = r[1] || {})[t[++s]] = a : o === 6 ? r[1][t[++s]] += a + "" : o ? (i = e.apply(a, L7(e, a, n, ["", null])), r.push(i), a[0] ? t[0] |= 2 : (t[s - 2] = 0, t[s] = i)) : r.push(a);
  }
  return r;
}, TS = /* @__PURE__ */ new Map();
function rY(e) {
  var t = TS.get(this);
  return t || (t = /* @__PURE__ */ new Map(), TS.set(this, t)), (t = L7(this, t.get(e) || (t.set(e, t = function(n) {
    for (var r, i, s = 1, o = "", a = "", l = [0], h = function(d) {
      s === 1 && (d || (o = o.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? l.push(0, d, o) : s === 3 && (d || o) ? (l.push(3, d, o), s = 2) : s === 2 && o === "..." && d ? l.push(4, d, 0) : s === 2 && o && !d ? l.push(5, 0, !0, o) : s >= 5 && ((o || !d && s === 5) && (l.push(s, 0, o, i), s = 6), d && (l.push(s, d, 0, i), s = 6)), o = "";
    }, u = 0; u < n.length; u++) {
      u && (s === 1 && h(), h(u));
      for (var f = 0; f < n[u].length; f++)
        r = n[u][f], s === 1 ? r === "<" ? (h(), l = [l], s = 3) : o += r : s === 4 ? o === "--" && r === ">" ? (s = 1, o = "") : o = r + o[0] : a ? r === a ? a = "" : o += r : r === '"' || r === "'" ? a = r : r === ">" ? (h(), s = 1) : s && (r === "=" ? (s = 5, i = o, o = "") : r === "/" && (s < 5 || n[u][f + 1] === ">") ? (h(), s === 3 && (l = l[0]), s = l, (l = l[0]).push(2, 0, s), s = 0) : r === " " || r === "	" || r === `
` || r === "\r" ? (h(), s = 2) : o += r), s === 3 && o === "!--" && (s = 4, l = l[0]);
    }
    return h(), l;
  }(e)), t), arguments, [])).length > 1 ? t : t[0];
}
var Kt = rY.bind(bs), ti = function() {
  return ti = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, ti.apply(this, arguments);
};
function Lh(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, s; r < i; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
function iY(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var sY = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, oY = /* @__PURE__ */ iY(
  function(e) {
    return sY.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
);
function M7(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}
function Lx(e, t) {
  for (var n in e)
    if (n !== "__source" && !(n in t))
      return !0;
  for (var r in t)
    if (r !== "__source" && e[r] !== t[r])
      return !0;
  return !1;
}
function Mx(e) {
  this.props = e;
}
function aY(e, t) {
  function n(i) {
    var s = this.props.ref, o = s == i.ref;
    return !o && s && (s.call ? s(null) : s.current = null), t ? !t(this.props, i) || !o : Lx(this.props, i);
  }
  function r(i) {
    return this.shouldComponentUpdate = n, bs(e, i);
  }
  return r.displayName = "Memo(" + (e.displayName || e.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
}
(Mx.prototype = new so()).isPureReactComponent = !0, Mx.prototype.shouldComponentUpdate = function(e, t) {
  return Lx(this.props, e) || Lx(this.state, t);
};
var ES = Xt.__b;
Xt.__b = function(e) {
  e.type && e.type.__f && e.ref && (e.props.ref = e.ref, e.ref = null), ES && ES(e);
};
var lY = typeof Symbol < "u" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function cY(e) {
  function t(n) {
    var r = M7({}, n);
    return delete r.ref, e(r, n.ref || null);
  }
  return t.$$typeof = lY, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (e.displayName || e.name) + ")", t;
}
var AS = function(e, t) {
  return e == null ? null : Ho(Ho(e).map(t));
}, hY = { map: AS, forEach: AS, count: function(e) {
  return e ? Ho(e).length : 0;
}, only: function(e) {
  var t = Ho(e);
  if (t.length !== 1)
    throw "Children.only";
  return t[0];
}, toArray: Ho }, uY = Xt.__e;
Xt.__e = function(e, t, n, r) {
  if (e.then) {
    for (var i, s = t; s = s.__; )
      if ((i = s.__c) && i.__c)
        return t.__e == null && (t.__e = n.__e, t.__k = n.__k), i.__c(e, t);
  }
  uY(e, t, n, r);
};
var PS = Xt.unmount;
function R7(e, t, n) {
  return e && (e.__c && e.__c.__H && (e.__c.__H.__.forEach(function(r) {
    typeof r.__c == "function" && r.__c();
  }), e.__c.__H = null), (e = M7({}, e)).__c != null && (e.__c.__P === n && (e.__c.__P = t), e.__c = null), e.__k = e.__k && e.__k.map(function(r) {
    return R7(r, t, n);
  })), e;
}
function $7(e, t, n) {
  return e && n && (e.__v = null, e.__k = e.__k && e.__k.map(function(r) {
    return $7(r, t, n);
  }), e.__c && e.__c.__P === t && (e.__e && n.appendChild(e.__e), e.__c.__e = !0, e.__c.__P = n)), e;
}
function S1() {
  this.__u = 0, this.t = null, this.__b = null;
}
function I7(e) {
  var t = e.__.__c;
  return t && t.__a && t.__a(e);
}
function fY(e) {
  var t, n, r;
  function i(s) {
    if (t || (t = e()).then(function(o) {
      n = o.default || o;
    }, function(o) {
      r = o;
    }), r)
      throw r;
    if (!n)
      throw t;
    return bs(n, s);
  }
  return i.displayName = "Lazy", i.__f = !0, i;
}
function vf() {
  this.u = null, this.o = null;
}
Xt.unmount = function(e) {
  var t = e.__c;
  t && t.__R && t.__R(), t && 32 & e.__u && (e.type = null), PS && PS(e);
}, (S1.prototype = new so()).__c = function(e, t) {
  var n = t.__c, r = this;
  r.t == null && (r.t = []), r.t.push(n);
  var i = I7(r.__v), s = !1, o = function() {
    s || (s = !0, n.__R = null, i ? i(a) : a());
  };
  n.__R = o;
  var a = function() {
    if (!--r.__u) {
      if (r.state.__a) {
        var l = r.state.__a;
        r.__v.__k[0] = $7(l, l.__c.__P, l.__c.__O);
      }
      var h;
      for (r.setState({ __a: r.__b = null }); h = r.t.pop(); )
        h.forceUpdate();
    }
  };
  r.__u++ || 32 & t.__u || r.setState({ __a: r.__b = r.__v.__k[0] }), e.then(o, o);
}, S1.prototype.componentWillUnmount = function() {
  this.t = [];
}, S1.prototype.render = function(e, t) {
  if (this.__b) {
    if (this.__v.__k) {
      var n = document.createElement("div"), r = this.__v.__k[0].__c;
      this.__v.__k[0] = R7(this.__b, n, r.__O = r.__P);
    }
    this.__b = null;
  }
  var i = t.__a && bs(ia, null, e.fallback);
  return i && (i.__u &= -33), [bs(ia, null, t.__a ? null : e.children), i];
};
var DS = function(e, t, n) {
  if (++n[1] === n[0] && e.o.delete(t), e.props.revealOrder && (e.props.revealOrder[0] !== "t" || !e.o.size))
    for (n = e.u; n; ) {
      for (; n.length > 3; )
        n.pop()();
      if (n[1] < n[0])
        break;
      e.u = n = n[2];
    }
};
function dY(e) {
  return this.getChildContext = function() {
    return e.context;
  }, e.children;
}
function pY(e) {
  var t = this, n = e.i;
  t.componentWillUnmount = function() {
    ud(null, t.l), t.l = null, t.i = null;
  }, t.i && t.i !== n && t.componentWillUnmount(), t.l || (t.i = n, t.l = { nodeType: 1, parentNode: n, childNodes: [], appendChild: function(r) {
    this.childNodes.push(r), t.i.appendChild(r);
  }, insertBefore: function(r, i) {
    this.childNodes.push(r), t.i.appendChild(r);
  }, removeChild: function(r) {
    this.childNodes.splice(this.childNodes.indexOf(r) >>> 1, 1), t.i.removeChild(r);
  } }), ud(bs(dY, { context: t.context }, e.__v), t.l);
}
function gY(e, t) {
  var n = bs(pY, { __v: e, i: t });
  return n.containerInfo = t, n;
}
(vf.prototype = new so()).__a = function(e) {
  var t = this, n = I7(t.__v), r = t.o.get(e);
  return r[0]++, function(i) {
    var s = function() {
      t.props.revealOrder ? (r.push(i), DS(t, e, r)) : i();
    };
    n ? n(s) : s();
  };
}, vf.prototype.render = function(e) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t = Ho(e.children);
  e.revealOrder && e.revealOrder[0] === "b" && t.reverse();
  for (var n = t.length; n--; )
    this.o.set(t[n], this.u = [1, 0, this.u]);
  return e.children;
}, vf.prototype.componentDidUpdate = vf.prototype.componentDidMount = function() {
  var e = this;
  this.o.forEach(function(t, n) {
    DS(e, n, t);
  });
};
var N7 = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, mY = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, yY = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, bY = /[A-Z0-9]/g, OY = typeof document < "u", xY = function(e) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/ : /fil|che|ra/).test(e);
};
function vY(e, t, n) {
  return t.__k == null && (t.textContent = ""), ud(e, t), typeof n == "function" && n(), e ? e.__c : null;
}
function _Y(e, t, n) {
  return E7(e, t), typeof n == "function" && n(), e ? e.__c : null;
}
so.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(e) {
  Object.defineProperty(so.prototype, e, { configurable: !0, get: function() {
    return this["UNSAFE_" + e];
  }, set: function(t) {
    Object.defineProperty(this, e, { configurable: !0, writable: !0, value: t });
  } });
});
var LS = Xt.event;
function kY() {
}
function wY() {
  return this.cancelBubble;
}
function SY() {
  return this.defaultPrevented;
}
Xt.event = function(e) {
  return LS && (e = LS(e)), e.persist = kY, e.isPropagationStopped = wY, e.isDefaultPrevented = SY, e.nativeEvent = e;
};
var qk, CY = { enumerable: !1, configurable: !0, get: function() {
  return this.class;
} }, MS = Xt.vnode;
Xt.vnode = function(e) {
  typeof e.type == "string" && function(t) {
    var n = t.props, r = t.type, i = {};
    for (var s in n) {
      var o = n[s];
      if (!(s === "value" && "defaultValue" in n && o == null || OY && s === "children" && r === "noscript" || s === "class" || s === "className")) {
        var a = s.toLowerCase();
        s === "defaultValue" && "value" in n && n.value == null ? s = "value" : s === "download" && o === !0 ? o = "" : a === "ondoubleclick" ? s = "ondblclick" : a !== "onchange" || r !== "input" && r !== "textarea" || xY(n.type) ? a === "onfocus" ? s = "onfocusin" : a === "onblur" ? s = "onfocusout" : yY.test(s) ? s = a : r.indexOf("-") === -1 && mY.test(s) ? s = s.replace(bY, "-$&").toLowerCase() : o === null && (o = void 0) : a = s = "oninput", a === "oninput" && i[s = a] && (s = "oninputCapture"), i[s] = o;
      }
    }
    r == "select" && i.multiple && Array.isArray(i.value) && (i.value = Ho(n.children).forEach(function(l) {
      l.props.selected = i.value.indexOf(l.props.value) != -1;
    })), r == "select" && i.defaultValue != null && (i.value = Ho(n.children).forEach(function(l) {
      l.props.selected = i.multiple ? i.defaultValue.indexOf(l.props.value) != -1 : i.defaultValue == l.props.value;
    })), n.class && !n.className ? (i.class = n.class, Object.defineProperty(i, "className", CY)) : (n.className && !n.class || n.class && n.className) && (i.class = i.className = n.className), t.props = i;
  }(e), e.$$typeof = N7, MS && MS(e);
};
var RS = Xt.__r;
Xt.__r = function(e) {
  RS && RS(e), qk = e.__c;
};
var $S = Xt.diffed;
Xt.diffed = function(e) {
  $S && $S(e);
  var t = e.props, n = e.__e;
  n != null && e.type === "textarea" && "value" in t && t.value !== n.value && (n.value = t.value == null ? "" : t.value), qk = null;
};
var TY = { ReactCurrentDispatcher: { current: { readContext: function(e) {
  return qk.__n[e.__c].props.value;
} } } };
function EY(e) {
  return bs.bind(null, e);
}
function T2(e) {
  return !!e && e.$$typeof === N7;
}
function AY(e) {
  return T2(e) && e.type === ia;
}
function PY(e) {
  return T2(e) ? HV.apply(null, arguments) : e;
}
function DY(e) {
  return !!e.__k && (ud(null, e), !0);
}
function LY(e) {
  return e && (e.base || e.nodeType === 1 && e) || null;
}
var MY = function(e, t) {
  return e(t);
}, RY = function(e, t) {
  return e(t);
}, $Y = ia;
function B7(e) {
  e();
}
function IY(e) {
  return e;
}
function NY() {
  return [!1, B7];
}
var BY = C2, FY = T2;
function QY(e, t) {
  var n = t(), r = mn({ h: { __: n, v: t } }), i = r[0].h, s = r[1];
  return C2(function() {
    i.__ = n, i.v = t, fb(i) && s({ h: i });
  }, [e, n, t]), lr(function() {
    return fb(i) && s({ h: i }), e(function() {
      fb(i) && s({ h: i });
    });
  }, [e]), n;
}
function fb(e) {
  var t, n, r = e.v, i = e.__;
  try {
    var s = r();
    return !((t = i) === (n = s) && (t !== 0 || 1 / t == 1 / n) || t != t && n != n);
  } catch {
    return !0;
  }
}
var tc = { useState: mn, useId: tY, useReducer: S2, useEffect: lr, useLayoutEffect: C2, useInsertionEffect: BY, useTransition: NY, useDeferredValue: IY, useSyncExternalStore: QY, startTransition: B7, useRef: us, useImperativeHandle: JV, useMemo: Dn, useCallback: Yk, useContext: P7, useDebugValue: Px, version: "17.0.2", Children: hY, render: vY, hydrate: _Y, unmountComponentAtNode: DY, createPortal: gY, createElement: bs, createContext: KV, createFactory: EY, cloneElement: PY, createRef: WV, Fragment: ia, isValidElement: T2, isElement: FY, isFragment: AY, findDOMNode: LY, Component: so, PureComponent: Mx, memo: aY, forwardRef: cY, flushSync: RY, unstable_batchedUpdates: MY, StrictMode: $Y, Suspense: S1, SuspenseList: vf, lazy: fY, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: TY }, E2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ZY(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function F7(e) {
  var t = e.default;
  if (typeof t == "function") {
    var n = function() {
      return t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var VY = function(t, n, r, i) {
  var s = r ? r.call(i, t, n) : void 0;
  if (s !== void 0)
    return !!s;
  if (t === n)
    return !0;
  if (typeof t != "object" || !t || typeof n != "object" || !n)
    return !1;
  var o = Object.keys(t), a = Object.keys(n);
  if (o.length !== a.length)
    return !1;
  for (var l = Object.prototype.hasOwnProperty.bind(n), h = 0; h < o.length; h++) {
    var u = o[h];
    if (!l(u))
      return !1;
    var f = t[u], d = n[u];
    if (s = r ? r.call(i, f, d, u) : void 0, s === !1 || s === void 0 && f !== d)
      return !1;
  }
  return !0;
}, nn = "-ms-", Ff = "-moz-", Ye = "-webkit-", Q7 = "comm", A2 = "rule", Wk = "decl", YY = "@import", Z7 = "@keyframes", zY = "@layer", qY = Math.abs, Uk = String.fromCharCode, Rx = Object.assign;
function WY(e, t) {
  return ir(e, 0) ^ 45 ? (((t << 2 ^ ir(e, 0)) << 2 ^ ir(e, 1)) << 2 ^ ir(e, 2)) << 2 ^ ir(e, 3) : 0;
}
function V7(e) {
  return e.trim();
}
function No(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function Pe(e, t, n) {
  return e.replace(t, n);
}
function C1(e, t) {
  return e.indexOf(t);
}
function ir(e, t) {
  return e.charCodeAt(t) | 0;
}
function Mh(e, t, n) {
  return e.slice(t, n);
}
function Us(e) {
  return e.length;
}
function Y7(e) {
  return e.length;
}
function _f(e, t) {
  return t.push(e), e;
}
function UY(e, t) {
  return e.map(t).join("");
}
function IS(e, t) {
  return e.filter(function(n) {
    return !No(n, t);
  });
}
var P2 = 1, Rh = 1, z7 = 0, Vi = 0, In = 0, Su = "";
function D2(e, t, n, r, i, s, o, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: s, line: P2, column: Rh, length: o, return: "", siblings: a };
}
function Sa(e, t) {
  return Rx(D2("", null, null, "", null, null, 0, e.siblings), e, { length: -e.length }, t);
}
function Bc(e) {
  for (; e.root; )
    e = Sa(e.root, { children: [e] });
  _f(e, e.siblings);
}
function jY() {
  return In;
}
function XY() {
  return In = Vi > 0 ? ir(Su, --Vi) : 0, Rh--, In === 10 && (Rh = 1, P2--), In;
}
function fs() {
  return In = Vi < z7 ? ir(Su, Vi++) : 0, Rh++, In === 10 && (Rh = 1, P2++), In;
}
function ql() {
  return ir(Su, Vi);
}
function T1() {
  return Vi;
}
function L2(e, t) {
  return Mh(Su, e, t);
}
function $x(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function GY(e) {
  return P2 = Rh = 1, z7 = Us(Su = e), Vi = 0, [];
}
function HY(e) {
  return Su = "", e;
}
function db(e) {
  return V7(L2(Vi - 1, Ix(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function KY(e) {
  for (; (In = ql()) && In < 33; )
    fs();
  return $x(e) > 2 || $x(In) > 3 ? "" : " ";
}
function JY(e, t) {
  for (; --t && fs() && !(In < 48 || In > 102 || In > 57 && In < 65 || In > 70 && In < 97); )
    ;
  return L2(e, T1() + (t < 6 && ql() == 32 && fs() == 32));
}
function Ix(e) {
  for (; fs(); )
    switch (In) {
      case e:
        return Vi;
      case 34:
      case 39:
        e !== 34 && e !== 39 && Ix(In);
        break;
      case 40:
        e === 41 && Ix(e);
        break;
      case 92:
        fs();
        break;
    }
  return Vi;
}
function tz(e, t) {
  for (; fs() && e + In !== 47 + 10; )
    if (e + In === 42 + 42 && ql() === 47)
      break;
  return "/*" + L2(t, Vi - 1) + "*" + Uk(e === 47 ? e : fs());
}
function ez(e) {
  for (; !$x(ql()); )
    fs();
  return L2(e, Vi);
}
function nz(e) {
  return HY(E1("", null, null, null, [""], e = GY(e), 0, [0], e));
}
function E1(e, t, n, r, i, s, o, a, l) {
  for (var h = 0, u = 0, f = o, d = 0, p = 0, g = 0, m = 1, y = 1, O = 1, x = 0, _ = "", w = i, E = s, T = r, S = _; y; )
    switch (g = x, x = fs()) {
      case 40:
        if (g != 108 && ir(S, f - 1) == 58) {
          C1(S += Pe(db(x), "&", "&\f"), "&\f") != -1 && (O = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        S += db(x);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        S += KY(g);
        break;
      case 92:
        S += JY(T1() - 1, 7);
        continue;
      case 47:
        switch (ql()) {
          case 42:
          case 47:
            _f(rz(tz(fs(), T1()), t, n, l), l);
            break;
          default:
            S += "/";
        }
        break;
      case 123 * m:
        a[h++] = Us(S) * O;
      case 125 * m:
      case 59:
      case 0:
        switch (x) {
          case 0:
          case 125:
            y = 0;
          case 59 + u:
            O == -1 && (S = Pe(S, /\f/g, "")), p > 0 && Us(S) - f && _f(p > 32 ? BS(S + ";", r, n, f - 1, l) : BS(Pe(S, " ", "") + ";", r, n, f - 2, l), l);
            break;
          case 59:
            S += ";";
          default:
            if (_f(T = NS(S, t, n, h, u, i, a, _, w = [], E = [], f, s), s), x === 123)
              if (u === 0)
                E1(S, t, T, T, w, s, f, a, E);
              else
                switch (d === 99 && ir(S, 3) === 110 ? 100 : d) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    E1(e, T, T, r && _f(NS(e, T, T, 0, 0, i, a, _, i, w = [], f, E), E), i, E, f, a, r ? w : E);
                    break;
                  default:
                    E1(S, T, T, T, [""], E, 0, a, E);
                }
        }
        h = u = p = 0, m = O = 1, _ = S = "", f = o;
        break;
      case 58:
        f = 1 + Us(S), p = g;
      default:
        if (m < 1) {
          if (x == 123)
            --m;
          else if (x == 125 && m++ == 0 && XY() == 125)
            continue;
        }
        switch (S += Uk(x), x * m) {
          case 38:
            O = u > 0 ? 1 : (S += "\f", -1);
            break;
          case 44:
            a[h++] = (Us(S) - 1) * O, O = 1;
            break;
          case 64:
            ql() === 45 && (S += db(fs())), d = ql(), u = f = Us(_ = S += ez(T1())), x++;
            break;
          case 45:
            g === 45 && Us(S) == 2 && (m = 0);
        }
    }
  return s;
}
function NS(e, t, n, r, i, s, o, a, l, h, u, f) {
  for (var d = i - 1, p = i === 0 ? s : [""], g = Y7(p), m = 0, y = 0, O = 0; m < r; ++m)
    for (var x = 0, _ = Mh(e, d + 1, d = qY(y = o[m])), w = e; x < g; ++x)
      (w = V7(y > 0 ? p[x] + " " + _ : Pe(_, /&\f/g, p[x]))) && (l[O++] = w);
  return D2(e, t, n, i === 0 ? A2 : a, l, h, u, f);
}
function rz(e, t, n, r) {
  return D2(e, t, n, Q7, Uk(jY()), Mh(e, 2, -2), 0, r);
}
function BS(e, t, n, r, i) {
  return D2(e, t, n, Wk, Mh(e, 0, r), Mh(e, r + 1, -1), r, i);
}
function q7(e, t, n) {
  switch (WY(e, t)) {
    case 5103:
      return Ye + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Ye + e + e;
    case 4789:
      return Ff + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Ye + e + Ff + e + nn + e + e;
    case 5936:
      switch (ir(e, t + 11)) {
        case 114:
          return Ye + e + nn + Pe(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return Ye + e + nn + Pe(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return Ye + e + nn + Pe(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
    case 6828:
    case 4268:
    case 2903:
      return Ye + e + nn + e + e;
    case 6165:
      return Ye + e + nn + "flex-" + e + e;
    case 5187:
      return Ye + e + Pe(e, /(\w+).+(:[^]+)/, Ye + "box-$1$2" + nn + "flex-$1$2") + e;
    case 5443:
      return Ye + e + nn + "flex-item-" + Pe(e, /flex-|-self/g, "") + (No(e, /flex-|baseline/) ? "" : nn + "grid-row-" + Pe(e, /flex-|-self/g, "")) + e;
    case 4675:
      return Ye + e + nn + "flex-line-pack" + Pe(e, /align-content|flex-|-self/g, "") + e;
    case 5548:
      return Ye + e + nn + Pe(e, "shrink", "negative") + e;
    case 5292:
      return Ye + e + nn + Pe(e, "basis", "preferred-size") + e;
    case 6060:
      return Ye + "box-" + Pe(e, "-grow", "") + Ye + e + nn + Pe(e, "grow", "positive") + e;
    case 4554:
      return Ye + Pe(e, /([^-])(transform)/g, "$1" + Ye + "$2") + e;
    case 6187:
      return Pe(Pe(Pe(e, /(zoom-|grab)/, Ye + "$1"), /(image-set)/, Ye + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return Pe(e, /(image-set\([^]*)/, Ye + "$1$`$1");
    case 4968:
      return Pe(Pe(e, /(.+:)(flex-)?(.*)/, Ye + "box-pack:$3" + nn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Ye + e + e;
    case 4200:
      if (!No(e, /flex-|baseline/))
        return nn + "grid-column-align" + Mh(e, t) + e;
      break;
    case 2592:
    case 3360:
      return nn + Pe(e, "template-", "") + e;
    case 4384:
    case 3616:
      return n && n.some(function(r, i) {
        return t = i, No(r.props, /grid-\w+-end/);
      }) ? ~C1(e + (n = n[t].value), "span") ? e : nn + Pe(e, "-start", "") + e + nn + "grid-row-span:" + (~C1(n, "span") ? No(n, /\d+/) : +No(n, /\d+/) - +No(e, /\d+/)) + ";" : nn + Pe(e, "-start", "") + e;
    case 4896:
    case 4128:
      return n && n.some(function(r) {
        return No(r.props, /grid-\w+-start/);
      }) ? e : nn + Pe(Pe(e, "-end", "-span"), "span ", "") + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Pe(e, /(.+)-inline(.+)/, Ye + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Us(e) - 1 - t > 6)
        switch (ir(e, t + 1)) {
          case 109:
            if (ir(e, t + 4) !== 45)
              break;
          case 102:
            return Pe(e, /(.+:)(.+)-([^]+)/, "$1" + Ye + "$2-$3$1" + Ff + (ir(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~C1(e, "stretch") ? q7(Pe(e, "stretch", "fill-available"), t, n) + e : e;
        }
      break;
    case 5152:
    case 5920:
      return Pe(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(r, i, s, o, a, l, h) {
        return nn + i + ":" + s + h + (o ? nn + i + "-span:" + (a ? l : +l - +s) + h : "") + e;
      });
    case 4949:
      if (ir(e, t + 6) === 121)
        return Pe(e, ":", ":" + Ye) + e;
      break;
    case 6444:
      switch (ir(e, ir(e, 14) === 45 ? 18 : 11)) {
        case 120:
          return Pe(e, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + Ye + (ir(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Ye + "$2$3$1" + nn + "$2box$3") + e;
        case 100:
          return Pe(e, ":", ":" + nn) + e;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return Pe(e, "scroll-", "scroll-snap-") + e;
  }
  return e;
}
function wg(e, t) {
  for (var n = "", r = 0; r < e.length; r++)
    n += t(e[r], r, e, t) || "";
  return n;
}
function iz(e, t, n, r) {
  switch (e.type) {
    case zY:
      if (e.children.length)
        break;
    case YY:
    case Wk:
      return e.return = e.return || e.value;
    case Q7:
      return "";
    case Z7:
      return e.return = e.value + "{" + wg(e.children, r) + "}";
    case A2:
      if (!Us(e.value = e.props.join(",")))
        return "";
  }
  return Us(n = wg(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function sz(e) {
  var t = Y7(e);
  return function(n, r, i, s) {
    for (var o = "", a = 0; a < t; a++)
      o += e[a](n, r, i, s) || "";
    return o;
  };
}
function oz(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function az(e, t, n, r) {
  if (e.length > -1 && !e.return)
    switch (e.type) {
      case Wk:
        e.return = q7(e.value, e.length, n);
        return;
      case Z7:
        return wg([Sa(e, { value: Pe(e.value, "@", "@" + Ye) })], r);
      case A2:
        if (e.length)
          return UY(n = e.props, function(i) {
            switch (No(i, r = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Bc(Sa(e, { props: [Pe(i, /:(read-\w+)/, ":" + Ff + "$1")] })), Bc(Sa(e, { props: [i] })), Rx(e, { props: IS(n, r) });
                break;
              case "::placeholder":
                Bc(Sa(e, { props: [Pe(i, /:(plac\w+)/, ":" + Ye + "input-$1")] })), Bc(Sa(e, { props: [Pe(i, /:(plac\w+)/, ":" + Ff + "$1")] })), Bc(Sa(e, { props: [Pe(i, /:(plac\w+)/, nn + "input-$1")] })), Bc(Sa(e, { props: [i] })), Rx(e, { props: IS(n, r) });
                break;
            }
            return "";
          });
    }
}
var lz = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, ec = typeof process < "u" && {} !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", W7 = "active", U7 = "data-styled-version", M2 = "6.1.2", jk = `/*!sc*/
`, Xk = typeof window < "u" && "HTMLElement" in window, cz = Boolean(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" ? {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY : {}.NODE_ENV !== "production"), FS = /invalid hook call/i, m0 = /* @__PURE__ */ new Set(), hz = function(e, t) {
  if ({}.NODE_ENV !== "production") {
    var n = t ? ' with the id of "'.concat(t, '"') : "", r = "The component ".concat(e).concat(n, ` has been created dynamically.
`) + `You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, i = console.error;
    try {
      var s = !0;
      console.error = function(o) {
        for (var a = [], l = 1; l < arguments.length; l++)
          a[l - 1] = arguments[l];
        FS.test(o) ? (s = !1, m0.delete(r)) : i.apply(void 0, Lh([o], a, !1));
      }, us(), s && !m0.has(r) && (console.warn(r), m0.add(r));
    } catch (o) {
      FS.test(o.message) && m0.delete(r);
    } finally {
      console.error = i;
    }
  }
}, R2 = Object.freeze([]), $h = Object.freeze({});
function uz(e, t, n) {
  return n === void 0 && (n = $h), e.theme !== n.theme && e.theme || t || n.theme;
}
var Nx = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), fz = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, dz = /(^-|-$)/g;
function QS(e) {
  return e.replace(fz, "-").replace(dz, "");
}
var pz = /(a)(d)/gi, y0 = 52, ZS = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function Bx(e) {
  var t, n = "";
  for (t = Math.abs(e); t > y0; t = t / y0 | 0)
    n = ZS(t % y0) + n;
  return (ZS(t % y0) + n).replace(pz, "$1-$2");
}
var pb, j7 = 5381, Dl = function(e, t) {
  for (var n = t.length; n; )
    e = 33 * e ^ t.charCodeAt(--n);
  return e;
}, X7 = function(e) {
  return Dl(j7, e);
};
function gz(e) {
  return Bx(X7(e) >>> 0);
}
function G7(e) {
  return {}.NODE_ENV !== "production" && typeof e == "string" && e || e.displayName || e.name || "Component";
}
function gb(e) {
  return typeof e == "string" && ({}.NODE_ENV === "production" || e.charAt(0) === e.charAt(0).toLowerCase());
}
var H7 = typeof Symbol == "function" && Symbol.for, K7 = H7 ? Symbol.for("react.memo") : 60115, mz = H7 ? Symbol.for("react.forward_ref") : 60112, yz = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, bz = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, J7 = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, Oz = ((pb = {})[mz] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, pb[K7] = J7, pb);
function VS(e) {
  return ("type" in (t = e) && t.type.$$typeof) === K7 ? J7 : "$$typeof" in e ? Oz[e.$$typeof] : yz;
  var t;
}
var xz = Object.defineProperty, vz = Object.getOwnPropertyNames, YS = Object.getOwnPropertySymbols, _z = Object.getOwnPropertyDescriptor, kz = Object.getPrototypeOf, zS = Object.prototype;
function t9(e, t, n) {
  if (typeof t != "string") {
    if (zS) {
      var r = kz(t);
      r && r !== zS && t9(e, r, n);
    }
    var i = vz(t);
    YS && (i = i.concat(YS(t)));
    for (var s = VS(e), o = VS(t), a = 0; a < i.length; ++a) {
      var l = i[a];
      if (!(l in bz || n && n[l] || o && l in o || s && l in s)) {
        var h = _z(t, l);
        try {
          xz(e, l, h);
        } catch {
        }
      }
    }
  }
  return e;
}
function Ih(e) {
  return typeof e == "function";
}
function Gk(e) {
  return typeof e == "object" && "styledComponentId" in e;
}
function Bl(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function qS(e, t) {
  if (e.length === 0)
    return "";
  for (var n = e[0], r = 1; r < e.length; r++)
    n += t ? t + e[r] : e[r];
  return n;
}
function Nh(e) {
  return e !== null && typeof e == "object" && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function Fx(e, t, n) {
  if (n === void 0 && (n = !1), !n && !Nh(e) && !Array.isArray(e))
    return t;
  if (Array.isArray(t))
    for (var r = 0; r < t.length; r++)
      e[r] = Fx(e[r], t[r]);
  else if (Nh(t))
    for (var r in t)
      e[r] = Fx(e[r], t[r]);
  return e;
}
function Hk(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
var wz = {}.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
`, 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function Sz() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var n = e[0], r = [], i = 1, s = e.length; i < s; i += 1)
    r.push(e[i]);
  return r.forEach(function(o) {
    n = n.replace(/%[a-z]/, o);
  }), n;
}
function Cu(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return {}.NODE_ENV === "production" ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e, " for more information.").concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : "")) : new Error(Sz.apply(void 0, Lh([wz[e]], t, !1)).trim());
}
var Cz = function() {
  function e(t) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t;
  }
  return e.prototype.indexOfGroup = function(t) {
    for (var n = 0, r = 0; r < t; r++)
      n += this.groupSizes[r];
    return n;
  }, e.prototype.insertRules = function(t, n) {
    if (t >= this.groupSizes.length) {
      for (var r = this.groupSizes, i = r.length, s = i; t >= s; )
        if ((s <<= 1) < 0)
          throw Cu(16, "".concat(t));
      this.groupSizes = new Uint32Array(s), this.groupSizes.set(r), this.length = s;
      for (var o = i; o < s; o++)
        this.groupSizes[o] = 0;
    }
    for (var a = this.indexOfGroup(t + 1), l = (o = 0, n.length); o < l; o++)
      this.tag.insertRule(a, n[o]) && (this.groupSizes[t]++, a++);
  }, e.prototype.clearGroup = function(t) {
    if (t < this.length) {
      var n = this.groupSizes[t], r = this.indexOfGroup(t), i = r + n;
      this.groupSizes[t] = 0;
      for (var s = r; s < i; s++)
        this.tag.deleteRule(r);
    }
  }, e.prototype.getGroup = function(t) {
    var n = "";
    if (t >= this.length || this.groupSizes[t] === 0)
      return n;
    for (var r = this.groupSizes[t], i = this.indexOfGroup(t), s = i + r, o = i; o < s; o++)
      n += "".concat(this.tag.getRule(o)).concat(jk);
    return n;
  }, e;
}(), A1 = /* @__PURE__ */ new Map(), Sg = /* @__PURE__ */ new Map(), P1 = 1, b0 = function(e) {
  if (A1.has(e))
    return A1.get(e);
  for (; Sg.has(P1); )
    P1++;
  var t = P1++;
  if ({}.NODE_ENV !== "production" && ((0 | t) < 0 || t > 1073741824))
    throw Cu(16, "".concat(t));
  return A1.set(e, t), Sg.set(t, e), t;
}, Tz = function(e, t) {
  P1 = t + 1, A1.set(e, t), Sg.set(t, e);
}, Ez = "style[".concat(ec, "][").concat(U7, '="').concat(M2, '"]'), Az = new RegExp("^".concat(ec, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), Pz = function(e, t, n) {
  for (var r, i = n.split(","), s = 0, o = i.length; s < o; s++)
    (r = i[s]) && e.registerName(t, r);
}, Dz = function(e, t) {
  for (var n, r = ((n = t.textContent) !== null && n !== void 0 ? n : "").split(jk), i = [], s = 0, o = r.length; s < o; s++) {
    var a = r[s].trim();
    if (a) {
      var l = a.match(Az);
      if (l) {
        var h = 0 | parseInt(l[1], 10), u = l[2];
        h !== 0 && (Tz(u, h), Pz(e, u, l[3]), e.getTag().insertRules(h, i)), i.length = 0;
      } else
        i.push(a);
    }
  }
};
function Lz() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var e9 = function(e) {
  var t = document.head, n = e || t, r = document.createElement("style"), i = function(a) {
    var l = Array.from(a.querySelectorAll("style[".concat(ec, "]")));
    return l[l.length - 1];
  }(n), s = i !== void 0 ? i.nextSibling : null;
  r.setAttribute(ec, W7), r.setAttribute(U7, M2);
  var o = Lz();
  return o && r.setAttribute("nonce", o), n.insertBefore(r, s), r;
}, Mz = function() {
  function e(t) {
    this.element = e9(t), this.element.appendChild(document.createTextNode("")), this.sheet = function(n) {
      if (n.sheet)
        return n.sheet;
      for (var r = document.styleSheets, i = 0, s = r.length; i < s; i++) {
        var o = r[i];
        if (o.ownerNode === n)
          return o;
      }
      throw Cu(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(t, n) {
    try {
      return this.sheet.insertRule(n, t), this.length++, !0;
    } catch {
      return !1;
    }
  }, e.prototype.deleteRule = function(t) {
    this.sheet.deleteRule(t), this.length--;
  }, e.prototype.getRule = function(t) {
    var n = this.sheet.cssRules[t];
    return n && n.cssText ? n.cssText : "";
  }, e;
}(), Rz = function() {
  function e(t) {
    this.element = e9(t), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(t, n) {
    if (t <= this.length && t >= 0) {
      var r = document.createTextNode(n);
      return this.element.insertBefore(r, this.nodes[t] || null), this.length++, !0;
    }
    return !1;
  }, e.prototype.deleteRule = function(t) {
    this.element.removeChild(this.nodes[t]), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.nodes[t].textContent : "";
  }, e;
}(), $z = function() {
  function e(t) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(t, n) {
    return t <= this.length && (this.rules.splice(t, 0, n), this.length++, !0);
  }, e.prototype.deleteRule = function(t) {
    this.rules.splice(t, 1), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.rules[t] : "";
  }, e;
}(), WS = Xk, Iz = { isServer: !Xk, useCSSOMInjection: !cz }, n9 = function() {
  function e(t, n, r) {
    t === void 0 && (t = $h), n === void 0 && (n = {});
    var i = this;
    this.options = ti(ti({}, Iz), t), this.gs = n, this.names = new Map(r), this.server = !!t.isServer, !this.server && Xk && WS && (WS = !1, function(s) {
      for (var o = document.querySelectorAll(Ez), a = 0, l = o.length; a < l; a++) {
        var h = o[a];
        h && h.getAttribute(ec) !== W7 && (Dz(s, h), h.parentNode && h.parentNode.removeChild(h));
      }
    }(this)), Hk(this, function() {
      return function(s) {
        for (var o = s.getTag(), a = o.length, l = "", h = function(f) {
          var d = function(O) {
            return Sg.get(O);
          }(f);
          if (d === void 0)
            return "continue";
          var p = s.names.get(d), g = o.getGroup(f);
          if (p === void 0 || g.length === 0)
            return "continue";
          var m = "".concat(ec, ".g").concat(f, '[id="').concat(d, '"]'), y = "";
          p !== void 0 && p.forEach(function(O) {
            O.length > 0 && (y += "".concat(O, ","));
          }), l += "".concat(g).concat(m, '{content:"').concat(y, '"}').concat(jk);
        }, u = 0; u < a; u++)
          h(u);
        return l;
      }(i);
    });
  }
  return e.registerId = function(t) {
    return b0(t);
  }, e.prototype.reconstructWithOptions = function(t, n) {
    return n === void 0 && (n = !0), new e(ti(ti({}, this.options), t), this.gs, n && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(t) {
    return this.gs[t] = (this.gs[t] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (t = function(n) {
      var r = n.useCSSOMInjection, i = n.target;
      return n.isServer ? new $z(i) : r ? new Mz(i) : new Rz(i);
    }(this.options), new Cz(t)));
    var t;
  }, e.prototype.hasNameForId = function(t, n) {
    return this.names.has(t) && this.names.get(t).has(n);
  }, e.prototype.registerName = function(t, n) {
    if (b0(t), this.names.has(t))
      this.names.get(t).add(n);
    else {
      var r = /* @__PURE__ */ new Set();
      r.add(n), this.names.set(t, r);
    }
  }, e.prototype.insertRules = function(t, n, r) {
    this.registerName(t, n), this.getTag().insertRules(b0(t), r);
  }, e.prototype.clearNames = function(t) {
    this.names.has(t) && this.names.get(t).clear();
  }, e.prototype.clearRules = function(t) {
    this.getTag().clearGroup(b0(t)), this.clearNames(t);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}(), Nz = /&/g, Bz = /^\s*\/\/.*$/gm;
function r9(e, t) {
  return e.map(function(n) {
    return n.type === "rule" && (n.value = "".concat(t, " ").concat(n.value), n.value = n.value.replaceAll(",", ",".concat(t, " ")), n.props = n.props.map(function(r) {
      return "".concat(t, " ").concat(r);
    })), Array.isArray(n.children) && n.type !== "@keyframes" && (n.children = r9(n.children, t)), n;
  });
}
function i9(e) {
  var t, n, r, i = e === void 0 ? $h : e, s = i.options, o = s === void 0 ? $h : s, a = i.plugins, l = a === void 0 ? R2 : a, h = function(d, p, g) {
    return g === n || g.startsWith(n) && g.endsWith(n) && g.replaceAll(n, "").length > 0 ? ".".concat(t) : d;
  }, u = l.slice();
  u.push(function(d) {
    d.type === A2 && d.value.includes("&") && (d.props[0] = d.props[0].replace(Nz, n).replace(r, h));
  }), o.prefix && u.push(az), u.push(iz);
  var f = function(d, p, g, m) {
    p === void 0 && (p = ""), g === void 0 && (g = ""), m === void 0 && (m = "&"), t = m, n = p, r = new RegExp("\\".concat(n, "\\b"), "g");
    var y = d.replace(Bz, ""), O = nz(g || p ? "".concat(g, " ").concat(p, " { ").concat(y, " }") : y);
    o.namespace && (O = r9(O, o.namespace));
    var x = [];
    return wg(O, sz(u.concat(oz(function(_) {
      return x.push(_);
    })))), x;
  };
  return f.hash = l.length ? l.reduce(function(d, p) {
    return p.name || Cu(15), Dl(d, p.name);
  }, j7).toString() : "", f;
}
var Fz = new n9(), Qx = i9(), Kk = tc.createContext({ shouldForwardProp: void 0, styleSheet: Fz, stylis: Qx });
Kk.Consumer;
var Qz = tc.createContext(void 0);
function Zx() {
  return P7(Kk);
}
function Zz(e) {
  var t = mn(e.stylisPlugins), n = t[0], r = t[1], i = Zx().styleSheet, s = Dn(function() {
    var l = i;
    return e.sheet ? l = e.sheet : e.target && (l = l.reconstructWithOptions({ target: e.target }, !1)), e.disableCSSOMInjection && (l = l.reconstructWithOptions({ useCSSOMInjection: !1 })), l;
  }, [e.disableCSSOMInjection, e.sheet, e.target, i]), o = Dn(function() {
    return i9({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: n });
  }, [e.enableVendorPrefixes, e.namespace, n]);
  lr(function() {
    VY(n, e.stylisPlugins) || r(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var a = Dn(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: s, stylis: o };
  }, [e.shouldForwardProp, s, o]);
  return tc.createElement(Kk.Provider, { value: a }, tc.createElement(Qz.Provider, { value: o }, e.children));
}
var US = function() {
  function e(t, n) {
    var r = this;
    this.inject = function(i, s) {
      s === void 0 && (s = Qx);
      var o = r.name + s.hash;
      i.hasNameForId(r.id, o) || i.insertRules(r.id, o, s(r.rules, o, "@keyframes"));
    }, this.name = t, this.id = "sc-keyframes-".concat(t), this.rules = n, Hk(this, function() {
      throw Cu(12, String(r.name));
    });
  }
  return e.prototype.getName = function(t) {
    return t === void 0 && (t = Qx), this.name + t.hash;
  }, e;
}(), Vz = function(e) {
  return e >= "A" && e <= "Z";
};
function jS(e) {
  for (var t = "", n = 0; n < e.length; n++) {
    var r = e[n];
    if (n === 1 && r === "-" && e[0] === "-")
      return e;
    Vz(r) ? t += "-" + r.toLowerCase() : t += r;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var s9 = function(e) {
  return e == null || e === !1 || e === "";
}, o9 = function(e) {
  var t, n, r = [];
  for (var i in e) {
    var s = e[i];
    e.hasOwnProperty(i) && !s9(s) && (Array.isArray(s) && s.isCss || Ih(s) ? r.push("".concat(jS(i), ":"), s, ";") : Nh(s) ? r.push.apply(r, Lh(Lh(["".concat(i, " {")], o9(s), !1), ["}"], !1)) : r.push("".concat(jS(i), ": ").concat((t = i, (n = s) == null || typeof n == "boolean" || n === "" ? "" : typeof n != "number" || n === 0 || t in lz || t.startsWith("--") ? String(n).trim() : "".concat(n, "px")), ";")));
  }
  return r;
};
function Wl(e, t, n, r) {
  if (s9(e))
    return [];
  if (Gk(e))
    return [".".concat(e.styledComponentId)];
  if (Ih(e)) {
    if (!Ih(s = e) || s.prototype && s.prototype.isReactComponent || !t)
      return [e];
    var i = e(t);
    return {}.NODE_ENV === "production" || typeof i != "object" || Array.isArray(i) || i instanceof US || Nh(i) || i === null || console.error("".concat(G7(e), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Wl(i, t, n, r);
  }
  var s;
  return e instanceof US ? n ? (e.inject(n, r), [e.getName(r)]) : [e] : Nh(e) ? o9(e) : Array.isArray(e) ? Array.prototype.concat.apply(R2, e.map(function(o) {
    return Wl(o, t, n, r);
  })) : [e.toString()];
}
function Yz(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t];
    if (Ih(n) && !Gk(n))
      return !1;
  }
  return !0;
}
var zz = X7(M2), qz = function() {
  function e(t, n, r) {
    this.rules = t, this.staticRulesId = "", this.isStatic = {}.NODE_ENV === "production" && (r === void 0 || r.isStatic) && Yz(t), this.componentId = n, this.baseHash = Dl(zz, n), this.baseStyle = r, n9.registerId(n);
  }
  return e.prototype.generateAndInjectStyles = function(t, n, r) {
    var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t, n, r) : "";
    if (this.isStatic && !r.hash)
      if (this.staticRulesId && n.hasNameForId(this.componentId, this.staticRulesId))
        i = Bl(i, this.staticRulesId);
      else {
        var s = qS(Wl(this.rules, t, n, r)), o = Bx(Dl(this.baseHash, s) >>> 0);
        if (!n.hasNameForId(this.componentId, o)) {
          var a = r(s, ".".concat(o), void 0, this.componentId);
          n.insertRules(this.componentId, o, a);
        }
        i = Bl(i, o), this.staticRulesId = o;
      }
    else {
      for (var l = Dl(this.baseHash, r.hash), h = "", u = 0; u < this.rules.length; u++) {
        var f = this.rules[u];
        if (typeof f == "string")
          h += f, {}.NODE_ENV !== "production" && (l = Dl(l, f));
        else if (f) {
          var d = qS(Wl(f, t, n, r));
          l = Dl(l, d + u), h += d;
        }
      }
      if (h) {
        var p = Bx(l >>> 0);
        n.hasNameForId(this.componentId, p) || n.insertRules(this.componentId, p, r(h, ".".concat(p), void 0, this.componentId)), i = Bl(i, p);
      }
    }
    return i;
  }, e;
}(), a9 = tc.createContext(void 0);
a9.Consumer;
var mb = {}, XS = /* @__PURE__ */ new Set();
function Wz(e, t, n) {
  var r = Gk(e), i = e, s = !gb(e), o = t.attrs, a = o === void 0 ? R2 : o, l = t.componentId, h = l === void 0 ? function(w, E) {
    var T = typeof w != "string" ? "sc" : QS(w);
    mb[T] = (mb[T] || 0) + 1;
    var S = "".concat(T, "-").concat(gz(M2 + T + mb[T]));
    return E ? "".concat(E, "-").concat(S) : S;
  }(t.displayName, t.parentComponentId) : l, u = t.displayName, f = u === void 0 ? function(w) {
    return gb(w) ? "styled.".concat(w) : "Styled(".concat(G7(w), ")");
  }(e) : u, d = t.displayName && t.componentId ? "".concat(QS(t.displayName), "-").concat(t.componentId) : t.componentId || h, p = r && i.attrs ? i.attrs.concat(a).filter(Boolean) : a, g = t.shouldForwardProp;
  if (r && i.shouldForwardProp) {
    var m = i.shouldForwardProp;
    if (t.shouldForwardProp) {
      var y = t.shouldForwardProp;
      g = function(w, E) {
        return m(w, E) && y(w, E);
      };
    } else
      g = m;
  }
  var O = new qz(n, d, r ? i.componentStyle : void 0);
  function x(w, E) {
    return function(T, S, R) {
      var A = T.attrs, P = T.componentStyle, C = T.defaultProps, k = T.foldedComponentIds, D = T.styledComponentId, b = T.target, M = tc.useContext(a9), v = Zx(), N = T.shouldForwardProp || v.shouldForwardProp;
      ({}).NODE_ENV !== "production" && Px(D);
      var tt = function(st, ct, Y) {
        for (var Ct, H = ti(ti({}, ct), { className: void 0, theme: Y }), et = 0; et < st.length; et += 1) {
          var U = Ih(Ct = st[et]) ? Ct(H) : Ct;
          for (var W in U)
            H[W] = W === "className" ? Bl(H[W], U[W]) : W === "style" ? ti(ti({}, H[W]), U[W]) : U[W];
        }
        return ct.className && (H.className = Bl(H.className, ct.className)), H;
      }(A, S, uz(S, M, C) || $h), Z = tt.as || b, z = {};
      for (var X in tt)
        tt[X] === void 0 || X[0] === "$" || X === "as" || X === "theme" || (X === "forwardedAs" ? z.as = tt.forwardedAs : N && !N(X, Z) || (z[X] = tt[X], N || {}.NODE_ENV !== "development" || oY(X) || XS.has(X) || !Nx.has(Z) || (XS.add(X), console.warn('styled-components: it looks like an unknown prop "'.concat(X, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var q = function(st, ct) {
        var Y = Zx(), Ct = st.generateAndInjectStyles(ct, Y.styleSheet, Y.stylis);
        return {}.NODE_ENV !== "production" && Px(Ct), Ct;
      }(P, tt);
      ({}).NODE_ENV !== "production" && T.warnTooManyClasses && T.warnTooManyClasses(q);
      var nt = Bl(k, D);
      return q && (nt += " " + q), tt.className && (nt += " " + tt.className), z[gb(Z) && !Nx.has(Z) ? "class" : "className"] = nt, z.ref = R, bs(Z, z);
    }(_, w, E);
  }
  x.displayName = f;
  var _ = tc.forwardRef(x);
  return _.attrs = p, _.componentStyle = O, _.displayName = f, _.shouldForwardProp = g, _.foldedComponentIds = r ? Bl(i.foldedComponentIds, i.styledComponentId) : "", _.styledComponentId = d, _.target = r ? i.target : e, Object.defineProperty(_, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(w) {
    this._foldedDefaultProps = r ? function(E) {
      for (var T = [], S = 1; S < arguments.length; S++)
        T[S - 1] = arguments[S];
      for (var R = 0, A = T; R < A.length; R++)
        Fx(E, A[R], !0);
      return E;
    }({}, i.defaultProps, w) : w;
  } }), {}.NODE_ENV !== "production" && (hz(f, d), _.warnTooManyClasses = function(w, E) {
    var T = {}, S = !1;
    return function(R) {
      if (!S && (T[R] = !0, Object.keys(T).length >= 200)) {
        var A = E ? ' with the id of "'.concat(E, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(w).concat(A, `.
`) + `Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), S = !0, T = {};
      }
    };
  }(f, d)), Hk(_, function() {
    return ".".concat(_.styledComponentId);
  }), s && t9(_, e, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), _;
}
function GS(e, t) {
  for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1)
    n.push(t[r], e[r + 1]);
  return n;
}
var HS = function(e) {
  return Object.assign(e, { isCss: !0 });
};
function Qf(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  if (Ih(e) || Nh(e))
    return HS(Wl(GS(R2, Lh([e], t, !0))));
  var r = e;
  return t.length === 0 && r.length === 1 && typeof r[0] == "string" ? Wl(r) : HS(Wl(GS(r, t)));
}
function Vx(e, t, n) {
  if (n === void 0 && (n = $h), !t)
    throw Cu(1, t);
  var r = function(i) {
    for (var s = [], o = 1; o < arguments.length; o++)
      s[o - 1] = arguments[o];
    return e(t, n, Qf.apply(void 0, Lh([i], s, !1)));
  };
  return r.attrs = function(i) {
    return Vx(e, t, ti(ti({}, n), { attrs: Array.prototype.concat(n.attrs, i).filter(Boolean) }));
  }, r.withConfig = function(i) {
    return Vx(e, t, ti(ti({}, n), i));
  }, r;
}
var l9 = function(e) {
  return Vx(Wz, e);
}, ue = l9;
Nx.forEach(function(e) {
  ue[e] = l9(e);
});
({}).NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`);
var O0 = "__sc-".concat(ec, "__");
({}).NODE_ENV !== "production" && {}.NODE_ENV !== "test" && typeof window < "u" && (window[O0] || (window[O0] = 0), window[O0] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window[O0] += 1);
class Be {
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  replace(t, n, r) {
    [t, n] = Bh(this, t, n);
    let i = [];
    return this.decompose(0, t, i, 2), r.length && r.decompose(0, r.length, i, 3), this.decompose(n, this.length, i, 1), Gs.from(i, this.length - (n - t) + r.length);
  }
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  slice(t, n = this.length) {
    [t, n] = Bh(this, t, n);
    let r = [];
    return this.decompose(t, n, r, 0), Gs.from(r, n - t);
  }
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let n = this.scanIdentical(t, 1), r = this.length - this.scanIdentical(t, -1), i = new Zf(this), s = new Zf(t);
    for (let o = n, a = n; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (a += i.value.length, i.done || a >= r)
        return !0;
    }
  }
  iter(t = 1) {
    return new Zf(this, t);
  }
  iterRange(t, n = this.length) {
    return new c9(this, t, n);
  }
  iterLines(t, n) {
    let r;
    if (t == null)
      r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(t).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new h9(r);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  constructor() {
  }
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? Be.empty : t.length <= 32 ? new Cn(t) : Gs.from(Cn.split(t, []));
  }
}
class Cn extends Be {
  constructor(t, n = Uz(t)) {
    super(), this.text = t, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], a = i + o.length;
      if ((n ? r : a) >= t)
        return new jz(i, a, r, o);
      i = a + 1, r++;
    }
  }
  decompose(t, n, r, i) {
    let s = t <= 0 && n >= this.length ? this : new Cn(KS(this.text, t, n), Math.min(n, this.length) - Math.max(0, t));
    if (i & 1) {
      let o = r.pop(), a = D1(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32)
        r.push(new Cn(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        r.push(new Cn(a.slice(0, l)), new Cn(a.slice(l)));
      }
    } else
      r.push(s);
  }
  replace(t, n, r) {
    if (!(r instanceof Cn))
      return super.replace(t, n, r);
    [t, n] = Bh(this, t, n);
    let i = D1(this.text, D1(r.text, KS(this.text, 0, t)), n), s = this.length + r.length - (n - t);
    return i.length <= 32 ? new Cn(i, s) : Gs.from(Cn.split(i, []), s);
  }
  sliceString(t, n = this.length, r = `
`) {
    [t, n] = Bh(this, t, n);
    let i = "";
    for (let s = 0, o = 0; s <= n && o < this.text.length; o++) {
      let a = this.text[o], l = s + a.length;
      s > t && o && (i += r), t < l && n > s && (i += a.slice(Math.max(0, t - s), n - s)), s = l + 1;
    }
    return i;
  }
  flatten(t) {
    for (let n of this.text)
      t.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, n) {
    let r = [], i = -1;
    for (let s of t)
      r.push(s), i += s.length + 1, r.length == 32 && (n.push(new Cn(r, i)), r = [], i = -1);
    return i > -1 && n.push(new Cn(r, i)), n;
  }
}
class Gs extends Be {
  constructor(t, n) {
    super(), this.children = t, this.length = n, this.lines = 0;
    for (let r of t)
      this.lines += r.lines;
  }
  lineInner(t, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], a = i + o.length, l = r + o.lines - 1;
      if ((n ? l : a) >= t)
        return o.lineInner(t, n, r, i);
      i = a + 1, r = l + 1;
    }
  }
  decompose(t, n, r, i) {
    for (let s = 0, o = 0; o <= n && s < this.children.length; s++) {
      let a = this.children[s], l = o + a.length;
      if (t <= l && n >= o) {
        let h = i & ((o <= t ? 1 : 0) | (l >= n ? 2 : 0));
        o >= t && l <= n && !h ? r.push(a) : a.decompose(t - o, n - o, r, h);
      }
      o = l + 1;
    }
  }
  replace(t, n, r) {
    if ([t, n] = Bh(this, t, n), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], a = s + o.length;
        if (t >= s && n <= a) {
          let l = o.replace(t - s, n - s, r), h = this.lines - o.lines + l.lines;
          if (l.lines < h >> 5 - 1 && l.lines > h >> 5 + 1) {
            let u = this.children.slice();
            return u[i] = l, new Gs(u, this.length - (n - t) + r.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(t, n, r);
  }
  sliceString(t, n = this.length, r = `
`) {
    [t, n] = Bh(this, t, n);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= n; s++) {
      let a = this.children[s], l = o + a.length;
      o > t && s && (i += r), t < l && n > o && (i += a.sliceString(t - o, n - o, r)), o = l + 1;
    }
    return i;
  }
  flatten(t) {
    for (let n of this.children)
      n.flatten(t);
  }
  scanIdentical(t, n) {
    if (!(t instanceof Gs))
      return 0;
    let r = 0, [i, s, o, a] = n > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; i += n, s += n) {
      if (i == o || s == a)
        return r;
      let l = this.children[i], h = t.children[s];
      if (l != h)
        return r + l.scanIdentical(h, n);
      r += l.length + 1;
    }
  }
  static from(t, n = t.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let p of t)
      r += p.lines;
    if (r < 32) {
      let p = [];
      for (let g of t)
        g.flatten(p);
      return new Cn(p, n);
    }
    let i = Math.max(32, r >> 5), s = i << 1, o = i >> 1, a = [], l = 0, h = -1, u = [];
    function f(p) {
      let g;
      if (p.lines > s && p instanceof Gs)
        for (let m of p.children)
          f(m);
      else
        p.lines > o && (l > o || !l) ? (d(), a.push(p)) : p instanceof Cn && l && (g = u[u.length - 1]) instanceof Cn && p.lines + g.lines <= 32 ? (l += p.lines, h += p.length + 1, u[u.length - 1] = new Cn(g.text.concat(p.text), g.length + 1 + p.length)) : (l + p.lines > i && d(), l += p.lines, h += p.length + 1, u.push(p));
    }
    function d() {
      l != 0 && (a.push(u.length == 1 ? u[0] : Gs.from(u, h)), h = -1, l = u.length = 0);
    }
    for (let p of t)
      f(p);
    return d(), a.length == 1 ? a[0] : new Gs(a, n);
  }
}
Be.empty = /* @__PURE__ */ new Cn([""], 0);
function Uz(e) {
  let t = -1;
  for (let n of e)
    t += n.length + 1;
  return t;
}
function D1(e, t, n = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < e.length && i <= r; s++) {
    let a = e[s], l = i + a.length;
    l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), o ? (t[t.length - 1] += a, o = !1) : t.push(a)), i = l + 1;
  }
  return t;
}
function KS(e, t, n) {
  return D1(e, [""], t, n);
}
class Zf {
  constructor(t, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [n > 0 ? 1 : (t instanceof Cn ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, a = i instanceof Cn ? i.text.length : i.children.length;
      if (o == (n > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[r] += n, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (i instanceof Cn) {
        let l = i.text[o + (n < 0 ? -1 : 0)];
        if (this.offsets[r] += n, l.length > Math.max(0, t))
          return this.value = t == 0 ? l : n > 0 ? l.slice(t) : l.slice(0, l.length - t), this;
        t -= l.length;
      } else {
        let l = i.children[o + (n < 0 ? -1 : 0)];
        t > l.length ? (t -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof Cn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}
class c9 {
  constructor(t, n, r) {
    this.value = "", this.done = !1, this.cursor = new Zf(t, n > r ? -1 : 1), this.pos = n > r ? t.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
  }
  nextInner(t, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    t > r && (t = r), r -= t;
    let { value: i } = this.cursor.next(t);
    return this.pos += (i.length + t) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class h9 {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(t);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Be.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Zf.prototype[Symbol.iterator] = c9.prototype[Symbol.iterator] = h9.prototype[Symbol.iterator] = function() {
  return this;
});
class jz {
  constructor(t, n, r, i) {
    this.from = t, this.to = n, this.number = r, this.text = i;
  }
  get length() {
    return this.to - this.from;
  }
}
function Bh(e, t, n) {
  return t = Math.max(0, Math.min(e.length, t)), [t, Math.max(t, Math.min(e.length, n))];
}
let uh = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
for (let e = 1; e < uh.length; e++)
  uh[e] += uh[e - 1];
function Xz(e) {
  for (let t = 1; t < uh.length; t += 2)
    if (uh[t] > e)
      return uh[t - 1] <= e;
  return !1;
}
function JS(e) {
  return e >= 127462 && e <= 127487;
}
const t4 = 8205;
function mr(e, t, n = !0, r = !0) {
  return (n ? u9 : Gz)(e, t, r);
}
function u9(e, t, n) {
  if (t == e.length)
    return t;
  t && f9(e.charCodeAt(t)) && d9(e.charCodeAt(t - 1)) && t--;
  let r = pr(e, t);
  for (t += Mi(r); t < e.length; ) {
    let i = pr(e, t);
    if (r == t4 || i == t4 || n && Xz(i))
      t += Mi(i), r = i;
    else if (JS(i)) {
      let s = 0, o = t - 2;
      for (; o >= 0 && JS(pr(e, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      t += 2;
    } else
      break;
  }
  return t;
}
function Gz(e, t, n) {
  for (; t > 0; ) {
    let r = u9(e, t - 2, n);
    if (r < t)
      return r;
    t--;
  }
  return 0;
}
function f9(e) {
  return e >= 56320 && e < 57344;
}
function d9(e) {
  return e >= 55296 && e < 56320;
}
function pr(e, t) {
  let n = e.charCodeAt(t);
  if (!d9(n) || t + 1 == e.length)
    return n;
  let r = e.charCodeAt(t + 1);
  return f9(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function Jk(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
function Mi(e) {
  return e < 65536 ? 1 : 2;
}
const Yx = /\r\n?|\n/;
var Gn = /* @__PURE__ */ function(e) {
  return e[e.Simple = 0] = "Simple", e[e.TrackDel = 1] = "TrackDel", e[e.TrackBefore = 2] = "TrackBefore", e[e.TrackAfter = 3] = "TrackAfter", e;
}(Gn || (Gn = {}));
class oo {
  constructor(t) {
    this.sections = t;
  }
  get length() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      t += this.sections[n];
    return t;
  }
  get newLength() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      t += r < 0 ? this.sections[n] : r;
    }
    return t;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(t) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let s = this.sections[n++], o = this.sections[n++];
      o < 0 ? (t(r, i, s), i += s) : i += o, r += s;
    }
  }
  iterChangedRanges(t, n = !1) {
    zx(this, t, n);
  }
  get invertedDesc() {
    let t = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      i < 0 ? t.push(r, i) : t.push(i, r);
    }
    return new oo(t);
  }
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : p9(this, t);
  }
  mapDesc(t, n = !1) {
    return t.empty ? this : qx(this, t, n);
  }
  mapPos(t, n = -1, r = Gn.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], h = i + a;
      if (l < 0) {
        if (h > t)
          return s + (t - i);
        s += a;
      } else {
        if (r != Gn.Simple && h >= t && (r == Gn.TrackDel && i < t && h > t || r == Gn.TrackBefore && i < t || r == Gn.TrackAfter && h > t))
          return null;
        if (h > t || h == t && n < 0 && !a)
          return t == i || n < 0 ? s : s + l;
        s += l;
      }
      i = h;
    }
    if (t > i)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${i}`);
    return s;
  }
  touchesRange(t, n = t) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let s = this.sections[r++], o = this.sections[r++], a = i + s;
      if (o >= 0 && i <= n && a >= t)
        return i < t && a > n ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  toString() {
    let t = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      t += (t ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return t;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new oo(t);
  }
  static create(t) {
    return new oo(t);
  }
}
class $n extends oo {
  constructor(t, n) {
    super(t), this.inserted = n;
  }
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return zx(this, (n, r, i, s, o) => t = t.replace(i, i + (r - n), o), !1), t;
  }
  mapDesc(t, n = !1) {
    return qx(this, t, n, !0);
  }
  invert(t) {
    let n = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < n.length; i += 2) {
      let o = n[i], a = n[i + 1];
      if (a >= 0) {
        n[i] = a, n[i + 1] = o;
        let l = i >> 1;
        for (; r.length < l; )
          r.push(Be.empty);
        r.push(o ? t.slice(s, s + o) : Be.empty);
      }
      s += o;
    }
    return new $n(n, r);
  }
  compose(t) {
    return this.empty ? t : t.empty ? this : p9(this, t, !0);
  }
  map(t, n = !1) {
    return t.empty ? this : qx(this, t, n, !0);
  }
  iterChanges(t, n = !1) {
    zx(this, t, n);
  }
  get desc() {
    return oo.create(this.sections);
  }
  filter(t) {
    let n = [], r = [], i = [], s = new fd(this);
    t:
      for (let o = 0, a = 0; ; ) {
        let l = o == t.length ? 1e9 : t[o++];
        for (; a < l || a == l && s.len == 0; ) {
          if (s.done)
            break t;
          let u = Math.min(s.len, l - a);
          Sr(i, u, -1);
          let f = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          Sr(n, u, f), f > 0 && $a(r, n, s.text), s.forward(u), a += u;
        }
        let h = t[o++];
        for (; a < h; ) {
          if (s.done)
            break t;
          let u = Math.min(s.len, h - a);
          Sr(n, u, -1), Sr(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), a += u;
        }
      }
    return {
      changes: new $n(n, r),
      filtered: oo.create(i)
    };
  }
  toJSON() {
    let t = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n], i = this.sections[n + 1];
      i < 0 ? t.push(r) : i == 0 ? t.push([r]) : t.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return t;
  }
  static of(t, n, r) {
    let i = [], s = [], o = 0, a = null;
    function l(u = !1) {
      if (!u && !i.length)
        return;
      o < n && Sr(i, n - o, -1);
      let f = new $n(i, s);
      a = a ? a.compose(f.map(a)) : f, i = [], s = [], o = 0;
    }
    function h(u) {
      if (Array.isArray(u))
        for (let f of u)
          h(f);
      else if (u instanceof $n) {
        if (u.length != n)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: f, to: d = f, insert: p } = u;
        if (f > d || f < 0 || d > n)
          throw new RangeError(`Invalid change range ${f} to ${d} (in doc of length ${n})`);
        let g = p ? typeof p == "string" ? Be.of(p.split(r || Yx)) : p : Be.empty, m = g.length;
        if (f == d && m == 0)
          return;
        f < o && l(), f > o && Sr(i, f - o, -1), Sr(i, d - f, m), $a(s, i, g), o = d;
      }
    }
    return h(t), l(!a), a;
  }
  static empty(t) {
    return new $n(t ? [t, -1] : [], []);
  }
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], r = [];
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      if (typeof s == "number")
        n.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          n.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(Be.empty);
          r[i] = Be.of(s.slice(1)), n.push(s[0], r[i].length);
        }
      }
    }
    return new $n(n, r);
  }
  static createSet(t, n) {
    return new $n(t, n);
  }
}
function Sr(e, t, n, r = !1) {
  if (t == 0 && n <= 0)
    return;
  let i = e.length - 2;
  i >= 0 && n <= 0 && n == e[i + 1] ? e[i] += t : t == 0 && e[i] == 0 ? e[i + 1] += n : r ? (e[i] += t, e[i + 1] += n) : e.push(t, n);
}
function $a(e, t, n) {
  if (n.length == 0)
    return;
  let r = t.length - 2 >> 1;
  if (r < e.length)
    e[e.length - 1] = e[e.length - 1].append(n);
  else {
    for (; e.length < r; )
      e.push(Be.empty);
    e.push(n);
  }
}
function zx(e, t, n) {
  let r = e.inserted;
  for (let i = 0, s = 0, o = 0; o < e.sections.length; ) {
    let a = e.sections[o++], l = e.sections[o++];
    if (l < 0)
      i += a, s += a;
    else {
      let h = i, u = s, f = Be.empty;
      for (; h += a, u += l, l && r && (f = f.append(r[o - 2 >> 1])), !(n || o == e.sections.length || e.sections[o + 1] < 0); )
        a = e.sections[o++], l = e.sections[o++];
      t(i, h, s, u, f), i = h, s = u;
    }
  }
}
function qx(e, t, n, r = !1) {
  let i = [], s = r ? [] : null, o = new fd(e), a = new fd(t);
  for (let l = -1; ; )
    if (o.ins == -1 && a.ins == -1) {
      let h = Math.min(o.len, a.len);
      Sr(i, h, -1), o.forward(h), a.forward(h);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !n))) {
      let h = a.len;
      for (Sr(i, a.ins, -1); h; ) {
        let u = Math.min(o.len, h);
        o.ins >= 0 && l < o.i && o.len <= u && (Sr(i, 0, o.ins), s && $a(s, i, o.text), l = o.i), o.forward(u), h -= u;
      }
      a.next();
    } else if (o.ins >= 0) {
      let h = 0, u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let f = Math.min(u, a.len);
          h += f, u -= f, a.forward(f);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      Sr(i, h, l < o.i ? o.ins : 0), s && l < o.i && $a(s, i, o.text), l = o.i, o.forward(o.len - u);
    } else {
      if (o.done && a.done)
        return s ? $n.createSet(i, s) : oo.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function p9(e, t, n = !1) {
  let r = [], i = n ? [] : null, s = new fd(e), o = new fd(t);
  for (let a = !1; ; ) {
    if (s.done && o.done)
      return i ? $n.createSet(r, i) : oo.create(r);
    if (s.ins == 0)
      Sr(r, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done)
      Sr(r, 0, o.ins, a), i && $a(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len), h = r.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Sr(r, l, u, a), i && u && $a(i, r, o.text);
        } else
          o.ins == -1 ? (Sr(r, s.off ? 0 : s.len, l, a), i && $a(i, r, s.textBit(l))) : (Sr(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), i && !o.off && $a(i, r, o.text));
        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || r.length > h), s.forward2(l), o.forward(l);
      }
    }
  }
}
class fd {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, n = this.i - 2 >> 1;
    return n >= t.length ? Be.empty : t[n];
  }
  textBit(t) {
    let { inserted: n } = this.set, r = this.i - 2 >> 1;
    return r >= n.length && !t ? Be.empty : n[r].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}
class Fl {
  constructor(t, n, r) {
    this.from = t, this.to = n, this.flags = r;
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  map(t, n = -1) {
    let r, i;
    return this.empty ? r = i = t.mapPos(this.from, n) : (r = t.mapPos(this.from, 1), i = t.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new Fl(r, i, this.flags);
  }
  extend(t, n = t) {
    if (t <= this.anchor && n >= this.anchor)
      return mt.range(t, n);
    let r = Math.abs(t - this.anchor) > Math.abs(n - this.anchor) ? t : n;
    return mt.range(this.anchor, r);
  }
  eq(t) {
    return this.anchor == t.anchor && this.head == t.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return mt.range(t.anchor, t.head);
  }
  static create(t, n, r) {
    return new Fl(t, n, r);
  }
}
class mt {
  constructor(t, n) {
    this.ranges = t, this.mainIndex = n;
  }
  map(t, n = -1) {
    return t.empty ? this : mt.create(this.ranges.map((r) => r.map(t, n)), this.mainIndex);
  }
  eq(t) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(t.ranges[n]))
        return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new mt([this.main], 0);
  }
  addRange(t, n = !0) {
    return mt.create([t].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  replaceRange(t, n = this.mainIndex) {
    let r = this.ranges.slice();
    return r[n] = t, mt.create(r, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new mt(t.ranges.map((n) => Fl.fromJSON(n)), t.main);
  }
  static single(t, n = t) {
    return new mt([mt.range(t, n)], 0);
  }
  static create(t, n = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < t.length; i++) {
      let s = t[i];
      if (s.empty ? s.from <= r : s.from < r)
        return mt.normalized(t.slice(), n);
      r = s.to;
    }
    return new mt(t, n);
  }
  static cursor(t, n = 0, r, i) {
    return Fl.create(t, t, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i != null ? i : 16777215) << 6);
  }
  static range(t, n, r, i) {
    let s = (r != null ? r : 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return n < t ? Fl.create(n, t, 48 | s) : Fl.create(t, n, (n > t ? 8 : 0) | s);
  }
  static normalized(t, n = 0) {
    let r = t[n];
    t.sort((i, s) => i.from - s.from), n = t.indexOf(r);
    for (let i = 1; i < t.length; i++) {
      let s = t[i], o = t[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from, l = Math.max(s.to, o.to);
        i <= n && n--, t.splice(--i, 2, s.anchor > s.head ? mt.range(l, a) : mt.range(a, l));
      }
    }
    return new mt(t, n);
  }
}
function g9(e, t) {
  for (let n of e.ranges)
    if (n.to > t)
      throw new RangeError("Selection points outside of document");
}
let tw = 0;
class Ft {
  constructor(t, n, r, i, s) {
    this.combine = t, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = tw++, this.default = t([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  get reader() {
    return this;
  }
  static define(t = {}) {
    return new Ft(t.combine || ((n) => n), t.compareInput || ((n, r) => n === r), t.compare || (t.combine ? (n, r) => n === r : ew), !!t.static, t.enables);
  }
  of(t) {
    return new L1([], this, 0, t);
  }
  compute(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new L1(t, this, 1, n);
  }
  computeN(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new L1(t, this, 2, n);
  }
  from(t, n) {
    return n || (n = (r) => r), this.compute([t], (r) => n(r.field(t)));
  }
}
function ew(e, t) {
  return e == t || e.length == t.length && e.every((n, r) => n === t[r]);
}
class L1 {
  constructor(t, n, r, i) {
    this.dependencies = t, this.facet = n, this.type = r, this.value = i, this.id = tw++;
  }
  dynamicSlot(t) {
    var n;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = t[s] >> 1, a = this.type == 2, l = !1, h = !1, u = [];
    for (let f of this.dependencies)
      f == "doc" ? l = !0 : f == "selection" ? h = !0 : (((n = t[f.id]) !== null && n !== void 0 ? n : 1) & 1) == 0 && u.push(t[f.id]);
    return {
      create(f) {
        return f.values[o] = r(f), 1;
      },
      update(f, d) {
        if (l && d.docChanged || h && (d.docChanged || d.selection) || Wx(f, u)) {
          let p = r(f);
          if (a ? !e4(p, f.values[o], i) : !i(p, f.values[o]))
            return f.values[o] = p, 1;
        }
        return 0;
      },
      reconfigure: (f, d) => {
        let p, g = d.config.address[s];
        if (g != null) {
          let m = Tg(d, g);
          if (this.dependencies.every((y) => y instanceof Ft ? d.facet(y) === f.facet(y) : y instanceof bn ? d.field(y, !1) == f.field(y, !1) : !0) || (a ? e4(p = r(f), m, i) : i(p = r(f), m)))
            return f.values[o] = m, 0;
        } else
          p = r(f);
        return f.values[o] = p, 1;
      }
    };
  }
}
function e4(e, t, n) {
  if (e.length != t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (!n(e[r], t[r]))
      return !1;
  return !0;
}
function Wx(e, t) {
  let n = !1;
  for (let r of t)
    Vf(e, r) & 1 && (n = !0);
  return n;
}
function Hz(e, t, n) {
  let r = n.map((l) => e[l.id]), i = n.map((l) => l.type), s = r.filter((l) => !(l & 1)), o = e[t.id] >> 1;
  function a(l) {
    let h = [];
    for (let u = 0; u < r.length; u++) {
      let f = Tg(l, r[u]);
      if (i[u] == 2)
        for (let d of f)
          h.push(d);
      else
        h.push(f);
    }
    return t.combine(h);
  }
  return {
    create(l) {
      for (let h of r)
        Vf(l, h);
      return l.values[o] = a(l), 1;
    },
    update(l, h) {
      if (!Wx(l, s))
        return 0;
      let u = a(l);
      return t.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);
    },
    reconfigure(l, h) {
      let u = Wx(l, r), f = h.config.facets[t.id], d = h.facet(t);
      if (f && !u && ew(n, f))
        return l.values[o] = d, 0;
      let p = a(l);
      return t.compare(p, d) ? (l.values[o] = d, 0) : (l.values[o] = p, 1);
    }
  };
}
const n4 = /* @__PURE__ */ Ft.define({ static: !0 });
class bn {
  constructor(t, n, r, i, s) {
    this.id = t, this.createF = n, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  static define(t) {
    let n = new bn(tw++, t.create, t.update, t.compare || ((r, i) => r === i), t);
    return t.provide && (n.provides = t.provide(n)), n;
  }
  create(t) {
    let n = t.facet(n4).find((r) => r.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(t);
  }
  slot(t) {
    let n = t[this.id] >> 1;
    return {
      create: (r) => (r.values[n] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[n], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[n] = o, 1);
      },
      reconfigure: (r, i) => i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1)
    };
  }
  init(t) {
    return [this, n4.of({ field: this, create: t })];
  }
  get extension() {
    return this;
  }
}
const Ll = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Hu(e) {
  return (t) => new m9(t, e);
}
const Ts = {
  highest: /* @__PURE__ */ Hu(Ll.highest),
  high: /* @__PURE__ */ Hu(Ll.high),
  default: /* @__PURE__ */ Hu(Ll.default),
  low: /* @__PURE__ */ Hu(Ll.low),
  lowest: /* @__PURE__ */ Hu(Ll.lowest)
};
class m9 {
  constructor(t, n) {
    this.inner = t, this.prec = n;
  }
}
class Sc {
  of(t) {
    return new Ux(this, t);
  }
  reconfigure(t) {
    return Sc.reconfigure.of({ compartment: this, extension: t });
  }
  get(t) {
    return t.config.compartments.get(this);
  }
}
class Ux {
  constructor(t, n) {
    this.compartment = t, this.inner = n;
  }
}
class Cg {
  constructor(t, n, r, i, s, o) {
    for (this.base = t, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(0);
  }
  staticFacet(t) {
    let n = this.address[t.id];
    return n == null ? t.default : this.staticValues[n >> 1];
  }
  static resolve(t, n, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let d of Kz(t, n, o))
      d instanceof bn ? i.push(d) : (s[d.facet.id] || (s[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], h = [];
    for (let d of i)
      a[d.id] = h.length << 1, h.push((p) => d.slot(p));
    let u = r == null ? void 0 : r.config.facets;
    for (let d in s) {
      let p = s[d], g = p[0].facet, m = u && u[d] || [];
      if (p.every((y) => y.type == 0))
        if (a[g.id] = l.length << 1 | 1, ew(m, p))
          l.push(r.facet(g));
        else {
          let y = g.combine(p.map((O) => O.value));
          l.push(r && g.compare(y, r.facet(g)) ? r.facet(g) : y);
        }
      else {
        for (let y of p)
          y.type == 0 ? (a[y.id] = l.length << 1 | 1, l.push(y.value)) : (a[y.id] = h.length << 1, h.push((O) => y.dynamicSlot(O)));
        a[g.id] = h.length << 1, h.push((y) => Hz(y, g, p));
      }
    }
    let f = h.map((d) => d(a));
    return new Cg(t, o, f, a, l, s);
  }
}
function Kz(e, t, n) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, a) {
    let l = i.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let h = r[l].indexOf(o);
      h > -1 && r[l].splice(h, 1), o instanceof Ux && n.delete(o.compartment);
    }
    if (i.set(o, a), Array.isArray(o))
      for (let h of o)
        s(h, a);
    else if (o instanceof Ux) {
      if (n.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let h = t.get(o.compartment) || o.inner;
      n.set(o.compartment, h), s(h, a);
    } else if (o instanceof m9)
      s(o.inner, o.prec);
    else if (o instanceof bn)
      r[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof L1)
      r[a].push(o), o.facet.extensions && s(o.facet.extensions, Ll.default);
    else {
      let h = o.extension;
      if (!h)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(h, a);
    }
  }
  return s(e, Ll.default), r.reduce((o, a) => o.concat(a));
}
function Vf(e, t) {
  if (t & 1)
    return 2;
  let n = t >> 1, r = e.status[n];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  e.status[n] = 4;
  let i = e.computeSlot(e, e.config.dynamicSlots[n]);
  return e.status[n] = 2 | i;
}
function Tg(e, t) {
  return t & 1 ? e.config.staticValues[t >> 1] : e.values[t >> 1];
}
const y9 = /* @__PURE__ */ Ft.define(), jx = /* @__PURE__ */ Ft.define({
  combine: (e) => e.some((t) => t),
  static: !0
}), b9 = /* @__PURE__ */ Ft.define({
  combine: (e) => e.length ? e[0] : void 0,
  static: !0
}), O9 = /* @__PURE__ */ Ft.define(), x9 = /* @__PURE__ */ Ft.define(), v9 = /* @__PURE__ */ Ft.define(), _9 = /* @__PURE__ */ Ft.define({
  combine: (e) => e.length ? e[0] : !1
});
class Es {
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  static define() {
    return new Jz();
  }
}
class Jz {
  of(t) {
    return new Es(this, t);
  }
}
class tq {
  constructor(t) {
    this.map = t;
  }
  of(t) {
    return new le(this, t);
  }
}
class le {
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  map(t) {
    let n = this.type.map(this.value, t);
    return n === void 0 ? void 0 : n == this.value ? this : new le(this.type, n);
  }
  is(t) {
    return this.type == t;
  }
  static define(t = {}) {
    return new tq(t.map || ((n) => n));
  }
  static mapEffects(t, n) {
    if (!t.length)
      return t;
    let r = [];
    for (let i of t) {
      let s = i.map(n);
      s && r.push(s);
    }
    return r;
  }
}
le.reconfigure = /* @__PURE__ */ le.define();
le.appendConfig = /* @__PURE__ */ le.define();
class Zn {
  constructor(t, n, r, i, s, o) {
    this.startState = t, this.changes = n, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && g9(r, n.newLength), s.some((a) => a.type == Zn.time) || (this.annotations = s.concat(Zn.time.of(Date.now())));
  }
  static create(t, n, r, i, s, o) {
    return new Zn(t, n, r, i, s, o);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(t) {
    for (let n of this.annotations)
      if (n.type == t)
        return n.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(t) {
    let n = this.annotation(Zn.userEvent);
    return !!(n && (n == t || n.length > t.length && n.slice(0, t.length) == t && n[t.length] == "."));
  }
}
Zn.time = /* @__PURE__ */ Es.define();
Zn.userEvent = /* @__PURE__ */ Es.define();
Zn.addToHistory = /* @__PURE__ */ Es.define();
Zn.remote = /* @__PURE__ */ Es.define();
function eq(e, t) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < e.length && (i == t.length || t[i] >= e[r]))
      s = e[r++], o = e[r++];
    else if (i < t.length)
      s = t[i++], o = t[i++];
    else
      return n;
    !n.length || n[n.length - 1] < s ? n.push(s, o) : n[n.length - 1] < o && (n[n.length - 1] = o);
  }
}
function k9(e, t, n) {
  var r;
  let i, s, o;
  return n ? (i = t.changes, s = $n.empty(t.changes.length), o = e.changes.compose(t.changes)) : (i = t.changes.map(e.changes), s = e.changes.mapDesc(t.changes, !0), o = e.changes.compose(i)), {
    changes: o,
    selection: t.selection ? t.selection.map(s) : (r = e.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: le.mapEffects(e.effects, i).concat(le.mapEffects(t.effects, s)),
    annotations: e.annotations.length ? e.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: e.scrollIntoView || t.scrollIntoView
  };
}
function Xx(e, t, n) {
  let r = t.selection, i = fh(t.annotations);
  return t.userEvent && (i = i.concat(Zn.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof $n ? t.changes : $n.of(t.changes || [], n, e.facet(b9)),
    selection: r && (r instanceof mt ? r : mt.single(r.anchor, r.head)),
    effects: fh(t.effects),
    annotations: i,
    scrollIntoView: !!t.scrollIntoView
  };
}
function w9(e, t, n) {
  let r = Xx(e, t.length ? t[0] : {}, e.doc.length);
  t.length && t[0].filter === !1 && (n = !1);
  for (let s = 1; s < t.length; s++) {
    t[s].filter === !1 && (n = !1);
    let o = !!t[s].sequential;
    r = k9(r, Xx(e, t[s], o ? r.changes.newLength : e.doc.length), o);
  }
  let i = Zn.create(e, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return rq(n ? nq(i) : i);
}
function nq(e) {
  let t = e.startState, n = !0;
  for (let i of t.facet(O9)) {
    let s = i(e);
    if (s === !1) {
      n = !1;
      break;
    }
    Array.isArray(s) && (n = n === !0 ? s : eq(n, s));
  }
  if (n !== !0) {
    let i, s;
    if (n === !1)
      s = e.changes.invertedDesc, i = $n.empty(t.doc.length);
    else {
      let o = e.changes.filter(n);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    e = Zn.create(t, i, e.selection && e.selection.map(s), le.mapEffects(e.effects, s), e.annotations, e.scrollIntoView);
  }
  let r = t.facet(x9);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](e);
    s instanceof Zn ? e = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Zn ? e = s[0] : e = w9(t, fh(s), !1);
  }
  return e;
}
function rq(e) {
  let t = e.startState, n = t.facet(v9), r = e;
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](e);
    s && Object.keys(s).length && (r = k9(r, Xx(t, s, e.changes.newLength), !0));
  }
  return r == e ? e : Zn.create(t, e.changes, e.selection, r.effects, r.annotations, r.scrollIntoView);
}
const iq = [];
function fh(e) {
  return e == null ? iq : Array.isArray(e) ? e : [e];
}
var hn = /* @__PURE__ */ function(e) {
  return e[e.Word = 0] = "Word", e[e.Space = 1] = "Space", e[e.Other = 2] = "Other", e;
}(hn || (hn = {}));
const sq = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Gx;
try {
  Gx = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function oq(e) {
  if (Gx)
    return Gx.test(e);
  for (let t = 0; t < e.length; t++) {
    let n = e[t];
    if (/\w/.test(n) || n > "\x80" && (n.toUpperCase() != n.toLowerCase() || sq.test(n)))
      return !0;
  }
  return !1;
}
function aq(e) {
  return (t) => {
    if (!/\S/.test(t))
      return hn.Space;
    if (oq(t))
      return hn.Word;
    for (let n = 0; n < e.length; n++)
      if (t.indexOf(e[n]) > -1)
        return hn.Word;
    return hn.Other;
  };
}
class De {
  constructor(t, n, r, i, s, o) {
    this.config = t, this.doc = n, this.selection = r, this.values = i, this.status = t.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Vf(this, a << 1);
    this.computeSlot = null;
  }
  field(t, n = !0) {
    let r = this.config.address[t.id];
    if (r == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Vf(this, r), Tg(this, r);
  }
  update(...t) {
    return w9(this, t, !0);
  }
  applyTransaction(t) {
    let n = this.config, { base: r, compartments: i } = n;
    for (let a of t.effects)
      a.is(Sc.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((l, h) => i.set(h, l)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(le.reconfigure) ? (n = null, r = a.value) : a.is(le.appendConfig) && (n = null, r = fh(r).concat(a.value));
    let s;
    n ? s = t.startState.values.slice() : (n = Cg.resolve(r, i, this), s = new De(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, h) => h.reconfigure(l, this), null).values);
    let o = t.startState.facet(jx) ? t.newSelection : t.newSelection.asSingle();
    new De(n, t.newDoc, o, s, (a, l) => l.update(a, t), t);
  }
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: t },
      range: mt.cursor(n.from + t.length)
    }));
  }
  changeByRange(t) {
    let n = this.selection, r = t(n.ranges[0]), i = this.changes(r.changes), s = [r.range], o = fh(r.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let l = t(n.ranges[a]), h = this.changes(l.changes), u = h.map(i);
      for (let d = 0; d < a; d++)
        s[d] = s[d].map(u);
      let f = i.mapDesc(h, !0);
      s.push(l.range.map(f)), i = i.compose(u), o = le.mapEffects(o, u).concat(le.mapEffects(fh(l.effects), f));
    }
    return {
      changes: i,
      selection: mt.create(s, n.mainIndex),
      effects: o
    };
  }
  changes(t = []) {
    return t instanceof $n ? t : $n.of(t, this.doc.length, this.facet(De.lineSeparator));
  }
  toText(t) {
    return Be.of(t.split(this.facet(De.lineSeparator) || Yx));
  }
  sliceDoc(t = 0, n = this.doc.length) {
    return this.doc.sliceString(t, n, this.lineBreak);
  }
  facet(t) {
    let n = this.config.address[t.id];
    return n == null ? t.default : (Vf(this, n), Tg(this, n));
  }
  toJSON(t) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let r in t) {
        let i = t[r];
        i instanceof bn && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(t[r]), this));
      }
    return n;
  }
  static fromJSON(t, n = {}, r) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(t, s)) {
          let o = r[s], a = t[s];
          i.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return De.create({
      doc: t.doc,
      selection: mt.fromJSON(t.selection),
      extensions: n.extensions ? i.concat([n.extensions]) : i
    });
  }
  static create(t = {}) {
    let n = Cg.resolve(t.extensions || [], /* @__PURE__ */ new Map()), r = t.doc instanceof Be ? t.doc : Be.of((t.doc || "").split(n.staticFacet(De.lineSeparator) || Yx)), i = t.selection ? t.selection instanceof mt ? t.selection : mt.single(t.selection.anchor, t.selection.head) : mt.single(0);
    return g9(i, r.length), n.staticFacet(jx) || (i = i.asSingle()), new De(n, r, i, n.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  get tabSize() {
    return this.facet(De.tabSize);
  }
  get lineBreak() {
    return this.facet(De.lineSeparator) || `
`;
  }
  get readOnly() {
    return this.facet(_9);
  }
  phrase(t, ...n) {
    for (let r of this.facet(De.phrases))
      if (Object.prototype.hasOwnProperty.call(r, t)) {
        t = r[t];
        break;
      }
    return n.length && (t = t.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > n.length ? r : n[s - 1];
    })), t;
  }
  languageDataAt(t, n, r = -1) {
    let i = [];
    for (let s of this.facet(y9))
      for (let o of s(this, n, r))
        Object.prototype.hasOwnProperty.call(o, t) && i.push(o[t]);
    return i;
  }
  charCategorizer(t) {
    return aq(this.languageDataAt("wordChars", t).join(""));
  }
  wordAt(t) {
    let { text: n, from: r, length: i } = this.doc.lineAt(t), s = this.charCategorizer(t), o = t - r, a = t - r;
    for (; o > 0; ) {
      let l = mr(n, o, !1);
      if (s(n.slice(l, o)) != hn.Word)
        break;
      o = l;
    }
    for (; a < i; ) {
      let l = mr(n, a);
      if (s(n.slice(a, l)) != hn.Word)
        break;
      a = l;
    }
    return o == a ? null : mt.range(o + r, a + r);
  }
}
De.allowMultipleSelections = jx;
De.tabSize = /* @__PURE__ */ Ft.define({
  combine: (e) => e.length ? e[0] : 4
});
De.lineSeparator = b9;
De.readOnly = _9;
De.phrases = /* @__PURE__ */ Ft.define({
  compare(e, t) {
    let n = Object.keys(e), r = Object.keys(t);
    return n.length == r.length && n.every((i) => e[i] == t[i]);
  }
});
De.languageData = y9;
De.changeFilter = O9;
De.transactionFilter = x9;
De.transactionExtender = v9;
Sc.reconfigure = /* @__PURE__ */ le.define();
function Oo(e, t, n = {}) {
  let r = {};
  for (let i of e)
    for (let s of Object.keys(i)) {
      let o = i[s], a = r[s];
      if (a === void 0)
        r[s] = o;
      else if (!(a === o || o === void 0))
        if (Object.hasOwnProperty.call(n, s))
          r[s] = n[s](a, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let i in t)
    r[i] === void 0 && (r[i] = t[i]);
  return r;
}
class nc {
  eq(t) {
    return this == t;
  }
  range(t, n = t) {
    return dd.create(t, n, this);
  }
}
nc.prototype.startSide = nc.prototype.endSide = 0;
nc.prototype.point = !1;
nc.prototype.mapMode = Gn.TrackDel;
class dd {
  constructor(t, n, r) {
    this.from = t, this.to = n, this.value = r;
  }
  static create(t, n, r) {
    return new dd(t, n, r);
  }
}
function Hx(e, t) {
  return e.from - t.from || e.value.startSide - t.value.startSide;
}
class nw {
  constructor(t, n, r, i) {
    this.from = t, this.to = n, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(t, n, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, a = s.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, h = s[l] - t || (r ? this.value[l].endSide : this.value[l].startSide) - n;
      if (l == o)
        return h >= 0 ? o : a;
      h >= 0 ? a = l : o = l + 1;
    }
  }
  between(t, n, r, i) {
    for (let s = this.findIndex(n, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + t, this.to[s] + t, this.value[s]) === !1)
        return !1;
  }
  map(t, n) {
    let r = [], i = [], s = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let h = this.value[l], u = this.from[l] + t, f = this.to[l] + t, d, p;
      if (u == f) {
        let g = n.mapPos(u, h.startSide, h.mapMode);
        if (g == null || (d = p = g, h.startSide != h.endSide && (p = n.mapPos(u, h.endSide), p < d)))
          continue;
      } else if (d = n.mapPos(u, h.startSide), p = n.mapPos(f, h.endSide), d > p || d == p && h.startSide > 0 && h.endSide <= 0)
        continue;
      (p - d || h.endSide - h.startSide) < 0 || (o < 0 && (o = d), h.point && (a = Math.max(a, p - d)), r.push(h), i.push(d - o), s.push(p - o));
    }
    return { mapped: r.length ? new nw(i, s, r, a) : null, pos: o };
  }
}
class Ne {
  constructor(t, n, r, i) {
    this.chunkPos = t, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
  }
  static create(t, n, r, i) {
    return new Ne(t, n, r, i);
  }
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let n of this.chunk)
      t += n.value.length;
    return t;
  }
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  update(t) {
    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = t, o = t.filter;
    if (n.length == 0 && !o)
      return this;
    if (r && (n = n.slice().sort(Hx)), this.isEmpty)
      return n.length ? Ne.of(n) : this;
    let a = new S9(this, null, -1).goto(0), l = 0, h = [], u = new cr();
    for (; a.value || l < n.length; )
      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
        let f = n[l++];
        u.addInner(f.from, f.to, f.value) || h.push(f);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!o || i > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || h.push(dd.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !h.length ? Ne.empty : this.nextLayer.update({ add: h, filter: o, filterFrom: i, filterTo: s }));
  }
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let n = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], h = t.touchesRange(a, a + l.length);
      if (h === !1)
        i = Math.max(i, l.maxPoint), n.push(l), r.push(t.mapPos(a));
      else if (h === !0) {
        let { mapped: u, pos: f } = l.map(a, t);
        u && (i = Math.max(i, u.maxPoint), n.push(u), r.push(f));
      }
    }
    let s = this.nextLayer.map(t);
    return n.length == 0 ? s : new Ne(r, n, s || Ne.empty, i);
  }
  between(t, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (n >= s && t <= s + o.length && o.between(s, t - s, n - s, r) === !1)
          return;
      }
      this.nextLayer.between(t, n, r);
    }
  }
  iter(t = 0) {
    return pd.from([this]).goto(t);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(t, n = 0) {
    return pd.from(t).goto(n);
  }
  static compare(t, n, r, i, s = -1) {
    let o = t.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= s), a = n.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= s), l = r4(o, a, r), h = new Ku(o, l, s), u = new Ku(a, l, s);
    r.iterGaps((f, d, p) => i4(h, f, u, d, p, i)), r.empty && r.length == 0 && i4(h, 0, u, 0, 0, i);
  }
  static eq(t, n, r = 0, i) {
    i == null && (i = 1e9 - 1);
    let s = t.filter((u) => !u.isEmpty && n.indexOf(u) < 0), o = n.filter((u) => !u.isEmpty && t.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let a = r4(s, o), l = new Ku(s, a, 0).goto(r), h = new Ku(o, a, 0).goto(r);
    for (; ; ) {
      if (l.to != h.to || !Kx(l.active, h.active) || l.point && (!h.point || !l.point.eq(h.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), h.next();
    }
  }
  static spans(t, n, r, i, s = -1) {
    let o = new Ku(t, null, s).goto(n), a = n, l = o.openStart;
    for (; ; ) {
      let h = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to), f = o.pointFrom < n ? u.length + 1 : Math.min(u.length, l);
        i.point(a, h, o.point, u, f, o.pointRank), l = Math.min(o.openEnd(h), u.length);
      } else
        h > a && (i.span(a, h, o.active, l), l = o.openEnd(h));
      if (o.to > r)
        return l + (o.point && o.to > r ? 1 : 0);
      a = o.to, o.next();
    }
  }
  static of(t, n = !1) {
    let r = new cr();
    for (let i of t instanceof dd ? [t] : n ? lq(t) : t)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
}
Ne.empty = /* @__PURE__ */ new Ne([], [], null, -1);
function lq(e) {
  if (e.length > 1)
    for (let t = e[0], n = 1; n < e.length; n++) {
      let r = e[n];
      if (Hx(t, r) > 0)
        return e.slice().sort(Hx);
      t = r;
    }
  return e;
}
Ne.empty.nextLayer = Ne.empty;
class cr {
  finishChunk(t) {
    this.chunks.push(new nw(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  add(t, n, r) {
    this.addInner(t, n, r) || (this.nextLayer || (this.nextLayer = new cr())).add(t, n, r);
  }
  addInner(t, n, r) {
    let i = t - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (t - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = t, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - t)), !0);
  }
  addChunk(t, n) {
    if ((t - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(t);
    let r = n.value.length - 1;
    return this.last = n.value[r], this.lastFrom = n.from[r] + t, this.lastTo = n.to[r] + t, !0;
  }
  finish() {
    return this.finishInner(Ne.empty);
  }
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let n = Ne.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, n;
  }
}
function r4(e, t, n) {
  let r = /* @__PURE__ */ new Map();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = r.get(s.chunk[o]);
      a != null && (n ? n.mapPos(a) : a) == s.chunkPos[o] && !(n != null && n.touchesRange(a, a + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class S9 {
  constructor(t, n, r, i = 0) {
    this.layer = t, this.skip = n, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, n, !1), this;
  }
  gotoInner(t, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < t || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(t, n) {
    (this.to - t || this.endSide - n) < 0 && this.gotoInner(t, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = t + n.from[this.rangeIndex];
        if (this.from = r, this.to = t + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}
class pd {
  constructor(t) {
    this.heap = t;
  }
  static from(t, n = null, r = -1) {
    let i = [];
    for (let s = 0; s < t.length; s++)
      for (let o = t[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new S9(o, n, r, s));
    return i.length == 1 ? i[0] : new pd(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, n = -1e9) {
    for (let r of this.heap)
      r.goto(t, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      yb(this.heap, r);
    return this.next(), this;
  }
  forward(t, n) {
    for (let r of this.heap)
      r.forward(t, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      yb(this.heap, r);
    (this.to - t || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), yb(this.heap, 0);
    }
  }
}
function yb(e, t) {
  for (let n = e[t]; ; ) {
    let r = (t << 1) + 1;
    if (r >= e.length)
      break;
    let i = e[r];
    if (r + 1 < e.length && i.compare(e[r + 1]) >= 0 && (i = e[r + 1], r++), n.compare(i) < 0)
      break;
    e[r] = n, e[t] = i, t = r;
  }
}
class Ku {
  constructor(t, n, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = pd.from(t, n, r);
  }
  goto(t, n = -1e9) {
    return this.cursor.goto(t, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(t, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, n);
  }
  removeActive(t) {
    x0(this.active, t), x0(this.activeTo, t), x0(this.activeRank, t), this.minActive = s4(this.active, this.activeTo);
  }
  addActive(t) {
    let n = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; n < this.activeRank.length && this.activeRank[n] <= s; )
      n++;
    v0(this.active, n, r), v0(this.activeTo, n, i), v0(this.activeRank, n, s), t && v0(t, n, this.cursor.from), this.minActive = s4(this.active, this.activeTo);
  }
  next() {
    let t = this.to, n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > t) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && x0(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < t; i--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > t || this.activeTo[r] == t && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(t) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > t; r--)
      n++;
    return n;
  }
}
function i4(e, t, n, r, i, s) {
  e.goto(t), n.goto(r);
  let o = r + i, a = r, l = r - t;
  for (; ; ) {
    let h = e.to + l - n.to || e.endSide - n.endSide, u = h < 0 ? e.to + l : n.to, f = Math.min(u, o);
    if (e.point || n.point ? e.point && n.point && (e.point == n.point || e.point.eq(n.point)) && Kx(e.activeForPoint(e.to), n.activeForPoint(n.to)) || s.comparePoint(a, f, e.point, n.point) : f > a && !Kx(e.active, n.active) && s.compareRange(a, f, e.active, n.active), u > o)
      break;
    a = u, h <= 0 && e.next(), h >= 0 && n.next();
  }
}
function Kx(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n] && !e[n].eq(t[n]))
      return !1;
  return !0;
}
function x0(e, t) {
  for (let n = t, r = e.length - 1; n < r; n++)
    e[n] = e[n + 1];
  e.pop();
}
function v0(e, t, n) {
  for (let r = e.length - 1; r >= t; r--)
    e[r + 1] = e[r];
  e[t] = n;
}
function s4(e, t) {
  let n = -1, r = 1e9;
  for (let i = 0; i < t.length; i++)
    (t[i] - r || e[i].endSide - e[n].endSide) < 0 && (n = i, r = t[i]);
  return n;
}
function Os(e, t, n = e.length) {
  let r = 0;
  for (let i = 0; i < n; )
    e.charCodeAt(i) == 9 ? (r += t - r % t, i++) : (r++, i = mr(e, i));
  return r;
}
function Jx(e, t, n, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= t)
      return i;
    if (i == e.length)
      break;
    s += e.charCodeAt(i) == 9 ? n - s % n : 1, i = mr(e, i);
  }
  return r === !0 ? -1 : e.length;
}
const tv = "\u037C", o4 = typeof Symbol > "u" ? "__" + tv : Symbol.for(tv), ev = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), a4 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class sa {
  constructor(t, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, h) {
      let u = [], f = /^@(\w+)\b/.exec(o[0]), d = f && f[1] == "keyframes";
      if (f && a == null)
        return l.push(o[0] + ";");
      for (let p in a) {
        let g = a[p];
        if (/&/.test(p))
          s(
            p.split(/,\s*/).map((m) => o.map((y) => m.replace(/&/, y))).reduce((m, y) => m.concat(y)),
            g,
            l
          );
        else if (g && typeof g == "object") {
          if (!f)
            throw new RangeError("The value of a property (" + p + ") should be a primitive value.");
          s(i(p), g, u, d);
        } else
          g != null && u.push(p.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + g + ";");
      }
      (u.length || d) && l.push((r && !f && !h ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in t)
      s(i(o), t[o], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let t = a4[o4] || 1;
    return a4[o4] = t + 1, tv + t.toString(36);
  }
  static mount(t, n, r) {
    let i = t[ev], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new cq(t, s), i.mount(Array.isArray(n) ? n : [n]);
  }
}
let l4 = /* @__PURE__ */ new Map();
class cq {
  constructor(t, n) {
    let r = t.ownerDocument || t, i = r.defaultView;
    if (!t.head && t.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = l4.get(r);
      if (s)
        return t.adoptedStyleSheets = [s.sheet, ...t.adoptedStyleSheets], t[ev] = s;
      this.sheet = new i.CSSStyleSheet(), t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets], l4.set(r, this);
    } else {
      this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
      let s = t.head || t;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], t[ev] = this;
  }
  mount(t) {
    let n = this.sheet, r = 0, i = 0;
    for (let s = 0; s < t.length; s++) {
      let o = t[s], a = this.modules.indexOf(o);
      if (a < i && a > -1 && (this.modules.splice(a, 1), i--, a = -1), a == -1) {
        if (this.modules.splice(i++, 0, o), n)
          for (let l = 0; l < o.rules.length; l++)
            n.insertRule(o.rules[l], r++);
      } else {
        for (; i < a; )
          r += this.modules[i++].rules.length;
        r += o.rules.length, i++;
      }
    }
    if (!n) {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}
var Ja = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, gd = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, hq = typeof navigator < "u" && /Mac/.test(navigator.platform), uq = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var gr = 0; gr < 10; gr++)
  Ja[48 + gr] = Ja[96 + gr] = String(gr);
for (var gr = 1; gr <= 24; gr++)
  Ja[gr + 111] = "F" + gr;
for (var gr = 65; gr <= 90; gr++)
  Ja[gr] = String.fromCharCode(gr + 32), gd[gr] = String.fromCharCode(gr);
for (var bb in Ja)
  gd.hasOwnProperty(bb) || (gd[bb] = Ja[bb]);
function fq(e) {
  var t = hq && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || uq && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? gd : Ja)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function Eg(e) {
  let t;
  return e.nodeType == 11 ? t = e.getSelection ? e : e.ownerDocument : t = e, t.getSelection();
}
function nv(e, t) {
  return t ? e == t || e.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
function dq(e) {
  let t = e.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function M1(e, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return nv(e, t.anchorNode);
  } catch {
    return !1;
  }
}
function md(e) {
  return e.nodeType == 3 ? rc(e, 0, e.nodeValue.length).getClientRects() : e.nodeType == 1 ? e.getClientRects() : [];
}
function Ag(e, t, n, r) {
  return n ? c4(e, t, n, r, -1) || c4(e, t, n, r, 1) : !1;
}
function yd(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}
function c4(e, t, n, r, i) {
  for (; ; ) {
    if (e == n && t == r)
      return !0;
    if (t == (i < 0 ? 0 : oa(e))) {
      if (e.nodeName == "DIV")
        return !1;
      let s = e.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      t = yd(e) + (i < 0 ? 0 : 1), e = s;
    } else if (e.nodeType == 1) {
      if (e = e.childNodes[t + (i < 0 ? -1 : 0)], e.nodeType == 1 && e.contentEditable == "false")
        return !1;
      t = i < 0 ? oa(e) : 0;
    } else
      return !1;
  }
}
function oa(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function rw(e, t) {
  let n = t ? e.left : e.right;
  return { left: n, right: n, top: e.top, bottom: e.bottom };
}
function pq(e) {
  return {
    left: 0,
    right: e.innerWidth,
    top: 0,
    bottom: e.innerHeight
  };
}
function C9(e, t) {
  let n = t.width / e.offsetWidth, r = t.height / e.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(t.width - e.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(t.height - e.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };
}
function gq(e, t, n, r, i, s, o, a) {
  let l = e.ownerDocument, h = l.defaultView || window;
  for (let u = e, f = !1; u && !f; )
    if (u.nodeType == 1) {
      let d, p = u == l.body, g = 1, m = 1;
      if (p)
        d = pq(h);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (f = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let x = u.getBoundingClientRect();
        ({ scaleX: g, scaleY: m } = C9(u, x)), d = {
          left: x.left,
          right: x.left + u.clientWidth * g,
          top: x.top,
          bottom: x.top + u.clientHeight * m
        };
      }
      let y = 0, O = 0;
      if (i == "nearest")
        t.top < d.top ? (O = -(d.top - t.top + o), n > 0 && t.bottom > d.bottom + O && (O = t.bottom - d.bottom + O + o)) : t.bottom > d.bottom && (O = t.bottom - d.bottom + o, n < 0 && t.top - O < d.top && (O = -(d.top + O - t.top + o)));
      else {
        let x = t.bottom - t.top, _ = d.bottom - d.top;
        O = (i == "center" && x <= _ ? t.top + x / 2 - _ / 2 : i == "start" || i == "center" && n < 0 ? t.top - o : t.bottom - _ + o) - d.top;
      }
      if (r == "nearest" ? t.left < d.left ? (y = -(d.left - t.left + s), n > 0 && t.right > d.right + y && (y = t.right - d.right + y + s)) : t.right > d.right && (y = t.right - d.right + s, n < 0 && t.left < d.left + y && (y = -(d.left + y - t.left + s))) : y = (r == "center" ? t.left + (t.right - t.left) / 2 - (d.right - d.left) / 2 : r == "start" == a ? t.left - s : t.right - (d.right - d.left) + s) - d.left, y || O)
        if (p)
          h.scrollBy(y, O);
        else {
          let x = 0, _ = 0;
          if (O) {
            let w = u.scrollTop;
            u.scrollTop += O / m, _ = (u.scrollTop - w) * m;
          }
          if (y) {
            let w = u.scrollLeft;
            u.scrollLeft += y / g, x = (u.scrollLeft - w) * g;
          }
          t = {
            left: t.left - x,
            top: t.top - _,
            right: t.right - x,
            bottom: t.bottom - _
          }, x && Math.abs(x - y) < 1 && (r = "nearest"), _ && Math.abs(_ - O) < 1 && (i = "nearest");
        }
      if (p)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function mq(e) {
  let t = e.ownerDocument;
  for (let n = e.parentNode; n && n != t.body; )
    if (n.nodeType == 1) {
      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth)
        return n;
      n = n.assignedSlot || n.parentNode;
    } else if (n.nodeType == 11)
      n = n.host;
    else
      break;
  return null;
}
class yq {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: n, focusNode: r } = t;
    this.set(n, Math.min(t.anchorOffset, n ? oa(n) : 0), r, Math.min(t.focusOffset, r ? oa(r) : 0));
  }
  set(t, n, r, i) {
    this.anchorNode = t, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
  }
}
let Fc = null;
function T9(e) {
  if (e.setActive)
    return e.setActive();
  if (Fc)
    return e.focus(Fc);
  let t = [];
  for (let n = e; n && (t.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (e.focus(Fc == null ? {
    get preventScroll() {
      return Fc = { preventScroll: !0 }, !0;
    }
  } : void 0), !Fc) {
    Fc = !1;
    for (let n = 0; n < t.length; ) {
      let r = t[n++], i = t[n++], s = t[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let h4;
function rc(e, t, n = t) {
  let r = h4 || (h4 = document.createRange());
  return r.setEnd(e, n), r.setStart(e, t), r;
}
function dh(e, t, n) {
  let r = { key: t, code: t, keyCode: n, which: n, cancelable: !0 }, i = new KeyboardEvent("keydown", r);
  i.synthetic = !0, e.dispatchEvent(i);
  let s = new KeyboardEvent("keyup", r);
  return s.synthetic = !0, e.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;
}
function bq(e) {
  for (; e; ) {
    if (e && (e.nodeType == 9 || e.nodeType == 11 && e.host))
      return e;
    e = e.assignedSlot || e.parentNode;
  }
  return null;
}
function E9(e) {
  for (; e.attributes.length; )
    e.removeAttributeNode(e.attributes[0]);
}
function Oq(e, t) {
  let n = t.focusNode, r = t.focusOffset;
  if (!n || t.anchorNode != n || t.anchorOffset != r)
    return !1;
  for (r = Math.min(r, oa(n)); ; )
    if (r) {
      if (n.nodeType != 1)
        return !1;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (n = i, r = oa(n));
    } else {
      if (n == e)
        return !0;
      r = yd(n), n = n.parentNode;
    }
}
function A9(e) {
  return e.scrollTop > Math.max(1, e.scrollHeight - e.clientHeight - 4);
}
class Cr {
  constructor(t, n, r = !0) {
    this.node = t, this.offset = n, this.precise = r;
  }
  static before(t, n) {
    return new Cr(t.parentNode, yd(t), n);
  }
  static after(t, n) {
    return new Cr(t.parentNode, yd(t) + 1, n);
  }
}
const iw = [];
class an {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == t)
        return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, n) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let a = an.get(s);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(t, n), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && s != o.dom && (n.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = u4(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && n && n.node == r && (n.written = !0); s; )
        s = u4(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(t, n), r.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, n) {
    let r;
    if (t == this.dom)
      r = this.dom.childNodes[n];
    else {
      let i = oa(t) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let s = t.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (t == s.firstChild ? i = -1 : i = 1), t = s;
      }
      i < 0 ? r = t : r = t.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !an.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(t, n, r = 0) {
    let i = -1, s = -1, o = -1, a = -1;
    for (let l = 0, h = r, u = r; l < this.children.length; l++) {
      let f = this.children[l], d = h + f.length;
      if (h < t && d > n)
        return f.domBoundsAround(t, n, h);
      if (d >= t && i == -1 && (i = l, s = h), h > n && f.dom.parentNode == this.dom) {
        o = l, a = u;
        break;
      }
      u = d, h = d + f.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? r + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let n = this.parent; n; n = n.parent) {
      if (t && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let n = t.parent;
      if (!n)
        return t;
      t = n;
    }
  }
  replaceChildren(t, n, r = iw) {
    this.markDirty();
    for (let i = t; i < n; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(t, n - t, ...r);
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new P9(this.children, t, this.children.length);
  }
  childPos(t, n = 1) {
    return this.childCursor().findPos(t, n);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, n, r, i, s, o) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}
an.prototype.breakAfter = 0;
function u4(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class P9 {
  constructor(t, n, r) {
    this.children = t, this.pos = n, this.i = r, this.off = 0;
  }
  findPos(t, n = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function D9(e, t, n, r, i, s, o, a, l) {
  let { children: h } = e, u = h.length ? h[t] : null, f = s.length ? s[s.length - 1] : null, d = f ? f.breakAfter : o;
  if (!(t == r && u && !o && !d && s.length < 2 && u.merge(n, i, s.length ? f : null, n == 0, a, l))) {
    if (r < h.length) {
      let p = h[r];
      p && (i < p.length || p.breakAfter && (f == null ? void 0 : f.breakAfter)) ? (t == r && (p = p.split(i), i = 0), !d && f && p.merge(0, i, f, !0, 0, l) ? s[s.length - 1] = p : ((i || p.children.length && !p.children[0].length) && p.merge(0, i, null, !1, 0, l), s.push(p))) : p != null && p.breakAfter && (f ? f.breakAfter = 1 : o = 1), r++;
    }
    for (u && (u.breakAfter = o, n > 0 && (!o && s.length && u.merge(n, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, !1, a, 0), t++)); t < r && s.length; )
      if (h[r - 1].become(s[s.length - 1]))
        r--, s.pop(), l = s.length ? 0 : a;
      else if (h[t].become(s[0]))
        t++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && t && r < h.length && !h[t - 1].breakAfter && h[r].merge(0, 0, h[t - 1], !1, a, l) && t--, (t < r || s.length) && e.replaceChildren(t, r, s);
  }
}
function L9(e, t, n, r, i, s) {
  let o = e.childCursor(), { i: a, off: l } = o.findPos(n, 1), { i: h, off: u } = o.findPos(t, -1), f = t - n;
  for (let d of r)
    f += d.length;
  e.length += f, D9(e, h, u, a, l, r, 0, i, s);
}
let mi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, rv = typeof document < "u" ? document : { documentElement: { style: {} } };
const iv = /* @__PURE__ */ /Edge\/(\d+)/.exec(mi.userAgent), M9 = /* @__PURE__ */ /MSIE \d/.test(mi.userAgent), sv = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(mi.userAgent), $2 = !!(M9 || sv || iv), f4 = !$2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(mi.userAgent), Ob = !$2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(mi.userAgent), d4 = "webkitFontSmoothing" in rv.documentElement.style, R9 = !$2 && /* @__PURE__ */ /Apple Computer/.test(mi.vendor), p4 = R9 && (/* @__PURE__ */ /Mobile\/\w+/.test(mi.userAgent) || mi.maxTouchPoints > 2);
var Wt = {
  mac: p4 || /* @__PURE__ */ /Mac/.test(mi.platform),
  windows: /* @__PURE__ */ /Win/.test(mi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(mi.platform),
  ie: $2,
  ie_version: M9 ? rv.documentMode || 6 : sv ? +sv[1] : iv ? +iv[1] : 0,
  gecko: f4,
  gecko_version: f4 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(mi.userAgent) || [0, 0])[1] : 0,
  chrome: !!Ob,
  chrome_version: Ob ? +Ob[1] : 0,
  ios: p4,
  android: /* @__PURE__ */ /Android\b/.test(mi.userAgent),
  webkit: d4,
  safari: R9,
  webkit_version: d4 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: rv.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const xq = 256;
class aa extends an {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, n, r) {
    return this.flags & 8 || r && (!(r instanceof aa) || this.length - (n - t) + r.length > xq || r.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(t) {
    let n = new aa(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(t, n) {
    return t == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(t) {
    return new Cr(this.dom, t);
  }
  domBoundsAround(t, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, n) {
    return vq(this.dom, t, n);
  }
}
class la extends an {
  constructor(t, n = [], r = 0) {
    super(), this.mark = t, this.children = n, this.length = r;
    for (let i of n)
      i.setParent(this);
  }
  setAttrs(t) {
    if (E9(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        t.setAttribute(n, this.mark.attrs[n]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, n);
  }
  merge(t, n, r, i, s, o) {
    return r && (!(r instanceof la && r.mark.eq(this.mark)) || t && s <= 0 || n < this.length && o <= 0) ? !1 : (L9(this, t, n, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(t) {
    let n = [], r = 0, i = -1, s = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > t && n.push(r < t ? a.split(t - r) : a), i < 0 && r >= t && (i = s), r = l, s++;
    }
    let o = this.length - t;
    return this.length = t, i > -1 && (this.children.length = i, this.markDirty()), new la(this.mark, n, o);
  }
  domAtPos(t) {
    return $9(this, t);
  }
  coordsAt(t, n) {
    return N9(this, t, n);
  }
}
function vq(e, t, n) {
  let r = e.nodeValue.length;
  t > r && (t = r);
  let i = t, s = t, o = 0;
  t == 0 && n < 0 || t == r && n >= 0 ? Wt.chrome || Wt.gecko || (t ? (i--, o = 1) : s < r && (s++, o = -1)) : n < 0 ? i-- : s < r && s++;
  let a = rc(e, i, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : n >= 0) ? 0 : a.length - 1];
  return Wt.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (h) => h.width) || l), o ? rw(l, o < 0) : l || null;
}
class Ia extends an {
  static create(t, n, r) {
    return new Ia(t, n, r);
  }
  constructor(t, n, r) {
    super(), this.widget = t, this.length = n, this.side = r, this.prevWidget = null;
  }
  split(t) {
    let n = Ia.create(this.widget, this.length - t, this.side);
    return this.length -= t, n;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(t, n, r, i, s, o) {
    return r && (!(r instanceof Ia) || !this.widget.compare(r.widget) || t > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = t + (r ? r.length : 0) + (this.length - n), !0);
  }
  become(t) {
    return t instanceof Ia && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Be.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: n } = t, r = n && n.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : Be.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? Cr.before(this.dom) : Cr.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, n) {
    let r = this.widget.coordsAt(this.dom, t, n);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : t > 0;
    for (let a = o ? i.length - 1 : 0; s = i[a], !(t > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
      ;
    return rw(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Fh extends an {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Fh && t.side == this.side;
  }
  split() {
    return new Fh(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? Cr.before(this.dom) : Cr.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Be.empty;
  }
  get isHidden() {
    return !0;
  }
}
aa.prototype.children = Ia.prototype.children = Fh.prototype.children = iw;
function $9(e, t) {
  let n = e.dom, { children: r } = e, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (t > s && t < a && o.dom.parentNode == n)
        return o.domAtPos(t - s);
      if (t <= s)
        break;
      s = a;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == n)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == n)
      return o.domAtPos(0);
  }
  return new Cr(n, 0);
}
function I9(e, t, n) {
  let r, { children: i } = e;
  n > 0 && t instanceof la && i.length && (r = i[i.length - 1]) instanceof la && r.mark.eq(t.mark) ? I9(r, t.children[0], n - 1) : (i.push(t), t.setParent(e)), e.length += t.length;
}
function N9(e, t, n) {
  let r = null, i = -1, s = null, o = -1;
  function a(h, u) {
    for (let f = 0, d = 0; f < h.children.length && d <= u; f++) {
      let p = h.children[f], g = d + p.length;
      g >= u && (p.children.length ? a(p, u - d) : (!s || s.isHidden && n > 0) && (g > u || d == g && p.getSide() > 0) ? (s = p, o = u - d) : (d < u || d == g && p.getSide() < 0 && !p.isHidden) && (r = p, i = u - d)), d = g;
    }
  }
  a(e, t);
  let l = (n < 0 ? r : s) || r || s;
  return l ? l.coordsAt(Math.max(0, l == r ? i : o), n) : _q(e);
}
function _q(e) {
  let t = e.dom.lastChild;
  if (!t)
    return e.dom.getBoundingClientRect();
  let n = md(t);
  return n[n.length - 1] || null;
}
function ov(e, t) {
  for (let n in e)
    n == "class" && t.class ? t.class += " " + e.class : n == "style" && t.style ? t.style += ";" + e.style : t[n] = e[n];
  return t;
}
const g4 = /* @__PURE__ */ Object.create(null);
function sw(e, t, n) {
  if (e == t)
    return !0;
  e || (e = g4), t || (t = g4);
  let r = Object.keys(e), i = Object.keys(t);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != n && (i.indexOf(s) == -1 || e[s] !== t[s]))
      return !1;
  return !0;
}
function av(e, t, n) {
  let r = !1;
  if (t)
    for (let i in t)
      n && i in n || (r = !0, i == "style" ? e.style.cssText = "" : e.removeAttribute(i));
  if (n)
    for (let i in n)
      t && t[i] == n[i] || (r = !0, i == "style" ? e.style.cssText = n[i] : e.setAttribute(i, n[i]));
  return r;
}
function kq(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < e.attributes.length; n++) {
    let r = e.attributes[n];
    t[r.name] = r.value;
  }
  return t;
}
class jn extends an {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(t, n, r, i, s, o) {
    if (r) {
      if (!(r instanceof jn))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), L9(this, t, n, r ? r.children.slice() : [], s, o), !0;
  }
  split(t) {
    let n = new jn();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: r, off: i } = this.childPos(t);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      n.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = t, n;
  }
  transferDOM(t) {
    !this.dom || (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    sw(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, n) {
    I9(this, t, n);
  }
  addLineDeco(t) {
    let n = t.spec.attributes, r = t.spec.class;
    n && (this.attrs = ov(n, this.attrs || {})), r && (this.attrs = ov({ class: r }, this.attrs || {}));
  }
  domAtPos(t) {
    return $9(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    var r;
    this.dom ? this.flags & 4 && (E9(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (av(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, n);
    let i = this.dom.lastChild;
    for (; i && an.get(i) instanceof la; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = an.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!Wt.ios || !this.children.some((s) => s instanceof aa))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, n;
    for (let r of this.children) {
      if (!(r instanceof aa) || /[^ -~]/.test(r.text))
        return null;
      let i = md(r.dom);
      if (i.length != 1)
        return null;
      t += i[0].width, n = i[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(t, n) {
    let r = N9(this, t, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(t) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(t, n) {
    for (let r = 0, i = 0; r < t.children.length; r++) {
      let s = t.children[r], o = i + s.length;
      if (o >= n) {
        if (s instanceof jn)
          return s;
        if (o > n)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class Za extends an {
  constructor(t, n, r) {
    super(), this.widget = t, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, n, r, i, s, o) {
    return r && (!(r instanceof Za) || !this.widget.compare(r.widget) || t > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = t + (r ? r.length : 0) + (this.length - n), !0);
  }
  domAtPos(t) {
    return t == 0 ? Cr.before(this.dom) : Cr.after(this.dom, t == this.length);
  }
  split(t) {
    let n = this.length - t;
    this.length = t;
    let r = new Za(this.widget, n, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return iw;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Be.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof Za && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, n) {
    return this.widget.coordsAt(this.dom, t, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : t < 0 ? n < 0 : r > 0;
  }
}
class si {
  eq(t) {
    return !1;
  }
  updateDOM(t, n) {
    return !1;
  }
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(t) {
    return !0;
  }
  coordsAt(t, n, r) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  destroy(t) {
  }
}
var Fr = /* @__PURE__ */ function(e) {
  return e[e.Text = 0] = "Text", e[e.WidgetBefore = 1] = "WidgetBefore", e[e.WidgetAfter = 2] = "WidgetAfter", e[e.WidgetRange = 3] = "WidgetRange", e;
}(Fr || (Fr = {}));
class Bt extends nc {
  constructor(t, n, r, i) {
    super(), this.startSide = t, this.endSide = n, this.widget = r, this.spec = i;
  }
  get heightRelevant() {
    return !1;
  }
  static mark(t) {
    return new Mp(t);
  }
  static widget(t) {
    let n = Math.max(-1e4, Math.min(1e4, t.side || 0)), r = !!t.block;
    return n += r && !t.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new tl(t, n, n, r, t.widget || null, !1);
  }
  static replace(t) {
    let n = !!t.block, r, i;
    if (t.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = B9(t, n);
      r = (s ? n ? -3e8 : -1 : 5e8) - 1, i = (o ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new tl(t, r, i, n, t.widget || null, !0);
  }
  static line(t) {
    return new Rp(t);
  }
  static set(t, n = !1) {
    return Ne.of(t, n);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Bt.none = Ne.empty;
class Mp extends Bt {
  constructor(t) {
    let { start: n, end: r } = B9(t);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var n, r;
    return this == t || t instanceof Mp && this.tagName == t.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (t.class || ((r = t.attrs) === null || r === void 0 ? void 0 : r.class)) && sw(this.attrs, t.attrs, "class");
  }
  range(t, n = t) {
    if (t >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, n);
  }
}
Mp.prototype.point = !1;
class Rp extends Bt {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Rp && this.spec.class == t.spec.class && sw(this.spec.attributes, t.spec.attributes);
  }
  range(t, n = t) {
    if (n != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, n);
  }
}
Rp.prototype.mapMode = Gn.TrackBefore;
Rp.prototype.point = !0;
class tl extends Bt {
  constructor(t, n, r, i, s, o) {
    super(n, r, s, t), this.block = i, this.isReplace = o, this.mapMode = i ? n <= 0 ? Gn.TrackBefore : Gn.TrackAfter : Gn.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? Fr.WidgetRange : this.startSide <= 0 ? Fr.WidgetBefore : Fr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof tl && wq(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, n = t) {
    if (this.isReplace && (t > n || t == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, n);
  }
}
tl.prototype.point = !0;
function B9(e, t = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = e;
  return n == null && (n = e.inclusive), r == null && (r = e.inclusive), { start: n != null ? n : t, end: r != null ? r : t };
}
function wq(e, t) {
  return e == t || !!(e && t && e.compare(t));
}
function lv(e, t, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= e ? n[i] = Math.max(n[i], t) : n.push(e, t);
}
class Yf {
  constructor(t, n, r, i) {
    this.doc = t, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof Za && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new jn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(_0(new Fh(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof Za) && this.getLine();
  }
  buildText(t, n, r) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(this.text.length - this.textOff, t, 512);
      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(_0(new aa(this.text.slice(this.textOff, this.textOff + i)), n), r), this.atCursorPos = !0, this.textOff += i, t -= i, r = 0;
    }
  }
  span(t, n, r, i) {
    this.buildText(n - t, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
  }
  point(t, n, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof tl) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - t;
    if (r instanceof tl)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Za(r.widget || new m4("div"), a, r));
      else {
        let l = Ia.create(r.widget || new m4("span"), a, a ? 0 : r.startSide), h = this.atCursorPos && !l.isEditable && s <= i.length && (t < n || r.startSide > 0), u = !l.isEditable && (t < n || s > i.length || r.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !h && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), h && (f.append(_0(new Fh(1), i), s), s = i.length + Math.max(0, s - i.length)), f.append(_0(l, i), s), this.atCursorPos = u, this.pendingBuffer = u ? t < n || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = s);
  }
  static build(t, n, r, i, s) {
    let o = new Yf(t, n, r, s);
    return o.openEnd = Ne.spans(i, n, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function _0(e, t) {
  for (let n of t)
    e = new la(n, [e], e.length);
  return e;
}
class m4 extends si {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const F9 = /* @__PURE__ */ Ft.define(), Q9 = /* @__PURE__ */ Ft.define(), Z9 = /* @__PURE__ */ Ft.define(), V9 = /* @__PURE__ */ Ft.define(), cv = /* @__PURE__ */ Ft.define(), Y9 = /* @__PURE__ */ Ft.define(), z9 = /* @__PURE__ */ Ft.define(), q9 = /* @__PURE__ */ Ft.define({
  combine: (e) => e.some((t) => t)
}), W9 = /* @__PURE__ */ Ft.define({
  combine: (e) => e.some((t) => t)
});
class ph {
  constructor(t, n = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = t, this.y = n, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(t) {
    return t.empty ? this : new ph(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new ph(mt.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const k0 = /* @__PURE__ */ le.define({ map: (e, t) => e.map(t) });
function Qi(e, t, n) {
  let r = e.facet(V9);
  r.length ? r[0](t) : window.onerror ? window.onerror(String(t), n, void 0, void 0, t) : n ? console.error(n + ":", t) : console.error(t);
}
const I2 = /* @__PURE__ */ Ft.define({ combine: (e) => e.length ? e[0] : !0 });
let Sq = 0;
const kf = /* @__PURE__ */ Ft.define();
class He {
  constructor(t, n, r, i, s) {
    this.id = t, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.extension = s(this);
  }
  static define(t, n) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = n || {};
    return new He(Sq++, t, r, i, (a) => {
      let l = [kf.of(a)];
      return o && l.push(bd.of((h) => {
        let u = h.plugin(a);
        return u ? o(u) : Bt.none;
      })), s && l.push(s(a)), l;
    });
  }
  static fromClass(t, n) {
    return He.define((r) => new t(r), n);
  }
}
class xb {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (r) {
            if (Qi(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(t);
      } catch (n) {
        Qi(t.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Qi(t.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const U9 = /* @__PURE__ */ Ft.define(), ow = /* @__PURE__ */ Ft.define(), bd = /* @__PURE__ */ Ft.define(), aw = /* @__PURE__ */ Ft.define(), j9 = /* @__PURE__ */ Ft.define();
function y4(e, t, n) {
  let r = e.state.facet(j9);
  if (!r.length)
    return r;
  let i = r.map((o) => o instanceof Function ? o(e) : o), s = [];
  return Ne.spans(i, t, n, {
    point() {
    },
    span(o, a, l, h) {
      let u = s;
      for (let f = l.length - 1; f >= 0; f--, h--) {
        let d = l[f].spec.bidiIsolate, p;
        if (d != null)
          if (h > 0 && u.length && (p = u[u.length - 1]).to == o && p.direction == d)
            p.to = a, u = p.inner;
          else {
            let g = { from: o, to: a, direction: d, inner: [] };
            u.push(g), u = g.inner;
          }
      }
    }
  }), s;
}
const X9 = /* @__PURE__ */ Ft.define();
function G9(e) {
  let t = 0, n = 0, r = 0, i = 0;
  for (let s of e.state.facet(X9)) {
    let o = s(e);
    o && (o.left != null && (t = Math.max(t, o.left)), o.right != null && (n = Math.max(n, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: t, right: n, top: r, bottom: i };
}
const wf = /* @__PURE__ */ Ft.define();
class Zi {
  constructor(t, n, r, i) {
    this.fromA = t, this.toA = n, this.fromB = r, this.toB = i;
  }
  join(t) {
    return new Zi(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let n = t.length, r = this;
    for (; n > 0; n--) {
      let i = t[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), t.splice(n - 1, 1);
      }
    }
    return t.splice(n, 0, r), t;
  }
  static extendWithRanges(t, n) {
    if (n.length == 0)
      return t;
    let r = [];
    for (let i = 0, s = 0, o = 0, a = 0; ; i++) {
      let l = i == t.length ? null : t[i], h = o - a, u = l ? l.fromB : 1e9;
      for (; s < n.length && n[s] < u; ) {
        let f = n[s], d = n[s + 1], p = Math.max(a, f), g = Math.min(u, d);
        if (p <= g && new Zi(p + h, g + h, p, g).addToSet(r), d > u)
          break;
        s += 2;
      }
      if (!l)
        return r;
      new Zi(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), o = l.toA, a = l.toB;
    }
  }
}
class Pg {
  constructor(t, n, r) {
    this.view = t, this.state = n, this.transactions = r, this.flags = 0, this.startState = t.state, this.changes = $n.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, a, l) => i.push(new Zi(s, o, a, l))), this.changedRanges = i;
  }
  static create(t, n, r) {
    return new Pg(t, n, r);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var yn = /* @__PURE__ */ function(e) {
  return e[e.LTR = 0] = "LTR", e[e.RTL = 1] = "RTL", e;
}(yn || (yn = {}));
const Od = yn.LTR, H9 = yn.RTL;
function K9(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    t.push(1 << +e[n]);
  return t;
}
const Cq = /* @__PURE__ */ K9("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Tq = /* @__PURE__ */ K9("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), hv = /* @__PURE__ */ Object.create(null), Fs = [];
for (let e of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ e.charCodeAt(0), n = /* @__PURE__ */ e.charCodeAt(1);
  hv[t] = n, hv[n] = -t;
}
function Eq(e) {
  return e <= 247 ? Cq[e] : 1424 <= e && e <= 1524 ? 2 : 1536 <= e && e <= 1785 ? Tq[e - 1536] : 1774 <= e && e <= 2220 ? 4 : 8192 <= e && e <= 8204 ? 256 : 64336 <= e && e <= 65023 ? 4 : 1;
}
const Aq = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Na {
  get dir() {
    return this.level % 2 ? H9 : Od;
  }
  constructor(t, n, r) {
    this.from = t, this.to = n, this.level = r;
  }
  side(t, n) {
    return this.dir == n == t ? this.to : this.from;
  }
  static find(t, n, r, i) {
    let s = -1;
    for (let o = 0; o < t.length; o++) {
      let a = t[o];
      if (a.from <= n && a.to >= n) {
        if (a.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : t[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function J9(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++) {
    let r = e[n], i = t[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !J9(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const je = [];
function Pq(e, t, n, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : t, a = s < r.length ? r[s].from : n, l = s ? 256 : i;
    for (let h = o, u = l, f = l; h < a; h++) {
      let d = Eq(e.charCodeAt(h));
      d == 512 ? d = u : d == 8 && f == 4 && (d = 16), je[h] = d == 4 ? 2 : d, d & 7 && (f = d), u = d;
    }
    for (let h = o, u = l, f = l; h < a; h++) {
      let d = je[h];
      if (d == 128)
        h < a - 1 && u == je[h + 1] && u & 24 ? d = je[h] = u : je[h] = 256;
      else if (d == 64) {
        let p = h + 1;
        for (; p < a && je[p] == 64; )
          p++;
        let g = h && u == 8 || p < n && je[p] == 8 ? f == 1 ? 1 : 8 : 256;
        for (let m = h; m < p; m++)
          je[m] = g;
        h = p - 1;
      } else
        d == 8 && f == 1 && (je[h] = 1);
      u = d, d & 7 && (f = d);
    }
  }
}
function Dq(e, t, n, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
    let h = o ? r[o - 1].to : t, u = o < r.length ? r[o].from : n;
    for (let f = h, d, p, g; f < u; f++)
      if (p = hv[d = e.charCodeAt(f)])
        if (p < 0) {
          for (let m = a - 3; m >= 0; m -= 3)
            if (Fs[m + 1] == -p) {
              let y = Fs[m + 2], O = y & 2 ? i : y & 4 ? y & 1 ? s : i : 0;
              O && (je[f] = je[Fs[m]] = O), a = m;
              break;
            }
        } else {
          if (Fs.length == 189)
            break;
          Fs[a++] = f, Fs[a++] = d, Fs[a++] = l;
        }
      else if ((g = je[f]) == 2 || g == 1) {
        let m = g == i;
        l = m ? 0 : 1;
        for (let y = a - 3; y >= 0; y -= 3) {
          let O = Fs[y + 2];
          if (O & 2)
            break;
          if (m)
            Fs[y + 2] |= 2;
          else {
            if (O & 4)
              break;
            Fs[y + 2] |= 4;
          }
        }
      }
  }
}
function Lq(e, t, n, r) {
  for (let i = 0, s = r; i <= n.length; i++) {
    let o = i ? n[i - 1].to : e, a = i < n.length ? n[i].from : t;
    for (let l = o; l < a; ) {
      let h = je[l];
      if (h == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (i == n.length)
              break;
            u = n[i++].to, a = i < n.length ? n[i].from : t;
          } else if (je[u] == 256)
            u++;
          else
            break;
        let f = s == 1, d = (u < t ? je[u] : r) == 1, p = f == d ? f ? 1 : 2 : r;
        for (let g = u, m = i, y = m ? n[m - 1].to : e; g > l; )
          g == y && (g = n[--m].from, y = m ? n[m - 1].to : e), je[--g] = p;
        l = u;
      } else
        s = h, l++;
    }
  }
}
function uv(e, t, n, r, i, s, o) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let l = t, h = 0; l < n; ) {
      let u = !0, f = !1;
      if (h == s.length || l < s[h].from) {
        let m = je[l];
        m != a && (u = !1, f = m == 16);
      }
      let d = !u && a == 1 ? [] : null, p = u ? r : r + 1, g = l;
      t:
        for (; ; )
          if (h < s.length && g == s[h].from) {
            if (f)
              break t;
            let m = s[h];
            if (!u)
              for (let y = m.to, O = h + 1; ; ) {
                if (y == n)
                  break t;
                if (O < s.length && s[O].from == y)
                  y = s[O++].to;
                else {
                  if (je[y] == a)
                    break t;
                  break;
                }
              }
            if (h++, d)
              d.push(m);
            else {
              m.from > l && o.push(new Na(l, m.from, p));
              let y = m.direction == Od != !(p % 2);
              fv(e, y ? r + 1 : r, i, m.inner, m.from, m.to, o), l = m.to;
            }
            g = m.to;
          } else {
            if (g == n || (u ? je[g] != a : je[g] == a))
              break;
            g++;
          }
      d ? uv(e, l, g, r + 1, i, d, o) : l < g && o.push(new Na(l, g, p)), l = g;
    }
  else
    for (let l = n, h = s.length; l > t; ) {
      let u = !0, f = !1;
      if (!h || l > s[h - 1].to) {
        let m = je[l - 1];
        m != a && (u = !1, f = m == 16);
      }
      let d = !u && a == 1 ? [] : null, p = u ? r : r + 1, g = l;
      t:
        for (; ; )
          if (h && g == s[h - 1].to) {
            if (f)
              break t;
            let m = s[--h];
            if (!u)
              for (let y = m.from, O = h; ; ) {
                if (y == t)
                  break t;
                if (O && s[O - 1].to == y)
                  y = s[--O].from;
                else {
                  if (je[y - 1] == a)
                    break t;
                  break;
                }
              }
            if (d)
              d.push(m);
            else {
              m.to < l && o.push(new Na(m.to, l, p));
              let y = m.direction == Od != !(p % 2);
              fv(e, y ? r + 1 : r, i, m.inner, m.from, m.to, o), l = m.from;
            }
            g = m.from;
          } else {
            if (g == t || (u ? je[g - 1] != a : je[g - 1] == a))
              break;
            g--;
          }
      d ? uv(e, g, l, r + 1, i, d, o) : g < l && o.push(new Na(g, l, p)), l = g;
    }
}
function fv(e, t, n, r, i, s, o) {
  let a = t % 2 ? 2 : 1;
  Pq(e, i, s, r, a), Dq(e, i, s, r, a), Lq(i, s, r, a), uv(e, i, s, t, n, r, o);
}
function Mq(e, t, n) {
  if (!e)
    return [new Na(0, 0, t == H9 ? 1 : 0)];
  if (t == Od && !n.length && !Aq.test(e))
    return tP(e.length);
  if (n.length)
    for (; e.length > je.length; )
      je[je.length] = 256;
  let r = [], i = t == Od ? 0 : 1;
  return fv(e, i, i, n, 0, e.length, r), r;
}
function tP(e) {
  return [new Na(0, e, 0)];
}
let eP = "";
function Rq(e, t, n, r, i) {
  var s;
  let o = r.head - e.from, a = -1;
  if (o == 0) {
    if (!i || !e.length)
      return null;
    t[0].level != n && (o = t[0].side(!1, n), a = 0);
  } else if (o == e.length) {
    if (i)
      return null;
    let d = t[t.length - 1];
    d.level != n && (o = d.side(!0, n), a = t.length - 1);
  }
  a < 0 && (a = Na.find(t, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc));
  let l = t[a];
  o == l.side(i, n) && (l = t[a += i ? 1 : -1], o = l.side(!i, n));
  let h = i == (l.dir == n), u = mr(e.text, o, h);
  if (eP = e.text.slice(Math.min(o, u), Math.max(o, u)), u > l.from && u < l.to)
    return mt.cursor(u + e.from, h ? -1 : 1, l.level);
  let f = a == (i ? t.length - 1 : 0) ? null : t[a + (i ? 1 : -1)];
  return !f && l.level != n ? mt.cursor(i ? e.to : e.from, i ? -1 : 1, n) : f && f.level < l.level ? mt.cursor(f.side(!i, n) + e.from, i ? 1 : -1, f.level) : mt.cursor(u + e.from, i ? -1 : 1, l.level);
}
class b4 extends an {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new jn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Zi(0, 0, 0, t.state.doc.length)], 0, null);
  }
  update(t) {
    var n;
    let r = t.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: h, toA: u }) => u < this.minWidthFrom || h > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !Zq(t.changes, this.hasComposition) && !t.selectionSet && (i = t.state.selection.main.head));
    let s = i > -1 ? Iq(this.view, t.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: h, to: u } = this.hasComposition;
      r = new Zi(h, u, t.changes.mapPos(h, -1), t.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (Wt.ie || Wt.chrome) && !s && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = Fq(o, a, t.changes);
    return r = Zi.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, t.startState.doc.length, s), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  updateInner(t, n, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = Wt.chrome || Wt.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach((o) => o.flags &= -9);
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Za && o.widget instanceof O4 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(t, n, r) {
    let i = r ? r.range.addToSet(t.slice()) : t, s = this.childCursor(n);
    for (let o = i.length - 1; ; o--) {
      let a = o >= 0 ? i[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: h, fromB: u, toB: f } = a, d, p, g, m;
      if (r && r.range.fromB < f && r.range.toB > u) {
        let w = Yf.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), E = Yf.build(this.view.state.doc, r.range.toB, f, this.decorations, this.dynamicDecorationMap);
        p = w.breakAtStart, g = w.openStart, m = E.openEnd;
        let T = this.compositionView(r);
        E.breakAtStart ? T.breakAfter = 1 : E.content.length && T.merge(T.length, T.length, E.content[0], !1, E.openStart, 0) && (T.breakAfter = E.content[0].breakAfter, E.content.shift()), w.content.length && T.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), d = w.content.concat(T).concat(E.content);
      } else
        ({ content: d, breakAtStart: p, openStart: g, openEnd: m } = Yf.build(this.view.state.doc, u, f, this.decorations, this.dynamicDecorationMap));
      let { i: y, off: O } = s.findPos(h, 1), { i: x, off: _ } = s.findPos(l, -1);
      D9(this, x, _, y, O, d, p, g, m);
    }
    r && this.fixCompositionDOM(r);
  }
  compositionView(t) {
    let n = new aa(t.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of t.marks)
      n = new la(i, [n], n.length);
    let r = new jn();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(t) {
    let n = (s, o) => {
      o.flags |= 8 | (o.children.some((l) => l.flags & 7) ? 1 : 0), this.markedForComposition.add(o);
      let a = an.get(s);
      a && a != o && (a.dom = null), o.setDOM(s);
    }, r = this.childPos(t.range.fromB, 1), i = this.children[r.i];
    n(t.line, i);
    for (let s = t.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], n(s >= 0 ? t.marks[s].node : t.text, i);
  }
  updateSelection(t = !1, n = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && M1(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), h = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (Wt.gecko && a.empty && !this.hasComposition && $q(l)) {
      let f = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(f, l.node.childNodes[l.offset] || null)), l = h = new Cr(f, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || !Ag(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Ag(h.node, h.offset, u.focusNode, u.focusOffset)) && (this.view.observer.ignore(() => {
      Wt.android && Wt.chrome && this.dom.contains(u.focusNode) && Qq(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let f = Eg(this.view.root);
      if (f)
        if (a.empty) {
          if (Wt.gecko) {
            let d = Nq(l.node, l.offset);
            if (d && d != 3) {
              let p = rP(l.node, l.offset, d == 1 ? 1 : -1);
              p && (l = new Cr(p.node, p.offset));
            }
          }
          f.collapse(l.node, l.offset), a.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = a.bidiLevel);
        } else if (f.extend) {
          f.collapse(l.node, l.offset);
          try {
            f.extend(h.node, h.offset);
          } catch {
          }
        } else {
          let d = document.createRange();
          a.anchor > a.head && ([l, h] = [h, l]), d.setEnd(h.node, h.offset), d.setStart(l.node, l.offset), f.removeAllRanges(), f.addRange(d);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, h)), this.impreciseAnchor = l.precise ? null : new Cr(u.anchorNode, u.anchorOffset), this.impreciseHead = h.precise ? null : new Cr(u.focusNode, u.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, n = t.state.selection.main, r = Eg(t.root), { anchorNode: i, anchorOffset: s } = t.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify)
      return;
    let o = jn.find(this, n.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (n.head == a || n.head == a + o.length)
      return;
    let l = this.coordsAt(n.head, -1), h = this.coordsAt(n.head, 1);
    if (!l || !h || l.bottom > h.top)
      return;
    let u = this.domAtPos(n.head + n.assoc);
    r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let f = t.observer.selectionRange;
    t.docView.posFromDOM(f.anchorNode, f.anchorOffset) != n.from && r.collapse(i, s);
  }
  moveToLine(t) {
    let n = this.dom, r;
    if (t.node != n)
      return t;
    for (let i = t.offset; !r && i < n.childNodes.length; i++) {
      let s = an.get(n.childNodes[i]);
      s instanceof jn && (r = s.domAtPos(0));
    }
    for (let i = t.offset - 1; !r && i >= 0; i--) {
      let s = an.get(n.childNodes[i]);
      s instanceof jn && (r = s.domAtPos(s.length));
    }
    return r ? new Cr(r.node, r.offset, !0) : t;
  }
  nearest(t) {
    for (let n = t; n; ) {
      let r = an.get(n);
      if (r && r.rootView == this)
        return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(t, n) {
    let r = this.nearest(t);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(t, n) + r.posAtStart;
  }
  domAtPos(t) {
    let { i: n, off: r } = this.childCursor().findPos(t, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof jn)
        break;
      n++, r = 0;
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(t, n) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = s - a.breakAfter, h = l - a.length;
      if (l < t)
        break;
      h <= t && (h < t || a.covers(-1)) && (l > t || a.covers(1)) && (!r || a instanceof jn && !(r instanceof jn && n >= 0)) && (r = a, i = h), s = h;
    }
    return r ? r.coordsAt(t - i, n) : null;
  }
  coordsForChar(t) {
    let { i: n, off: r } = this.childPos(t, 1), i = this.children[n];
    if (!(i instanceof jn))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(r, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      r = l;
    }
    if (!(i instanceof aa))
      return null;
    let s = mr(i.text, r);
    if (s == r)
      return null;
    let o = rc(i.dom, r, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let n = [], { from: r, to: i } = t, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == yn.LTR;
    for (let h = 0, u = 0; u < this.children.length; u++) {
      let f = this.children[u], d = h + f.length;
      if (d > i)
        break;
      if (h >= r) {
        let p = f.dom.getBoundingClientRect();
        if (n.push(p.height), o) {
          let g = f.dom.lastChild, m = g ? md(g) : [];
          if (m.length) {
            let y = m[m.length - 1], O = l ? y.right - p.left : p.right - y.left;
            O > a && (a = O, this.minWidth = s, this.minWidthFrom = h, this.minWidthTo = d);
          }
        }
      }
      h = d + f.breakAfter;
    }
    return n;
  }
  textDirectionAt(t) {
    let { i: n } = this.childPos(t, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? yn.RTL : yn.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof jn) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let t = document.createElement("div"), n, r, i;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let s = md(t.firstChild)[0];
      n = t.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : n, t.remove();
    }), { lineHeight: n, charWidth: r, textHeight: i };
  }
  childCursor(t = this.length) {
    let n = this.children.length;
    return n && (t -= this.children[--n].length), new P9(this.children, t, n);
  }
  computeBlockGapDeco() {
    let t = [], n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == n.viewports.length ? null : n.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let a = (n.lineBlockAt(o).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        t.push(Bt.replace({
          widget: new O4(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return Bt.set(t);
  }
  updateDeco() {
    let t = this.view.state.facet(bd).map((n, r) => (this.dynamicDecorationMap[r] = typeof n == "function") ? n(this.view) : n);
    for (let n = t.length; n < t.length + 3; n++)
      this.dynamicDecorationMap[n] = !1;
    return this.decorations = [
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let h = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = h.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    let { range: n } = t, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
    if (!r)
      return;
    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = G9(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    gq(this.view.scrollDOM, o, n.head < n.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, a), -a), Math.max(Math.min(t.yMargin, l), -l), this.view.textDirection == yn.LTR);
  }
}
function $q(e) {
  return e.node.nodeType == 1 && e.node.firstChild && (e.offset == 0 || e.node.childNodes[e.offset - 1].contentEditable == "false") && (e.offset == e.node.childNodes.length || e.node.childNodes[e.offset].contentEditable == "false");
}
class O4 extends si {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function nP(e, t) {
  let n = e.observer.selectionRange, r = n.focusNode && rP(n.focusNode, n.focusOffset, 0);
  if (!r)
    return null;
  let i = t - r.offset;
  return { from: i, to: i + r.node.nodeValue.length, node: r.node };
}
function Iq(e, t, n) {
  let r = nP(e, n);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, a = i.nodeValue;
  if (/[\n\r]/.test(a) || e.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let l = t.invertedDesc, h = new Zi(l.mapPos(s), l.mapPos(o), s, o), u = [];
  for (let f = i.parentNode; ; f = f.parentNode) {
    let d = an.get(f);
    if (d instanceof la)
      u.push({ node: f, deco: d.mark });
    else {
      if (d instanceof jn || f.nodeName == "DIV" && f.parentNode == e.contentDOM)
        return { range: h, text: i, marks: u, line: f };
      if (f != e.contentDOM)
        u.push({ node: f, deco: new Mp({
          inclusive: !0,
          attributes: kq(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function rP(e, t, n) {
  if (n <= 0)
    for (let r = e, i = t; ; ) {
      if (r.nodeType == 3)
        return { node: r, offset: i };
      if (r.nodeType == 1 && i > 0)
        r = r.childNodes[i - 1], i = oa(r);
      else
        break;
    }
  if (n >= 0)
    for (let r = e, i = t; ; ) {
      if (r.nodeType == 3)
        return { node: r, offset: i };
      if (r.nodeType == 1 && i < r.childNodes.length && n >= 0)
        r = r.childNodes[i], i = 0;
      else
        break;
    }
  return null;
}
function Nq(e, t) {
  return e.nodeType != 1 ? 0 : (t && e.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < e.childNodes.length && e.childNodes[t].contentEditable == "false" ? 2 : 0);
}
let Bq = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, n) {
    lv(t, n, this.changes);
  }
  comparePoint(t, n) {
    lv(t, n, this.changes);
  }
};
function Fq(e, t, n) {
  let r = new Bq();
  return Ne.compare(e, t, n, r), r.changes;
}
function Qq(e, t) {
  for (let n = e; n && n != t; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function Zq(e, t) {
  let n = !1;
  return t && e.iterChangedRanges((r, i) => {
    r < t.to && i > t.from && (n = !0);
  }), n;
}
function Vq(e, t, n = 1) {
  let r = e.charCategorizer(t), i = e.doc.lineAt(t), s = t - i.from;
  if (i.length == 0)
    return mt.cursor(t);
  s == 0 ? n = 1 : s == i.length && (n = -1);
  let o = s, a = s;
  n < 0 ? o = mr(i.text, s, !1) : a = mr(i.text, s);
  let l = r(i.text.slice(o, a));
  for (; o > 0; ) {
    let h = mr(i.text, o, !1);
    if (r(i.text.slice(h, o)) != l)
      break;
    o = h;
  }
  for (; a < i.length; ) {
    let h = mr(i.text, a);
    if (r(i.text.slice(a, h)) != l)
      break;
    a = h;
  }
  return mt.range(o + i.from, a + i.from);
}
function Yq(e, t) {
  return t.left > e ? t.left - e : Math.max(0, e - t.right);
}
function zq(e, t) {
  return t.top > e ? t.top - e : Math.max(0, e - t.bottom);
}
function vb(e, t) {
  return e.top < t.bottom - 1 && e.bottom > t.top + 1;
}
function x4(e, t) {
  return t < e.top ? { top: t, left: e.left, right: e.right, bottom: e.bottom } : e;
}
function v4(e, t) {
  return t > e.bottom ? { top: e.top, left: e.left, right: e.right, bottom: t } : e;
}
function dv(e, t, n) {
  let r, i, s, o, a = !1, l, h, u, f;
  for (let g = e.firstChild; g; g = g.nextSibling) {
    let m = md(g);
    for (let y = 0; y < m.length; y++) {
      let O = m[y];
      i && vb(i, O) && (O = x4(v4(O, i.bottom), i.top));
      let x = Yq(t, O), _ = zq(n, O);
      if (x == 0 && _ == 0)
        return g.nodeType == 3 ? _4(g, t, n) : dv(g, t, n);
      if (!r || o > _ || o == _ && s > x) {
        r = g, i = O, s = x, o = _;
        let w = _ ? n < O.top ? -1 : 1 : x ? t < O.left ? -1 : 1 : 0;
        a = !w || (w > 0 ? y < m.length - 1 : y > 0);
      }
      x == 0 ? n > O.bottom && (!u || u.bottom < O.bottom) ? (l = g, u = O) : n < O.top && (!f || f.top > O.top) && (h = g, f = O) : u && vb(u, O) ? u = v4(u, O.bottom) : f && vb(f, O) && (f = x4(f, O.top));
    }
  }
  if (u && u.bottom >= n ? (r = l, i = u) : f && f.top <= n && (r = h, i = f), !r)
    return { node: e, offset: 0 };
  let d = Math.max(i.left, Math.min(i.right, t));
  if (r.nodeType == 3)
    return _4(r, d, n);
  if (a && r.contentEditable != "false")
    return dv(r, d, n);
  let p = Array.prototype.indexOf.call(e.childNodes, r) + (t >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: e, offset: p };
}
function _4(e, t, n) {
  let r = e.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let a = 0; a < r; a++) {
    let l = rc(e, a, a + 1).getClientRects();
    for (let h = 0; h < l.length; h++) {
      let u = l[h];
      if (u.top == u.bottom)
        continue;
      o || (o = t - u.left);
      let f = (u.top > n ? u.top - n : n - u.bottom) - 1;
      if (u.left - 1 <= t && u.right + 1 >= t && f < s) {
        let d = t >= (u.left + u.right) / 2, p = d;
        if ((Wt.chrome || Wt.gecko) && rc(e, a).getBoundingClientRect().left == u.right && (p = !d), f <= 0)
          return { node: e, offset: a + (p ? 1 : 0) };
        i = a + (p ? 1 : 0), s = f;
      }
    }
  }
  return { node: e, offset: i > -1 ? i : o > 0 ? e.nodeValue.length : 0 };
}
function iP(e, t, n, r = -1) {
  var i, s;
  let o = e.contentDOM.getBoundingClientRect(), a = o.top + e.viewState.paddingTop, l, { docHeight: h } = e.viewState, { x: u, y: f } = t, d = f - a;
  if (d < 0)
    return 0;
  if (d > h)
    return e.state.doc.length;
  for (let w = e.viewState.heightOracle.textHeight / 2, E = !1; l = e.elementAtHeight(d), l.type != Fr.Text; )
    for (; d = r > 0 ? l.bottom + w : l.top - w, !(d >= 0 && d <= h); ) {
      if (E)
        return n ? null : 0;
      E = !0, r = -r;
    }
  f = a + d;
  let p = l.from;
  if (p < e.viewport.from)
    return e.viewport.from == 0 ? 0 : n ? null : k4(e, o, l, u, f);
  if (p > e.viewport.to)
    return e.viewport.to == e.state.doc.length ? e.state.doc.length : n ? null : k4(e, o, l, u, f);
  let g = e.dom.ownerDocument, m = e.root.elementFromPoint ? e.root : g, y = m.elementFromPoint(u, f);
  y && !e.contentDOM.contains(y) && (y = null), y || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), y = m.elementFromPoint(u, f), y && !e.contentDOM.contains(y) && (y = null));
  let O, x = -1;
  if (y && ((i = e.docView.nearest(y)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (g.caretPositionFromPoint) {
      let w = g.caretPositionFromPoint(u, f);
      w && ({ offsetNode: O, offset: x } = w);
    } else if (g.caretRangeFromPoint) {
      let w = g.caretRangeFromPoint(u, f);
      w && ({ startContainer: O, startOffset: x } = w, (!e.contentDOM.contains(O) || Wt.safari && qq(O, x, u) || Wt.chrome && Wq(O, x, u)) && (O = void 0));
    }
  }
  if (!O || !e.docView.dom.contains(O)) {
    let w = jn.find(e.docView, p);
    if (!w)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: O, offset: x } = dv(w.dom, u, f));
  }
  let _ = e.docView.nearest(O);
  if (!_)
    return null;
  if (_.isWidget && ((s = _.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = _.dom.getBoundingClientRect();
    return t.y < w.top || t.y <= w.bottom && t.x <= (w.left + w.right) / 2 ? _.posAtStart : _.posAtEnd;
  } else
    return _.localPosFromDOM(O, x) + _.posAtStart;
}
function k4(e, t, n, r, i) {
  let s = Math.round((r - t.left) * e.defaultCharacterWidth);
  if (e.lineWrapping && n.height > e.defaultLineHeight * 1.5) {
    let a = e.viewState.heightOracle.textHeight, l = Math.floor((i - n.top - (e.defaultLineHeight - a) * 0.5) / a);
    s += l * e.viewState.heightOracle.lineLength;
  }
  let o = e.state.sliceDoc(n.from, n.to);
  return n.from + Jx(o, s, e.state.tabSize);
}
function qq(e, t, n) {
  let r;
  if (e.nodeType != 3 || t != (r = e.nodeValue.length))
    return !1;
  for (let i = e.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return rc(e, r - 1, r).getBoundingClientRect().left > n;
}
function Wq(e, t, n) {
  if (t != 0)
    return !1;
  for (let i = e; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = e.nodeType == 1 ? e.getBoundingClientRect() : rc(e, 0, Math.max(e.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function pv(e, t) {
  let n = e.lineBlockAt(t);
  if (Array.isArray(n.type)) {
    for (let r of n.type)
      if (r.to > t || r.to == t && (r.to == n.to || r.type == Fr.Text))
        return r;
  }
  return n;
}
function Uq(e, t, n, r) {
  let i = pv(e, t.head), s = !r || i.type != Fr.Text || !(e.lineWrapping || i.widgetLineBreaks) ? null : e.coordsAtPos(t.assoc < 0 && t.head > i.from ? t.head - 1 : t.head);
  if (s) {
    let o = e.dom.getBoundingClientRect(), a = e.textDirectionAt(i.from), l = e.posAtCoords({
      x: n == (a == yn.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return mt.cursor(l, n ? -1 : 1);
  }
  return mt.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function w4(e, t, n, r) {
  let i = e.state.doc.lineAt(t.head), s = e.bidiSpans(i), o = e.textDirectionAt(i.from);
  for (let a = t, l = null; ; ) {
    let h = Rq(i, s, o, a, n), u = eP;
    if (!h) {
      if (i.number == (n ? e.state.doc.lines : 1))
        return a;
      u = `
`, i = e.state.doc.line(i.number + (n ? 1 : -1)), s = e.bidiSpans(i), h = mt.cursor(n ? i.from : i.to);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!r)
        return h;
      l = r(u);
    }
    a = h;
  }
}
function jq(e, t, n) {
  let r = e.state.charCategorizer(t), i = r(n);
  return (s) => {
    let o = r(s);
    return i == hn.Space && (i = o), i == o;
  };
}
function Xq(e, t, n, r) {
  let i = t.head, s = n ? 1 : -1;
  if (i == (n ? e.state.doc.length : 0))
    return mt.cursor(i, t.assoc);
  let o = t.goalColumn, a, l = e.contentDOM.getBoundingClientRect(), h = e.coordsAtPos(i, t.assoc || -1), u = e.documentTop;
  if (h)
    o == null && (o = h.left - l.left), a = s < 0 ? h.top : h.bottom;
  else {
    let p = e.viewState.lineBlockAt(i);
    o == null && (o = Math.min(l.right - l.left, e.defaultCharacterWidth * (i - p.from))), a = (s < 0 ? p.top : p.bottom) + u;
  }
  let f = l.left + o, d = r != null ? r : e.viewState.heightOracle.textHeight >> 1;
  for (let p = 0; ; p += 10) {
    let g = a + (d + p) * s, m = iP(e, { x: f, y: g }, !1, s);
    if (g < l.top || g > l.bottom || (s < 0 ? m < i : m > i)) {
      let y = e.docView.coordsForChar(m), O = !y || g < y.top ? -1 : 1;
      return mt.cursor(m, O, void 0, o);
    }
  }
}
function R1(e, t, n) {
  for (; ; ) {
    let r = 0;
    for (let i of e)
      i.between(t - 1, t + 1, (s, o, a) => {
        if (t > s && t < o) {
          let l = r || n || (t - s < o - t ? -1 : 1);
          t = l < 0 ? s : o, r = l;
        }
      });
    if (!r)
      return t;
  }
}
function _b(e, t, n) {
  let r = R1(e.state.facet(aw).map((i) => i(e)), n.from, t.head > n.from ? -1 : 1);
  return r == n.from ? n : mt.cursor(r, r < n.from ? 1 : -1);
}
class Gq {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, Wt.safari && t.contentDOM.addEventListener("input", () => null), Wt.gecko && fW(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !iW(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || this.runHandlers(t.type, t);
  }
  runHandlers(t, n) {
    let r = this.handlers[t];
    if (r) {
      for (let i of r.observers)
        i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented)
          break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let n = Hq(t), r = this.handlers, i = this.view.contentDOM;
    for (let s in n)
      if (s != "scroll") {
        let o = !n[s].handlers.length, a = r[s];
        a && o != !a.handlers.length && (i.removeEventListener(s, this.handleEvent), a = null), a || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !n[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = n;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (t.keyCode != 27 && oP.indexOf(t.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), Wt.android && Wt.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let n;
    return Wt.ios && !t.synthetic && !t.altKey && !t.metaKey && ((n = sP.find((r) => r.keyCode == t.keyCode)) && !t.ctrlKey || Kq.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = n || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, dh(this.view.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : Wt.safari && !Wt.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function S4(e, t) {
  return (n, r) => {
    try {
      return t.call(e, r, n);
    } catch (i) {
      Qi(n.state, i);
    }
  };
}
function Hq(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(r) {
    return t[r] || (t[r] = { observers: [], handlers: [] });
  }
  for (let r of e) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s];
        o && n(s).handlers.push(S4(r.value, o));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s];
        o && n(s).observers.push(S4(r.value, o));
      }
  }
  for (let r in xs)
    n(r).handlers.push(xs[r]);
  for (let r in vs)
    n(r).observers.push(vs[r]);
  return t;
}
const sP = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], Kq = "dthko", oP = [16, 17, 18, 20, 91, 92, 224, 225], w0 = 6;
function S0(e) {
  return Math.max(0, e) * 0.7 + 8;
}
function Jq(e, t) {
  return Math.max(Math.abs(e.clientX - t.clientX), Math.abs(e.clientY - t.clientY));
}
class tW {
  constructor(t, n, r, i) {
    this.view = t, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParent = mq(t.contentDOM), this.atoms = t.state.facet(aw).map((o) => o(t));
    let s = t.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = t.state.facet(De.allowMultipleSelections) && eW(t, n), this.dragging = rW(t, n) && hP(n) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    var n;
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && Jq(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let r = 0, i = 0, s = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = G9(this.view);
    t.clientX - o.left <= s.left + w0 ? r = -S0(s.left - t.clientX) : t.clientX + o.right >= s.right - w0 && (r = S0(t.clientX - s.right)), t.clientY - o.top <= s.top + w0 ? i = -S0(s.top - t.clientY) : t.clientY + o.bottom >= s.bottom - w0 && (i = S0(t.clientY - s.bottom)), this.setScrollSpeed(r, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, n) {
    this.scrollSpeed = { x: t, y: n }, t || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(t) {
    let n = null;
    for (let r = 0; r < t.ranges.length; r++) {
      let i = t.ranges[r], s = null;
      if (i.empty) {
        let o = R1(this.atoms, i.from, 0);
        o != i.from && (s = mt.cursor(o, -1));
      } else {
        let o = R1(this.atoms, i.from, -1), a = R1(this.atoms, i.to, 1);
        (o != i.from || a != i.to) && (s = mt.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a));
      }
      s && (n || (n = t.ranges.slice()), n[r] = s);
    }
    return n ? mt.create(n, t.mainIndex) : t;
  }
  select(t) {
    let { view: n } = this, r = this.skipAtoms(this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection) || r.main.assoc != n.state.selection.main.assoc && this.dragging === !1) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function eW(e, t) {
  let n = e.state.facet(F9);
  return n.length ? n[0](t) : Wt.mac ? t.metaKey : t.ctrlKey;
}
function nW(e, t) {
  let n = e.state.facet(Q9);
  return n.length ? n[0](t) : Wt.mac ? !t.altKey : !t.ctrlKey;
}
function rW(e, t) {
  let { main: n } = e.state.selection;
  if (n.empty)
    return !1;
  let r = Eg(e.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= t.clientX && o.right >= t.clientX && o.top <= t.clientY && o.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
function iW(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target, r; n != e.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (r = an.get(n)) && r.ignoreEvent(t))
      return !1;
  return !0;
}
const xs = /* @__PURE__ */ Object.create(null), vs = /* @__PURE__ */ Object.create(null), aP = Wt.ie && Wt.ie_version < 15 || Wt.ios && Wt.webkit_version < 604;
function sW(e) {
  let t = e.dom.parentNode;
  if (!t)
    return;
  let n = t.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    e.focus(), n.remove(), lP(e, n.value);
  }, 50);
}
function lP(e, t) {
  let { state: n } = e, r, i = 1, s = n.toText(t), o = s.lines == n.selection.ranges.length;
  if (gv != null && n.selection.ranges.every((l) => l.empty) && gv == s.toString()) {
    let l = -1;
    r = n.changeByRange((h) => {
      let u = n.doc.lineAt(h.from);
      if (u.from == l)
        return { range: h };
      l = u.from;
      let f = n.toText((o ? s.line(i++).text : t) + n.lineBreak);
      return {
        changes: { from: u.from, insert: f },
        range: mt.cursor(h.from + f.length)
      };
    });
  } else
    o ? r = n.changeByRange((l) => {
      let h = s.line(i++);
      return {
        changes: { from: l.from, to: l.to, insert: h.text },
        range: mt.cursor(l.from + h.length)
      };
    }) : r = n.replaceSelection(s);
  e.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
vs.scroll = (e) => {
  e.inputState.lastScrollTop = e.scrollDOM.scrollTop, e.inputState.lastScrollLeft = e.scrollDOM.scrollLeft;
};
xs.keydown = (e, t) => (e.inputState.setSelectionOrigin("select"), t.keyCode == 27 && (e.inputState.lastEscPress = Date.now()), !1);
vs.touchstart = (e, t) => {
  e.inputState.lastTouchTime = Date.now(), e.inputState.setSelectionOrigin("select.pointer");
};
vs.touchmove = (e) => {
  e.inputState.setSelectionOrigin("select.pointer");
};
xs.mousedown = (e, t) => {
  if (e.observer.flush(), e.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let r of e.state.facet(Z9))
    if (n = r(e, t), n)
      break;
  if (!n && t.button == 0 && (n = lW(e, t)), n) {
    let r = !e.hasFocus;
    e.inputState.startMouseSelection(new tW(e, t, n, r)), r && e.observer.ignore(() => T9(e.contentDOM));
    let i = e.inputState.mouseSelection;
    if (i)
      return i.start(t), i.dragging === !1;
  }
  return !1;
};
function C4(e, t, n, r) {
  if (r == 1)
    return mt.cursor(t, n);
  if (r == 2)
    return Vq(e.state, t, n);
  {
    let i = jn.find(e.docView, t), s = e.state.doc.lineAt(i ? i.posAtEnd : t), o = i ? i.posAtStart : s.from, a = i ? i.posAtEnd : s.to;
    return a < e.state.doc.length && a == s.to && a++, mt.range(o, a);
  }
}
let cP = (e, t) => e >= t.top && e <= t.bottom, T4 = (e, t, n) => cP(t, n) && e >= n.left && e <= n.right;
function oW(e, t, n, r) {
  let i = jn.find(e.docView, t);
  if (!i)
    return 1;
  let s = t - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && T4(n, r, o))
    return -1;
  let a = i.coordsAt(s, 1);
  return a && T4(n, r, a) ? 1 : o && cP(r, o) ? -1 : 1;
}
function E4(e, t) {
  let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: n, bias: oW(e, n, t.clientX, t.clientY) };
}
const aW = Wt.ie && Wt.ie_version <= 11;
let A4 = null, P4 = 0, D4 = 0;
function hP(e) {
  if (!aW)
    return e.detail;
  let t = A4, n = D4;
  return A4 = e, D4 = Date.now(), P4 = !t || n > Date.now() - 400 && Math.abs(t.clientX - e.clientX) < 2 && Math.abs(t.clientY - e.clientY) < 2 ? (P4 + 1) % 3 : 1;
}
function lW(e, t) {
  let n = E4(e, t), r = hP(t), i = e.state.selection;
  return {
    update(s) {
      s.docChanged && (n.pos = s.changes.mapPos(n.pos), i = i.map(s.changes));
    },
    get(s, o, a) {
      let l = E4(e, s), h, u = C4(e, l.pos, l.bias, r);
      if (n.pos != l.pos && !o) {
        let f = C4(e, n.pos, n.bias, r), d = Math.min(f.from, u.from), p = Math.max(f.to, u.to);
        u = d < u.from ? mt.range(d, p) : mt.range(p, d);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (h = cW(i, l.pos)) ? h : a ? i.addRange(u) : mt.create([u]);
    }
  };
}
function cW(e, t) {
  for (let n = 0; n < e.ranges.length; n++) {
    let { from: r, to: i } = e.ranges[n];
    if (r <= t && i >= t)
      return mt.create(e.ranges.slice(0, n).concat(e.ranges.slice(n + 1)), e.mainIndex == n ? 0 : e.mainIndex - (e.mainIndex > n ? 1 : 0));
  }
  return null;
}
xs.dragstart = (e, t) => {
  let { selection: { main: n } } = e.state;
  if (t.target.draggable) {
    let i = e.docView.nearest(t.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= n.to || o <= n.from) && (n = mt.range(s, o));
    }
  }
  let { inputState: r } = e;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = n, t.dataTransfer && (t.dataTransfer.setData("Text", e.state.sliceDoc(n.from, n.to)), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
xs.dragend = (e) => (e.inputState.draggedContent = null, !1);
function L4(e, t, n, r) {
  if (!n)
    return;
  let i = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: s } = e.inputState, o = r && s && nW(e, t) ? { from: s.from, to: s.to } : null, a = { from: i, insert: n }, l = e.state.changes(o ? [o, a] : a);
  e.focus(), e.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), e.inputState.draggedContent = null;
}
xs.drop = (e, t) => {
  if (!t.dataTransfer)
    return !1;
  if (e.state.readOnly)
    return !0;
  let n = t.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length), i = 0, s = () => {
      ++i == n.length && L4(e, t, r.filter((o) => o != null).join(e.state.lineBreak), !1);
    };
    for (let o = 0; o < n.length; o++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result), s();
      }, a.readAsText(n[o]);
    }
    return !0;
  } else {
    let r = t.dataTransfer.getData("Text");
    if (r)
      return L4(e, t, r, !0), !0;
  }
  return !1;
};
xs.paste = (e, t) => {
  if (e.state.readOnly)
    return !0;
  e.observer.flush();
  let n = aP ? null : t.clipboardData;
  return n ? (lP(e, n.getData("text/plain") || n.getData("text/uri-text")), !0) : (sW(e), !1);
};
function hW(e, t) {
  let n = e.dom.parentNode;
  if (!n)
    return;
  let r = n.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = t, r.focus(), r.selectionEnd = t.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), e.focus();
  }, 50);
}
function uW(e) {
  let t = [], n = [], r = !1;
  for (let i of e.selection.ranges)
    i.empty || (t.push(e.sliceDoc(i.from, i.to)), n.push(i));
  if (!t.length) {
    let i = -1;
    for (let { from: s } of e.selection.ranges) {
      let o = e.doc.lineAt(s);
      o.number > i && (t.push(o.text), n.push({ from: o.from, to: Math.min(e.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: t.join(e.lineBreak), ranges: n, linewise: r };
}
let gv = null;
xs.copy = xs.cut = (e, t) => {
  let { text: n, ranges: r, linewise: i } = uW(e.state);
  if (!n && !i)
    return !1;
  gv = i ? n : null, t.type == "cut" && !e.state.readOnly && e.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = aP ? null : t.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", n), !0) : (hW(e, n), !1);
};
const uP = /* @__PURE__ */ Es.define();
function fP(e, t) {
  let n = [];
  for (let r of e.facet(z9)) {
    let i = r(e, t);
    i && n.push(i);
  }
  return n ? e.update({ effects: n, annotations: uP.of(!0) }) : null;
}
function dP(e) {
  setTimeout(() => {
    let t = e.hasFocus;
    if (t != e.inputState.notifiedFocused) {
      let n = fP(e.state, t);
      n ? e.dispatch(n) : e.update([]);
    }
  }, 10);
}
vs.focus = (e) => {
  e.inputState.lastFocusTime = Date.now(), !e.scrollDOM.scrollTop && (e.inputState.lastScrollTop || e.inputState.lastScrollLeft) && (e.scrollDOM.scrollTop = e.inputState.lastScrollTop, e.scrollDOM.scrollLeft = e.inputState.lastScrollLeft), dP(e);
};
vs.blur = (e) => {
  e.observer.clearSelectionRange(), dP(e);
};
vs.compositionstart = vs.compositionupdate = (e) => {
  e.inputState.compositionFirstChange == null && (e.inputState.compositionFirstChange = !0), e.inputState.composing < 0 && (e.inputState.composing = 0);
};
vs.compositionend = (e) => {
  e.inputState.composing = -1, e.inputState.compositionEndedAt = Date.now(), e.inputState.compositionPendingKey = !0, e.inputState.compositionPendingChange = e.observer.pendingRecords().length > 0, e.inputState.compositionFirstChange = null, Wt.chrome && Wt.android ? e.observer.flushSoon() : e.inputState.compositionPendingChange ? Promise.resolve().then(() => e.observer.flush()) : setTimeout(() => {
    e.inputState.composing < 0 && e.docView.hasComposition && e.update([]);
  }, 50);
};
vs.contextmenu = (e) => {
  e.inputState.lastContextMenu = Date.now();
};
xs.beforeinput = (e, t) => {
  var n;
  let r;
  if (Wt.chrome && Wt.android && (r = sP.find((i) => i.inputType == t.inputType)) && (e.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && e.hasFocus && (e.contentDOM.blur(), e.focus());
    }, 100);
  }
  return !1;
};
const M4 = /* @__PURE__ */ new Set();
function fW(e) {
  M4.has(e) || (M4.add(e), e.addEventListener("copy", () => {
  }), e.addEventListener("cut", () => {
  }));
}
const R4 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class dW {
  constructor(t) {
    this.lineWrapping = t, this.doc = Be.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(t, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - t - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return R4.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let n = !1;
    for (let r = 0; r < t.length; r++) {
      let i = t[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return n;
  }
  refresh(t, n, r, i, s, o) {
    let a = R4.indexOf(t) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let h = 0; h < o.length; h++) {
        let u = o[h];
        u < 0 ? h++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class pW {
  constructor(t, n) {
    this.from = t, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Hs {
  constructor(t, n, r, i, s) {
    this.from = t, this.length = n, this.top = r, this.height = i, this._content = s;
  }
  get type() {
    return typeof this._content == "number" ? Fr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof tl ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  join(t) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new Hs(this.from, this.length + t.length, this.top, this.height + t.height, n);
  }
}
var sn = /* @__PURE__ */ function(e) {
  return e[e.ByPos = 0] = "ByPos", e[e.ByHeight = 1] = "ByHeight", e[e.ByPosNoHeight = 2] = "ByPosNoHeight", e;
}(sn || (sn = {}));
const $1 = 1e-3;
class Qr {
  constructor(t, n, r = 2) {
    this.length = t, this.height = n, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t, n) {
    this.height != n && (Math.abs(this.height - n) > $1 && (t.heightChanged = !0), this.height = n);
  }
  replace(t, n, r) {
    return Qr.of(r);
  }
  decomposeLeft(t, n) {
    n.push(this);
  }
  decomposeRight(t, n) {
    n.push(this);
  }
  applyChanges(t, n, r, i) {
    let s = this, o = r.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: h, fromB: u, toB: f } = i[a], d = s.lineAt(l, sn.ByPosNoHeight, r.setDoc(n), 0, 0), p = d.to >= h ? d : s.lineAt(h, sn.ByPosNoHeight, r, 0, 0);
      for (f += p.to - h, h = p.to; a > 0 && d.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < d.from && (d = s.lineAt(l, sn.ByPosNoHeight, r, 0, 0));
      u += d.from - l, l = d.from;
      let g = lw.build(r.setDoc(o), t, u, f);
      s = s.replace(l, h, g);
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new fi(0, 0);
  }
  static of(t) {
    if (t.length == 1)
      return t[0];
    let n = 0, r = t.length, i = 0, s = 0;
    for (; ; )
      if (n == r)
        if (i > s * 2) {
          let a = t[n - 1];
          a.break ? t.splice(--n, 1, a.left, null, a.right) : t.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
        } else if (s > i * 2) {
          let a = t[r];
          a.break ? t.splice(r, 1, a.left, null, a.right) : t.splice(r, 1, a.left, a.right), r += 2 + a.break, s -= a.size;
        } else
          break;
      else if (i < s) {
        let a = t[n++];
        a && (i += a.size);
      } else {
        let a = t[--r];
        a && (s += a.size);
      }
    let o = 0;
    return t[n - 1] == null ? (o = 1, n--) : t[n] == null && (o = 1, r++), new gW(Qr.of(t.slice(0, n)), o, Qr.of(t.slice(r)));
  }
}
Qr.prototype.size = 1;
class pP extends Qr {
  constructor(t, n, r) {
    super(t, n), this.deco = r;
  }
  blockAt(t, n, r, i) {
    return new Hs(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(t, n, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(t, n, r, i, s, o) {
    t <= s + this.length && n >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(t, n = 0, r = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(t, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class fi extends pP {
  constructor(t, n) {
    super(t, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, n, r, i) {
    return new Hs(i, this.length, r, this.height, this.breaks);
  }
  replace(t, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof fi || i instanceof dr && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof dr ? i = new fi(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Qr.of(r);
  }
  updateHeight(t, n = 0, r = !1, i) {
    return i && i.from <= n && i.more ? this.setHeight(t, i.heights[i.index++]) : (r || this.outdated) && this.setHeight(t, Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class dr extends Qr {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, n) {
    let r = t.doc.lineAt(n).number, i = t.doc.lineAt(n + this.length).number, s = i - r + 1, o, a = 0;
    if (t.lineWrapping) {
      let l = Math.min(this.height, t.lineHeight * s);
      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: a };
  }
  blockAt(t, n, r, i) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let h = i + Math.round(Math.max(0, Math.min(1, (t - r) / this.height)) * this.length), u = n.doc.lineAt(h), f = a + u.length * l, d = Math.max(r, t - f / 2);
      return new Hs(u.from, u.length, d, f, 0);
    } else {
      let h = Math.max(0, Math.min(o - s, Math.floor((t - r) / a))), { from: u, length: f } = n.doc.line(s + h);
      return new Hs(u, f, r + a * h, a, 0);
    }
  }
  lineAt(t, n, r, i, s) {
    if (n == sn.ByHeight)
      return this.blockAt(t, r, i, s);
    if (n == sn.ByPosNoHeight) {
      let { from: p, to: g } = r.doc.lineAt(t);
      return new Hs(p, g - p, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, s), h = r.doc.lineAt(t), u = a + h.length * l, f = h.number - o, d = i + a * f + l * (h.from - s - f);
    return new Hs(h.from, h.length, Math.max(i, Math.min(d, i + this.height - u)), u, 0);
  }
  forEachLine(t, n, r, i, s, o) {
    t = Math.max(t, s), n = Math.min(n, s + this.length);
    let { firstLine: a, perLine: l, perChar: h } = this.heightMetrics(r, s);
    for (let u = t, f = i; u <= n; ) {
      let d = r.doc.lineAt(u);
      if (u == t) {
        let g = d.number - a;
        f += l * g + h * (t - s - g);
      }
      let p = l + h * d.length;
      o(new Hs(d.from, d.length, f, p, 0)), f += p, u = d.to + 1;
    }
  }
  replace(t, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof dr ? r[r.length - 1] = new dr(s.length + i) : r.push(null, new dr(i - 1));
    }
    if (t > 0) {
      let s = r[0];
      s instanceof dr ? r[0] = new dr(t + s.length) : r.unshift(new dr(t - 1), null);
    }
    return Qr.of(r);
  }
  decomposeLeft(t, n) {
    n.push(new dr(t - 1), null);
  }
  decomposeRight(t, n) {
    n.push(null, new dr(this.length - t - 1));
  }
  updateHeight(t, n = 0, r = !1, i) {
    let s = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let o = [], a = Math.max(n, i.from), l = -1;
      for (i.from > n && o.push(new dr(i.from - n - 1).updateHeight(t, n)); a <= s && i.more; ) {
        let u = t.doc.lineAt(a).length;
        o.length && o.push(null);
        let f = i.heights[i.index++];
        l == -1 ? l = f : Math.abs(f - l) >= $1 && (l = -2);
        let d = new fi(u, f);
        d.outdated = !1, o.push(d), a += u + 1;
      }
      a <= s && o.push(null, new dr(s - a).updateHeight(t, a));
      let h = Qr.of(o);
      return (l < 0 || Math.abs(h.height - this.height) >= $1 || Math.abs(l - this.heightMetrics(t, n).perLine) >= $1) && (t.heightChanged = !0), h;
    } else
      (r || this.outdated) && (this.setHeight(t, t.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class gW extends Qr {
  constructor(t, n, r) {
    super(t.length + n + r.length, t.height + r.height, n | (t.outdated || r.outdated ? 2 : 0)), this.left = t, this.right = r, this.size = t.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, n, r, i) {
    let s = r + this.left.height;
    return t < s ? this.left.blockAt(t, n, r, i) : this.right.blockAt(t, n, s, i + this.left.length + this.break);
  }
  lineAt(t, n, r, i, s) {
    let o = i + this.left.height, a = s + this.left.length + this.break, l = n == sn.ByHeight ? t < o : t < a, h = l ? this.left.lineAt(t, n, r, i, s) : this.right.lineAt(t, n, r, o, a);
    if (this.break || (l ? h.to < a : h.from > a))
      return h;
    let u = n == sn.ByPosNoHeight ? sn.ByPosNoHeight : sn.ByPos;
    return l ? h.join(this.right.lineAt(a, u, r, o, a)) : this.left.lineAt(a, u, r, i, s).join(h);
  }
  forEachLine(t, n, r, i, s, o) {
    let a = i + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      t < l && this.left.forEachLine(t, n, r, i, s, o), n >= l && this.right.forEachLine(t, n, r, a, l, o);
    else {
      let h = this.lineAt(l, sn.ByPos, r, i, s);
      t < h.from && this.left.forEachLine(t, h.from - 1, r, i, s, o), h.to >= t && h.from <= n && o(h), n > h.to && this.right.forEachLine(h.to + 1, n, r, a, l, o);
    }
  }
  replace(t, n, r) {
    let i = this.left.length + this.break;
    if (n < i)
      return this.balanced(this.left.replace(t, n, r), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - i, n - i, r));
    let s = [];
    t > 0 && this.decomposeLeft(t, s);
    let o = s.length;
    for (let a of r)
      s.push(a);
    if (t > 0 && $4(s, o - 1), n < this.length) {
      let a = s.length;
      this.decomposeRight(n, s), $4(s, a);
    }
    return Qr.of(s);
  }
  decomposeLeft(t, n) {
    let r = this.left.length;
    if (t <= r)
      return this.left.decomposeLeft(t, n);
    n.push(this.left), this.break && (r++, t >= r && n.push(null)), t > r && this.right.decomposeLeft(t - r, n);
  }
  decomposeRight(t, n) {
    let r = this.left.length, i = r + this.break;
    if (t >= i)
      return this.right.decomposeRight(t - i, n);
    t < r && this.left.decomposeRight(t, n), this.break && t < i && n.push(null), n.push(this.right);
  }
  balanced(t, n) {
    return t.size > 2 * n.size || n.size > 2 * t.size ? Qr.of(this.break ? [t, null, n] : [t, n]) : (this.left = t, this.right = n, this.height = t.height + n.height, this.outdated = t.outdated || n.outdated, this.size = t.size + n.size, this.length = t.length + this.break + n.length, this);
  }
  updateHeight(t, n = 0, r = !1, i) {
    let { left: s, right: o } = this, a = n + s.length + this.break, l = null;
    return i && i.from <= n + s.length && i.more ? l = s = s.updateHeight(t, n, r, i) : s.updateHeight(t, n, r), i && i.from <= a + o.length && i.more ? l = o = o.updateHeight(t, a, r, i) : o.updateHeight(t, a, r), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function $4(e, t) {
  let n, r;
  e[t] == null && (n = e[t - 1]) instanceof dr && (r = e[t + 1]) instanceof dr && e.splice(t - 1, 3, new dr(n.length + 1 + r.length));
}
const mW = 5;
class lw {
  constructor(t, n) {
    this.pos = t, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof fi ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new fi(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(t, n, r) {
    if (t < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = n - t;
      r.block ? this.addBlock(new pP(o, i, r)) : (o || s || i >= mW) && this.addLineDeco(i, s, o);
    } else
      n > t && this.span(t, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = n, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new fi(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, n) {
    let r = new dr(n - t);
    return this.oracle.doc.lineAt(t).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof fi)
      return t;
    let n = new fi(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(t) {
    this.enterLine();
    let n = t.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, n && n.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, n, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, t), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
  }
  finish(t) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof fi) && !this.isCovered ? this.nodes.push(new fi(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = t;
    for (let i of this.nodes)
      i instanceof fi && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  static build(t, n, r, i) {
    let s = new lw(r, t);
    return Ne.spans(n, r, i, s, 0), s.finish(r);
  }
}
function yW(e, t, n) {
  let r = new bW();
  return Ne.compare(e, t, n, r, 0), r.changes;
}
class bW {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, n, r, i) {
    (t < n || r && r.heightRelevant || i && i.heightRelevant) && lv(t, n, this.changes, 5);
  }
}
function OW(e, t) {
  let n = e.getBoundingClientRect(), r = e.ownerDocument, i = r.defaultView || window, s = Math.max(0, n.left), o = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(i.innerHeight, n.bottom);
  for (let h = e.parentNode; h && h != r.body; )
    if (h.nodeType == 1) {
      let u = h, f = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && f.overflow != "visible") {
        let d = u.getBoundingClientRect();
        s = Math.max(s, d.left), o = Math.min(o, d.right), a = Math.max(a, d.top), l = h == e.parentNode ? d.bottom : Math.min(l, d.bottom);
      }
      h = f.position == "absolute" || f.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
  return {
    left: s - n.left,
    right: Math.max(s, o) - n.left,
    top: a - (n.top + t),
    bottom: Math.max(a, l) - (n.top + t)
  };
}
function xW(e, t) {
  let n = e.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: t,
    bottom: n.bottom - (n.top + t)
  };
}
class kb {
  constructor(t, n, r) {
    this.from = t, this.to = n, this.size = r;
  }
  static same(t, n) {
    if (t.length != n.length)
      return !1;
    for (let r = 0; r < t.length; r++) {
      let i = t[r], s = n[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(t, n) {
    return Bt.replace({
      widget: new vW(this.size * (n ? t.scaleY : t.scaleX), n)
    }).range(this.from, this.to);
  }
}
class vW extends si {
  constructor(t, n) {
    super(), this.size = t, this.vertical = n;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class I4 {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = N4, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = yn.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = t.facet(ow).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new dW(n), this.stateDeco = t.facet(bd).filter((r) => typeof r != "function"), this.heightMap = Qr.empty().applyChanges(this.stateDeco, Be.empty, this.heightOracle.setDoc(t.doc), [new Zi(0, 0, 0, t.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Bt.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!t.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        t.push(new C0(s, o));
      }
    }
    this.viewports = t.sort((r, i) => r.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? N4 : new wW(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(this.scaler.scale == 1 ? t : Sf(t, this.scaler));
    });
  }
  update(t, n = null) {
    this.state = t.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(bd).filter((u) => typeof u != "function");
    let i = t.changedRanges, s = Zi.extendWithRanges(i, yW(r, this.stateDeco, t ? t.changes : $n.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (t.flags |= 2), a ? (this.scrollAnchorPos = t.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = s.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
    let h = !t.changes.empty || t.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), h && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(W9) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let n = t.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? yn.RTL : yn.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), a = n.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let h = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: w, scaleY: E } = C9(n, a);
      (this.scaleX != w || this.scaleY != E) && (this.scaleX = w, this.scaleY = E, h |= 8, o = l = !0);
    }
    let f = (parseInt(r.paddingTop) || 0) * this.scaleY, d = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != f || this.paddingBottom != d) && (this.paddingTop = f, this.paddingBottom = d, h |= 10), this.editorWidth != t.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, h |= 8);
    let p = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != p && (this.scrollAnchorHeight = -1, this.scrollTop = p), this.scrolledToBottom = A9(t.scrollDOM);
    let g = (this.printing ? xW : OW)(n, this.paddingTop), m = g.top - this.pixelViewport.top, y = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let O = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (O != this.inView && (this.inView = O, O && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let x = a.width;
    if ((this.contentDOMWidth != x || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = t.scrollDOM.clientHeight, h |= 8), l) {
      let w = t.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(w) && (o = !0), o || i.lineWrapping && Math.abs(x - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: E, charWidth: T, textHeight: S } = t.docView.measureTextSize();
        o = E > 0 && i.refresh(s, E, T, S, x / T, w), o && (t.docView.minWidth = 0, h |= 8);
      }
      m > 0 && y > 0 ? u = Math.max(m, y) : m < 0 && y < 0 && (u = Math.min(m, y)), i.heightChanged = !1;
      for (let E of this.viewports) {
        let T = E.from == this.viewport.from ? w : t.docView.measureVisibleLineHeights(E);
        this.heightMap = (o ? Qr.empty().applyChanges(this.stateDeco, Be.empty, this.heightOracle, [new Zi(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new pW(E.from, T));
      }
      i.heightChanged && (h |= 2);
    }
    let _ = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return _ && (this.viewport = this.getViewport(u, this.scrollTarget)), this.updateForViewport(), (h & 2 || _) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, t)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new C0(i.lineAt(o - r * 1e3, sn.ByHeight, s, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, sn.ByHeight, s, 0, 0).to);
    if (n) {
      let { head: h } = n.range;
      if (h < l.from || h > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = i.lineAt(h, sn.ByPos, s, 0, 0), d;
        n.y == "center" ? d = (f.top + f.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && h < l.from ? d = f.top : d = f.bottom - u, l = new C0(i.lineAt(d - 1e3 / 2, sn.ByHeight, s, 0, 0).from, i.lineAt(d + u + 1e3 / 2, sn.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(t, n) {
    let r = n.mapPos(t.from, -1), i = n.mapPos(t.to, 1);
    return new C0(this.heightMap.lineAt(r, sn.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, sn.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate({ from: t, to: n }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(t, sn.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(n, sn.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (t == 0 || i <= o - Math.max(10, Math.min(-r, 250))) && (n == this.state.doc.length || s >= a + Math.max(10, Math.min(r, 250))) && i > o - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(t, n) {
    if (!t.length || n.empty)
      return t;
    let r = [];
    for (let i of t)
      n.touchesRange(i.from, i.to) || r.push(new kb(n.mapPos(i.from), n.mapPos(i.to), i.size));
    return r;
  }
  ensureLineGaps(t, n) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != yn.LTR && !r)
      return [];
    let a = [], l = (h, u, f, d) => {
      if (u - h < s)
        return;
      let p = this.state.selection.main, g = [p.from];
      p.empty || g.push(p.to);
      for (let y of g)
        if (y > h && y < u) {
          l(h, y - 10, f, d), l(y + 10, u, f, d);
          return;
        }
      let m = kW(t, (y) => y.from >= f.from && y.to <= f.to && Math.abs(y.from - h) < s && Math.abs(y.to - u) < s && !g.some((O) => y.from < O && y.to > O));
      if (!m) {
        if (u < f.to && n && r && n.visibleRanges.some((y) => y.from <= u && y.to >= u)) {
          let y = n.moveToLineBoundary(mt.cursor(u), !1, !0).head;
          y > h && (u = y);
        }
        m = new kb(h, u, this.gapSize(f, h, u, d));
      }
      a.push(m);
    };
    for (let h of this.viewportLines) {
      if (h.length < o)
        continue;
      let u = _W(h.from, h.to, this.stateDeco);
      if (u.total < o)
        continue;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, d, p;
      if (r) {
        let g = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, y;
        if (f != null) {
          let O = E0(u, f), x = ((this.visibleBottom - this.visibleTop) / 2 + g) / h.height;
          m = O - x, y = O + x;
        } else
          m = (this.visibleTop - h.top - g) / h.height, y = (this.visibleBottom - h.top + g) / h.height;
        d = T0(u, m), p = T0(u, y);
      } else {
        let g = u.total * this.heightOracle.charWidth, m = i * this.heightOracle.charWidth, y, O;
        if (f != null) {
          let x = E0(u, f), _ = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + m) / g;
          y = x - _, O = x + _;
        } else
          y = (this.pixelViewport.left - m) / g, O = (this.pixelViewport.right + m) / g;
        d = T0(u, y), p = T0(u, O);
      }
      d > h.from && l(h.from, d, h, u), p < h.to && l(p, h.to, h, u);
    }
    return a;
  }
  gapSize(t, n, r, i) {
    let s = E0(i, r) - E0(i, n);
    return this.heightOracle.lineWrapping ? t.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(t) {
    kb.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = Bt.set(t.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let n = [];
    Ne.spans(t, this.viewport.from, this.viewport.to, {
      span(i, s) {
        n.push({ from: i, to: s });
      },
      point() {
      }
    }, 20);
    let r = n.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != n[s].from || i.to != n[s].to);
    return this.visibleRanges = n, r ? 4 : 0;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((n) => n.from <= t && n.to >= t) || Sf(this.heightMap.lineAt(t, sn.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return Sf(this.heightMap.lineAt(this.scaler.fromDOM(t), sn.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let n = this.lineBlockAtHeight(t + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return Sf(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class C0 {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
}
function _W(e, t, n) {
  let r = [], i = e, s = 0;
  return Ne.spans(n, e, t, {
    span() {
    },
    point(o, a) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = a;
    }
  }, 20), i < t && (r.push({ from: i, to: t }), s += t - i), { total: s, ranges: r };
}
function T0({ total: e, ranges: t }, n) {
  if (n <= 0)
    return t[0].from;
  if (n >= 1)
    return t[t.length - 1].to;
  let r = Math.floor(e * n);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = t[i], a = o - s;
    if (r <= a)
      return s + r;
    r -= a;
  }
}
function E0(e, t) {
  let n = 0;
  for (let { from: r, to: i } of e.ranges) {
    if (t <= i) {
      n += t - r;
      break;
    }
    n += i - r;
  }
  return n / e.total;
}
function kW(e, t) {
  for (let n of e)
    if (t(n))
      return n;
}
const N4 = {
  toDOM(e) {
    return e;
  },
  fromDOM(e) {
    return e;
  },
  scale: 1
};
class wW {
  constructor(t, n, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let h = n.lineAt(a, sn.ByPos, t, 0, 0).top, u = n.lineAt(l, sn.ByPos, t, 0, 0).bottom;
      return i += u - h, { from: a, to: l, top: h, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (n.height - i);
    for (let a of this.viewports)
      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(t) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || t < s.top)
        return i + (t - r) * this.scale;
      if (t <= s.bottom)
        return s.domTop + (t - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(t) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || t < s.domTop)
        return r + (t - i) / this.scale;
      if (t <= s.domBottom)
        return s.top + (t - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
}
function Sf(e, t) {
  if (t.scale == 1)
    return e;
  let n = t.toDOM(e.top), r = t.toDOM(e.bottom);
  return new Hs(e.from, e.length, n, r - n, Array.isArray(e._content) ? e._content.map((i) => Sf(i, t)) : e._content);
}
const A0 = /* @__PURE__ */ Ft.define({ combine: (e) => e.join(" ") }), mv = /* @__PURE__ */ Ft.define({ combine: (e) => e.indexOf(!0) > -1 }), yv = /* @__PURE__ */ sa.newName(), gP = /* @__PURE__ */ sa.newName(), mP = /* @__PURE__ */ sa.newName(), yP = { "&light": "." + gP, "&dark": "." + mP };
function bv(e, t, n) {
  return new sa(t, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return e;
        if (!n || !n[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return n[i];
      }) : e + " " + r;
    }
  });
}
const SW = /* @__PURE__ */ bv("." + yv, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, yP), Cf = "\uFFFF";
class CW {
  constructor(t, n) {
    this.points = t, this.text = "", this.lineSeparator = n.facet(De.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += Cf;
  }
  readRange(t, n) {
    if (!t)
      return this;
    let r = t.parentNode;
    for (let i = t; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == n)
        break;
      let a = an.get(i), l = an.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : B4(i)) || B4(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(t) {
    let n = t.nodeValue;
    for (let r of this.points)
      r.node == t && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, a;
      if (this.lineSeparator ? (s = n.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (a = i.exec(n)) && (s = a.index, o = a[0].length), this.append(n.slice(r, s < 0 ? n.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == t && l.pos > this.text.length && (l.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let n = an.get(t), r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(t, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, n) {
    for (let r of this.points)
      r.node == t && t.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(t, n) {
    for (let r of this.points)
      (t.nodeType == 3 ? r.node == t : t.contains(r.node)) && (r.pos = this.text.length + (TW(t, r.node, r.offset) ? n : 0));
  }
}
function TW(e, t, n) {
  for (; ; ) {
    if (!t || n < oa(t))
      return !1;
    if (t == e)
      return !0;
    n = yd(t) + 1, t = t.parentNode;
  }
}
function B4(e) {
  return e.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName);
}
class F4 {
  constructor(t, n) {
    this.node = t, this.offset = n, this.pos = -1;
  }
}
class EW {
  constructor(t, n, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = t.docView;
    if (t.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = t.docView.domBoundsAround(n, r, 0))) {
      let a = s || o ? [] : DW(t), l = new CW(a, t.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = LW(a, this.bounds.from);
    } else {
      let a = t.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !nv(t.contentDOM, a.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(a.focusNode, a.focusOffset), h = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !nv(t.contentDOM, a.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(a.anchorNode, a.anchorOffset);
      this.newSel = mt.single(h, l);
    }
  }
}
function bP(e, t) {
  let n, { newSel: r } = t, i = e.state.selection.main, s = e.inputState.lastKeyTime > Date.now() - 100 ? e.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: o, to: a } = t.bounds, l = i.from, h = null;
    (s === 8 || Wt.android && t.text.length < a - o) && (l = i.to, h = "end");
    let u = PW(e.state.doc.sliceString(o, a, Cf), t.text, l - o, h);
    u && (Wt.chrome && s == 13 && u.toB == u.from + 2 && t.text.slice(u.from, u.toB) == Cf + Cf && u.toB--, n = {
      from: o + u.from,
      to: o + u.toA,
      insert: Be.of(t.text.slice(u.from, u.toB).split(Cf))
    });
  } else
    r && (!e.hasFocus && e.state.facet(I2) || r.main.eq(i)) && (r = null);
  if (!n && !r)
    return !1;
  if (!n && t.typeOver && !i.empty && r && r.main.empty ? n = { from: i.from, to: i.to, insert: e.state.doc.slice(i.from, i.to) } : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
    from: i.from,
    to: i.to,
    insert: e.state.doc.slice(i.from, n.from).append(n.insert).append(e.state.doc.slice(n.to, i.to))
  } : (Wt.mac || Wt.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && e.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = mt.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: Be.of([" "]) }) : Wt.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && e.lineWrapping && (r && (r = mt.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: Be.of([" "]) }), n) {
    if (Wt.ios && e.inputState.flushIOSKey() || Wt.android && (n.from == i.from && n.to == i.to && n.insert.length == 1 && n.insert.lines == 2 && dh(e.contentDOM, "Enter", 13) || (n.from == i.from - 1 && n.to == i.to && n.insert.length == 0 || s == 8 && n.insert.length < n.to - n.from && n.to > i.head) && dh(e.contentDOM, "Backspace", 8) || n.from == i.from && n.to == i.to + 1 && n.insert.length == 0 && dh(e.contentDOM, "Delete", 46)))
      return !0;
    let o = n.insert.toString();
    e.inputState.composing >= 0 && e.inputState.composing++;
    let a, l = () => a || (a = AW(e, n, r));
    return e.state.facet(Y9).some((h) => h(e, n.from, n.to, o, l)) || e.dispatch(l()), !0;
  } else if (r && !r.main.eq(i)) {
    let o = !1, a = "select";
    return e.inputState.lastSelectionTime > Date.now() - 50 && (e.inputState.lastSelectionOrigin == "select" && (o = !0), a = e.inputState.lastSelectionOrigin), e.dispatch({ selection: r, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function AW(e, t, n) {
  let r, i = e.state, s = i.selection.main;
  if (t.from >= s.from && t.to <= s.to && t.to - t.from >= (s.to - s.from) / 3 && (!n || n.main.empty && n.main.from == t.from + t.insert.length) && e.inputState.composing < 0) {
    let a = s.from < t.from ? i.sliceDoc(s.from, t.from) : "", l = s.to > t.to ? i.sliceDoc(t.to, s.to) : "";
    r = i.replaceSelection(e.state.toText(a + t.insert.sliceString(0, void 0, e.state.lineBreak) + l));
  } else {
    let a = i.changes(t), l = n && n.main.to <= a.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && e.inputState.composing >= 0 && t.to <= s.to && t.to >= s.to - 10) {
      let h = e.state.sliceDoc(t.from, t.to), u, f = n && nP(e, n.main.head);
      if (f) {
        let g = t.insert.length - (t.to - t.from);
        u = { from: f.from, to: f.to - g };
      } else
        u = e.state.doc.lineAt(s.head);
      let d = s.to - t.to, p = s.to - s.from;
      r = i.changeByRange((g) => {
        if (g.from == s.from && g.to == s.to)
          return { changes: a, range: l || g.map(a) };
        let m = g.to - d, y = m - h.length;
        if (g.to - g.from != p || e.state.sliceDoc(y, m) != h || g.to >= u.from && g.from <= u.to)
          return { range: g };
        let O = i.changes({ from: y, to: m, insert: t.insert }), x = g.to - s.to;
        return {
          changes: O,
          range: l ? mt.range(Math.max(0, l.anchor + x), Math.max(0, l.head + x)) : g.map(O)
        };
      });
    } else
      r = {
        changes: a,
        selection: l && i.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (e.composing || e.inputState.compositionPendingChange && e.inputState.compositionEndedAt > Date.now() - 50) && (e.inputState.compositionPendingChange = !1, o += ".compose", e.inputState.compositionFirstChange && (o += ".start", e.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: o, scrollIntoView: !0 });
}
function PW(e, t, n, r) {
  let i = Math.min(e.length, t.length), s = 0;
  for (; s < i && e.charCodeAt(s) == t.charCodeAt(s); )
    s++;
  if (s == i && e.length == t.length)
    return null;
  let o = e.length, a = t.length;
  for (; o > 0 && a > 0 && e.charCodeAt(o - 1) == t.charCodeAt(a - 1); )
    o--, a--;
  if (r == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    n -= o + l - s;
  }
  if (o < s && e.length < t.length) {
    let l = n <= s && n >= o ? s - n : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = n <= s && n >= a ? s - n : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { from: s, toA: o, toB: a };
}
function DW(e) {
  let t = [];
  if (e.root.activeElement != e.contentDOM)
    return t;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s } = e.observer.selectionRange;
  return n && (t.push(new F4(n, r)), (i != n || s != r) && t.push(new F4(i, s))), t;
}
function LW(e, t) {
  if (e.length == 0)
    return null;
  let n = e[0].pos, r = e.length == 2 ? e[1].pos : n;
  return n > -1 && r > -1 ? mt.single(n + t, r + t) : null;
}
const MW = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, wb = Wt.ie && Wt.ie_version <= 11;
class RW {
  constructor(t) {
    this.view = t, this.active = !1, this.selectionRange = new yq(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (Wt.ie && Wt.ie_version <= 11 || Wt.ios && t.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), wb && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((n, r) => n != t[r]))) {
      this.gapIntersection.disconnect();
      for (let n of t)
        this.gapIntersection.observe(n);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(I2) ? r.root.activeElement != this.dom : !M1(r.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(t)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (Wt.ie && Wt.ie_version <= 11 || Wt.android && Wt.chrome) && !r.state.selection.main.empty && i.focusNode && Ag(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, n = Wt.safari && t.root.nodeType == 11 && dq(this.dom.ownerDocument) == this.dom && $W(this.view) || Eg(t.root);
    if (!n || this.selectionRange.eq(n))
      return !1;
    let r = M1(this.dom, n);
    return r && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && Oq(this.dom, n) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(n), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, n) {
    this.selectionRange.set(t.node, t.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && t < this.scrollTargets.length && this.scrollTargets[t] == r ? t++ : n || (n = this.scrollTargets.slice(0, t)), n && n.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (t < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, t)), n) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = n)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, MW), wb && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    !this.active || (this.active = !1, this.observer.disconnect(), wb && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  delayAndroidKey(t, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && dh(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: n,
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let n = -1, r = -1, i = !1;
    for (let s of t) {
      let o = this.readMutation(s);
      !o || (o.typeOver && (i = !0), n == -1 ? { from: n, to: r } = o : (n = Math.min(o.from, n), r = Math.max(o.to, r)));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: t, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && M1(this.dom, this.selectionRange);
    if (t < 0 && !i)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new EW(this.view, t, n, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = bP(this.view, n);
    return this.view.state == r && this.view.update([]), i;
  }
  readMutation(t) {
    let n = this.view.docView.nearest(t.target);
    if (!n || n.ignoreMutation(t))
      return null;
    if (n.markDirty(t.type == "attributes"), t.type == "attributes" && (n.flags |= 4), t.type == "childList") {
      let r = Q4(n, t.previousSibling || t.target.previousSibling, -1), i = Q4(n, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: r ? n.posAfter(r) : n.posAtStart,
        to: i ? n.posBefore(i) : n.posAtEnd,
        typeOver: !1
      };
    } else
      return t.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var t, n, r;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function Q4(e, t, n) {
  for (; t; ) {
    let r = an.get(t);
    if (r && r.parent == e)
      return r;
    let i = t.parentNode;
    t = i != e.dom ? i : n > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
function $W(e) {
  let t = null;
  function n(l) {
    l.preventDefault(), l.stopImmediatePropagation(), t = l.getTargetRanges()[0];
  }
  if (e.contentDOM.addEventListener("beforeinput", n, !0), e.dom.ownerDocument.execCommand("indent"), e.contentDOM.removeEventListener("beforeinput", n, !0), !t)
    return null;
  let r = t.startContainer, i = t.startOffset, s = t.endContainer, o = t.endOffset, a = e.docView.domAtPos(e.state.selection.main.anchor);
  return Ag(a.node, a.offset, s, o) && ([r, i, s, o] = [s, o, r, i]), { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o };
}
class Pt {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(t = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: n } = t;
    this.dispatchTransactions = t.dispatchTransactions || n && ((r) => r.forEach((i) => n(i, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = t.root || bq(t.parent) || document, this.viewState = new I4(t.state || De.create(t)), t.scrollTo && t.scrollTo.is(k0) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(kf).map((r) => new xb(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new RW(this), this.inputState = new Gq(this), this.inputState.ensureHandlers(this.plugins), this.docView = new b4(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...t) {
    let n = t.length == 1 && t[0] instanceof Zn ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(n, this);
  }
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, r = !1, i, s = this.state;
    for (let d of t) {
      if (d.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    t.some((d) => d.annotation(uP)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = fP(s, o), l || (a = 1));
    let h = this.observer.delayedAndroidKey, u = null;
    if (h ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(De.phrases) != this.state.facet(De.phrases))
      return this.setState(s);
    i = Pg.create(this, s, t), i.flags |= a;
    let f = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of t) {
        if (f && (f = f.map(d.changes)), d.scrollIntoView) {
          let { main: p } = d.state.selection;
          f = new ph(p.empty ? p : mt.cursor(p.head, p.head > p.anchor ? -1 : 1));
        }
        for (let p of d.effects)
          p.is(k0) && (f = p.value.clip(this.state));
      }
      this.viewState.update(i, f), this.bidiCache = Dg.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(wf) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(n, t.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(A0) != i.state.facet(A0) && (this.viewState.mustMeasureContent = !0), (n || r || f || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let d of this.state.facet(cv))
        try {
          d(i);
        } catch (p) {
          Qi(this.state, p, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !bP(this, u) && h.force && dh(this.contentDOM, h.key, h.keyCode);
    });
  }
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new I4(t), this.plugins = t.facet(kf).map((r) => new xb(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new b4(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let n = t.startState.facet(kf), r = t.state.facet(kf);
    if (n != r) {
      let i = [];
      for (let s of r) {
        let o = n.indexOf(s);
        if (o < 0)
          i.push(new xb(s));
        else {
          let a = this.plugins[o];
          a.mustUpdate = t, i.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != t && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = t;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (A9(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let p = this.viewState.scrollAnchorAt(i);
            s = p.from, o = p.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        l & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let u = h.map((p) => {
          try {
            return p.read(this);
          } catch (g) {
            return Qi(this.state, g), Z4;
          }
        }), f = Pg.create(this, this.state, []), d = !1;
        f.flags |= l, n ? n.flags |= l : n = f, this.updateState = 2, f.empty || (this.updatePlugins(f), this.inputState.update(f), this.updateAttrs(), d = this.docView.update(f));
        for (let p = 0; p < h.length; p++)
          if (u[p] != Z4)
            try {
              let g = h[p];
              g.write && g.write(u[p], this);
            } catch (g) {
              Qi(this.state, g);
            }
        if (d && this.docView.updateSelection(!0), !f.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let g = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (g > 1 || g < -1) {
                i = i + g, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let a of this.state.facet(cv))
        a(n);
  }
  get themeClasses() {
    return yv + " " + (this.state.facet(mv) ? mP : gP) + " " + this.state.facet(A0);
  }
  updateAttrs() {
    let t = V4(this, U9, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(I2) ? "true" : "false",
      class: "cm-content",
      style: `${Wt.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), V4(this, ow, n);
    let r = this.observer.ignore(() => {
      let i = av(this.contentDOM, this.contentAttrs, n), s = av(this.dom, this.editorAttrs, t);
      return i || s;
    });
    return this.editorAttrs = t, this.contentAttrs = n, r;
  }
  showAnnouncements(t) {
    let n = !0;
    for (let r of t)
      for (let i of r.effects)
        if (i.is(Pt.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(wf);
    let t = this.state.facet(Pt.cspNonce);
    sa.mount(this.root, this.styleModules.concat(SW).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === t.key) {
            this.measureRequests[n] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  plugin(t) {
    let n = this.pluginMap.get(t);
    return (n === void 0 || n && n.spec != t) && this.pluginMap.set(t, n = this.plugins.find((r) => r.spec == t) || null), n && n.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(t, n, r) {
    return _b(this, t, w4(this, t, n, r));
  }
  moveByGroup(t, n) {
    return _b(this, t, w4(this, t, n, (r) => jq(this, t.head, r)));
  }
  moveToLineBoundary(t, n, r = !0) {
    return Uq(this, t, n, r);
  }
  moveVertically(t, n, r) {
    return _b(this, t, Xq(this, t, n, r));
  }
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  posAtDOM(t, n = 0) {
    return this.docView.posFromDOM(t, n);
  }
  posAtCoords(t, n = !0) {
    return this.readMeasured(), iP(this, t, n);
  }
  coordsAtPos(t, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(t, n);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(t), s = this.bidiSpans(i), o = s[Na.find(s, t - i.from, -1, n)];
    return rw(r, o.dir == yn.LTR == n > 0);
  }
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(t) {
    return !this.state.facet(q9) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(t) {
    if (t.length > IW)
      return tP(t.length);
    let n = this.textDirectionAt(t.from), r;
    for (let s of this.bidiCache)
      if (s.from == t.from && s.dir == n && (s.fresh || J9(s.isolates, r = y4(this, t.from, t.to))))
        return s.order;
    r || (r = y4(this, t.from, t.to));
    let i = Mq(t.text, n, r);
    return this.bidiCache.push(new Dg(t.from, t.to, n, r, !0, i)), i;
  }
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || Wt.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      T9(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  static scrollIntoView(t, n = {}) {
    return k0.of(new ph(typeof t == "number" ? mt.cursor(t) : t, n.y, n.x, n.yMargin, n.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(t);
    return k0.of(new ph(mt.cursor(r.from), "start", "start", r.top - t, n, !0));
  }
  static domEventHandlers(t) {
    return He.define(() => ({}), { eventHandlers: t });
  }
  static domEventObservers(t) {
    return He.define(() => ({}), { eventObservers: t });
  }
  static theme(t, n) {
    let r = sa.newName(), i = [A0.of(r), wf.of(bv(`.${r}`, t))];
    return n && n.dark && i.push(mv.of(!0)), i;
  }
  static baseTheme(t) {
    return Ts.lowest(wf.of(bv("." + yv, t, yP)));
  }
  static findFromDOM(t) {
    var n;
    let r = t.querySelector(".cm-content"), i = r && an.get(r) || an.get(t);
    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
Pt.styleModule = wf;
Pt.inputHandler = Y9;
Pt.focusChangeEffect = z9;
Pt.perLineTextDirection = q9;
Pt.exceptionSink = V9;
Pt.updateListener = cv;
Pt.editable = I2;
Pt.mouseSelectionStyle = Z9;
Pt.dragMovesSelection = Q9;
Pt.clickAddsSelectionRange = F9;
Pt.decorations = bd;
Pt.atomicRanges = aw;
Pt.bidiIsolatedRanges = j9;
Pt.scrollMargins = X9;
Pt.darkTheme = mv;
Pt.cspNonce = /* @__PURE__ */ Ft.define({ combine: (e) => e.length ? e[0] : "" });
Pt.contentAttributes = ow;
Pt.editorAttributes = U9;
Pt.lineWrapping = /* @__PURE__ */ Pt.contentAttributes.of({ class: "cm-lineWrapping" });
Pt.announce = /* @__PURE__ */ le.define();
const IW = 4096, Z4 = {};
class Dg {
  constructor(t, n, r, i, s, o) {
    this.from = t, this.to = n, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(t, n) {
    if (n.empty && !t.some((s) => s.fresh))
      return t;
    let r = [], i = t.length ? t[t.length - 1].dir : yn.LTR;
    for (let s = Math.max(0, t.length - 10); s < t.length; s++) {
      let o = t[s];
      o.dir == i && !n.touchesRange(o.from, o.to) && r.push(new Dg(n.mapPos(o.from, 1), n.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function V4(e, t, n) {
  for (let r = e.state.facet(t), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(e) : s;
    o && ov(o, n);
  }
  return n;
}
const NW = Wt.mac ? "mac" : Wt.windows ? "win" : Wt.linux ? "linux" : "key";
function BW(e, t) {
  const n = e.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, a;
  for (let l = 0; l < n.length - 1; ++l) {
    const h = n[l];
    if (/^(cmd|meta|m)$/i.test(h))
      a = !0;
    else if (/^a(lt)?$/i.test(h))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(h))
      s = !0;
    else if (/^s(hift)?$/i.test(h))
      o = !0;
    else if (/^mod$/i.test(h))
      t == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + h);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), a && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function P0(e, t, n) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n !== !1 && t.shiftKey && (e = "Shift-" + e), e;
}
const FW = /* @__PURE__ */ Ts.default(/* @__PURE__ */ Pt.domEventHandlers({
  keydown(e, t) {
    return xP(OP(t.state), e, t, "editor");
  }
})), Ko = /* @__PURE__ */ Ft.define({ enables: FW }), Y4 = /* @__PURE__ */ new WeakMap();
function OP(e) {
  let t = e.facet(Ko), n = Y4.get(t);
  return n || Y4.set(t, n = VW(t.reduce((r, i) => r.concat(i), []))), n;
}
function QW(e, t, n) {
  return xP(OP(e.state), t, e, n);
}
let Pa = null;
const ZW = 4e3;
function VW(e, t = NW) {
  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, a) => {
    let l = r[o];
    if (l == null)
      r[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, a, l, h, u) => {
    var f, d;
    let p = n[o] || (n[o] = /* @__PURE__ */ Object.create(null)), g = a.split(/ (?!$)/).map((O) => BW(O, t));
    for (let O = 1; O < g.length; O++) {
      let x = g.slice(0, O).join(" ");
      i(x, !0), p[x] || (p[x] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(_) => {
          let w = Pa = { view: _, prefix: x, scope: o };
          return setTimeout(() => {
            Pa == w && (Pa = null);
          }, ZW), !0;
        }]
      });
    }
    let m = g.join(" ");
    i(m, !1);
    let y = p[m] || (p[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (f = p._any) === null || f === void 0 ? void 0 : f.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && y.run.push(l), h && (y.preventDefault = !0), u && (y.stopPropagation = !0);
  };
  for (let o of e) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let h of a) {
        let u = n[h] || (n[h] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let f in u)
          u[f].run.push(o.any);
      }
    let l = o[t] || o.key;
    if (!!l)
      for (let h of a)
        s(h, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(h, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return n;
}
function xP(e, t, n, r) {
  let i = fq(t), s = pr(i, 0), o = Mi(s) == i.length && i != " ", a = "", l = !1, h = !1, u = !1;
  Pa && Pa.view == n && Pa.scope == r && (a = Pa.prefix + " ", oP.indexOf(t.keyCode) < 0 && (h = !0, Pa = null));
  let f = /* @__PURE__ */ new Set(), d = (y) => {
    if (y) {
      for (let O of y.run)
        if (!f.has(O) && (f.add(O), O(n, t)))
          return y.stopPropagation && (u = !0), !0;
      y.preventDefault && (y.stopPropagation && (u = !0), h = !0);
    }
    return !1;
  }, p = e[r], g, m;
  return p && (d(p[a + P0(i, t, !o)]) ? l = !0 : o && (t.altKey || t.metaKey || t.ctrlKey) && !(Wt.windows && t.ctrlKey && t.altKey) && (g = Ja[t.keyCode]) && g != i ? (d(p[a + P0(g, t, !0)]) || t.shiftKey && (m = gd[t.keyCode]) != i && m != g && d(p[a + P0(m, t, !1)])) && (l = !0) : o && t.shiftKey && d(p[a + P0(i, t, !0)]) && (l = !0), !l && d(p._any) && (l = !0)), h && (l = !0), l && u && t.stopPropagation(), l;
}
class $p {
  constructor(t, n, r, i, s) {
    this.className = t, this.left = n, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let t = document.createElement("div");
    return t.className = this.className, this.adjust(t), t;
  }
  update(t, n) {
    return n.className != this.className ? !1 : (this.adjust(t), !0);
  }
  adjust(t) {
    t.style.left = this.left + "px", t.style.top = this.top + "px", this.width != null && (t.style.width = this.width + "px"), t.style.height = this.height + "px";
  }
  eq(t) {
    return this.left == t.left && this.top == t.top && this.width == t.width && this.height == t.height && this.className == t.className;
  }
  static forRange(t, n, r) {
    if (r.empty) {
      let i = t.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = vP(t);
      return [new $p(n, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return YW(t, n, r);
  }
}
function vP(e) {
  let t = e.scrollDOM.getBoundingClientRect();
  return { left: (e.textDirection == yn.LTR ? t.left : t.right - e.scrollDOM.clientWidth * e.scaleX) - e.scrollDOM.scrollLeft * e.scaleX, top: t.top - e.scrollDOM.scrollTop * e.scaleY };
}
function z4(e, t, n) {
  let r = mt.cursor(t);
  return {
    from: Math.max(n.from, e.moveToLineBoundary(r, !1, !0).from),
    to: Math.min(n.to, e.moveToLineBoundary(r, !0, !0).from),
    type: Fr.Text
  };
}
function YW(e, t, n) {
  if (n.to <= e.viewport.from || n.from >= e.viewport.to)
    return [];
  let r = Math.max(n.from, e.viewport.from), i = Math.min(n.to, e.viewport.to), s = e.textDirection == yn.LTR, o = e.contentDOM, a = o.getBoundingClientRect(), l = vP(e), h = o.querySelector(".cm-line"), u = h && window.getComputedStyle(h), f = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), d = a.right - (u ? parseInt(u.paddingRight) : 0), p = pv(e, r), g = pv(e, i), m = p.type == Fr.Text ? p : null, y = g.type == Fr.Text ? g : null;
  if (m && (e.lineWrapping || p.widgetLineBreaks) && (m = z4(e, r, m)), y && (e.lineWrapping || g.widgetLineBreaks) && (y = z4(e, i, y)), m && y && m.from == y.from)
    return x(_(n.from, n.to, m));
  {
    let E = m ? _(n.from, null, m) : w(p, !1), T = y ? _(null, n.to, y) : w(g, !0), S = [];
    return (m || p).to < (y || g).from - (m && y ? 1 : 0) || p.widgetLineBreaks > 1 && E.bottom + e.defaultLineHeight / 2 < T.top ? S.push(O(f, E.bottom, d, T.top)) : E.bottom < T.top && e.elementAtHeight((E.bottom + T.top) / 2).type == Fr.Text && (E.bottom = T.top = (E.bottom + T.top) / 2), x(E).concat(S).concat(x(T));
  }
  function O(E, T, S, R) {
    return new $p(t, E - l.left, T - l.top - 0.01, S - E, R - T + 0.01);
  }
  function x({ top: E, bottom: T, horizontal: S }) {
    let R = [];
    for (let A = 0; A < S.length; A += 2)
      R.push(O(S[A], E, S[A + 1], T));
    return R;
  }
  function _(E, T, S) {
    let R = 1e9, A = -1e9, P = [];
    function C(b, M, v, N, tt) {
      let Z = e.coordsAtPos(b, b == S.to ? -2 : 2), z = e.coordsAtPos(v, v == S.from ? 2 : -2);
      !Z || !z || (R = Math.min(Z.top, z.top, R), A = Math.max(Z.bottom, z.bottom, A), tt == yn.LTR ? P.push(s && M ? f : Z.left, s && N ? d : z.right) : P.push(!s && N ? f : z.left, !s && M ? d : Z.right));
    }
    let k = E != null ? E : S.from, D = T != null ? T : S.to;
    for (let b of e.visibleRanges)
      if (b.to > k && b.from < D)
        for (let M = Math.max(b.from, k), v = Math.min(b.to, D); ; ) {
          let N = e.state.doc.lineAt(M);
          for (let tt of e.bidiSpans(N)) {
            let Z = tt.from + N.from, z = tt.to + N.from;
            if (Z >= v)
              break;
            z > M && C(Math.max(Z, M), E == null && Z <= k, Math.min(z, v), T == null && z >= D, tt.dir);
          }
          if (M = N.to + 1, M >= v)
            break;
        }
    return P.length == 0 && C(k, E == null, D, T == null, e.textDirection), { top: R, bottom: A, horizontal: P };
  }
  function w(E, T) {
    let S = a.top + (T ? E.top : E.bottom);
    return { top: S, bottom: S, horizontal: [] };
  }
}
function zW(e, t) {
  return e.constructor == t.constructor && e.eq(t);
}
class qW {
  constructor(t, n) {
    this.view = t, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = t.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(t.state), t.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, t);
  }
  update(t) {
    t.startState.facet(I1) != t.state.facet(I1) && this.setOrder(t.state), (this.layer.update(t, this.dom) || t.geometryChanged) && (this.scale(), t.view.requestMeasure(this.measureReq));
  }
  setOrder(t) {
    let n = 0, r = t.facet(I1);
    for (; n < r.length && r[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: t, scaleY: n } = this.view;
    (t != this.scaleX || n != this.scaleY) && (this.scaleX = t, this.scaleY = n, this.dom.style.transform = `scale(${1 / t}, ${1 / n})`);
  }
  draw(t) {
    if (t.length != this.drawn.length || t.some((n, r) => !zW(n, this.drawn[r]))) {
      let n = this.dom.firstChild, r = 0;
      for (let i of t)
        i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), n = i;
      }
      this.drawn = t;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const I1 = /* @__PURE__ */ Ft.define();
function _P(e) {
  return [
    He.define((t) => new qW(t, e)),
    I1.of(e)
  ];
}
const kP = !Wt.ios, xd = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (t, n) => Math.min(t, n),
      drawRangeCursor: (t, n) => t || n
    });
  }
});
function wP(e = {}) {
  return [
    xd.of(e),
    WW,
    UW,
    jW,
    W9.of(!0)
  ];
}
function SP(e) {
  return e.startState.facet(xd) != e.state.facet(xd);
}
const WW = /* @__PURE__ */ _P({
  above: !0,
  markers(e) {
    let { state: t } = e, n = t.facet(xd), r = [];
    for (let i of t.selection.ranges) {
      let s = i == t.selection.main;
      if (i.empty ? !s || kP : n.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : mt.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of $p.forRange(e, o, a))
          r.push(l);
      }
    }
    return r;
  },
  update(e, t) {
    e.transactions.some((r) => r.selection) && (t.style.animationName = t.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = SP(e);
    return n && q4(e.state, t), e.docChanged || e.selectionSet || n;
  },
  mount(e, t) {
    q4(t.state, e);
  },
  class: "cm-cursorLayer"
});
function q4(e, t) {
  t.style.animationDuration = e.facet(xd).cursorBlinkRate + "ms";
}
const UW = /* @__PURE__ */ _P({
  above: !1,
  markers(e) {
    return e.state.selection.ranges.map((t) => t.empty ? [] : $p.forRange(e, "cm-selectionBackground", t)).reduce((t, n) => t.concat(n));
  },
  update(e, t) {
    return e.docChanged || e.selectionSet || e.viewportChanged || SP(e);
  },
  class: "cm-selectionLayer"
}), Ov = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
kP && (Ov[".cm-line"].caretColor = "transparent !important", Ov[".cm-content"] = { caretColor: "transparent !important" });
const jW = /* @__PURE__ */ Ts.highest(/* @__PURE__ */ Pt.theme(Ov)), CP = /* @__PURE__ */ le.define({
  map(e, t) {
    return e == null ? null : t.mapPos(e);
  }
}), Tf = /* @__PURE__ */ bn.define({
  create() {
    return null;
  },
  update(e, t) {
    return e != null && (e = t.changes.mapPos(e)), t.effects.reduce((n, r) => r.is(CP) ? r.value : n, e);
  }
}), XW = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.view = e, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(e) {
    var t;
    let n = e.state.field(Tf);
    n == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (e.startState.field(Tf) != n || e.docChanged || e.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: e } = this, t = e.state.field(Tf), n = t != null && e.coordsAtPos(t);
    if (!n)
      return null;
    let r = e.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - r.left + e.scrollDOM.scrollLeft * e.scaleX,
      top: n.top - r.top + e.scrollDOM.scrollTop * e.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(e) {
    if (this.cursor) {
      let { scaleX: t, scaleY: n } = this.view;
      e ? (this.cursor.style.left = e.left / t + "px", this.cursor.style.top = e.top / n + "px", this.cursor.style.height = e.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(e) {
    this.view.state.field(Tf) != e && this.view.dispatch({ effects: CP.of(e) });
  }
}, {
  eventObservers: {
    dragover(e) {
      this.setDropPos(this.view.posAtCoords({ x: e.clientX, y: e.clientY }));
    },
    dragleave(e) {
      (e.target == this.view.contentDOM || !this.view.contentDOM.contains(e.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function GW() {
  return [Tf, XW];
}
function W4(e, t, n, r, i) {
  t.lastIndex = 0;
  for (let s = e.iterRange(n, r), o = n, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; a = t.exec(s.value); )
        i(o + a.index, a);
}
function HW(e, t) {
  let n = e.visibleRanges;
  if (n.length == 1 && n[0].from == e.viewport.from && n[0].to == e.viewport.to)
    return n;
  let r = [];
  for (let { from: i, to: s } of n)
    i = Math.max(e.state.doc.lineAt(i).from, i - t), s = Math.min(e.state.doc.lineAt(s).to, s + t), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class KW {
  constructor(t) {
    const { regexp: n, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = t;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, i)
      this.addMatch = (a, l, h, u) => i(u, h, h + a[0].length, a, l);
    else if (typeof r == "function")
      this.addMatch = (a, l, h, u) => {
        let f = r(a, l, h);
        f && u(h, h + a[0].length, f);
      };
    else if (r)
      this.addMatch = (a, l, h, u) => u(h, h + a[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  createDeco(t) {
    let n = new cr(), r = n.add.bind(n);
    for (let { from: i, to: s } of HW(t, this.maxLength))
      W4(t.state.doc, this.regexp, i, s, (o, a) => this.addMatch(a, t, o, r));
    return n.finish();
  }
  updateDeco(t, n) {
    let r = 1e9, i = -1;
    return t.docChanged && t.changes.iterChanges((s, o, a, l) => {
      l > t.view.viewport.from && a < t.view.viewport.to && (r = Math.min(a, r), i = Math.max(l, i));
    }), t.viewportChanged || i - r > 1e3 ? this.createDeco(t.view) : i > -1 ? this.updateRange(t.view, n.map(t.changes), r, i) : n;
  }
  updateRange(t, n, r, i) {
    for (let s of t.visibleRanges) {
      let o = Math.max(s.from, r), a = Math.min(s.to, i);
      if (a > o) {
        let l = t.state.doc.lineAt(o), h = l.to < a ? t.state.doc.lineAt(a) : l, u = Math.max(s.from, l.from), f = Math.min(s.to, h.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o;
              break;
            }
          for (; a < h.to; a++)
            if (this.boundary.test(h.text[a - h.from])) {
              f = a;
              break;
            }
        }
        let d = [], p, g = (m, y, O) => d.push(O.range(m, y));
        if (l == h)
          for (this.regexp.lastIndex = u - l.from; (p = this.regexp.exec(l.text)) && p.index < f - l.from; )
            this.addMatch(p, t, p.index + l.from, g);
        else
          W4(t.state.doc, this.regexp, u, f, (m, y) => this.addMatch(y, t, m, g));
        n = n.update({ filterFrom: u, filterTo: f, filter: (m, y) => m < u || y > f, add: d });
      }
    }
    return n;
  }
}
const xv = /x/.unicode != null ? "gu" : "g", JW = /* @__PURE__ */ new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, xv), tU = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Sb = null;
function eU() {
  var e;
  if (Sb == null && typeof document < "u" && document.body) {
    let t = document.body.style;
    Sb = ((e = t.tabSize) !== null && e !== void 0 ? e : t.MozTabSize) != null;
  }
  return Sb || !1;
}
const N1 = /* @__PURE__ */ Ft.define({
  combine(e) {
    let t = Oo(e, {
      render: null,
      specialChars: JW,
      addSpecialChars: null
    });
    return (t.replaceTabs = !eU()) && (t.specialChars = new RegExp("	|" + t.specialChars.source, xv)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, xv)), t;
  }
});
function TP(e = {}) {
  return [N1.of(e), nU()];
}
let U4 = null;
function nU() {
  return U4 || (U4 = He.fromClass(class {
    constructor(e) {
      this.view = e, this.decorations = Bt.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(e.state.facet(N1)), this.decorations = this.decorator.createDeco(e);
    }
    makeDecorator(e) {
      return new KW({
        regexp: e.specialChars,
        decoration: (t, n, r) => {
          let { doc: i } = n.state, s = pr(t[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), a = n.state.tabSize, l = Os(o.text, a, r - o.from);
            return Bt.replace({
              widget: new oU((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = Bt.replace({ widget: new sU(e, s) }));
        },
        boundary: e.replaceTabs ? void 0 : /[^]/
      });
    }
    update(e) {
      let t = e.state.facet(N1);
      e.startState.facet(N1) != t ? (this.decorator = this.makeDecorator(t), this.decorations = this.decorator.createDeco(e.view)) : this.decorations = this.decorator.updateDeco(e, this.decorations);
    }
  }, {
    decorations: (e) => e.decorations
  }));
}
const rU = "\u2022";
function iU(e) {
  return e >= 32 ? rU : e == 10 ? "\u2424" : String.fromCharCode(9216 + e);
}
class sU extends si {
  constructor(t, n) {
    super(), this.options = t, this.code = n;
  }
  eq(t) {
    return t.code == this.code;
  }
  toDOM(t) {
    let n = iU(this.code), r = t.state.phrase("Control character") + " " + (tU[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = n, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class oU extends si {
  constructor(t) {
    super(), this.width = t;
  }
  eq(t) {
    return t.width == this.width;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.textContent = "	", t.className = "cm-tab", t.style.width = this.width + "px", t;
  }
  ignoreEvent() {
    return !1;
  }
}
function EP() {
  return lU;
}
const aU = /* @__PURE__ */ Bt.line({ class: "cm-activeLine" }), lU = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.decorations = this.getDeco(e);
  }
  update(e) {
    (e.docChanged || e.selectionSet) && (this.decorations = this.getDeco(e.view));
  }
  getDeco(e) {
    let t = -1, n = [];
    for (let r of e.state.selection.ranges) {
      let i = e.lineBlockAt(r.head);
      i.from > t && (n.push(aU.range(i.from)), t = i.from);
    }
    return Bt.set(n);
  }
}, {
  decorations: (e) => e.decorations
}), vv = 2e3;
function cU(e, t, n) {
  let r = Math.min(t.line, n.line), i = Math.max(t.line, n.line), s = [];
  if (t.off > vv || n.off > vv || t.col < 0 || n.col < 0) {
    let o = Math.min(t.off, n.off), a = Math.max(t.off, n.off);
    for (let l = r; l <= i; l++) {
      let h = e.doc.line(l);
      h.length <= a && s.push(mt.range(h.from + o, h.to + a));
    }
  } else {
    let o = Math.min(t.col, n.col), a = Math.max(t.col, n.col);
    for (let l = r; l <= i; l++) {
      let h = e.doc.line(l), u = Jx(h.text, o, e.tabSize, !0);
      if (u < 0)
        s.push(mt.cursor(h.to));
      else {
        let f = Jx(h.text, a, e.tabSize);
        s.push(mt.range(h.from + u, h.from + f));
      }
    }
  }
  return s;
}
function hU(e, t) {
  let n = e.coordsAtPos(e.viewport.from);
  return n ? Math.round(Math.abs((n.left - t) / e.defaultCharacterWidth)) : -1;
}
function j4(e, t) {
  let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1), r = e.state.doc.lineAt(n), i = n - r.from, s = i > vv ? -1 : i == r.length ? hU(e, t.clientX) : Os(r.text, e.state.tabSize, n - r.from);
  return { line: r.number, col: s, off: i };
}
function uU(e, t) {
  let n = j4(e, t), r = e.state.selection;
  return n ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(n.line).from), o = i.state.doc.lineAt(s);
        n = { line: o.number, col: n.col, off: Math.min(n.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let a = j4(e, i);
      if (!a)
        return r;
      let l = cU(e.state, n, a);
      return l.length ? o ? mt.create(l.concat(r.ranges)) : mt.create(l) : r;
    }
  } : null;
}
function fU(e) {
  let t = (e == null ? void 0 : e.eventFilter) || ((n) => n.altKey && n.button == 0);
  return Pt.mouseSelectionStyle.of((n, r) => t(r) ? uU(n, r) : null);
}
const dU = {
  Alt: [18, (e) => !!e.altKey],
  Control: [17, (e) => !!e.ctrlKey],
  Shift: [16, (e) => !!e.shiftKey],
  Meta: [91, (e) => !!e.metaKey]
}, pU = { style: "cursor: crosshair" };
function gU(e = {}) {
  let [t, n] = dU[e.key || "Alt"], r = He.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == t || n(i));
      },
      keyup(i) {
        (i.keyCode == t || !n(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(n(i));
      }
    }
  });
  return [
    r,
    Pt.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? pU : null;
    })
  ];
}
const Ju = "-10000px";
class AP {
  constructor(t, n, r) {
    this.facet = n, this.createTooltipView = r, this.input = t.state.facet(n), this.tooltips = this.input.filter((i) => i), this.tooltipViews = this.tooltips.map(r);
  }
  update(t, n) {
    var r;
    let i = t.state.facet(this.facet), s = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(t);
      return !1;
    }
    let o = [], a = n ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let h = s[l], u = -1;
      if (!!h) {
        for (let f = 0; f < this.tooltips.length; f++) {
          let d = this.tooltips[f];
          d && d.create == h.create && (u = f);
        }
        if (u < 0)
          o[l] = this.createTooltipView(h), a && (a[l] = !!h.above);
        else {
          let f = o[l] = this.tooltipViews[u];
          a && (a[l] = n[u]), f.update && f.update(t);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (l.dom.remove(), (r = l.destroy) === null || r === void 0 || r.call(l));
    return n && (a.forEach((l, h) => n[h] = l), n.length = a.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function mU(e) {
  let { win: t } = e;
  return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth };
}
const Cb = /* @__PURE__ */ Ft.define({
  combine: (e) => {
    var t, n, r;
    return {
      position: Wt.ios ? "absolute" : ((t = e.find((i) => i.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((n = e.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((r = e.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || mU
    };
  }
}), X4 = /* @__PURE__ */ new WeakMap(), cw = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.view = e, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = e.state.facet(Cb);
    this.position = t.position, this.parent = t.parent, this.classes = e.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new AP(e, hw, (n) => this.createTooltip(n)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), e.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let e of this.manager.tooltipViews)
        this.intersectionObserver.observe(e.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(e) {
    e.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(e, this.above);
    t && this.observeIntersection();
    let n = t || e.geometryChanged, r = e.state.facet(Cb);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      n = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      n = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(e) {
    let t = e.create(this.view);
    if (t.dom.classList.add("cm-tooltip"), e.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let n = document.createElement("div");
      n.className = "cm-tooltip-arrow", t.dom.appendChild(n);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Ju, t.dom.style.left = "0px", this.container.appendChild(t.dom), t.mount && t.mount(this.view), t;
  }
  destroy() {
    var e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (e = n.destroy) === null || e === void 0 || e.call(n);
    this.parent && this.container.remove(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let e = this.view.dom.getBoundingClientRect(), t = 1, n = 1, r = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (Wt.gecko)
        r = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == Ju && i.style.left == "0px") {
        let s = i.getBoundingClientRect();
        r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (t = i.width / this.parent.offsetWidth, n = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: n } = this.view.viewState);
    return {
      editor: e,
      parent: this.parent ? this.container.getBoundingClientRect() : e,
      pos: this.manager.tooltips.map((i, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(Cb).tooltipSpace(this.view),
      scaleX: t,
      scaleY: n,
      makeAbsolute: r
    };
  }
  writeMeasure(e) {
    var t;
    if (e.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: n, space: r, scaleX: i, scaleY: s } = e, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], h = this.manager.tooltipViews[a], { dom: u } = h, f = e.pos[a], d = e.size[a];
      if (!f || f.bottom <= Math.max(n.top, r.top) || f.top >= Math.min(n.bottom, r.bottom) || f.right < Math.max(n.left, r.left) - 0.1 || f.left > Math.min(n.right, r.right) + 0.1) {
        u.style.top = Ju;
        continue;
      }
      let p = l.arrow ? h.dom.querySelector(".cm-tooltip-arrow") : null, g = p ? 7 : 0, m = d.right - d.left, y = (t = X4.get(h)) !== null && t !== void 0 ? t : d.bottom - d.top, O = h.offset || bU, x = this.view.textDirection == yn.LTR, _ = d.width > r.right - r.left ? x ? r.left : r.right - d.width : x ? Math.min(f.left - (p ? 14 : 0) + O.x, r.right - m) : Math.max(r.left, f.left - m + (p ? 14 : 0) - O.x), w = this.above[a];
      !l.strictSide && (w ? f.top - (d.bottom - d.top) - O.y < r.top : f.bottom + (d.bottom - d.top) + O.y > r.bottom) && w == r.bottom - f.bottom > f.top - r.top && (w = this.above[a] = !w);
      let E = (w ? f.top - r.top : r.bottom - f.bottom) - g;
      if (E < y && h.resize !== !1) {
        if (E < this.view.defaultLineHeight) {
          u.style.top = Ju;
          continue;
        }
        X4.set(h, y), u.style.height = (y = E) / s + "px";
      } else
        u.style.height && (u.style.height = "");
      let T = w ? f.top - y - g - O.y : f.bottom + g + O.y, S = _ + m;
      if (h.overlap !== !0)
        for (let R of o)
          R.left < S && R.right > _ && R.top < T + y && R.bottom > T && (T = w ? R.top - y - 2 - g : R.bottom + g + 2);
      if (this.position == "absolute" ? (u.style.top = (T - e.parent.top) / s + "px", u.style.left = (_ - e.parent.left) / i + "px") : (u.style.top = T / s + "px", u.style.left = _ / i + "px"), p) {
        let R = f.left + (x ? O.x : -O.x) - (_ + 14 - 7);
        p.style.left = R / i + "px";
      }
      h.overlap !== !0 && o.push({ left: _, top: T, right: S, bottom: T + y }), u.classList.toggle("cm-tooltip-above", w), u.classList.toggle("cm-tooltip-below", !w), h.positioned && h.positioned(e.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let e of this.manager.tooltipViews)
        e.dom.style.top = Ju;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), yU = /* @__PURE__ */ Pt.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), bU = { x: 0, y: 0 }, hw = /* @__PURE__ */ Ft.define({
  enables: [cw, yU]
}), Lg = /* @__PURE__ */ Ft.define();
class N2 {
  static create(t) {
    return new N2(t);
  }
  constructor(t) {
    this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new AP(t, Lg, (n) => this.createHostedView(n));
  }
  createHostedView(t) {
    let n = t.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(n.dom), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(t) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(t);
    this.mounted = !0;
  }
  positioned(t) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(t);
  }
  update(t) {
    this.manager.update(t);
  }
  destroy() {
    var t;
    for (let n of this.manager.tooltipViews)
      (t = n.destroy) === null || t === void 0 || t.call(n);
  }
  passProp(t) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[t];
      if (i !== void 0) {
        if (n === void 0)
          n = i;
        else if (n !== i)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const OU = /* @__PURE__ */ hw.compute([Lg], (e) => {
  let t = e.facet(Lg).filter((n) => n);
  return t.length === 0 ? null : {
    pos: Math.min(...t.map((n) => n.pos)),
    end: Math.max(...t.map((n) => {
      var r;
      return (r = n.end) !== null && r !== void 0 ? r : n.pos;
    })),
    create: N2.create,
    above: t[0].above,
    arrow: t.some((n) => n.arrow)
  };
});
class xU {
  constructor(t, n, r, i, s) {
    this.view = t, this.source = n, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let t = Date.now() - this.lastMove.time;
    t < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: t, lastMove: n } = this, r = t.docView.nearest(n.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof Ia)
      i = r.posAtStart;
    else {
      if (i = t.posAtCoords(n), i == null)
        return;
      let a = t.coordsAtPos(i);
      if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - t.defaultCharacterWidth || n.x > a.right + t.defaultCharacterWidth)
        return;
      let l = t.bidiSpans(t.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), h = l && l.dir == yn.RTL ? -1 : 1;
      s = n.x < a.left ? -h : h;
    }
    let o = this.source(t, i, s);
    if (o != null && o.then) {
      let a = this.pending = { pos: i };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && t.dispatch({ effects: this.setHover.of(l) }));
      }, (l) => Qi(t.state, l, "hover tooltip"));
    } else
      o && t.dispatch({ effects: this.setHover.of(o) });
  }
  get tooltip() {
    let t = this.view.plugin(cw), n = t ? t.manager.tooltips.findIndex((r) => r.create == N2.create) : -1;
    return n > -1 ? t.manager.tooltipViews[n] : null;
  }
  mousemove(t) {
    var n;
    this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: r, tooltip: i } = this;
    if (r && i && !vU(i.dom, t) || this.pending) {
      let { pos: s } = r || this.pending, o = (n = r == null ? void 0 : r.end) !== null && n !== void 0 ? n : s;
      (s == o ? this.view.posAtCoords(this.lastMove) != s : !_U(this.view, s, o, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(t) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n) {
      let { tooltip: r } = this;
      r && r.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of(null) });
    }
  }
  watchTooltipLeave(t) {
    let n = (r) => {
      t.removeEventListener("mouseleave", n), this.active && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
    };
    t.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const D0 = 4;
function vU(e, t) {
  let n = e.getBoundingClientRect();
  return t.clientX >= n.left - D0 && t.clientX <= n.right + D0 && t.clientY >= n.top - D0 && t.clientY <= n.bottom + D0;
}
function _U(e, t, n, r, i, s) {
  let o = e.scrollDOM.getBoundingClientRect(), a = e.documentTop + e.documentPadding.top + e.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, a) < i)
    return !1;
  let l = e.posAtCoords({ x: r, y: i }, !1);
  return l >= t && l <= n;
}
function kU(e, t = {}) {
  let n = le.define(), r = bn.define({
    create() {
      return null;
    },
    update(i, s) {
      if (i && (t.hideOnChange && (s.docChanged || s.selection) || t.hideOn && t.hideOn(s, i)))
        return null;
      if (i && s.docChanged) {
        let o = s.changes.mapPos(i.pos, -1, Gn.TrackDel);
        if (o == null)
          return null;
        let a = Object.assign(/* @__PURE__ */ Object.create(null), i);
        a.pos = o, i.end != null && (a.end = s.changes.mapPos(i.end)), i = a;
      }
      for (let o of s.effects)
        o.is(n) && (i = o.value), o.is(wU) && (i = null);
      return i;
    },
    provide: (i) => Lg.from(i)
  });
  return [
    r,
    He.define((i) => new xU(i, e, r, n, t.hoverTime || 300)),
    OU
  ];
}
function PP(e, t) {
  let n = e.plugin(cw);
  if (!n)
    return null;
  let r = n.manager.tooltips.indexOf(t);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const wU = /* @__PURE__ */ le.define(), G4 = /* @__PURE__ */ Ft.define({
  combine(e) {
    let t, n;
    for (let r of e)
      t = t || r.topContainer, n = n || r.bottomContainer;
    return { topContainer: t, bottomContainer: n };
  }
});
function vd(e, t) {
  let n = e.plugin(DP), r = n ? n.specs.indexOf(t) : -1;
  return r > -1 ? n.panels[r] : null;
}
const DP = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.input = e.state.facet(_d), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(e));
    let t = e.state.facet(G4);
    this.top = new L0(e, !0, t.topContainer), this.bottom = new L0(e, !1, t.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(e) {
    let t = e.state.facet(G4);
    this.top.container != t.topContainer && (this.top.sync([]), this.top = new L0(e.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new L0(e.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = e.state.facet(_d);
    if (n != this.input) {
      let r = n.filter((l) => l), i = [], s = [], o = [], a = [];
      for (let l of r) {
        let h = this.specs.indexOf(l), u;
        h < 0 ? (u = l(e.view), a.push(u)) : (u = this.panels[h], u.update && u.update(e)), i.push(u), (u.top ? s : o).push(u);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(e);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (e) => Pt.scrollMargins.of((t) => {
    let n = t.plugin(e);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class L0 {
  constructor(t, n, r) {
    this.view = t, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(t) {
    for (let n of this.panels)
      n.destroy && t.indexOf(n) < 0 && n.destroy();
    this.panels = t, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let t = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; t != n.dom; )
          t = H4(t);
        t = t.nextSibling;
      } else
        this.dom.insertBefore(n.dom, t);
    for (; t; )
      t = H4(t);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let t of this.classes.split(" "))
        t && this.container.classList.remove(t);
      for (let t of (this.classes = this.view.themeClasses).split(" "))
        t && this.container.classList.add(t);
    }
  }
}
function H4(e) {
  let t = e.nextSibling;
  return e.remove(), t;
}
const _d = /* @__PURE__ */ Ft.define({
  enables: DP
});
class Yi extends nc {
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  eq(t) {
    return !1;
  }
  destroy(t) {
  }
}
Yi.prototype.elementClass = "";
Yi.prototype.toDOM = void 0;
Yi.prototype.mapMode = Gn.TrackBefore;
Yi.prototype.startSide = Yi.prototype.endSide = -1;
Yi.prototype.point = !0;
const B1 = /* @__PURE__ */ Ft.define(), SU = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Ne.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, zf = /* @__PURE__ */ Ft.define();
function B2(e) {
  return [LP(), zf.of(Object.assign(Object.assign({}, SU), e))];
}
const _v = /* @__PURE__ */ Ft.define({
  combine: (e) => e.some((t) => t)
});
function LP(e) {
  let t = [
    CU
  ];
  return e && e.fixed === !1 && t.push(_v.of(!0)), t;
}
const CU = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.view = e, this.prevViewport = e.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = e.state.facet(zf).map((t) => new J4(e, t));
    for (let t of this.gutters)
      this.dom.appendChild(t.dom);
    this.fixed = !e.state.facet(_v), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), e.scrollDOM.insertBefore(this.dom, e.contentDOM);
  }
  update(e) {
    if (this.updateGutters(e)) {
      let t = this.prevViewport, n = e.view.viewport, r = Math.min(t.to, n.to) - Math.max(t.from, n.from);
      this.syncGutters(r < (n.to - n.from) * 0.8);
    }
    e.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(_v) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = e.view.viewport;
  }
  syncGutters(e) {
    let t = this.dom.nextSibling;
    e && this.dom.remove();
    let n = Ne.iter(this.view.state.facet(B1), this.view.viewport.from), r = [], i = this.gutters.map((s) => new TU(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let a of s.type)
          if (a.type == Fr.Text && o) {
            kv(n, r, a.from);
            for (let l of i)
              l.line(this.view, a, r);
            o = !1;
          } else if (a.widget)
            for (let l of i)
              l.widget(this.view, a);
      } else if (s.type == Fr.Text) {
        kv(n, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    e && this.view.scrollDOM.insertBefore(this.dom, t);
  }
  updateGutters(e) {
    let t = e.startState.facet(zf), n = e.state.facet(zf), r = e.docChanged || e.heightChanged || e.viewportChanged || !Ne.eq(e.startState.facet(B1), e.state.facet(B1), e.view.viewport.from, e.view.viewport.to);
    if (t == n)
      for (let i of this.gutters)
        i.update(e) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of n) {
        let o = t.indexOf(s);
        o < 0 ? i.push(new J4(this.view, s)) : (this.gutters[o].update(e), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let e of this.gutters)
      e.destroy();
    this.dom.remove();
  }
}, {
  provide: (e) => Pt.scrollMargins.of((t) => {
    let n = t.plugin(e);
    return !n || n.gutters.length == 0 || !n.fixed ? null : t.textDirection == yn.LTR ? { left: n.dom.offsetWidth * t.scaleX } : { right: n.dom.offsetWidth * t.scaleX };
  })
});
function K4(e) {
  return Array.isArray(e) ? e : [e];
}
function kv(e, t, n) {
  for (; e.value && e.from <= n; )
    e.from == n && t.push(e.value), e.next();
}
class TU {
  constructor(t, n, r) {
    this.gutter = t, this.height = r, this.i = 0, this.cursor = Ne.iter(t.markers, n.from);
  }
  addElement(t, n, r) {
    let { gutter: i } = this, s = (n.top - this.height) / t.scaleY, o = n.height / t.scaleY;
    if (this.i == i.elements.length) {
      let a = new MP(t, o, s, r);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(t, o, s, r);
    this.height = n.bottom, this.i++;
  }
  line(t, n, r) {
    let i = [];
    kv(this.cursor, i, n.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(t, n, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(t, n, i);
  }
  widget(t, n) {
    let r = this.gutter.config.widgetMarker(t, n.widget, n);
    r && this.addElement(t, n, [r]);
  }
  finish() {
    let t = this.gutter;
    for (; t.elements.length > this.i; ) {
      let n = t.elements.pop();
      t.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class J4 {
  constructor(t, n) {
    this.view = t, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = i.clientY;
        let a = t.lineBlockAtHeight(o - t.documentTop);
        n.domEventHandlers[r](t, a, i) && i.preventDefault();
      });
    this.markers = K4(n.markers(t)), n.initialSpacer && (this.spacer = new MP(t, 0, 0, [n.initialSpacer(t)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t) {
    let n = this.markers;
    if (this.markers = K4(this.config.markers(t.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], t);
      i != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [i]);
    }
    let r = t.view.viewport;
    return !Ne.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(t) : !1);
  }
  destroy() {
    for (let t of this.elements)
      t.destroy();
  }
}
class MP {
  constructor(t, n, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, n, r, i);
  }
  update(t, n, r, i) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), EU(this.markers, i) || this.setMarkers(t, i);
  }
  setMarkers(t, n) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o, l = s < n.length ? n[s++] : null, h = !1;
      if (l) {
        let u = l.elementClass;
        u && (r += " " + u);
        for (let f = o; f < this.markers.length; f++)
          if (this.markers[f].compare(l)) {
            a = f, h = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let f = i.nextSibling;
          i.remove(), i = f;
        }
      }
      if (!l)
        break;
      l.toDOM && (h ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(t), i)), h && o++;
    }
    this.dom.className = r, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function EU(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!e[n].compare(t[n]))
      return !1;
  return !0;
}
const AU = /* @__PURE__ */ Ft.define(), Hc = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(t, n) {
        let r = Object.assign({}, t);
        for (let i in n) {
          let s = r[i], o = n[i];
          r[i] = s ? (a, l, h) => s(a, l, h) || o(a, l, h) : o;
        }
        return r;
      }
    });
  }
});
class Tb extends Yi {
  constructor(t) {
    super(), this.number = t;
  }
  eq(t) {
    return this.number == t.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Eb(e, t) {
  return e.state.facet(Hc).formatNumber(t, e.state);
}
const PU = /* @__PURE__ */ zf.compute([Hc], (e) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(t) {
    return t.state.facet(AU);
  },
  lineMarker(t, n, r) {
    return r.some((i) => i.toDOM) ? null : new Tb(Eb(t, t.state.doc.lineAt(n.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (t) => t.startState.facet(Hc) != t.state.facet(Hc),
  initialSpacer(t) {
    return new Tb(Eb(t, tC(t.state.doc.lines)));
  },
  updateSpacer(t, n) {
    let r = Eb(n.view, tC(n.view.state.doc.lines));
    return r == t.number ? t : new Tb(r);
  },
  domEventHandlers: e.facet(Hc).domEventHandlers
}));
function DU(e = {}) {
  return [
    Hc.of(e),
    LP(),
    PU
  ];
}
function tC(e) {
  let t = 9;
  for (; t < e; )
    t = t * 10 + 9;
  return t;
}
const LU = /* @__PURE__ */ new class extends Yi {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), MU = /* @__PURE__ */ B1.compute(["selection"], (e) => {
  let t = [], n = -1;
  for (let r of e.selection.ranges) {
    let i = e.doc.lineAt(r.head).from;
    i > n && (n = i, t.push(LU.range(i)));
  }
  return Ne.of(t);
});
function RU() {
  return MU;
}
const RP = 1024;
let $U = 0;
class Ii {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
}
class _e {
  constructor(t = {}) {
    this.id = $U++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = Jn.match(t)), (n) => {
      let r = t(n);
      return r === void 0 ? null : [this, r];
    };
  }
}
_e.closedBy = new _e({ deserialize: (e) => e.split(" ") });
_e.openedBy = new _e({ deserialize: (e) => e.split(" ") });
_e.group = new _e({ deserialize: (e) => e.split(" ") });
_e.contextHash = new _e({ perNode: !0 });
_e.lookAhead = new _e({ perNode: !0 });
_e.mounted = new _e({ perNode: !0 });
class kd {
  constructor(t, n, r) {
    this.tree = t, this.overlay = n, this.parser = r;
  }
  static get(t) {
    return t && t.props && t.props[_e.mounted.id];
  }
}
const IU = /* @__PURE__ */ Object.create(null);
class Jn {
  constructor(t, n, r, i = 0) {
    this.name = t, this.props = n, this.id = r, this.flags = i;
  }
  static define(t) {
    let n = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : IU, r = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), i = new Jn(t.name || "", n, t.id, r);
    if (t.props) {
      for (let s of t.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[s[0].id] = s[1];
        }
    }
    return i;
  }
  prop(t) {
    return this.props[t.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let n = this.prop(_e.group);
      return n ? n.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  static match(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in t)
      for (let i of r.split(" "))
        n[i] = t[r];
    return (r) => {
      for (let i = r.prop(_e.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = n[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
}
Jn.none = new Jn("", /* @__PURE__ */ Object.create(null), 0, 8);
class Ip {
  constructor(t) {
    this.types = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...t) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let s of t) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);
      }
      n.push(i ? new Jn(r.name, i, r.id, r.flags) : r);
    }
    return new Ip(n);
  }
}
const M0 = /* @__PURE__ */ new WeakMap(), eC = /* @__PURE__ */ new WeakMap();
var tn;
(function(e) {
  e[e.ExcludeBuffers = 1] = "ExcludeBuffers", e[e.IncludeAnonymous = 2] = "IncludeAnonymous", e[e.IgnoreMounts = 4] = "IgnoreMounts", e[e.IgnoreOverlays = 8] = "IgnoreOverlays";
})(tn || (tn = {}));
class ze {
  constructor(t, n, r, i, s) {
    if (this.type = t, this.children = n, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of s)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  toString() {
    let t = kd.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), n += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  cursor(t = 0) {
    return new Mg(this.topNode, t);
  }
  cursorAt(t, n = 0, r = 0) {
    let i = M0.get(this) || this.topNode, s = new Mg(i);
    return s.moveTo(t, n), M0.set(this, s._tree), s;
  }
  get topNode() {
    return new Ar(this, 0, 0, null);
  }
  resolve(t, n = 0) {
    let r = wd(M0.get(this) || this.topNode, t, n, !1);
    return M0.set(this, r), r;
  }
  resolveInner(t, n = 0) {
    let r = wd(eC.get(this) || this.topNode, t, n, !0);
    return eC.set(this, r), r;
  }
  resolveStack(t, n = 0) {
    return FU(this, t, n);
  }
  iterate(t) {
    let { enter: n, leave: r, from: i = 0, to: s = this.length } = t, o = t.mode || 0, a = (o & tn.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | tn.IncludeAnonymous); ; ) {
      let h = !1;
      if (l.from <= s && l.to >= i && (!a && l.type.isAnonymous || n(l) !== !1)) {
        if (l.firstChild())
          continue;
        h = !0;
      }
      for (; h && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        h = !0;
      }
    }
  }
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  get propValues() {
    let t = [];
    if (this.props)
      for (let n in this.props)
        t.push([+n, this.props[n]]);
    return t;
  }
  balance(t = {}) {
    return this.children.length <= 8 ? this : dw(Jn.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new ze(this.type, n, r, i, this.propValues), t.makeTree || ((n, r, i) => new ze(Jn.none, n, r, i)));
  }
  static build(t) {
    return QU(t);
  }
}
ze.empty = new ze(Jn.none, [], [], 0);
class uw {
  constructor(t, n) {
    this.buffer = t, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new uw(this.buffer, this.index);
  }
}
class el {
  constructor(t, n, r) {
    this.buffer = t, this.length = n, this.set = r;
  }
  get type() {
    return Jn.none;
  }
  toString() {
    let t = [];
    for (let n = 0; n < this.buffer.length; )
      t.push(this.childString(n)), n = this.buffer[n + 3];
    return t.join(",");
  }
  childString(t) {
    let n = this.buffer[t], r = this.buffer[t + 3], i = this.set.types[n], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), t += 4, r == t)
      return s;
    let o = [];
    for (; t < r; )
      o.push(this.childString(t)), t = this.buffer[t + 3];
    return s + "(" + o.join(",") + ")";
  }
  findChild(t, n, r, i, s) {
    let { buffer: o } = this, a = -1;
    for (let l = t; l != n && !($P(s, i, o[l + 1], o[l + 2]) && (a = l, r > 0)); l = o[l + 3])
      ;
    return a;
  }
  slice(t, n, r) {
    let i = this.buffer, s = new Uint16Array(n - t), o = 0;
    for (let a = t, l = 0; a < n; ) {
      s[l++] = i[a++], s[l++] = i[a++] - r;
      let h = s[l++] = i[a++] - r;
      s[l++] = i[a++] - t, o = Math.max(o, h);
    }
    return new el(s, o, this.set);
  }
}
function $P(e, t, n, r) {
  switch (e) {
    case -2:
      return n < t;
    case -1:
      return r >= t && n < t;
    case 0:
      return n < t && r > t;
    case 1:
      return n <= t && r > t;
    case 2:
      return r > t;
    case 4:
      return !0;
  }
}
function wd(e, t, n, r) {
  for (var i; e.from == e.to || (n < 1 ? e.from >= t : e.from > t) || (n > -1 ? e.to <= t : e.to < t); ) {
    let o = !r && e instanceof Ar && e.index < 0 ? null : e.parent;
    if (!o)
      return e;
    e = o;
  }
  let s = r ? 0 : tn.IgnoreOverlays;
  if (r)
    for (let o = e, a = o.parent; a; o = a, a = o.parent)
      o instanceof Ar && o.index < 0 && ((i = a.enter(t, n, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (e = a);
  for (; ; ) {
    let o = e.enter(t, n, s);
    if (!o)
      return e;
    e = o;
  }
}
class IP {
  cursor(t = 0) {
    return new Mg(this, t);
  }
  getChild(t, n = null, r = null) {
    let i = nC(this, t, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(t, n = null, r = null) {
    return nC(this, t, n, r);
  }
  resolve(t, n = 0) {
    return wd(this, t, n, !1);
  }
  resolveInner(t, n = 0) {
    return wd(this, t, n, !0);
  }
  matchContext(t) {
    return wv(this, t);
  }
  enterUnfinishedNodesBefore(t) {
    let n = this.childBefore(t), r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to)
        break;
      i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Ar extends IP {
  constructor(t, n, r, i) {
    super(), this._tree = t, this.from = n, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, n, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, h = n > 0 ? a.length : -1; t != h; t += n) {
        let u = a[t], f = l[t] + o.from;
        if (!!$P(i, r, f, f + u.length)) {
          if (u instanceof el) {
            if (s & tn.ExcludeBuffers)
              continue;
            let d = u.findChild(0, u.buffer.length, n, r - f, i);
            if (d > -1)
              return new Js(new NU(o, u, t, f), null, d);
          } else if (s & tn.IncludeAnonymous || !u.type.isAnonymous || fw(u)) {
            let d;
            if (!(s & tn.IgnoreMounts) && (d = kd.get(u)) && !d.overlay)
              return new Ar(d.tree, f, t, o);
            let p = new Ar(u, f, t, o);
            return s & tn.IncludeAnonymous || !p.type.isAnonymous ? p : p.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (s & tn.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? t = o.index + n : t = n < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(t) {
    return this.nextChild(0, 1, t, 2);
  }
  childBefore(t) {
    return this.nextChild(this._tree.children.length - 1, -1, t, -2);
  }
  enter(t, n, r = 0) {
    let i;
    if (!(r & tn.IgnoreOverlays) && (i = kd.get(this._tree)) && i.overlay) {
      let s = t - this.from;
      for (let { from: o, to: a } of i.overlay)
        if ((n > 0 ? o <= s : o < s) && (n < 0 ? a >= s : a > s))
          return new Ar(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, n, r);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function nC(e, t, n, r) {
  let i = e.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (n != null) {
    for (; !i.type.is(n); )
      if (!i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(t) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function wv(e, t, n = t.length - 1) {
  for (let r = e.parent; n >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (t[n] && t[n] != r.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class NU {
  constructor(t, n, r, i) {
    this.parent = t, this.buffer = n, this.index = r, this.start = i;
  }
}
class Js extends IP {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, n, r) {
    super(), this.context = t, this._parent = n, this.index = r, this.type = t.buffer.set.types[t.buffer.buffer[r]];
  }
  child(t, n, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], t, n - this.context.start, r);
    return s < 0 ? null : new Js(this.context, this, s);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(t) {
    return this.child(1, t, 2);
  }
  childBefore(t) {
    return this.child(-1, t, -2);
  }
  enter(t, n, r = 0) {
    if (r & tn.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, t - this.context.start, n);
    return s < 0 ? null : new Js(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + t, t, 0, 4);
  }
  get nextSibling() {
    let { buffer: t } = this.context, n = t.buffer[this.index + 3];
    return n < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Js(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Js(this.context, this._parent, t.findChild(n, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], n = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      t.push(r.slice(i, s, o)), n.push(0);
    }
    return new ze(this.type, t, n, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function NP(e) {
  if (!e.length)
    return null;
  let t = 0, n = e[0];
  for (let s = 1; s < e.length; s++) {
    let o = e[s];
    (o.from > n.from || o.to < n.to) && (n = o, t = s);
  }
  let r = n instanceof Ar && n.index < 0 ? null : n.parent, i = e.slice();
  return r ? i[t] = r : i.splice(t, 1), new BU(i, n);
}
class BU {
  constructor(t, n) {
    this.heads = t, this.node = n;
  }
  get next() {
    return NP(this.heads);
  }
}
function FU(e, t, n) {
  let r = e.resolveInner(t, n), i = null;
  for (let s = r instanceof Ar ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(t, n)), s = o;
    } else {
      let o = kd.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= t && o.overlay[o.overlay.length - 1].to >= t) {
        let a = new Ar(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(wd(a, t, n, !1));
      }
    }
  return i ? NP(i) : r;
}
class Mg {
  get name() {
    return this.type.name;
  }
  constructor(t, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof Ar)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let r = t._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, n) {
    this.index = t;
    let { start: r, buffer: i } = this.buffer;
    return this.type = n || i.set.types[i.buffer[t]], this.from = r + i.buffer[t + 1], this.to = r + i.buffer[t + 2], !0;
  }
  yield(t) {
    return t ? t instanceof Ar ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(t, n, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, n, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], t, n - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(t) {
    return this.enterChild(1, t, 2);
  }
  childBefore(t) {
    return this.enterChild(-1, t, -2);
  }
  enter(t, n, r = this.mode) {
    return this.buffer ? r & tn.ExcludeBuffers ? !1 : this.enterChild(1, t, n) : this.yield(this._tree.enter(t, n, r));
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & tn.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & tn.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, r = this.stack.length - 1;
    if (t < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let n, r, { buffer: i } = this;
    if (i) {
      if (t > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: n, parent: r } = i);
    } else
      ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let s = n + t, o = t < 0 ? -1 : r._tree.children.length; s != o; s += t) {
          let a = r._tree.children[s];
          if (this.mode & tn.IncludeAnonymous || a instanceof el || !a.type.isAnonymous || fw(a))
            return !1;
        }
    return !0;
  }
  move(t, n) {
    if (n && this.enterChild(t, 0, 4))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  next(t = !0) {
    return this.move(1, t);
  }
  prev(t = !0) {
    return this.move(-1, t);
  }
  moveTo(t, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= t : this.from > t) || (n > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, n); )
      ;
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, n = null, r = 0;
    if (t && t.context == this.buffer) {
      t:
        for (let i = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = t; o; o = o._parent)
            if (o.index == i) {
              if (i == this.index)
                return o;
              n = o, r = s + 1;
              break t;
            }
          i = this.stack[--s];
        }
    }
    for (let i = r; i < this.stack.length; i++)
      n = new Js(this.buffer, n, this.stack[i]);
    return this.bufferNode = new Js(this.buffer, n, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(t, n) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && n && n(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!r)
          return;
        this.parent(), r--, i = !0;
      }
    }
  }
  matchContext(t) {
    if (!this.buffer)
      return wv(this.node, t);
    let { buffer: n } = this.buffer, { types: r } = n.set;
    for (let i = t.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return wv(this.node, t, i);
      let o = r[n.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (t[i] && t[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function fw(e) {
  return e.children.some((t) => t instanceof el || !t.type.isAnonymous || fw(t));
}
function QU(e) {
  var t;
  let { buffer: n, nodeSet: r, maxBufferLength: i = RP, reused: s = [], minRepeatType: o = r.types.length } = e, a = Array.isArray(n) ? new uw(n, n.length) : n, l = r.types, h = 0, u = 0;
  function f(E, T, S, R, A, P) {
    let { id: C, start: k, end: D, size: b } = a, M = u;
    for (; b < 0; )
      if (a.next(), b == -1) {
        let z = s[C];
        S.push(z), R.push(k - E);
        return;
      } else if (b == -3) {
        h = C;
        return;
      } else if (b == -4) {
        u = C;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${b}`);
    let v = l[C], N, tt, Z = k - E;
    if (D - k <= i && (tt = y(a.pos - T, A))) {
      let z = new Uint16Array(tt.size - tt.skip), X = a.pos - tt.size, q = z.length;
      for (; a.pos > X; )
        q = O(tt.start, z, q);
      N = new el(z, D - tt.start, r), Z = tt.start - E;
    } else {
      let z = a.pos - b;
      a.next();
      let X = [], q = [], nt = C >= o ? C : -1, st = 0, ct = D;
      for (; a.pos > z; )
        nt >= 0 && a.id == nt && a.size >= 0 ? (a.end <= ct - i && (g(X, q, k, st, a.end, ct, nt, M), st = X.length, ct = a.end), a.next()) : P > 2500 ? d(k, z, X, q) : f(k, z, X, q, nt, P + 1);
      if (nt >= 0 && st > 0 && st < X.length && g(X, q, k, st, k, ct, nt, M), X.reverse(), q.reverse(), nt > -1 && st > 0) {
        let Y = p(v);
        N = dw(v, X, q, 0, X.length, 0, D - k, Y, Y);
      } else
        N = m(v, X, q, D - k, M - D);
    }
    S.push(N), R.push(Z);
  }
  function d(E, T, S, R) {
    let A = [], P = 0, C = -1;
    for (; a.pos > T; ) {
      let { id: k, start: D, end: b, size: M } = a;
      if (M > 4)
        a.next();
      else {
        if (C > -1 && D < C)
          break;
        C < 0 && (C = b - i), A.push(k, D, b), P++, a.next();
      }
    }
    if (P) {
      let k = new Uint16Array(P * 4), D = A[A.length - 2];
      for (let b = A.length - 3, M = 0; b >= 0; b -= 3)
        k[M++] = A[b], k[M++] = A[b + 1] - D, k[M++] = A[b + 2] - D, k[M++] = M;
      S.push(new el(k, A[2] - D, r)), R.push(D - E);
    }
  }
  function p(E) {
    return (T, S, R) => {
      let A = 0, P = T.length - 1, C, k;
      if (P >= 0 && (C = T[P]) instanceof ze) {
        if (!P && C.type == E && C.length == R)
          return C;
        (k = C.prop(_e.lookAhead)) && (A = S[P] + C.length + k);
      }
      return m(E, T, S, R, A);
    };
  }
  function g(E, T, S, R, A, P, C, k) {
    let D = [], b = [];
    for (; E.length > R; )
      D.push(E.pop()), b.push(T.pop() + S - A);
    E.push(m(r.types[C], D, b, P - A, k - P)), T.push(A - S);
  }
  function m(E, T, S, R, A = 0, P) {
    if (h) {
      let C = [_e.contextHash, h];
      P = P ? [C].concat(P) : [C];
    }
    if (A > 25) {
      let C = [_e.lookAhead, A];
      P = P ? [C].concat(P) : [C];
    }
    return new ze(E, T, S, R, P);
  }
  function y(E, T) {
    let S = a.fork(), R = 0, A = 0, P = 0, C = S.end - i, k = { size: 0, start: 0, skip: 0 };
    t:
      for (let D = S.pos - E; S.pos > D; ) {
        let b = S.size;
        if (S.id == T && b >= 0) {
          k.size = R, k.start = A, k.skip = P, P += 4, R += 4, S.next();
          continue;
        }
        let M = S.pos - b;
        if (b < 0 || M < D || S.start < C)
          break;
        let v = S.id >= o ? 4 : 0, N = S.start;
        for (S.next(); S.pos > M; ) {
          if (S.size < 0)
            if (S.size == -3)
              v += 4;
            else
              break t;
          else
            S.id >= o && (v += 4);
          S.next();
        }
        A = N, R += b, P += v;
      }
    return (T < 0 || R == E) && (k.size = R, k.start = A, k.skip = P), k.size > 4 ? k : void 0;
  }
  function O(E, T, S) {
    let { id: R, start: A, end: P, size: C } = a;
    if (a.next(), C >= 0 && R < o) {
      let k = S;
      if (C > 4) {
        let D = a.pos - (C - 4);
        for (; a.pos > D; )
          S = O(E, T, S);
      }
      T[--S] = k, T[--S] = P - E, T[--S] = A - E, T[--S] = R;
    } else
      C == -3 ? h = R : C == -4 && (u = R);
    return S;
  }
  let x = [], _ = [];
  for (; a.pos > 0; )
    f(e.start || 0, e.bufferStart || 0, x, _, -1, 0);
  let w = (t = e.length) !== null && t !== void 0 ? t : x.length ? _[0] + x[0].length : 0;
  return new ze(l[e.topID], x.reverse(), _.reverse(), w);
}
const rC = /* @__PURE__ */ new WeakMap();
function F1(e, t) {
  if (!e.isAnonymous || t instanceof el || t.type != e)
    return 1;
  let n = rC.get(t);
  if (n == null) {
    n = 1;
    for (let r of t.children) {
      if (r.type != e || !(r instanceof ze)) {
        n = 1;
        break;
      }
      n += F1(e, r);
    }
    rC.set(t, n);
  }
  return n;
}
function dw(e, t, n, r, i, s, o, a, l) {
  let h = 0;
  for (let g = r; g < i; g++)
    h += F1(e, t[g]);
  let u = Math.ceil(h * 1.5 / 8), f = [], d = [];
  function p(g, m, y, O, x) {
    for (let _ = y; _ < O; ) {
      let w = _, E = m[_], T = F1(e, g[_]);
      for (_++; _ < O; _++) {
        let S = F1(e, g[_]);
        if (T + S >= u)
          break;
        T += S;
      }
      if (_ == w + 1) {
        if (T > u) {
          let S = g[w];
          p(S.children, S.positions, 0, S.children.length, m[w] + x);
          continue;
        }
        f.push(g[w]);
      } else {
        let S = m[_ - 1] + g[_ - 1].length - E;
        f.push(dw(e, g, m, w, _, E, S, null, l));
      }
      d.push(E + x - s);
    }
  }
  return p(t, n, r, i, 0), (a || l)(f, d, o);
}
class BP {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, n, r) {
    let i = this.map.get(t);
    i || this.map.set(t, i = /* @__PURE__ */ new Map()), i.set(n, r);
  }
  getBuffer(t, n) {
    let r = this.map.get(t);
    return r && r.get(n);
  }
  set(t, n) {
    t instanceof Js ? this.setBuffer(t.context.buffer, t.index, n) : t instanceof Ar && this.map.set(t.tree, n);
  }
  get(t) {
    return t instanceof Js ? this.getBuffer(t.context.buffer, t.index) : t instanceof Ar ? this.map.get(t.tree) : void 0;
  }
  cursorSet(t, n) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, n) : this.map.set(t.tree, n);
  }
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}
class Jo {
  constructor(t, n, r, i, s = !1, o = !1) {
    this.from = t, this.to = n, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(t, n = [], r = !1) {
    let i = [new Jo(0, t.length, t, 0, !1, r)];
    for (let s of n)
      s.to > t.length && i.push(s);
    return i;
  }
  static applyChanges(t, n, r = 128) {
    if (!n.length)
      return t;
    let i = [], s = 1, o = t.length ? t[0] : null;
    for (let a = 0, l = 0, h = 0; ; a++) {
      let u = a < n.length ? n[a] : null, f = u ? u.fromA : 1e9;
      if (f - l >= r)
        for (; o && o.from < f; ) {
          let d = o;
          if (l >= d.from || f <= d.to || h) {
            let p = Math.max(d.from, l) - h, g = Math.min(d.to, f) - h;
            d = p >= g ? null : new Jo(p, g, d.tree, d.offset + h, a > 0, !!u);
          }
          if (d && i.push(d), o.to > f)
            break;
          o = s < t.length ? t[s++] : null;
        }
      if (!u)
        break;
      l = u.toA, h = u.toA - u.toB;
    }
    return i;
  }
}
class pw {
  startParse(t, n, r) {
    return typeof t == "string" && (t = new ZU(t)), r = r ? r.length ? r.map((i) => new Ii(i.from, i.to)) : [new Ii(0, 0)] : [new Ii(0, t.length)], this.createParse(t, n || [], r);
  }
  parse(t, n, r) {
    let i = this.startParse(t, n, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
}
class ZU {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, n) {
    return this.string.slice(t, n);
  }
}
function FP(e) {
  return (t, n, r, i) => new YU(t, e, n, r, i);
}
class iC {
  constructor(t, n, r, i, s) {
    this.parser = t, this.parse = n, this.overlay = r, this.target = i, this.from = s;
  }
}
function sC(e) {
  if (!e.length || e.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(e));
}
class VU {
  constructor(t, n, r, i, s, o, a) {
    this.parser = t, this.predicate = n, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const Sv = new _e({ perNode: !0 });
class YU {
  constructor(t, n, r, i, s) {
    this.nest = n, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new ze(r.type, r.children, r.positions, r.length, r.propValues.concat([[Sv, this.stoppedAt]]))), r;
    }
    let t = this.inner[this.innerDone], n = t.parse.advance();
    if (n) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      r[_e.mounted.id] = new kd(n, t.overlay, t.parser), t.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++)
      this.inner[n].from < t && (t = Math.min(t, this.inner[n].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let n = this.innerDone; n < this.inner.length; n++)
        this.inner[n].parse.stopAt(t);
  }
  startInner() {
    let t = new WU(this.fragments), n = null, r = null, i = new Mg(new Ar(this.baseTree, this.ranges[0].from, 0, null), tn.IncludeAnonymous | tn.IgnoreMounts);
    t:
      for (let s, o; ; ) {
        let a = !0, l;
        if (this.stoppedAt != null && i.from >= this.stoppedAt)
          a = !1;
        else if (t.hasNode(i)) {
          if (n) {
            let h = n.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
            if (h)
              for (let u of h.mount.overlay) {
                let f = u.from + h.pos, d = u.to + h.pos;
                f >= i.from && d <= i.to && !n.ranges.some((p) => p.from < d && p.to > f) && n.ranges.push({ from: f, to: d });
              }
          }
          a = !1;
        } else if (r && (o = zU(r.ranges, i.from, i.to)))
          a = o != 2;
        else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
          i.tree || qU(i);
          let h = t.findMounts(i.from, s.parser);
          if (typeof s.overlay == "function")
            n = new VU(s.parser, s.overlay, h, this.inner.length, i.from, i.tree, n);
          else {
            let u = lC(this.ranges, s.overlay || (i.from < i.to ? [new Ii(i.from, i.to)] : []));
            u.length && sC(u), (u.length || !s.overlay) && this.inner.push(new iC(s.parser, u.length ? s.parser.startParse(this.input, cC(h, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((f) => new Ii(f.from - i.from, f.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : a = !1;
          }
        } else
          n && (l = n.predicate(i)) && (l === !0 && (l = new Ii(i.from, i.to)), l.from < l.to && n.ranges.push(l));
        if (a && i.firstChild())
          n && n.depth++, r && r.depth++;
        else
          for (; !i.nextSibling(); ) {
            if (!i.parent())
              break t;
            if (n && !--n.depth) {
              let h = lC(this.ranges, n.ranges);
              h.length && (sC(h), this.inner.splice(n.index, 0, new iC(n.parser, n.parser.startParse(this.input, cC(n.mounts, h), h), n.ranges.map((u) => new Ii(u.from - n.start, u.to - n.start)), n.target, h[0].from))), n = n.prev;
            }
            r && !--r.depth && (r = r.prev);
          }
      }
  }
}
function zU(e, t, n) {
  for (let r of e) {
    if (r.from >= n)
      break;
    if (r.to > t)
      return r.from <= t && r.to >= n ? 2 : 1;
  }
  return 0;
}
function oC(e, t, n, r, i, s) {
  if (t < n) {
    let o = e.buffer[t + 1];
    r.push(e.slice(t, n, o)), i.push(o - s);
  }
}
function qU(e) {
  let { node: t } = e, n = [], r = t.context.buffer;
  do
    n.push(e.index), e.parent();
  while (!e.tree);
  let i = e.tree, s = i.children.indexOf(r), o = i.children[s], a = o.buffer, l = [s];
  function h(u, f, d, p, g, m) {
    let y = n[m], O = [], x = [];
    oC(o, u, y, O, x, p);
    let _ = a[y + 1], w = a[y + 2];
    l.push(O.length);
    let E = m ? h(y + 4, a[y + 3], o.set.types[a[y]], _, w - _, m - 1) : t.toTree();
    return O.push(E), x.push(_ - p), oC(o, a[y + 3], f, O, x, p), new ze(d, O, x, g);
  }
  i.children[s] = h(0, a.length, Jn.none, 0, o.length, n.length - 1);
  for (let u of l) {
    let f = e.tree.children[u], d = e.tree.positions[u];
    e.yield(new Ar(f, d + e.from, u, e._tree));
  }
}
class aC {
  constructor(t, n) {
    this.offset = n, this.done = !1, this.cursor = t.cursor(tn.IncludeAnonymous | tn.IgnoreMounts);
  }
  moveTo(t) {
    let { cursor: n } = this, r = t - this.offset;
    for (; !this.done && n.from < r; )
      n.to >= t && n.enter(r, 1, tn.IgnoreOverlays | tn.ExcludeBuffers) || n.next(!1) || (this.done = !0);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let n = this.cursor.tree; ; ) {
        if (n == t.tree)
          return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof ze)
          n = n.children[0];
        else
          break;
      }
    return !1;
  }
}
class WU {
  constructor(t) {
    var n;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let r = this.curFrag = t[0];
      this.curTo = (n = r.tree.prop(Sv)) !== null && n !== void 0 ? n : r.to, this.inner = new aC(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let n = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = n.tree.prop(Sv)) !== null && t !== void 0 ? t : n.to, this.inner = new aC(n.tree, -n.offset);
    }
  }
  findMounts(t, n) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(_e.mounted);
        if (o && o.parser == n)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= s.to)
              break;
            l.tree == this.curFrag.tree && i.push({
              frag: l,
              pos: s.from - l.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
}
function lC(e, t) {
  let n = null, r = t;
  for (let i = 1, s = 0; i < e.length; i++) {
    let o = e[i - 1].to, a = e[i].from;
    for (; s < r.length; s++) {
      let l = r[s];
      if (l.from >= a)
        break;
      l.to <= o || (n || (r = n = t.slice()), l.from < o ? (n[s] = new Ii(l.from, o), l.to > a && n.splice(s + 1, 0, new Ii(a, l.to))) : l.to > a ? n[s--] = new Ii(a, l.to) : n.splice(s--, 1));
    }
  }
  return r;
}
function UU(e, t, n, r) {
  let i = 0, s = 0, o = !1, a = !1, l = -1e9, h = [];
  for (; ; ) {
    let u = i == e.length ? 1e9 : o ? e[i].to : e[i].from, f = s == t.length ? 1e9 : a ? t[s].to : t[s].from;
    if (o != a) {
      let d = Math.max(l, n), p = Math.min(u, f, r);
      d < p && h.push(new Ii(d, p));
    }
    if (l = Math.min(u, f), l == 1e9)
      break;
    u == l && (o ? (o = !1, i++) : o = !0), f == l && (a ? (a = !1, s++) : a = !0);
  }
  return h;
}
function cC(e, t) {
  let n = [];
  for (let { pos: r, mount: i, frag: s } of e) {
    let o = r + (i.overlay ? i.overlay[0].from : 0), a = o + i.tree.length, l = Math.max(s.from, o), h = Math.min(s.to, a);
    if (i.overlay) {
      let u = i.overlay.map((d) => new Ii(d.from + r, d.to + r)), f = UU(t, u, l, h);
      for (let d = 0, p = l; ; d++) {
        let g = d == f.length, m = g ? h : f[d].from;
        if (m > p && n.push(new Jo(p, m, i.tree, -o, s.from >= p || s.openStart, s.to <= m || s.openEnd)), g)
          break;
        p = f[d].to;
      }
    } else
      n.push(new Jo(l, h, i.tree, -o, s.from >= o || s.openStart, s.to <= a || s.openEnd));
  }
  return n;
}
let jU = 0;
class is {
  constructor(t, n, r) {
    this.set = t, this.base = n, this.modified = r, this.id = jU++;
  }
  static define(t) {
    if (t != null && t.base)
      throw new Error("Can not derive from a modified tag");
    let n = new is([], null, []);
    if (n.set.push(n), t)
      for (let r of t.set)
        n.set.push(r);
    return n;
  }
  static defineModifier() {
    let t = new Rg();
    return (n) => n.modified.indexOf(t) > -1 ? n : Rg.get(n.base || n, n.modified.concat(t).sort((r, i) => r.id - i.id));
  }
}
let XU = 0;
class Rg {
  constructor() {
    this.instances = [], this.id = XU++;
  }
  static get(t, n) {
    if (!n.length)
      return t;
    let r = n[0].instances.find((a) => a.base == t && GU(n, a.modified));
    if (r)
      return r;
    let i = [], s = new is(i, t, n);
    for (let a of n)
      a.instances.push(s);
    let o = HU(n);
    for (let a of t.set)
      if (!a.modified.length)
        for (let l of o)
          i.push(Rg.get(a, l));
    return s;
  }
}
function GU(e, t) {
  return e.length == t.length && e.every((n, r) => n == t[r]);
}
function HU(e) {
  let t = [[]];
  for (let n = 0; n < e.length; n++)
    for (let r = 0, i = t.length; r < i; r++)
      t.push(t[r].concat(e[n]));
  return t.sort((n, r) => r.length - n.length);
}
function Tu(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let r = e[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let s = [], o = 2, a = i;
        for (let f = 0; ; ) {
          if (a == "..." && f > 0 && f + 3 == i.length) {
            o = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + i);
          if (s.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), f += d[0].length, f == i.length)
            break;
          let p = i[f++];
          if (f == i.length && p == "!") {
            o = 0;
            break;
          }
          if (p != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(f);
        }
        let l = s.length - 1, h = s[l];
        if (!h)
          throw new RangeError("Invalid path: " + i);
        let u = new $g(r, o, l > 0 ? s.slice(0, l) : null);
        t[h] = u.sort(t[h]);
      }
  }
  return QP.add(t);
}
const QP = new _e();
class $g {
  constructor(t, n, r, i) {
    this.tags = t, this.mode = n, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
$g.empty = new $g([], 2, null);
function ZP(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let s of e)
    if (!Array.isArray(s.tag))
      n[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        n[o.id] = s.class;
  let { scope: r, all: i = null } = t || {};
  return {
    style: (s) => {
      let o = i;
      for (let a of s)
        for (let l of a.set) {
          let h = n[l.id];
          if (h) {
            o = o ? o + " " + h : h;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function KU(e, t) {
  let n = null;
  for (let r of e) {
    let i = r.style(t);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function JU(e, t, n, r = 0, i = e.length) {
  let s = new tj(r, Array.isArray(t) ? t : [t], n);
  s.highlightRange(e.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class tj {
  constructor(t, n, r) {
    this.at = t, this.highlighters = n, this.span = r, this.class = "";
  }
  startSpan(t, n) {
    n != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = n);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, n, r, i, s) {
    let { type: o, from: a, to: l } = t;
    if (a >= r || l <= n)
      return;
    o.isTop && (s = this.highlighters.filter((p) => !p.scope || p.scope(o)));
    let h = i, u = ej(t) || $g.empty, f = KU(s, u.tags);
    if (f && (h && (h += " "), h += f, u.mode == 1 && (i += (i ? " " : "") + f)), this.startSpan(Math.max(n, a), h), u.opaque)
      return;
    let d = t.tree && t.tree.prop(_e.mounted);
    if (d && d.overlay) {
      let p = t.node.enter(d.overlay[0].from + a, 1), g = this.highlighters.filter((y) => !y.scope || y.scope(d.tree.type)), m = t.firstChild();
      for (let y = 0, O = a; ; y++) {
        let x = y < d.overlay.length ? d.overlay[y] : null, _ = x ? x.from + a : l, w = Math.max(n, O), E = Math.min(r, _);
        if (w < E && m)
          for (; t.from < E && (this.highlightRange(t, w, E, i, s), this.startSpan(Math.min(E, t.to), h), !(t.to >= _ || !t.nextSibling())); )
            ;
        if (!x || _ > r)
          break;
        O = x.to + a, O > n && (this.highlightRange(p.cursor(), Math.max(n, x.from + a), Math.min(r, O), "", g), this.startSpan(Math.min(r, O), h));
      }
      m && t.parent();
    } else if (t.firstChild()) {
      d && (i = "");
      do
        if (!(t.to <= n)) {
          if (t.from >= r)
            break;
          this.highlightRange(t, n, r, i, s), this.startSpan(Math.min(r, t.to), h);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}
function ej(e) {
  let t = e.type.prop(QP);
  for (; t && t.context && !e.matchContext(t.context); )
    t = t.next;
  return t || null;
}
const Rt = is.define, R0 = Rt(), Ta = Rt(), hC = Rt(Ta), uC = Rt(Ta), Ea = Rt(), $0 = Rt(Ea), Ab = Rt(Ea), qs = Rt(), xl = Rt(qs), Qs = Rt(), Zs = Rt(), Cv = Rt(), tf = Rt(Cv), I0 = Rt(), j = {
  comment: R0,
  lineComment: Rt(R0),
  blockComment: Rt(R0),
  docComment: Rt(R0),
  name: Ta,
  variableName: Rt(Ta),
  typeName: hC,
  tagName: Rt(hC),
  propertyName: uC,
  attributeName: Rt(uC),
  className: Rt(Ta),
  labelName: Rt(Ta),
  namespace: Rt(Ta),
  macroName: Rt(Ta),
  literal: Ea,
  string: $0,
  docString: Rt($0),
  character: Rt($0),
  attributeValue: Rt($0),
  number: Ab,
  integer: Rt(Ab),
  float: Rt(Ab),
  bool: Rt(Ea),
  regexp: Rt(Ea),
  escape: Rt(Ea),
  color: Rt(Ea),
  url: Rt(Ea),
  keyword: Qs,
  self: Rt(Qs),
  null: Rt(Qs),
  atom: Rt(Qs),
  unit: Rt(Qs),
  modifier: Rt(Qs),
  operatorKeyword: Rt(Qs),
  controlKeyword: Rt(Qs),
  definitionKeyword: Rt(Qs),
  moduleKeyword: Rt(Qs),
  operator: Zs,
  derefOperator: Rt(Zs),
  arithmeticOperator: Rt(Zs),
  logicOperator: Rt(Zs),
  bitwiseOperator: Rt(Zs),
  compareOperator: Rt(Zs),
  updateOperator: Rt(Zs),
  definitionOperator: Rt(Zs),
  typeOperator: Rt(Zs),
  controlOperator: Rt(Zs),
  punctuation: Cv,
  separator: Rt(Cv),
  bracket: tf,
  angleBracket: Rt(tf),
  squareBracket: Rt(tf),
  paren: Rt(tf),
  brace: Rt(tf),
  content: qs,
  heading: xl,
  heading1: Rt(xl),
  heading2: Rt(xl),
  heading3: Rt(xl),
  heading4: Rt(xl),
  heading5: Rt(xl),
  heading6: Rt(xl),
  contentSeparator: Rt(qs),
  list: Rt(qs),
  quote: Rt(qs),
  emphasis: Rt(qs),
  strong: Rt(qs),
  link: Rt(qs),
  monospace: Rt(qs),
  strikethrough: Rt(qs),
  inserted: Rt(),
  deleted: Rt(),
  changed: Rt(),
  invalid: Rt(),
  meta: I0,
  documentMeta: Rt(I0),
  annotation: Rt(I0),
  processingInstruction: Rt(I0),
  definition: is.defineModifier(),
  constant: is.defineModifier(),
  function: is.defineModifier(),
  standard: is.defineModifier(),
  local: is.defineModifier(),
  special: is.defineModifier()
};
ZP([
  { tag: j.link, class: "tok-link" },
  { tag: j.heading, class: "tok-heading" },
  { tag: j.emphasis, class: "tok-emphasis" },
  { tag: j.strong, class: "tok-strong" },
  { tag: j.keyword, class: "tok-keyword" },
  { tag: j.atom, class: "tok-atom" },
  { tag: j.bool, class: "tok-bool" },
  { tag: j.url, class: "tok-url" },
  { tag: j.labelName, class: "tok-labelName" },
  { tag: j.inserted, class: "tok-inserted" },
  { tag: j.deleted, class: "tok-deleted" },
  { tag: j.literal, class: "tok-literal" },
  { tag: j.string, class: "tok-string" },
  { tag: j.number, class: "tok-number" },
  { tag: [j.regexp, j.escape, j.special(j.string)], class: "tok-string2" },
  { tag: j.variableName, class: "tok-variableName" },
  { tag: j.local(j.variableName), class: "tok-variableName tok-local" },
  { tag: j.definition(j.variableName), class: "tok-variableName tok-definition" },
  { tag: j.special(j.variableName), class: "tok-variableName2" },
  { tag: j.definition(j.propertyName), class: "tok-propertyName tok-definition" },
  { tag: j.typeName, class: "tok-typeName" },
  { tag: j.namespace, class: "tok-namespace" },
  { tag: j.className, class: "tok-className" },
  { tag: j.macroName, class: "tok-macroName" },
  { tag: j.propertyName, class: "tok-propertyName" },
  { tag: j.operator, class: "tok-operator" },
  { tag: j.comment, class: "tok-comment" },
  { tag: j.meta, class: "tok-meta" },
  { tag: j.invalid, class: "tok-invalid" },
  { tag: j.punctuation, class: "tok-punctuation" }
]);
var Pb;
const Ql = /* @__PURE__ */ new _e();
function gw(e) {
  return Ft.define({
    combine: e ? (t) => t.concat(e) : void 0
  });
}
const mw = /* @__PURE__ */ new _e();
class Ni {
  constructor(t, n, r = [], i = "") {
    this.data = t, this.name = i, De.prototype.hasOwnProperty("tree") || Object.defineProperty(De.prototype, "tree", { get() {
      return en(this);
    } }), this.parser = n, this.extension = [
      nl.of(this),
      De.languageData.of((s, o, a) => {
        let l = fC(s, o, a), h = l.type.prop(Ql);
        if (!h)
          return [];
        let u = s.facet(h), f = l.type.prop(mw);
        if (f) {
          let d = l.resolve(o - l.from, a);
          for (let p of f)
            if (p.test(d, s)) {
              let g = s.facet(p.facet);
              return p.type == "replace" ? g : g.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  isActiveAt(t, n, r = -1) {
    return fC(t, n, r).type.prop(Ql) == this.data;
  }
  findRegions(t) {
    let n = t.facet(nl);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(Ql) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let a = s.prop(_e.mounted);
      if (a) {
        if (a.tree.prop(Ql) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + o, to: l.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (i(a.tree, a.overlay[0].from + o), r.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let h = s.children[l];
        h instanceof ze && i(h, s.positions[l] + o);
      }
    };
    return i(en(t), 0), r;
  }
  get allowsNesting() {
    return !0;
  }
}
Ni.setState = /* @__PURE__ */ le.define();
function fC(e, t, n) {
  let r = e.facet(nl), i = en(e).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(t, n, tn.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class Qh extends Ni {
  constructor(t, n, r) {
    super(t, n, [], r), this.parser = n;
  }
  static define(t) {
    let n = gw(t.languageData);
    return new Qh(n, t.parser.configure({
      props: [Ql.add((r) => r.isTop ? n : void 0)]
    }), t.name);
  }
  configure(t, n) {
    return new Qh(this.data, this.parser.configure(t), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function en(e) {
  let t = e.field(Ni.state, !1);
  return t ? t.tree : ze.empty;
}
class nj {
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, n) {
    let r = this.cursorPos - this.string.length;
    return t < r || n >= this.cursorPos ? this.doc.sliceString(t, n) : this.string.slice(t - r, n - r);
  }
}
let ef = null;
class Sd {
  constructor(t, n, r = [], i, s, o, a, l) {
    this.parser = t, this.state = n, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  static create(t, n, r) {
    return new Sd(t, n, [], ze.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new nj(this.state.doc), this.fragments);
  }
  work(t, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != ze.empty && this.isDone(n != null ? n : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof t == "number") {
        let i = Date.now() + t;
        t = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(Jo.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n != null ? n : this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  takeTree() {
    let t, n;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = n, this.fragments = this.withoutTempSkipped(Jo.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let n = ef;
    ef = this;
    try {
      return t();
    } finally {
      ef = n;
    }
  }
  withoutTempSkipped(t) {
    for (let n; n = this.tempSkipped.pop(); )
      t = dC(t, n.from, n.to);
    return t;
  }
  changes(t, n) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: a } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((h, u, f, d) => l.push({ fromA: h, toA: u, fromB: f, toB: d })), r = Jo.applyChanges(r, l), i = ze.empty, s = 0, o = { from: t.mapPos(o.from, -1), to: t.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let h of this.skipped) {
          let u = t.mapPos(h.from, 1), f = t.mapPos(h.to, -1);
          u < f && a.push({ from: u, to: f });
        }
      }
    }
    return new Sd(this.parser, n, r, i, s, o, a, this.scheduleOn);
  }
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < t.to && s > t.from && (this.fragments = dC(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  skipUntilInView(t, n) {
    this.skipped.push({ from: t, to: n });
  }
  static getSkippingParser(t) {
    return new class extends pw {
      createParse(n, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = ef;
            if (l) {
              for (let h of i)
                l.tempSkipped.push(h);
              t && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, t]) : t);
            }
            return this.parsedPos = o, new ze(Jn.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= t && n.length && n[0].from == 0 && n[0].to >= t;
  }
  static get() {
    return ef;
  }
}
function dC(e, t, n) {
  return Jo.applyChanges(e, [{ fromA: t, toA: n, fromB: t, toB: n }]);
}
class Zh {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(t.changes, t.state), r = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new Zh(n);
  }
  static init(t) {
    let n = Math.min(3e3, t.doc.length), r = Sd.create(t.facet(nl).parser, t, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new Zh(r);
  }
}
Ni.state = /* @__PURE__ */ bn.define({
  create: Zh.init,
  update(e, t) {
    for (let n of t.effects)
      if (n.is(Ni.setState))
        return n.value;
    return t.startState.facet(nl) != t.state.facet(nl) ? Zh.init(t.state) : e.apply(t);
  }
});
let VP = (e) => {
  let t = setTimeout(() => e(), 500);
  return () => clearTimeout(t);
};
typeof requestIdleCallback < "u" && (VP = (e) => {
  let t = -1, n = setTimeout(() => {
    t = requestIdleCallback(e, { timeout: 500 - 100 });
  }, 100);
  return () => t < 0 ? clearTimeout(n) : cancelIdleCallback(t);
});
const Db = typeof navigator < "u" && ((Pb = navigator.scheduling) === null || Pb === void 0 ? void 0 : Pb.isInputPending) ? () => navigator.scheduling.isInputPending() : null, rj = /* @__PURE__ */ He.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let n = this.view.state.field(Ni.state).context;
    (n.updateViewport(t.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, n = t.field(Ni.state);
    (n.tree != n.context.tree || !n.context.isDone(t.doc.length)) && (this.working = VP(this.work));
  }
  work(t) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field(Ni.state);
    if (s.tree == s.context.tree && s.context.isDone(i + 1e5))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, t && !Db ? Math.max(25, t.timeRemaining() - 5) : 1e9), a = s.context.treeLen < i && r.doc.length > i + 1e3, l = s.context.work(() => Db && Db() || Date.now() > o, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: Ni.setState.of(new Zh(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((n) => Qi(this.view.state, n)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), nl = /* @__PURE__ */ Ft.define({
  combine(e) {
    return e.length ? e[0] : null;
  },
  enables: (e) => [
    Ni.state,
    rj,
    Pt.contentAttributes.compute([e], (t) => {
      let n = t.facet(e);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class Cd {
  constructor(t, n = []) {
    this.language = t, this.support = n, this.extension = [t, n];
  }
}
class Ig {
  constructor(t, n, r, i, s, o = void 0) {
    this.name = t, this.alias = n, this.extensions = r, this.filename = i, this.loadFunc = s, this.support = o, this.loading = null;
  }
  load() {
    return this.loading || (this.loading = this.loadFunc().then((t) => this.support = t, (t) => {
      throw this.loading = null, t;
    }));
  }
  static of(t) {
    let { load: n, support: r } = t;
    if (!n) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      n = () => Promise.resolve(r);
    }
    return new Ig(t.name, (t.alias || []).concat(t.name).map((i) => i.toLowerCase()), t.extensions || [], t.filename, n, r);
  }
  static matchFilename(t, n) {
    for (let i of t)
      if (i.filename && i.filename.test(n))
        return i;
    let r = /\.([^.]+)$/.exec(n);
    if (r) {
      for (let i of t)
        if (i.extensions.indexOf(r[1]) > -1)
          return i;
    }
    return null;
  }
  static matchLanguageName(t, n, r = !0) {
    n = n.toLowerCase();
    for (let i of t)
      if (i.alias.some((s) => s == n))
        return i;
    if (r)
      for (let i of t)
        for (let s of i.alias) {
          let o = n.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(n[o - 1]) && !/\w/.test(n[o + s.length])))
            return i;
        }
    return null;
  }
}
const ij = /* @__PURE__ */ Ft.define(), Np = /* @__PURE__ */ Ft.define({
  combine: (e) => {
    if (!e.length)
      return "  ";
    let t = e[0];
    if (!t || /\S/.test(t) || Array.from(t).some((n) => n != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(e[0]));
    return t;
  }
});
function Ng(e) {
  let t = e.facet(Np);
  return t.charCodeAt(0) == 9 ? e.tabSize * t.length : t.length;
}
function Td(e, t) {
  let n = "", r = e.tabSize, i = e.facet(Np)[0];
  if (i == "	") {
    for (; t >= r; )
      n += "	", t -= r;
    i = " ";
  }
  for (let s = 0; s < t; s++)
    n += i;
  return n;
}
function yw(e, t) {
  e instanceof De && (e = new F2(e));
  for (let r of e.state.facet(ij)) {
    let i = r(e, t);
    if (i !== void 0)
      return i;
  }
  let n = en(e.state);
  return n.length >= t ? sj(e, n, t) : null;
}
class F2 {
  constructor(t, n = {}) {
    this.state = t, this.options = n, this.unit = Ng(t);
  }
  lineAt(t, n = 1) {
    let r = this.state.doc.lineAt(t), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == t ? { text: "", from: t } : (n < 0 ? i < t : i <= t) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  textAfterPos(t, n = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(t, n);
    return r.slice(t - i, Math.min(r.length, t + 100 - i));
  }
  column(t, n = 1) {
    let { text: r, from: i } = this.lineAt(t, n), s = this.countColumn(r, t - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  countColumn(t, n = t.length) {
    return Os(t, this.state.tabSize, n);
  }
  lineIndent(t, n = 1) {
    let { text: r, from: i } = this.lineAt(t, n), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Bp = /* @__PURE__ */ new _e();
function sj(e, t, n) {
  let r = t.resolveStack(n), i = r.node.enterUnfinishedNodesBefore(n);
  if (i != r.node) {
    let s = [];
    for (let o = i; o != r.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return YP(r, e, n);
}
function YP(e, t, n) {
  for (let r = e; r; r = r.next) {
    let i = aj(r.node);
    if (i)
      return i(bw.create(t, n, r));
  }
  return 0;
}
function oj(e) {
  return e.pos == e.options.simulateBreak && e.options.simulateDoubleBreak;
}
function aj(e) {
  let t = e.type.prop(Bp);
  if (t)
    return t;
  let n = e.firstChild, r;
  if (n && (r = n.type.prop(_e.closedBy))) {
    let i = e.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => zP(o, !0, 1, void 0, s && !oj(o) ? i.from : void 0);
  }
  return e.parent == null ? lj : null;
}
function lj() {
  return 0;
}
class bw extends F2 {
  constructor(t, n, r) {
    super(t.state, t.options), this.base = t, this.pos = n, this.context = r;
  }
  get node() {
    return this.context.node;
  }
  static create(t, n, r) {
    return new bw(t, n, r);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(t) {
    let n = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let r = t.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (cj(r, t))
        break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  continue() {
    return YP(this.context.next, this.base, this.pos);
  }
}
function cj(e, t) {
  for (let n = t; n; n = n.parent)
    if (e == n)
      return !0;
  return !1;
}
function hj(e) {
  let t = e.node, n = t.childAfter(t.from), r = t.lastChild;
  if (!n)
    return null;
  let i = e.options.simulateBreak, s = e.state.doc.lineAt(n.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let a = n.to; ; ) {
    let l = t.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped)
      return l.from < o ? n : null;
    a = l.to;
  }
}
function uj({ closing: e, align: t = !0, units: n = 1 }) {
  return (r) => zP(r, t, n, e);
}
function zP(e, t, n, r, i) {
  let s = e.textAfter, o = s.match(/^\s*/)[0].length, a = r && s.slice(o, o + r.length) == r || i == e.pos + o, l = t ? hj(e) : null;
  return l ? a ? e.column(l.from) : e.column(l.to) : e.baseIndent + (a ? 0 : e.unit * n);
}
const fj = (e) => e.baseIndent;
function Q1({ except: e, units: t = 1 } = {}) {
  return (n) => {
    let r = e && e.test(n.textAfter);
    return n.baseIndent + (r ? 0 : t * n.unit);
  };
}
const dj = 200;
function pj() {
  return De.transactionFilter.of((e) => {
    if (!e.docChanged || !e.isUserEvent("input.type") && !e.isUserEvent("input.complete"))
      return e;
    let t = e.startState.languageDataAt("indentOnInput", e.startState.selection.main.head);
    if (!t.length)
      return e;
    let n = e.newDoc, { head: r } = e.newSelection.main, i = n.lineAt(r);
    if (r > i.from + dj)
      return e;
    let s = n.sliceString(i.from, r);
    if (!t.some((h) => h.test(s)))
      return e;
    let { state: o } = e, a = -1, l = [];
    for (let { head: h } of o.selection.ranges) {
      let u = o.doc.lineAt(h);
      if (u.from == a)
        continue;
      a = u.from;
      let f = yw(o, u.from);
      if (f == null)
        continue;
      let d = /^\s*/.exec(u.text)[0], p = Td(o, f);
      d != p && l.push({ from: u.from, to: u.from + d.length, insert: p });
    }
    return l.length ? [e, { changes: l, sequential: !0 }] : e;
  });
}
const qP = /* @__PURE__ */ Ft.define(), Eu = /* @__PURE__ */ new _e();
function WP(e) {
  let t = e.firstChild, n = e.lastChild;
  return t && t.to < n.from ? { from: t.to, to: n.type.isError ? e.to : n.from } : null;
}
function gj(e, t, n) {
  let r = en(e);
  if (r.length < n)
    return null;
  let i = r.resolveStack(n, 1), s = null;
  for (let o = i; o; o = o.next) {
    let a = o.node;
    if (a.to <= n || a.from > n)
      continue;
    if (s && a.from < t)
      break;
    let l = a.type.prop(Eu);
    if (l && (a.to < r.length - 50 || r.length == e.doc.length || !mj(a))) {
      let h = l(a, e);
      h && h.from <= n && h.from >= t && h.to > n && (s = h);
    }
  }
  return s;
}
function mj(e) {
  let t = e.lastChild;
  return t && t.to == e.to && t.type.isError;
}
function Bg(e, t, n) {
  for (let r of e.facet(qP)) {
    let i = r(e, t, n);
    if (i)
      return i;
  }
  return gj(e, t, n);
}
function UP(e, t) {
  let n = t.mapPos(e.from, 1), r = t.mapPos(e.to, -1);
  return n >= r ? void 0 : { from: n, to: r };
}
const Q2 = /* @__PURE__ */ le.define({ map: UP }), Fp = /* @__PURE__ */ le.define({ map: UP });
function jP(e) {
  let t = [];
  for (let { head: n } of e.state.selection.ranges)
    t.some((r) => r.from <= n && r.to >= n) || t.push(e.lineBlockAt(n));
  return t;
}
const ic = /* @__PURE__ */ bn.define({
  create() {
    return Bt.none;
  },
  update(e, t) {
    e = e.map(t.changes);
    for (let n of t.effects)
      if (n.is(Q2) && !yj(e, n.value.from, n.value.to)) {
        let { preparePlaceholder: r } = t.state.facet(Ow), i = r ? Bt.replace({ widget: new wj(r(t.state, n.value)) }) : pC;
        e = e.update({ add: [i.range(n.value.from, n.value.to)] });
      } else
        n.is(Fp) && (e = e.update({
          filter: (r, i) => n.value.from != r || n.value.to != i,
          filterFrom: n.value.from,
          filterTo: n.value.to
        }));
    if (t.selection) {
      let n = !1, { head: r } = t.selection.main;
      e.between(r, r, (i, s) => {
        i < r && s > r && (n = !0);
      }), n && (e = e.update({
        filterFrom: r,
        filterTo: r,
        filter: (i, s) => s <= r || i >= r
      }));
    }
    return e;
  },
  provide: (e) => Pt.decorations.from(e),
  toJSON(e, t) {
    let n = [];
    return e.between(0, t.doc.length, (r, i) => {
      n.push(r, i);
    }), n;
  },
  fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let t = [];
    for (let n = 0; n < e.length; ) {
      let r = e[n++], i = e[n++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      t.push(pC.range(r, i));
    }
    return Bt.set(t, !0);
  }
});
function Fg(e, t, n) {
  var r;
  let i = null;
  return (r = e.field(ic, !1)) === null || r === void 0 || r.between(t, n, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function yj(e, t, n) {
  let r = !1;
  return e.between(t, t, (i, s) => {
    i == t && s == n && (r = !0);
  }), r;
}
function XP(e, t) {
  return e.field(ic, !1) ? t : t.concat(le.appendConfig.of(HP()));
}
const bj = (e) => {
  for (let t of jP(e)) {
    let n = Bg(e.state, t.from, t.to);
    if (n)
      return e.dispatch({ effects: XP(e.state, [Q2.of(n), GP(e, n)]) }), !0;
  }
  return !1;
}, Oj = (e) => {
  if (!e.state.field(ic, !1))
    return !1;
  let t = [];
  for (let n of jP(e)) {
    let r = Fg(e.state, n.from, n.to);
    r && t.push(Fp.of(r), GP(e, r, !1));
  }
  return t.length && e.dispatch({ effects: t }), t.length > 0;
};
function GP(e, t, n = !0) {
  let r = e.state.doc.lineAt(t.from).number, i = e.state.doc.lineAt(t.to).number;
  return Pt.announce.of(`${e.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${e.state.phrase("to")} ${i}.`);
}
const xj = (e) => {
  let { state: t } = e, n = [];
  for (let r = 0; r < t.doc.length; ) {
    let i = e.lineBlockAt(r), s = Bg(t, i.from, i.to);
    s && n.push(Q2.of(s)), r = (s ? e.lineBlockAt(s.to) : i).to + 1;
  }
  return n.length && e.dispatch({ effects: XP(e.state, n) }), !!n.length;
}, vj = (e) => {
  let t = e.state.field(ic, !1);
  if (!t || !t.size)
    return !1;
  let n = [];
  return t.between(0, e.state.doc.length, (r, i) => {
    n.push(Fp.of({ from: r, to: i }));
  }), e.dispatch({ effects: n }), !0;
}, _j = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: bj },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Oj },
  { key: "Ctrl-Alt-[", run: xj },
  { key: "Ctrl-Alt-]", run: vj }
], kj = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "\u2026"
}, Ow = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, kj);
  }
});
function HP(e) {
  let t = [ic, Tj];
  return e && t.push(Ow.of(e)), t;
}
function KP(e, t) {
  let { state: n } = e, r = n.facet(Ow), i = (o) => {
    let a = e.lineBlockAt(e.posAtDOM(o.target)), l = Fg(e.state, a.from, a.to);
    l && e.dispatch({ effects: Fp.of(l) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(e, i, t);
  let s = document.createElement("span");
  return s.textContent = r.placeholderText, s.setAttribute("aria-label", n.phrase("folded code")), s.title = n.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const pC = /* @__PURE__ */ Bt.replace({ widget: /* @__PURE__ */ new class extends si {
  toDOM(e) {
    return KP(e, null);
  }
}() });
class wj extends si {
  constructor(t) {
    super(), this.value = t;
  }
  eq(t) {
    return this.value == t.value;
  }
  toDOM(t) {
    return KP(t, this.value);
  }
}
const Sj = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Lb extends Yi {
  constructor(t, n) {
    super(), this.config = t, this.open = n;
  }
  eq(t) {
    return this.config == t.config && this.open == t.open;
  }
  toDOM(t) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function Cj(e = {}) {
  let t = Object.assign(Object.assign({}, Sj), e), n = new Lb(t, !0), r = new Lb(t, !1), i = He.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(nl) != o.state.facet(nl) || o.startState.field(ic, !1) != o.state.field(ic, !1) || en(o.startState) != en(o.state) || t.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new cr();
      for (let l of o.viewportLineBlocks) {
        let h = Fg(o.state, l.from, l.to) ? r : Bg(o.state, l.from, l.to) ? n : null;
        h && a.add(l.from, l.from, h);
      }
      return a.finish();
    }
  }), { domEventHandlers: s } = t;
  return [
    i,
    B2({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || Ne.empty;
      },
      initialSpacer() {
        return new Lb(t, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, a, l) => {
        if (s.click && s.click(o, a, l))
          return !0;
        let h = Fg(o.state, a.from, a.to);
        if (h)
          return o.dispatch({ effects: Fp.of(h) }), !0;
        let u = Bg(o.state, a.from, a.to);
        return u ? (o.dispatch({ effects: Q2.of(u) }), !0) : !1;
      } })
    }),
    HP()
  ];
}
const Tj = /* @__PURE__ */ Pt.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Z2 {
  constructor(t, n) {
    this.specs = t;
    let r;
    function i(a) {
      let l = sa.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, o = n.scope;
    this.scope = o instanceof Ni ? (a) => a.prop(Ql) == o.data : o ? (a) => a == o : void 0, this.style = ZP(t.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new sa(r) : null, this.themeType = n.themeType;
  }
  static define(t, n) {
    return new Z2(t, n || {});
  }
}
const Tv = /* @__PURE__ */ Ft.define(), JP = /* @__PURE__ */ Ft.define({
  combine(e) {
    return e.length ? [e[0]] : null;
  }
});
function Mb(e) {
  let t = e.facet(Tv);
  return t.length ? t : e.facet(JP);
}
function tD(e, t) {
  let n = [Aj], r;
  return e instanceof Z2 && (e.module && n.push(Pt.styleModule.of(e.module)), r = e.themeType), t != null && t.fallback ? n.push(JP.of(e)) : r ? n.push(Tv.computeN([Pt.darkTheme], (i) => i.facet(Pt.darkTheme) == (r == "dark") ? [e] : [])) : n.push(Tv.of(e)), n;
}
class Ej {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = en(t.state), this.decorations = this.buildDeco(t, Mb(t.state));
  }
  update(t) {
    let n = en(t.state), r = Mb(t.state), i = r != Mb(t.startState);
    n.length < t.view.viewport.to && !i && n.type == this.tree.type ? this.decorations = this.decorations.map(t.changes) : (n != this.tree || t.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(t.view, r));
  }
  buildDeco(t, n) {
    if (!n || !this.tree.length)
      return Bt.none;
    let r = new cr();
    for (let { from: i, to: s } of t.visibleRanges)
      JU(this.tree, n, (o, a, l) => {
        r.add(o, a, this.markCache[l] || (this.markCache[l] = Bt.mark({ class: l })));
      }, i, s);
    return r.finish();
  }
}
const Aj = /* @__PURE__ */ Ts.high(/* @__PURE__ */ He.fromClass(Ej, {
  decorations: (e) => e.decorations
})), eD = /* @__PURE__ */ Z2.define([
  {
    tag: j.meta,
    color: "#404740"
  },
  {
    tag: j.link,
    textDecoration: "underline"
  },
  {
    tag: j.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: j.emphasis,
    fontStyle: "italic"
  },
  {
    tag: j.strong,
    fontWeight: "bold"
  },
  {
    tag: j.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: j.keyword,
    color: "#708"
  },
  {
    tag: [j.atom, j.bool, j.url, j.contentSeparator, j.labelName],
    color: "#219"
  },
  {
    tag: [j.literal, j.inserted],
    color: "#164"
  },
  {
    tag: [j.string, j.deleted],
    color: "#a11"
  },
  {
    tag: [j.regexp, j.escape, /* @__PURE__ */ j.special(j.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ j.definition(j.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ j.local(j.variableName),
    color: "#30a"
  },
  {
    tag: [j.typeName, j.namespace],
    color: "#085"
  },
  {
    tag: j.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ j.special(j.variableName), j.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ j.definition(j.propertyName),
    color: "#00c"
  },
  {
    tag: j.comment,
    color: "#940"
  },
  {
    tag: j.invalid,
    color: "#f00"
  }
]), Pj = /* @__PURE__ */ Pt.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), nD = 1e4, rD = "()[]{}", iD = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, {
      afterCursor: !0,
      brackets: rD,
      maxScanDistance: nD,
      renderMatch: Mj
    });
  }
}), Dj = /* @__PURE__ */ Bt.mark({ class: "cm-matchingBracket" }), Lj = /* @__PURE__ */ Bt.mark({ class: "cm-nonmatchingBracket" });
function Mj(e) {
  let t = [], n = e.matched ? Dj : Lj;
  return t.push(n.range(e.start.from, e.start.to)), e.end && t.push(n.range(e.end.from, e.end.to)), t;
}
const Rj = /* @__PURE__ */ bn.define({
  create() {
    return Bt.none;
  },
  update(e, t) {
    if (!t.docChanged && !t.selection)
      return e;
    let n = [], r = t.state.facet(iD);
    for (let i of t.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = to(t.state, i.head, -1, r) || i.head > 0 && to(t.state, i.head - 1, 1, r) || r.afterCursor && (to(t.state, i.head, 1, r) || i.head < t.state.doc.length && to(t.state, i.head + 1, -1, r));
      s && (n = n.concat(r.renderMatch(s, t.state)));
    }
    return Bt.set(n, !0);
  },
  provide: (e) => Pt.decorations.from(e)
}), $j = [
  Rj,
  Pj
];
function Ij(e = {}) {
  return [iD.of(e), $j];
}
const sD = /* @__PURE__ */ new _e();
function Ev(e, t, n) {
  let r = e.prop(t < 0 ? _e.openedBy : _e.closedBy);
  if (r)
    return r;
  if (e.name.length == 1) {
    let i = n.indexOf(e.name);
    if (i > -1 && i % 2 == (t < 0 ? 1 : 0))
      return [n[i + t]];
  }
  return null;
}
function Av(e) {
  let t = e.type.prop(sD);
  return t ? t(e.node) : e;
}
function to(e, t, n, r = {}) {
  let i = r.maxScanDistance || nD, s = r.brackets || rD, o = en(e), a = o.resolveInner(t, n);
  for (let l = a; l; l = l.parent) {
    let h = Ev(l.type, n, s);
    if (h && l.from < l.to) {
      let u = Av(l);
      if (u && (n > 0 ? t >= u.from && t < u.to : t > u.from && t <= u.to))
        return Nj(e, t, n, l, u, h, s);
    }
  }
  return Bj(e, t, n, o, a.type, i, s);
}
function Nj(e, t, n, r, i, s, o) {
  let a = r.parent, l = { from: i.from, to: i.to }, h = 0, u = a == null ? void 0 : a.cursor();
  if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (n < 0 ? u.to <= r.from : u.from >= r.to) {
        if (h == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let f = Av(u);
          return { start: l, end: f ? { from: f.from, to: f.to } : void 0, matched: !0 };
        } else if (Ev(u.type, n, o))
          h++;
        else if (Ev(u.type, -n, o)) {
          if (h == 0) {
            let f = Av(u);
            return {
              start: l,
              end: f && f.from < f.to ? { from: f.from, to: f.to } : void 0,
              matched: !1
            };
          }
          h--;
        }
      }
    while (n < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function Bj(e, t, n, r, i, s, o) {
  let a = n < 0 ? e.sliceDoc(t - 1, t) : e.sliceDoc(t, t + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != n > 0)
    return null;
  let h = { from: n < 0 ? t - 1 : t, to: n > 0 ? t + 1 : t }, u = e.doc.iterRange(t, n > 0 ? e.doc.length : 0), f = 0;
  for (let d = 0; !u.next().done && d <= s; ) {
    let p = u.value;
    n < 0 && (d += p.length);
    let g = t + d * n;
    for (let m = n > 0 ? 0 : p.length - 1, y = n > 0 ? p.length : -1; m != y; m += n) {
      let O = o.indexOf(p[m]);
      if (!(O < 0 || r.resolveInner(g + m, 1).type != i))
        if (O % 2 == 0 == n > 0)
          f++;
        else {
          if (f == 1)
            return { start: h, end: { from: g + m, to: g + m + 1 }, matched: O >> 1 == l >> 1 };
          f--;
        }
    }
    n > 0 && (d += p.length);
  }
  return u.done ? { start: h, matched: !1 } : null;
}
const Fj = /* @__PURE__ */ Object.create(null), gC = [Jn.none], mC = [], yC = /* @__PURE__ */ Object.create(null), Qj = /* @__PURE__ */ Object.create(null);
for (let [e, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  Qj[e] = /* @__PURE__ */ Zj(Fj, t);
function Rb(e, t) {
  mC.indexOf(e) > -1 || (mC.push(e), console.warn(t));
}
function Zj(e, t) {
  let n = [];
  for (let a of t.split(" ")) {
    let l = [];
    for (let h of a.split(".")) {
      let u = e[h] || j[h];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : Rb(h, `Modifier ${h} used at start of tag`) : l.length ? Rb(h, `Tag ${h} used as modifier`) : l = Array.isArray(u) ? u : [u] : Rb(h, `Unknown highlighting tag ${h}`);
    }
    for (let h of l)
      n.push(h);
  }
  if (!n.length)
    return 0;
  let r = t.replace(/ /g, "_"), i = r + " " + n.map((a) => a.id), s = yC[i];
  if (s)
    return s.id;
  let o = yC[i] = Jn.define({
    id: gC.length,
    name: r,
    props: [Tu({ [r]: n })]
  });
  return gC.push(o), o.id;
}
const Vj = (e) => {
  let { state: t } = e, n = t.doc.lineAt(t.selection.main.from), r = vw(e.state, n.from);
  return r.line ? Yj(e) : r.block ? qj(e) : !1;
};
function xw(e, t) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly)
      return !1;
    let i = e(t, n);
    return i ? (r(n.update(i)), !0) : !1;
  };
}
const Yj = /* @__PURE__ */ xw(jj, 0), zj = /* @__PURE__ */ xw(oD, 0), qj = /* @__PURE__ */ xw((e, t) => oD(e, t, Uj(t)), 0);
function vw(e, t) {
  let n = e.languageDataAt("commentTokens", t);
  return n.length ? n[0] : {};
}
const nf = 50;
function Wj(e, { open: t, close: n }, r, i) {
  let s = e.sliceDoc(r - nf, r), o = e.sliceDoc(i, i + nf), a = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(o)[0].length, h = s.length - a;
  if (s.slice(h - t.length, h) == t && o.slice(l, l + n.length) == n)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: i + l, margin: l && 1 }
    };
  let u, f;
  i - r <= 2 * nf ? u = f = e.sliceDoc(r, i) : (u = e.sliceDoc(r, r + nf), f = e.sliceDoc(i - nf, i));
  let d = /^\s*/.exec(u)[0].length, p = /\s*$/.exec(f)[0].length, g = f.length - p - n.length;
  return u.slice(d, d + t.length) == t && f.slice(g, g + n.length) == n ? {
    open: {
      pos: r + d + t.length,
      margin: /\s/.test(u.charAt(d + t.length)) ? 1 : 0
    },
    close: {
      pos: i - p - n.length,
      margin: /\s/.test(f.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
function Uj(e) {
  let t = [];
  for (let n of e.selection.ranges) {
    let r = e.doc.lineAt(n.from), i = n.to <= r.to ? r : e.doc.lineAt(n.to), s = t.length - 1;
    s >= 0 && t[s].to > r.from ? t[s].to = i.to : t.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return t;
}
function oD(e, t, n = t.selection.ranges) {
  let r = n.map((s) => vw(t, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = n.map((s, o) => Wj(t, r[o], s.from, s.to));
  if (e != 2 && !i.every((s) => s))
    return { changes: t.changes(n.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (e != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, a; o < i.length; o++)
      if (a = i[o]) {
        let l = r[o], { open: h, close: u } = a;
        s.push({ from: h.pos - l.open.length, to: h.pos + h.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function jj(e, t, n = t.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of n) {
    let a = r.length, l = 1e9, h = vw(t, s).line;
    if (!!h) {
      for (let u = s; u <= o; ) {
        let f = t.doc.lineAt(u);
        if (f.from > i && (s == o || o > f.from)) {
          i = f.from;
          let d = /^\s*/.exec(f.text)[0].length, p = d == f.length, g = f.text.slice(d, d + h.length) == h ? d : -1;
          d < f.text.length && d < l && (l = d), r.push({ line: f, comment: g, token: h, indent: d, empty: p, single: !1 });
        }
        u = f.to + 1;
      }
      if (l < 1e9)
        for (let u = a; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = l);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (e != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: h, empty: u, single: f } of r)
      (f || !u) && s.push({ from: a.from + h, insert: l + " " });
    let o = t.changes(s);
    return { changes: o, selection: t.selection.map(o, 1) };
  } else if (e != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: a, token: l } of r)
      if (a >= 0) {
        let h = o.from + a, u = h + l.length;
        o.text[u - o.from] == " " && u++, s.push({ from: h, to: u });
      }
    return { changes: s };
  }
  return null;
}
const Pv = /* @__PURE__ */ Es.define(), Xj = /* @__PURE__ */ Es.define(), Gj = /* @__PURE__ */ Ft.define(), aD = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (t, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (t, n) => (r, i) => t(r, i) || n(r, i)
    });
  }
}), lD = /* @__PURE__ */ bn.define({
  create() {
    return eo.empty;
  },
  update(e, t) {
    let n = t.state.facet(aD), r = t.annotation(Pv);
    if (r) {
      let l = ei.fromTransaction(t, r.selection), h = r.side, u = h == 0 ? e.undone : e.done;
      return l ? u = Zg(u, u.length, n.minDepth, l) : u = uD(u, t.startState.selection), new eo(h == 0 ? r.rest : u, h == 0 ? u : r.rest);
    }
    let i = t.annotation(Xj);
    if ((i == "full" || i == "before") && (e = e.isolate()), t.annotation(Zn.addToHistory) === !1)
      return t.changes.empty ? e : e.addMapping(t.changes.desc);
    let s = ei.fromTransaction(t), o = t.annotation(Zn.time), a = t.annotation(Zn.userEvent);
    return s ? e = e.addChanges(s, o, a, n, t) : t.selection && (e = e.addSelection(t.startState.selection, o, a, n.newGroupDelay)), (i == "full" || i == "after") && (e = e.isolate()), e;
  },
  toJSON(e) {
    return { done: e.done.map((t) => t.toJSON()), undone: e.undone.map((t) => t.toJSON()) };
  },
  fromJSON(e) {
    return new eo(e.done.map(ei.fromJSON), e.undone.map(ei.fromJSON));
  }
});
function _w(e = {}) {
  return [
    lD,
    aD.of(e),
    Pt.domEventHandlers({
      beforeinput(t, n) {
        let r = t.inputType == "historyUndo" ? cD : t.inputType == "historyRedo" ? Qg : null;
        return r ? (t.preventDefault(), r(n)) : !1;
      }
    })
  ];
}
function V2(e, t) {
  return function({ state: n, dispatch: r }) {
    if (!t && n.readOnly)
      return !1;
    let i = n.field(lD, !1);
    if (!i)
      return !1;
    let s = i.pop(e, n, t);
    return s ? (r(s), !0) : !1;
  };
}
const cD = /* @__PURE__ */ V2(0, !1), Qg = /* @__PURE__ */ V2(1, !1), Hj = /* @__PURE__ */ V2(0, !0), Kj = /* @__PURE__ */ V2(1, !0);
class ei {
  constructor(t, n, r, i, s) {
    this.changes = t, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(t) {
    return new ei(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, n, r;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(t) {
    return new ei(t.changes && $n.fromJSON(t.changes), [], t.mapped && oo.fromJSON(t.mapped), t.startSelection && mt.fromJSON(t.startSelection), t.selectionsAfter.map(mt.fromJSON));
  }
  static fromTransaction(t, n) {
    let r = Bi;
    for (let i of t.startState.facet(Gj)) {
      let s = i(t);
      s.length && (r = r.concat(s));
    }
    return !r.length && t.changes.empty ? null : new ei(t.changes.invert(t.startState.doc), r, void 0, n || t.startState.selection, Bi);
  }
  static selection(t) {
    return new ei(void 0, Bi, void 0, void 0, t);
  }
}
function Zg(e, t, n, r) {
  let i = t + 1 > n + 20 ? t - n - 1 : 0, s = e.slice(i, t);
  return s.push(r), s;
}
function Jj(e, t) {
  let n = [], r = !1;
  return e.iterChangedRanges((i, s) => n.push(i, s)), t.iterChangedRanges((i, s, o, a) => {
    for (let l = 0; l < n.length; ) {
      let h = n[l++], u = n[l++];
      a >= h && o <= u && (r = !0);
    }
  }), r;
}
function tX(e, t) {
  return e.ranges.length == t.ranges.length && e.ranges.filter((n, r) => n.empty != t.ranges[r].empty).length === 0;
}
function hD(e, t) {
  return e.length ? t.length ? e.concat(t) : e : t;
}
const Bi = [], eX = 200;
function uD(e, t) {
  if (e.length) {
    let n = e[e.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - eX));
    return r.length && r[r.length - 1].eq(t) ? e : (r.push(t), Zg(e, e.length - 1, 1e9, n.setSelAfter(r)));
  } else
    return [ei.selection([t])];
}
function nX(e) {
  let t = e[e.length - 1], n = e.slice();
  return n[e.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), n;
}
function $b(e, t) {
  if (!e.length)
    return e;
  let n = e.length, r = Bi;
  for (; n; ) {
    let i = rX(e[n - 1], t, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = e.slice(0, n);
      return s[n - 1] = i, s;
    } else
      t = i.mapped, n--, r = i.selectionsAfter;
  }
  return r.length ? [ei.selection(r)] : Bi;
}
function rX(e, t, n) {
  let r = hD(e.selectionsAfter.length ? e.selectionsAfter.map((a) => a.map(t)) : Bi, n);
  if (!e.changes)
    return ei.selection(r);
  let i = e.changes.map(t), s = t.mapDesc(e.changes, !0), o = e.mapped ? e.mapped.composeDesc(s) : s;
  return new ei(i, le.mapEffects(e.effects, t), o, e.startSelection.map(s), r);
}
const iX = /^(input\.type|delete)($|\.)/;
class eo {
  constructor(t, n, r = 0, i = void 0) {
    this.done = t, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new eo(this.done, this.undone) : this;
  }
  addChanges(t, n, r, i, s) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && t.changes && (!r || iX.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(s, Jj(a.changes, t.changes)) || r == "input.type.compose") ? o = Zg(o, o.length - 1, i.minDepth, new ei(t.changes.compose(a.changes), hD(t.effects, a.effects), a.mapped, a.startSelection, Bi)) : o = Zg(o, o.length, i.minDepth, t), new eo(o, Bi, n, r);
  }
  addSelection(t, n, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Bi;
    return s.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && tX(s[s.length - 1], t) ? this : new eo(uD(this.done, t), this.undone, n, r);
  }
  addMapping(t) {
    return new eo($b(this.done, t), $b(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, n, r) {
    let i = t == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || n.selection;
    if (r && s.selectionsAfter.length)
      return n.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: Pv.of({ side: t, rest: nX(i), selection: o }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let a = i.length == 1 ? Bi : i.slice(0, i.length - 1);
      return s.mapped && (a = $b(a, s.mapped)), n.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: Pv.of({ side: t, rest: a, selection: o }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
eo.empty = /* @__PURE__ */ new eo(Bi, Bi);
const fD = [
  { key: "Mod-z", run: cD, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Qg, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Qg, preventDefault: !0 },
  { key: "Mod-u", run: Hj, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: Kj, preventDefault: !0 }
];
function Au(e, t) {
  return mt.create(e.ranges.map(t), e.mainIndex);
}
function xo(e, t) {
  return e.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
function As({ state: e, dispatch: t }, n) {
  let r = Au(e.selection, n);
  return r.eq(e.selection) ? !1 : (t(xo(e, r)), !0);
}
function Y2(e, t) {
  return mt.cursor(t ? e.to : e.from);
}
function dD(e, t) {
  return As(e, (n) => n.empty ? e.moveByChar(n, t) : Y2(n, t));
}
function Dr(e) {
  return e.textDirectionAt(e.state.selection.main.head) == yn.LTR;
}
const pD = (e) => dD(e, !Dr(e)), gD = (e) => dD(e, Dr(e));
function mD(e, t) {
  return As(e, (n) => n.empty ? e.moveByGroup(n, t) : Y2(n, t));
}
const sX = (e) => mD(e, !Dr(e)), oX = (e) => mD(e, Dr(e));
function aX(e, t, n) {
  if (t.type.prop(n))
    return !0;
  let r = t.to - t.from;
  return r && (r > 2 || /[^\s,.;:]/.test(e.sliceDoc(t.from, t.to))) || t.firstChild;
}
function z2(e, t, n) {
  let r = en(e).resolveInner(t.head), i = n ? _e.closedBy : _e.openedBy;
  for (let l = t.head; ; ) {
    let h = n ? r.childAfter(l) : r.childBefore(l);
    if (!h)
      break;
    aX(e, h, i) ? r = h : l = n ? h.to : h.from;
  }
  let s = r.type.prop(i), o, a;
  return s && (o = n ? to(e, r.from, 1) : to(e, r.to, -1)) && o.matched ? a = n ? o.end.to : o.end.from : a = n ? r.to : r.from, mt.cursor(a, n ? -1 : 1);
}
const lX = (e) => As(e, (t) => z2(e.state, t, !Dr(e))), cX = (e) => As(e, (t) => z2(e.state, t, Dr(e)));
function yD(e, t) {
  return As(e, (n) => {
    if (!n.empty)
      return Y2(n, t);
    let r = e.moveVertically(n, t);
    return r.head != n.head ? r : e.moveToLineBoundary(n, t);
  });
}
const bD = (e) => yD(e, !1), OD = (e) => yD(e, !0);
function xD(e) {
  let t = e.scrollDOM.clientHeight < e.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
  if (t) {
    for (let s of e.state.facet(Pt.scrollMargins)) {
      let o = s(e);
      o != null && o.top && (n = Math.max(o == null ? void 0 : o.top, n)), o != null && o.bottom && (r = Math.max(o == null ? void 0 : o.bottom, r));
    }
    i = e.scrollDOM.clientHeight - n - r;
  } else
    i = (e.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: r,
    selfScroll: t,
    height: Math.max(e.defaultLineHeight, i - 5)
  };
}
function vD(e, t) {
  let n = xD(e), { state: r } = e, i = Au(r.selection, (o) => o.empty ? e.moveVertically(o, t, n.height) : Y2(o, t));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (n.selfScroll) {
    let o = e.coordsAtPos(r.selection.main.head), a = e.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, h = a.bottom - n.marginBottom;
    o && o.top > l && o.bottom < h && (s = Pt.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - l }));
  }
  return e.dispatch(xo(r, i), { effects: s }), !0;
}
const bC = (e) => vD(e, !1), Dv = (e) => vD(e, !0);
function fl(e, t, n) {
  let r = e.lineBlockAt(t.head), i = e.moveToLineBoundary(t, n);
  if (i.head == t.head && i.head != (n ? r.to : r.from) && (i = e.moveToLineBoundary(t, n, !1)), !n && i.head == r.from && r.length) {
    let s = /^\s*/.exec(e.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && t.head != r.from + s && (i = mt.cursor(r.from + s));
  }
  return i;
}
const hX = (e) => As(e, (t) => fl(e, t, !0)), uX = (e) => As(e, (t) => fl(e, t, !1)), fX = (e) => As(e, (t) => fl(e, t, !Dr(e))), dX = (e) => As(e, (t) => fl(e, t, Dr(e))), pX = (e) => As(e, (t) => mt.cursor(e.lineBlockAt(t.head).from, 1)), gX = (e) => As(e, (t) => mt.cursor(e.lineBlockAt(t.head).to, -1));
function mX(e, t, n) {
  let r = !1, i = Au(e.selection, (s) => {
    let o = to(e, s.head, -1) || to(e, s.head, 1) || s.head > 0 && to(e, s.head - 1, 1) || s.head < e.doc.length && to(e, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let a = o.start.from == s.head ? o.end.to : o.end.from;
    return n ? mt.range(s.anchor, a) : mt.cursor(a);
  });
  return r ? (t(xo(e, i)), !0) : !1;
}
const yX = ({ state: e, dispatch: t }) => mX(e, t, !1);
function Hi(e, t) {
  let n = Au(e.state.selection, (r) => {
    let i = t(r);
    return mt.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(e.state.selection) ? !1 : (e.dispatch(xo(e.state, n)), !0);
}
function _D(e, t) {
  return Hi(e, (n) => e.moveByChar(n, t));
}
const kD = (e) => _D(e, !Dr(e)), wD = (e) => _D(e, Dr(e));
function SD(e, t) {
  return Hi(e, (n) => e.moveByGroup(n, t));
}
const bX = (e) => SD(e, !Dr(e)), OX = (e) => SD(e, Dr(e)), xX = (e) => Hi(e, (t) => z2(e.state, t, !Dr(e))), vX = (e) => Hi(e, (t) => z2(e.state, t, Dr(e)));
function CD(e, t) {
  return Hi(e, (n) => e.moveVertically(n, t));
}
const TD = (e) => CD(e, !1), ED = (e) => CD(e, !0);
function AD(e, t) {
  return Hi(e, (n) => e.moveVertically(n, t, xD(e).height));
}
const OC = (e) => AD(e, !1), xC = (e) => AD(e, !0), _X = (e) => Hi(e, (t) => fl(e, t, !0)), kX = (e) => Hi(e, (t) => fl(e, t, !1)), wX = (e) => Hi(e, (t) => fl(e, t, !Dr(e))), SX = (e) => Hi(e, (t) => fl(e, t, Dr(e))), CX = (e) => Hi(e, (t) => mt.cursor(e.lineBlockAt(t.head).from)), TX = (e) => Hi(e, (t) => mt.cursor(e.lineBlockAt(t.head).to)), vC = ({ state: e, dispatch: t }) => (t(xo(e, { anchor: 0 })), !0), _C = ({ state: e, dispatch: t }) => (t(xo(e, { anchor: e.doc.length })), !0), kC = ({ state: e, dispatch: t }) => (t(xo(e, { anchor: e.selection.main.anchor, head: 0 })), !0), wC = ({ state: e, dispatch: t }) => (t(xo(e, { anchor: e.selection.main.anchor, head: e.doc.length })), !0), EX = ({ state: e, dispatch: t }) => (t(e.update({ selection: { anchor: 0, head: e.doc.length }, userEvent: "select" })), !0), AX = ({ state: e, dispatch: t }) => {
  let n = q2(e).map(({ from: r, to: i }) => mt.range(r, Math.min(i + 1, e.doc.length)));
  return t(e.update({ selection: mt.create(n), userEvent: "select" })), !0;
}, PX = ({ state: e, dispatch: t }) => {
  let n = Au(e.selection, (r) => {
    var i;
    let s = en(e).resolveStack(r.from, 1);
    for (let o = s; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && ((i = a.parent) === null || i === void 0 ? void 0 : i.parent))
        return mt.range(a.to, a.from);
    }
    return r;
  });
  return t(xo(e, n)), !0;
}, DX = ({ state: e, dispatch: t }) => {
  let n = e.selection, r = null;
  return n.ranges.length > 1 ? r = mt.create([n.main]) : n.main.empty || (r = mt.create([mt.cursor(n.main.head)])), r ? (t(xo(e, r)), !0) : !1;
};
function Qp(e, t) {
  if (e.state.readOnly)
    return !1;
  let n = "delete.selection", { state: r } = e, i = r.changeByRange((s) => {
    let { from: o, to: a } = s;
    if (o == a) {
      let l = t(s);
      l < o ? (n = "delete.backward", l = N0(e, l, !1)) : l > o && (n = "delete.forward", l = N0(e, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = N0(e, o, !1), a = N0(e, a, !0);
    return o == a ? { range: s } : { changes: { from: o, to: a }, range: mt.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (e.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? Pt.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function N0(e, t, n) {
  if (e instanceof Pt)
    for (let r of e.state.facet(Pt.atomicRanges).map((i) => i(e)))
      r.between(t, t, (i, s) => {
        i < t && s > t && (t = n ? s : i);
      });
  return t;
}
const PD = (e, t) => Qp(e, (n) => {
  let r = n.from, { state: i } = e, s = i.doc.lineAt(r), o, a;
  if (!t && r > s.from && r < s.from + 200 && !/[^ \t]/.test(o = s.text.slice(0, r - s.from))) {
    if (o[o.length - 1] == "	")
      return r - 1;
    let l = Os(o, i.tabSize), h = l % Ng(i) || Ng(i);
    for (let u = 0; u < h && o[o.length - 1 - u] == " "; u++)
      r--;
    a = r;
  } else
    a = mr(s.text, r - s.from, t, t) + s.from, a == r && s.number != (t ? i.doc.lines : 1) ? a += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(s.text.slice(a - s.from, r - s.from)) && (a = mr(s.text, a - s.from, !1, !1) + s.from);
  return a;
}), Lv = (e) => PD(e, !1), DD = (e) => PD(e, !0), LD = (e, t) => Qp(e, (n) => {
  let r = n.head, { state: i } = e, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (t ? s.to : s.from)) {
      r == n.head && s.number != (t ? i.doc.lines : 1) && (r += t ? 1 : -1);
      break;
    }
    let l = mr(s.text, r - s.from, t) + s.from, h = s.text.slice(Math.min(r, l) - s.from, Math.max(r, l) - s.from), u = o(h);
    if (a != null && u != a)
      break;
    (h != " " || r != n.head) && (a = u), r = l;
  }
  return r;
}), MD = (e) => LD(e, !1), LX = (e) => LD(e, !0), MX = (e) => Qp(e, (t) => {
  let n = e.lineBlockAt(t.head).to;
  return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1);
}), RX = (e) => Qp(e, (t) => {
  let n = e.moveToLineBoundary(t, !1).head;
  return t.head > n ? n : Math.max(0, t.head - 1);
}), $X = (e) => Qp(e, (t) => {
  let n = e.moveToLineBoundary(t, !0).head;
  return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1);
}), IX = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = e.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: Be.of(["", ""]) },
    range: mt.cursor(r.from)
  }));
  return t(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, NX = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = e.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == e.doc.length)
      return { range: r };
    let i = r.from, s = e.doc.lineAt(i), o = i == s.from ? i - 1 : mr(s.text, i - s.from, !1) + s.from, a = i == s.to ? i + 1 : mr(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: a, insert: e.doc.slice(i, a).append(e.doc.slice(o, i)) },
      range: mt.cursor(a)
    };
  });
  return n.changes.empty ? !1 : (t(e.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function q2(e) {
  let t = [], n = -1;
  for (let r of e.selection.ranges) {
    let i = e.doc.lineAt(r.from), s = e.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = e.doc.lineAt(r.to - 1)), n >= i.number) {
      let o = t[t.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      t.push({ from: i.from, to: s.to, ranges: [r] });
    n = s.number + 1;
  }
  return t;
}
function RD(e, t, n) {
  if (e.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of q2(e)) {
    if (n ? s.to == e.doc.length : s.from == 0)
      continue;
    let o = e.doc.lineAt(n ? s.to + 1 : s.from - 1), a = o.length + 1;
    if (n) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + e.lineBreak });
      for (let l of s.ranges)
        i.push(mt.range(Math.min(e.doc.length, l.anchor + a), Math.min(e.doc.length, l.head + a)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: e.lineBreak + o.text });
      for (let l of s.ranges)
        i.push(mt.range(l.anchor - a, l.head - a));
    }
  }
  return r.length ? (t(e.update({
    changes: r,
    scrollIntoView: !0,
    selection: mt.create(i, e.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const BX = ({ state: e, dispatch: t }) => RD(e, t, !1), FX = ({ state: e, dispatch: t }) => RD(e, t, !0);
function $D(e, t, n) {
  if (e.readOnly)
    return !1;
  let r = [];
  for (let i of q2(e))
    n ? r.push({ from: i.from, insert: e.doc.slice(i.from, i.to) + e.lineBreak }) : r.push({ from: i.to, insert: e.lineBreak + e.doc.slice(i.from, i.to) });
  return t(e.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const QX = ({ state: e, dispatch: t }) => $D(e, t, !1), ZX = ({ state: e, dispatch: t }) => $D(e, t, !0), VX = (e) => {
  if (e.state.readOnly)
    return !1;
  let { state: t } = e, n = t.changes(q2(t).map(({ from: i, to: s }) => (i > 0 ? i-- : s < t.doc.length && s++, { from: i, to: s }))), r = Au(t.selection, (i) => e.moveVertically(i, !0)).map(n);
  return e.dispatch({ changes: n, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function YX(e, t) {
  if (/\(\)|\[\]|\{\}/.test(e.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let n = en(e).resolveInner(t), r = n.childBefore(t), i = n.childAfter(t), s;
  return r && i && r.to <= t && i.from >= t && (s = r.type.prop(_e.closedBy)) && s.indexOf(i.name) > -1 && e.doc.lineAt(r.to).from == e.doc.lineAt(i.from).from && !/\S/.test(e.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const zX = /* @__PURE__ */ ID(!1), qX = /* @__PURE__ */ ID(!0);
function ID(e) {
  return ({ state: t, dispatch: n }) => {
    if (t.readOnly)
      return !1;
    let r = t.changeByRange((i) => {
      let { from: s, to: o } = i, a = t.doc.lineAt(s), l = !e && s == o && YX(t, s);
      e && (s = o = (o <= a.to ? a : t.doc.lineAt(o)).to);
      let h = new F2(t, { simulateBreak: s, simulateDoubleBreak: !!l }), u = yw(h, s);
      for (u == null && (u = Os(/^\s*/.exec(t.doc.lineAt(s).text)[0], t.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: s, to: o } = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let f = ["", Td(t, u)];
      return l && f.push(Td(t, h.lineIndent(a.from, -1))), {
        changes: { from: s, to: o, insert: Be.of(f) },
        range: mt.cursor(s + 1 + f[1].length)
      };
    });
    return n(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function kw(e, t) {
  let n = -1;
  return e.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let a = e.doc.lineAt(o);
      a.number > n && (r.empty || r.to > a.from) && (t(a, i, r), n = a.number), o = a.to + 1;
    }
    let s = e.changes(i);
    return {
      changes: i,
      range: mt.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const WX = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), r = new F2(e, { overrideIndentation: (s) => {
    let o = n[s];
    return o == null ? -1 : o;
  } }), i = kw(e, (s, o, a) => {
    let l = yw(r, s.from);
    if (l == null)
      return;
    /\S/.test(s.text) || (l = 0);
    let h = /^\s*/.exec(s.text)[0], u = Td(e, l);
    (h != u || a.from < s.from + h.length) && (n[s.from] = l, o.push({ from: s.from, to: s.from + h.length, insert: u }));
  });
  return i.changes.empty || t(e.update(i, { userEvent: "indent" })), !0;
}, ND = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(kw(e, (n, r) => {
  r.push({ from: n.from, insert: e.facet(Np) });
}), { userEvent: "input.indent" })), !0), BD = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(kw(e, (n, r) => {
  let i = /^\s*/.exec(n.text)[0];
  if (!i)
    return;
  let s = Os(i, e.tabSize), o = 0, a = Td(e, Math.max(0, s - Ng(e)));
  for (; o < i.length && o < a.length && i.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  r.push({ from: n.from + o, to: n.from + i.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), UX = [
  { key: "Ctrl-b", run: pD, shift: kD, preventDefault: !0 },
  { key: "Ctrl-f", run: gD, shift: wD },
  { key: "Ctrl-p", run: bD, shift: TD },
  { key: "Ctrl-n", run: OD, shift: ED },
  { key: "Ctrl-a", run: pX, shift: CX },
  { key: "Ctrl-e", run: gX, shift: TX },
  { key: "Ctrl-d", run: DD },
  { key: "Ctrl-h", run: Lv },
  { key: "Ctrl-k", run: MX },
  { key: "Ctrl-Alt-h", run: MD },
  { key: "Ctrl-o", run: IX },
  { key: "Ctrl-t", run: NX },
  { key: "Ctrl-v", run: Dv }
], jX = /* @__PURE__ */ [
  { key: "ArrowLeft", run: pD, shift: kD, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: sX, shift: bX, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: fX, shift: wX, preventDefault: !0 },
  { key: "ArrowRight", run: gD, shift: wD, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: oX, shift: OX, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: dX, shift: SX, preventDefault: !0 },
  { key: "ArrowUp", run: bD, shift: TD, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: vC, shift: kC },
  { mac: "Ctrl-ArrowUp", run: bC, shift: OC },
  { key: "ArrowDown", run: OD, shift: ED, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: _C, shift: wC },
  { mac: "Ctrl-ArrowDown", run: Dv, shift: xC },
  { key: "PageUp", run: bC, shift: OC },
  { key: "PageDown", run: Dv, shift: xC },
  { key: "Home", run: uX, shift: kX, preventDefault: !0 },
  { key: "Mod-Home", run: vC, shift: kC },
  { key: "End", run: hX, shift: _X, preventDefault: !0 },
  { key: "Mod-End", run: _C, shift: wC },
  { key: "Enter", run: zX },
  { key: "Mod-a", run: EX },
  { key: "Backspace", run: Lv, shift: Lv },
  { key: "Delete", run: DD },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: MD },
  { key: "Mod-Delete", mac: "Alt-Delete", run: LX },
  { mac: "Mod-Backspace", run: RX },
  { mac: "Mod-Delete", run: $X }
].concat(/* @__PURE__ */ UX.map((e) => ({ mac: e.key, run: e.run, shift: e.shift }))), FD = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: lX, shift: xX },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cX, shift: vX },
  { key: "Alt-ArrowUp", run: BX },
  { key: "Shift-Alt-ArrowUp", run: QX },
  { key: "Alt-ArrowDown", run: FX },
  { key: "Shift-Alt-ArrowDown", run: ZX },
  { key: "Escape", run: DX },
  { key: "Mod-Enter", run: qX },
  { key: "Alt-l", mac: "Ctrl-l", run: AX },
  { key: "Mod-i", run: PX, preventDefault: !0 },
  { key: "Mod-[", run: BD },
  { key: "Mod-]", run: ND },
  { key: "Mod-Alt-\\", run: WX },
  { key: "Shift-Mod-k", run: VX },
  { key: "Shift-Mod-\\", run: yX },
  { key: "Mod-/", run: Vj },
  { key: "Alt-A", run: zj }
].concat(jX), XX = { key: "Tab", run: ND, shift: BD };
function Je() {
  var e = arguments[0];
  typeof e == "string" && (e = document.createElement(e));
  var t = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n)
      if (Object.prototype.hasOwnProperty.call(n, r)) {
        var i = n[r];
        typeof i == "string" ? e.setAttribute(r, i) : i != null && (e[r] = i);
      }
    t++;
  }
  for (; t < arguments.length; t++)
    QD(e, arguments[t]);
  return e;
}
function QD(e, t) {
  if (typeof t == "string")
    e.appendChild(document.createTextNode(t));
  else if (t != null)
    if (t.nodeType != null)
      e.appendChild(t);
    else if (Array.isArray(t))
      for (var n = 0; n < t.length; n++)
        QD(e, t[n]);
    else
      throw new RangeError("Unsupported child node: " + t);
}
const SC = typeof String.prototype.normalize == "function" ? (e) => e.normalize("NFKD") : (e) => e;
class Vh {
  constructor(t, n, r = 0, i = t.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = t.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (a) => s(SC(a)) : SC, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return pr(this.buffer, this.bufferPos);
  }
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (; ; ) {
      let t = this.peek();
      if (t < 0)
        return this.done = !0, this;
      let n = Jk(t), r = this.bufferStart + this.bufferPos;
      this.bufferPos += Mi(t);
      let i = this.normalize(n);
      for (let s = 0, o = r; ; s++) {
        let a = i.charCodeAt(s), l = this.match(a, o);
        if (s == i.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        o == r && s < n.length && n.charCodeAt(s) == a && o++;
      }
    }
  }
  match(t, n) {
    let r = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let s = this.matches[i], o = !1;
      this.query.charCodeAt(s) == t && (s == this.query.length - 1 ? r = { from: this.matches[i + 1], to: n + 1 } : (this.matches[i]++, o = !0)), o || (this.matches.splice(i, 2), i -= 2);
    }
    return this.query.charCodeAt(0) == t && (this.query.length == 1 ? r = { from: n, to: n + 1 } : this.matches.push(1, n)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r;
  }
}
typeof Symbol < "u" && (Vh.prototype[Symbol.iterator] = function() {
  return this;
});
const ZD = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, ww = "gm" + (/x/.unicode == null ? "" : "u");
class VD {
  constructor(t, n, r, i = 0, s = t.length) {
    if (this.text = t, this.to = s, this.curLine = "", this.done = !1, this.value = ZD, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new YD(t, n, r, i, s);
    this.re = new RegExp(n, ww + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = t.iter();
    let o = t.lineAt(i);
    this.curLineStart = o.from, this.matchPos = Vg(t, i), this.getLine(this.curLineStart);
  }
  getLine(t) {
    this.iter.next(t), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  next() {
    for (let t = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = t;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index, i = r + n[0].length;
        if (this.matchPos = Vg(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this;
        t = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), t = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Ib = /* @__PURE__ */ new WeakMap();
class gh {
  constructor(t, n) {
    this.from = t, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(t, n, r) {
    let i = Ib.get(t);
    if (!i || i.from >= r || i.to <= n) {
      let a = new gh(n, t.sliceString(n, r));
      return Ib.set(t, a), a;
    }
    if (i.from == n && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > n && (s = t.sliceString(n, o) + s, o = n), i.to < r && (s += t.sliceString(i.to, r)), Ib.set(t, new gh(o, s)), new gh(n, s.slice(n - o, r - o));
  }
}
class YD {
  constructor(t, n, r, i, s) {
    this.text = t, this.to = s, this.done = !1, this.value = ZD, this.matchPos = Vg(t, i), this.re = new RegExp(n, ww + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = gh.get(t, i, this.chunkEnd(i + 5e3));
  }
  chunkEnd(t) {
    return t >= this.to ? this.to : this.text.lineAt(t).to;
  }
  next() {
    for (; ; ) {
      let t = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == t && (this.re.lastIndex = t + 1, n = this.re.exec(this.flat.text)), n) {
        let r = this.flat.from + n.index, i = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this.matchPos = Vg(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = gh.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (VD.prototype[Symbol.iterator] = YD.prototype[Symbol.iterator] = function() {
  return this;
});
function GX(e) {
  try {
    return new RegExp(e, ww), !0;
  } catch {
    return !1;
  }
}
function Vg(e, t) {
  if (t >= e.length)
    return t;
  let n = e.lineAt(t), r;
  for (; t < n.to && (r = n.text.charCodeAt(t - n.from)) >= 56320 && r < 57344; )
    t++;
  return t;
}
function Mv(e) {
  let t = String(e.state.doc.lineAt(e.state.selection.main.head).number), n = Je("input", { class: "cm-textfield", name: "line", value: t }), r = Je("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), e.dispatch({ effects: Yg.of(!1) }), e.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, Je("label", e.state.phrase("Go to line"), ": ", n), " ", Je("button", { class: "cm-button", type: "submit" }, e.state.phrase("go")));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!s)
      return;
    let { state: o } = e, a = o.doc.lineAt(o.selection.main.head), [, l, h, u, f] = s, d = u ? +u.slice(1) : 0, p = h ? +h : a.number;
    if (h && f) {
      let y = p / 100;
      l && (y = y * (l == "-" ? -1 : 1) + a.number / o.doc.lines), p = Math.round(o.doc.lines * y);
    } else
      h && l && (p = p * (l == "-" ? -1 : 1) + a.number);
    let g = o.doc.line(Math.max(1, Math.min(o.doc.lines, p))), m = mt.cursor(g.from + Math.max(0, Math.min(d, g.length)));
    e.dispatch({
      effects: [Yg.of(!1), Pt.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), e.focus();
  }
  return { dom: r };
}
const Yg = /* @__PURE__ */ le.define(), CC = /* @__PURE__ */ bn.define({
  create() {
    return !0;
  },
  update(e, t) {
    for (let n of t.effects)
      n.is(Yg) && (e = n.value);
    return e;
  },
  provide: (e) => _d.from(e, (t) => t ? Mv : null)
}), HX = (e) => {
  let t = vd(e, Mv);
  if (!t) {
    let n = [Yg.of(!0)];
    e.state.field(CC, !1) == null && n.push(le.appendConfig.of([CC, KX])), e.dispatch({ effects: n }), t = vd(e, Mv);
  }
  return t && t.dom.querySelector("input").select(), !0;
}, KX = /* @__PURE__ */ Pt.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), JX = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, zD = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, JX, {
      highlightWordAroundCursor: (t, n) => t || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function tG(e) {
  let t = [sG, iG];
  return e && t.push(zD.of(e)), t;
}
const eG = /* @__PURE__ */ Bt.mark({ class: "cm-selectionMatch" }), nG = /* @__PURE__ */ Bt.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function TC(e, t, n, r) {
  return (n == 0 || e(t.sliceDoc(n - 1, n)) != hn.Word) && (r == t.doc.length || e(t.sliceDoc(r, r + 1)) != hn.Word);
}
function rG(e, t, n, r) {
  return e(t.sliceDoc(n, n + 1)) == hn.Word && e(t.sliceDoc(r - 1, r)) == hn.Word;
}
const iG = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.decorations = this.getDeco(e);
  }
  update(e) {
    (e.selectionSet || e.docChanged || e.viewportChanged) && (this.decorations = this.getDeco(e.view));
  }
  getDeco(e) {
    let t = e.state.facet(zD), { state: n } = e, r = n.selection;
    if (r.ranges.length > 1)
      return Bt.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!t.highlightWordAroundCursor)
        return Bt.none;
      let l = n.wordAt(i.head);
      if (!l)
        return Bt.none;
      o = n.charCategorizer(i.head), s = n.sliceDoc(l.from, l.to);
    } else {
      let l = i.to - i.from;
      if (l < t.minSelectionLength || l > 200)
        return Bt.none;
      if (t.wholeWords) {
        if (s = n.sliceDoc(i.from, i.to), o = n.charCategorizer(i.head), !(TC(o, n, i.from, i.to) && rG(o, n, i.from, i.to)))
          return Bt.none;
      } else if (s = n.sliceDoc(i.from, i.to).trim(), !s)
        return Bt.none;
    }
    let a = [];
    for (let l of e.visibleRanges) {
      let h = new Vh(n.doc, s, l.from, l.to);
      for (; !h.next().done; ) {
        let { from: u, to: f } = h.value;
        if ((!o || TC(o, n, u, f)) && (i.empty && u <= i.from && f >= i.to ? a.push(nG.range(u, f)) : (u >= i.to || f <= i.from) && a.push(eG.range(u, f)), a.length > t.maxMatches))
          return Bt.none;
      }
    }
    return Bt.set(a);
  }
}, {
  decorations: (e) => e.decorations
}), sG = /* @__PURE__ */ Pt.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), oG = ({ state: e, dispatch: t }) => {
  let { selection: n } = e, r = mt.create(n.ranges.map((i) => e.wordAt(i.head) || mt.cursor(i.head)), n.mainIndex);
  return r.eq(n) ? !1 : (t(e.update({ selection: r })), !0);
};
function aG(e, t) {
  let { main: n, ranges: r } = e.selection, i = e.wordAt(n.head), s = i && i.from == n.from && i.to == n.to;
  for (let o = !1, a = new Vh(e.doc, t, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new Vh(e.doc, t, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((l) => l.from == a.value.from))
        continue;
      if (s) {
        let l = e.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const lG = ({ state: e, dispatch: t }) => {
  let { ranges: n } = e.selection;
  if (n.some((s) => s.from === s.to))
    return oG({ state: e, dispatch: t });
  let r = e.sliceDoc(n[0].from, n[0].to);
  if (e.selection.ranges.some((s) => e.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = aG(e, r);
  return i ? (t(e.update({
    selection: e.selection.addRange(mt.range(i.from, i.to), !1),
    effects: Pt.scrollIntoView(i.to)
  })), !0) : !1;
}, Pu = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (t) => new xG(t),
      scrollToMatch: (t) => Pt.scrollIntoView(t)
    });
  }
});
class qD {
  constructor(t) {
    this.search = t.search, this.caseSensitive = !!t.caseSensitive, this.literal = !!t.literal, this.regexp = !!t.regexp, this.replace = t.replace || "", this.valid = !!this.search && (!this.regexp || GX(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!t.wholeWord;
  }
  unquote(t) {
    return this.literal ? t : t.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  eq(t) {
    return this.search == t.search && this.replace == t.replace && this.caseSensitive == t.caseSensitive && this.regexp == t.regexp && this.wholeWord == t.wholeWord;
  }
  create() {
    return this.regexp ? new fG(this) : new hG(this);
  }
  getCursor(t, n = 0, r) {
    let i = t.doc ? t : De.create({ doc: t });
    return r == null && (r = i.doc.length), this.regexp ? qc(this, i, n, r) : zc(this, i, n, r);
  }
}
class WD {
  constructor(t) {
    this.spec = t;
  }
}
function zc(e, t, n, r) {
  return new Vh(t.doc, e.unquoted, n, r, e.caseSensitive ? void 0 : (i) => i.toLowerCase(), e.wholeWord ? cG(t.doc, t.charCategorizer(t.selection.main.head)) : void 0);
}
function cG(e, t) {
  return (n, r, i, s) => ((s > n || s + i.length < r) && (s = Math.max(0, n - 2), i = e.sliceString(s, Math.min(e.length, r + 2))), (t(zg(i, n - s)) != hn.Word || t(qg(i, n - s)) != hn.Word) && (t(qg(i, r - s)) != hn.Word || t(zg(i, r - s)) != hn.Word));
}
class hG extends WD {
  constructor(t) {
    super(t);
  }
  nextMatch(t, n, r) {
    let i = zc(this.spec, t, r, t.doc.length).nextOverlapping();
    return i.done && (i = zc(this.spec, t, 0, n).nextOverlapping()), i.done ? null : i.value;
  }
  prevMatchInRange(t, n, r) {
    for (let i = r; ; ) {
      let s = Math.max(n, i - 1e4 - this.spec.unquoted.length), o = zc(this.spec, t, s, i), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (s == n)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(t, n, r) {
    return this.prevMatchInRange(t, 0, n) || this.prevMatchInRange(t, r, t.doc.length);
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(t, n) {
    let r = zc(this.spec, t, 0, t.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(t, n, r, i) {
    let s = zc(this.spec, t, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, t.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function qc(e, t, n, r) {
  return new VD(t.doc, e.search, {
    ignoreCase: !e.caseSensitive,
    test: e.wholeWord ? uG(t.charCategorizer(t.selection.main.head)) : void 0
  }, n, r);
}
function zg(e, t) {
  return e.slice(mr(e, t, !1), t);
}
function qg(e, t) {
  return e.slice(t, mr(e, t));
}
function uG(e) {
  return (t, n, r) => !r[0].length || (e(zg(r.input, r.index)) != hn.Word || e(qg(r.input, r.index)) != hn.Word) && (e(qg(r.input, r.index + r[0].length)) != hn.Word || e(zg(r.input, r.index + r[0].length)) != hn.Word);
}
class fG extends WD {
  nextMatch(t, n, r) {
    let i = qc(this.spec, t, r, t.doc.length).next();
    return i.done && (i = qc(this.spec, t, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(t, n, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(n, r - i * 1e4), o = qc(this.spec, t, s, r), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (s == n || a.from > s + 10))
        return a;
      if (s == n)
        return null;
    }
  }
  prevMatch(t, n, r) {
    return this.prevMatchInRange(t, 0, n) || this.prevMatchInRange(t, r, t.doc.length);
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, r) => r == "$" ? "$" : r == "&" ? t.match[0] : r != "0" && +r < t.match.length ? t.match[r] : n);
  }
  matchAll(t, n) {
    let r = qc(this.spec, t, 0, t.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(t, n, r, i) {
    let s = qc(this.spec, t, Math.max(0, n - 250), Math.min(r + 250, t.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const Ed = /* @__PURE__ */ le.define(), Sw = /* @__PURE__ */ le.define(), Va = /* @__PURE__ */ bn.define({
  create(e) {
    return new Nb(Rv(e).create(), null);
  },
  update(e, t) {
    for (let n of t.effects)
      n.is(Ed) ? e = new Nb(n.value.create(), e.panel) : n.is(Sw) && (e = new Nb(e.query, n.value ? Cw : null));
    return e;
  },
  provide: (e) => _d.from(e, (t) => t.panel)
});
class Nb {
  constructor(t, n) {
    this.query = t, this.panel = n;
  }
}
const dG = /* @__PURE__ */ Bt.mark({ class: "cm-searchMatch" }), pG = /* @__PURE__ */ Bt.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), gG = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.view = e, this.decorations = this.highlight(e.state.field(Va));
  }
  update(e) {
    let t = e.state.field(Va);
    (t != e.startState.field(Va) || e.docChanged || e.selectionSet || e.viewportChanged) && (this.decorations = this.highlight(t));
  }
  highlight({ query: e, panel: t }) {
    if (!t || !e.spec.valid)
      return Bt.none;
    let { view: n } = this, r = new cr();
    for (let i = 0, s = n.visibleRanges, o = s.length; i < o; i++) {
      let { from: a, to: l } = s[i];
      for (; i < o - 1 && l > s[i + 1].from - 2 * 250; )
        l = s[++i].to;
      e.highlight(n.state, a, l, (h, u) => {
        let f = n.state.selection.ranges.some((d) => d.from == h && d.to == u);
        r.add(h, u, f ? pG : dG);
      });
    }
    return r.finish();
  }
}, {
  decorations: (e) => e.decorations
});
function Zp(e) {
  return (t) => {
    let n = t.state.field(Va, !1);
    return n && n.query.spec.valid ? e(t, n) : XD(t);
  };
}
const Wg = /* @__PURE__ */ Zp((e, { query: t }) => {
  let { to: n } = e.state.selection.main, r = t.nextMatch(e.state, n, n);
  if (!r)
    return !1;
  let i = mt.single(r.from, r.to), s = e.state.facet(Pu);
  return e.dispatch({
    selection: i,
    effects: [Tw(e, r), s.scrollToMatch(i.main, e)],
    userEvent: "select.search"
  }), jD(e), !0;
}), Ug = /* @__PURE__ */ Zp((e, { query: t }) => {
  let { state: n } = e, { from: r } = n.selection.main, i = t.prevMatch(n, r, r);
  if (!i)
    return !1;
  let s = mt.single(i.from, i.to), o = e.state.facet(Pu);
  return e.dispatch({
    selection: s,
    effects: [Tw(e, i), o.scrollToMatch(s.main, e)],
    userEvent: "select.search"
  }), jD(e), !0;
}), mG = /* @__PURE__ */ Zp((e, { query: t }) => {
  let n = t.matchAll(e.state, 1e3);
  return !n || !n.length ? !1 : (e.dispatch({
    selection: mt.create(n.map((r) => mt.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), yG = ({ state: e, dispatch: t }) => {
  let n = e.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: r, to: i } = n.main, s = [], o = 0;
  for (let a = new Vh(e.doc, e.sliceDoc(r, i)); !a.next().done; ) {
    if (s.length > 1e3)
      return !1;
    a.value.from == r && (o = s.length), s.push(mt.range(a.value.from, a.value.to));
  }
  return t(e.update({
    selection: mt.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, EC = /* @__PURE__ */ Zp((e, { query: t }) => {
  let { state: n } = e, { from: r, to: i } = n.selection.main;
  if (n.readOnly)
    return !1;
  let s = t.nextMatch(n, r, r);
  if (!s)
    return !1;
  let o = [], a, l, h = [];
  if (s.from == r && s.to == i && (l = n.toText(t.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: l }), s = t.nextMatch(n, s.from, s.to), h.push(Pt.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))), s) {
    let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - l.length;
    a = mt.single(s.from - u, s.to - u), h.push(Tw(e, s)), h.push(n.facet(Pu).scrollToMatch(a.main, e));
  }
  return e.dispatch({
    changes: o,
    selection: a,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), bG = /* @__PURE__ */ Zp((e, { query: t }) => {
  if (e.state.readOnly)
    return !1;
  let n = t.matchAll(e.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: t.getReplacement(i) };
  });
  if (!n.length)
    return !1;
  let r = e.state.phrase("replaced $ matches", n.length) + ".";
  return e.dispatch({
    changes: n,
    effects: Pt.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Cw(e) {
  return e.state.facet(Pu).createPanel(e);
}
function Rv(e, t) {
  var n, r, i, s, o;
  let a = e.selection.main, l = a.empty || a.to > a.from + 100 ? "" : e.sliceDoc(a.from, a.to);
  if (t && !l)
    return t;
  let h = e.facet(Pu);
  return new qD({
    search: ((n = t == null ? void 0 : t.literal) !== null && n !== void 0 ? n : h.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = t == null ? void 0 : t.caseSensitive) !== null && r !== void 0 ? r : h.caseSensitive,
    literal: (i = t == null ? void 0 : t.literal) !== null && i !== void 0 ? i : h.literal,
    regexp: (s = t == null ? void 0 : t.regexp) !== null && s !== void 0 ? s : h.regexp,
    wholeWord: (o = t == null ? void 0 : t.wholeWord) !== null && o !== void 0 ? o : h.wholeWord
  });
}
function UD(e) {
  let t = vd(e, Cw);
  return t && t.dom.querySelector("[main-field]");
}
function jD(e) {
  let t = UD(e);
  t && t == e.root.activeElement && t.select();
}
const XD = (e) => {
  let t = e.state.field(Va, !1);
  if (t && t.panel) {
    let n = UD(e);
    if (n && n != e.root.activeElement) {
      let r = Rv(e.state, t.query.spec);
      r.valid && e.dispatch({ effects: Ed.of(r) }), n.focus(), n.select();
    }
  } else
    e.dispatch({ effects: [
      Sw.of(!0),
      t ? Ed.of(Rv(e.state, t.query.spec)) : le.appendConfig.of(_G)
    ] });
  return !0;
}, GD = (e) => {
  let t = e.state.field(Va, !1);
  if (!t || !t.panel)
    return !1;
  let n = vd(e, Cw);
  return n && n.dom.contains(e.root.activeElement) && e.focus(), e.dispatch({ effects: Sw.of(!1) }), !0;
}, OG = [
  { key: "Mod-f", run: XD, scope: "editor search-panel" },
  { key: "F3", run: Wg, shift: Ug, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Wg, shift: Ug, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: GD, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: yG },
  { key: "Mod-Alt-g", run: HX },
  { key: "Mod-d", run: lG, preventDefault: !0 }
];
class xG {
  constructor(t) {
    this.view = t;
    let n = this.query = t.state.field(Va).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Je("input", {
      value: n.search,
      placeholder: ai(t, "Find"),
      "aria-label": ai(t, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Je("input", {
      value: n.replace,
      placeholder: ai(t, "Replace"),
      "aria-label": ai(t, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Je("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = Je("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = Je("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return Je("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = Je("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Wg(t), [ai(t, "next")]),
      r("prev", () => Ug(t), [ai(t, "previous")]),
      r("select", () => mG(t), [ai(t, "all")]),
      Je("label", null, [this.caseField, ai(t, "match case")]),
      Je("label", null, [this.reField, ai(t, "regexp")]),
      Je("label", null, [this.wordField, ai(t, "by word")]),
      ...t.state.readOnly ? [] : [
        Je("br"),
        this.replaceField,
        r("replace", () => EC(t), [ai(t, "replace")]),
        r("replaceAll", () => bG(t), [ai(t, "replace all")])
      ],
      Je("button", {
        name: "close",
        onclick: () => GD(t),
        "aria-label": ai(t, "close"),
        type: "button"
      }, ["\xD7"])
    ]);
  }
  commit() {
    let t = new qD({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    t.eq(this.query) || (this.query = t, this.view.dispatch({ effects: Ed.of(t) }));
  }
  keydown(t) {
    QW(this.view, t, "search-panel") ? t.preventDefault() : t.keyCode == 13 && t.target == this.searchField ? (t.preventDefault(), (t.shiftKey ? Ug : Wg)(this.view)) : t.keyCode == 13 && t.target == this.replaceField && (t.preventDefault(), EC(this.view));
  }
  update(t) {
    for (let n of t.transactions)
      for (let r of n.effects)
        r.is(Ed) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(t) {
    this.query = t, this.searchField.value = t.search, this.replaceField.value = t.replace, this.caseField.checked = t.caseSensitive, this.reField.checked = t.regexp, this.wordField.checked = t.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Pu).top;
  }
}
function ai(e, t) {
  return e.state.phrase(t);
}
const B0 = 30, F0 = /[\s\.,:;?!]/;
function Tw(e, { from: t, to: n }) {
  let r = e.state.doc.lineAt(t), i = e.state.doc.lineAt(n).to, s = Math.max(r.from, t - B0), o = Math.min(i, n + B0), a = e.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let l = 0; l < B0; l++)
      if (!F0.test(a[l + 1]) && F0.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != i) {
    for (let l = a.length - 1; l > a.length - B0; l--)
      if (!F0.test(a[l - 1]) && F0.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return Pt.announce.of(`${e.state.phrase("current match")}. ${a} ${e.state.phrase("on line")} ${r.number}.`);
}
const vG = /* @__PURE__ */ Pt.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), _G = [
  Va,
  /* @__PURE__ */ Ts.low(gG),
  vG
];
class Ew {
  constructor(t, n, r) {
    this.state = t, this.pos = n, this.explicit = r, this.abortListeners = [];
  }
  tokenBefore(t) {
    let n = en(this.state).resolveInner(this.pos, -1);
    for (; n && t.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  matchBefore(t) {
    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), s = i.search(KD(t, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(t, n) {
    t == "abort" && this.abortListeners && this.abortListeners.push(n);
  }
}
function AC(e) {
  let t = Object.keys(e).join(""), n = /\w/.test(t);
  return n && (t = t.replace(/\w/g, "")), `[${n ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
function kG(e) {
  let t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of e) {
    t[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      n[i[s]] = !0;
  }
  let r = AC(t) + AC(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function HD(e) {
  let t = e.map((i) => typeof i == "string" ? { label: i } : i), [n, r] = t.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : kG(t);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: t, validFor: n } : null;
  };
}
function wG(e, t) {
  return (n) => {
    for (let r = en(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
      if (e.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return t(n);
  };
}
class PC {
  constructor(t, n, r, i) {
    this.completion = t, this.source = n, this.match = r, this.score = i;
  }
}
function Ya(e) {
  return e.selection.main.from;
}
function KD(e, t) {
  var n;
  let { source: r } = e, i = t && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? e : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (n = e.flags) !== null && n !== void 0 ? n : e.ignoreCase ? "i" : "");
}
const JD = /* @__PURE__ */ Es.define();
function SG(e, t, n, r) {
  let { main: i } = e.selection, s = n - i.from, o = r - i.from;
  return Object.assign(Object.assign({}, e.changeByRange((a) => a != i && n != r && e.sliceDoc(a.from + s, a.from + o) != e.sliceDoc(n, r) ? { range: a } : {
    changes: { from: a.from + s, to: r == i.from ? a.to : a.from + o, insert: t },
    range: mt.cursor(a.from + s + t.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const DC = /* @__PURE__ */ new WeakMap();
function CG(e) {
  if (!Array.isArray(e))
    return e;
  let t = DC.get(e);
  return t || DC.set(e, t = HD(e)), t;
}
const Aw = /* @__PURE__ */ le.define(), Ad = /* @__PURE__ */ le.define();
class TG {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < t.length; ) {
      let r = pr(t, n), i = Mi(r);
      this.chars.push(r);
      let s = t.slice(n, n + i), o = s.toUpperCase();
      this.folded.push(pr(o == s ? s.toLowerCase() : o, 0)), n += i;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, n) {
    return this.score = t, this.matched = n, !0;
  }
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return !1;
    let { chars: n, folded: r, any: i, precise: s, byWord: o } = this;
    if (n.length == 1) {
      let x = pr(t, 0), _ = Mi(x), w = _ == t.length ? 0 : -100;
      if (x != n[0])
        if (x == r[0])
          w += -200;
        else
          return !1;
      return this.ret(w, [0, _]);
    }
    let a = t.indexOf(this.pattern);
    if (a == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = n.length, h = 0;
    if (a < 0) {
      for (let x = 0, _ = Math.min(t.length, 200); x < _ && h < l; ) {
        let w = pr(t, x);
        (w == n[h] || w == r[h]) && (i[h++] = x), x += Mi(w);
      }
      if (h < l)
        return !1;
    }
    let u = 0, f = 0, d = !1, p = 0, g = -1, m = -1, y = /[a-z]/.test(t), O = !0;
    for (let x = 0, _ = Math.min(t.length, 200), w = 0; x < _ && f < l; ) {
      let E = pr(t, x);
      a < 0 && (u < l && E == n[u] && (s[u++] = x), p < l && (E == n[p] || E == r[p] ? (p == 0 && (g = x), m = x + 1, p++) : p = 0));
      let T, S = E < 255 ? E >= 48 && E <= 57 || E >= 97 && E <= 122 ? 2 : E >= 65 && E <= 90 ? 1 : 0 : (T = Jk(E)) != T.toLowerCase() ? 1 : T != T.toUpperCase() ? 2 : 0;
      (!x || S == 1 && y || w == 0 && S != 0) && (n[f] == E || r[f] == E && (d = !0) ? o[f++] = x : o.length && (O = !1)), w = S, x += Mi(E);
    }
    return f == l && o[0] == 0 && O ? this.result(-100 + (d ? -200 : 0), o, t) : p == l && g == 0 ? this.ret(-200 - t.length + (m == t.length ? 0 : -100), [0, m]) : a > -1 ? this.ret(-700 - t.length, [a, a + this.pattern.length]) : p == l ? this.ret(-200 + -700 - t.length, [g, m]) : f == l ? this.result(-100 + (d ? -200 : 0) + -700 + (O ? 0 : -1100), o, t) : n.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, t);
  }
  result(t, n, r) {
    let i = [], s = 0;
    for (let o of n) {
      let a = o + (this.astral ? Mi(pr(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = a : (i[s++] = o, i[s++] = a);
    }
    return this.ret(t - r.length, i);
  }
}
const Tr = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Oo(e, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: EG,
      compareCompletions: (t, n) => t.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (t, n) => t && n,
      closeOnBlur: (t, n) => t && n,
      icons: (t, n) => t && n,
      tooltipClass: (t, n) => (r) => LC(t(r), n(r)),
      optionClass: (t, n) => (r) => LC(t(r), n(r)),
      addToOptions: (t, n) => t.concat(n)
    });
  }
});
function LC(e, t) {
  return e ? t ? e + " " + t : e : t;
}
function EG(e, t, n, r, i, s) {
  let o = e.textDirection == yn.RTL, a = o, l = !1, h = "top", u, f, d = t.left - i.left, p = i.right - t.right, g = r.right - r.left, m = r.bottom - r.top;
  if (a && d < Math.min(g, p) ? a = !1 : !a && p < Math.min(g, d) && (a = !0), g <= (a ? d : p))
    u = Math.max(i.top, Math.min(n.top, i.bottom - m)) - t.top, f = Math.min(400, a ? d : p);
  else {
    l = !0, f = Math.min(400, (o ? t.right : i.right - t.left) - 30);
    let x = i.bottom - t.bottom;
    x >= m || x > t.top ? u = n.bottom - t.top : (h = "bottom", u = t.bottom - n.top);
  }
  let y = (t.bottom - t.top) / s.offsetHeight, O = (t.right - t.left) / s.offsetWidth;
  return {
    style: `${h}: ${u / y}px; max-width: ${f / O}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function AG(e) {
  let t = e.addToOptions.slice();
  return e.icons && t.push({
    render(n) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), t.push({
    render(n, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = n.displayLabel || n.label, l = 0;
      for (let h = 0; h < s.length; ) {
        let u = s[h++], f = s[h++];
        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
        let d = o.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(a.slice(u, f))), d.className = "cm-completionMatchedText", l = f;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = n.detail, r;
    },
    position: 80
  }), t.sort((n, r) => n.position - r.position).map((n) => n.render);
}
function Bb(e, t, n) {
  if (e <= n)
    return { from: 0, to: e };
  if (t < 0 && (t = 0), t <= e >> 1) {
    let i = Math.floor(t / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((e - t) / n);
  return { from: e - (r + 1) * n, to: e - r * n };
}
class PG {
  constructor(t, n, r) {
    this.view = t, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = t.state.field(n), { options: s, selected: o } = i.open, a = t.state.facet(Tr);
    this.optionContent = AG(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Bb(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: h } = t.state.field(n).open;
      for (let u = l.target, f; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (f = /-(\d+)$/.exec(u.id)) && +f[1] < h.length) {
          this.applyCompletion(t, h[+f[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let h = t.state.field(this.stateField, !1);
      h && h.tooltip && t.state.facet(Tr).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: Ad.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var n;
    let r = t.state.field(this.stateField), i = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), r != i) {
      let { options: s, selected: o, disabled: a } = r.open;
      (!i.open || i.open.options != s) && (this.range = Bb(s.length, o, t.state.facet(Tr).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(t) {
    let n = this.tooltipClass(t);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of n.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), n = t.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Bb(n.options.length, n.selected, this.view.state.facet(Tr).maxRenderedOptions), this.showOptions(n.options, t.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected], { info: i } = r;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(o, r);
      }).catch((o) => Qi(this.view.state, o, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(t, n) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", t.nodeType != null)
      r.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = t;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == t ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && LG(this.list, n), n;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = t.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return i.top > Math.min(s.bottom, n.bottom) - 10 || i.bottom < Math.max(s.top, n.top) + 10 ? null : this.view.state.facet(Tr).positionInfo(this.view, n, i, r, s, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, n, r) {
    const i = document.createElement("ul");
    i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: a, match: l } = t[o], { section: h } = a;
      if (h) {
        let d = typeof h == "string" ? h : h.name;
        if (d != s && (o > r.from || r.from == 0))
          if (s = d, typeof h != "string" && h.header)
            i.appendChild(h.header(h));
          else {
            let p = i.appendChild(document.createElement("completion-section"));
            p.textContent = d;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = n + "-" + o, u.setAttribute("role", "option");
      let f = this.optionClass(a);
      f && (u.className = f);
      for (let d of this.optionContent) {
        let p = d(a, this.view.state, this.view, l);
        p && u.appendChild(p);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < t.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function DG(e, t) {
  return (n) => new PG(n, e, t);
}
function LG(e, t) {
  let n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), i = n.height / e.offsetHeight;
  r.top < n.top ? e.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (e.scrollTop += (r.bottom - n.bottom) / i);
}
function MC(e) {
  return (e.boost || 0) * 100 + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0);
}
function MG(e, t) {
  let n = [], r = null, i = (l) => {
    n.push(l);
    let { section: h } = l.completion;
    if (h) {
      r || (r = []);
      let u = typeof h == "string" ? h : h.name;
      r.some((f) => f.name == u) || r.push(typeof h == "string" ? { name: u } : h);
    }
  };
  for (let l of e)
    if (l.hasResult()) {
      let h = l.result.getMatch;
      if (l.result.filter === !1)
        for (let u of l.result.options)
          i(new PC(u, l.source, h ? h(u) : [], 1e9 - n.length));
      else {
        let u = new TG(t.sliceDoc(l.from, l.to));
        for (let f of l.result.options)
          if (u.match(f.label)) {
            let d = f.displayLabel ? h ? h(f, u.matched) : [] : u.matched;
            i(new PC(f, l.source, d, u.score + (f.boost || 0)));
          }
      }
    }
  if (r) {
    let l = /* @__PURE__ */ Object.create(null), h = 0, u = (f, d) => {
      var p, g;
      return ((p = f.rank) !== null && p !== void 0 ? p : 1e9) - ((g = d.rank) !== null && g !== void 0 ? g : 1e9) || (f.name < d.name ? -1 : 1);
    };
    for (let f of r.sort(u))
      h -= 1e5, l[f.name] = h;
    for (let f of n) {
      let { section: d } = f.completion;
      d && (f.score += l[typeof d == "string" ? d : d.name]);
    }
  }
  let s = [], o = null, a = t.facet(Tr).compareCompletions;
  for (let l of n.sort((h, u) => u.score - h.score || a(h.completion, u.completion))) {
    let h = l.completion;
    !o || o.label != h.label || o.detail != h.detail || o.type != null && h.type != null && o.type != h.type || o.apply != h.apply || o.boost != h.boost ? s.push(l) : MC(l.completion) > MC(o) && (s[s.length - 1] = l), o = l.completion;
  }
  return s;
}
class Kc {
  constructor(t, n, r, i, s, o) {
    this.options = t, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(t, n) {
    return t == this.selected || t >= this.options.length ? this : new Kc(this.options, RC(n, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, n, r, i, s) {
    let o = MG(t, n);
    if (!o.length)
      return i && t.some((l) => l.state == 1) ? new Kc(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let a = n.facet(Tr).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let l = i.options[i.selected].completion;
      for (let h = 0; h < o.length; h++)
        if (o[h].completion == l) {
          a = h;
          break;
        }
    }
    return new Kc(o, RC(r, a), {
      pos: t.reduce((l, h) => h.hasResult() ? Math.min(l, h.from) : l, 1e8),
      create: BG,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(t) {
    return new Kc(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class jg {
  constructor(t, n, r) {
    this.active = t, this.id = n, this.open = r;
  }
  static start() {
    return new jg(IG, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: n } = t, r = n.facet(Tr), s = (r.override || n.languageDataAt("autocomplete", Ya(n)).map(CG)).map((a) => (this.active.find((h) => h.source == a) || new jr(a, this.active.some((h) => h.state != 0) ? 1 : 0)).update(t, r));
    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);
    let o = this.open;
    o && t.docChanged && (o = o.map(t.changes)), t.selection || s.some((a) => a.hasResult() && t.changes.touchesRange(a.from, a.to)) || !RG(s, this.active) ? o = Kc.build(s, n, this.id, o, r) : o && o.disabled && !s.some((a) => a.state == 1) && (o = null), !o && s.every((a) => a.state != 1) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new jr(a.source, 0) : a));
    for (let a of t.effects)
      a.is(eL) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new jg(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : $G;
  }
}
function RG(e, t) {
  if (e == t)
    return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < e.length && !e[n].hasResult; )
      n++;
    for (; r < t.length && !t[r].hasResult; )
      r++;
    let i = n == e.length, s = r == t.length;
    if (i || s)
      return i == s;
    if (e[n++].result != t[r++].result)
      return !1;
  }
}
const $G = {
  "aria-autocomplete": "list"
};
function RC(e, t) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": e
  };
  return t > -1 && (n["aria-activedescendant"] = e + "-" + t), n;
}
const IG = [];
function $v(e) {
  return e.isUserEvent("input.type") ? "input" : e.isUserEvent("delete.backward") ? "delete" : null;
}
class jr {
  constructor(t, n, r = -1) {
    this.source = t, this.state = n, this.explicitPos = r;
  }
  hasResult() {
    return !1;
  }
  update(t, n) {
    let r = $v(t), i = this;
    r ? i = i.handleUserEvent(t, r, n) : t.docChanged ? i = i.handleChange(t) : t.selection && i.state != 0 && (i = new jr(i.source, 0));
    for (let s of t.effects)
      if (s.is(Aw))
        i = new jr(i.source, 1, s.value ? Ya(t.state) : -1);
      else if (s.is(Ad))
        i = new jr(i.source, 0);
      else if (s.is(tL))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  handleUserEvent(t, n, r) {
    return n == "delete" || !r.activateOnTyping ? this.map(t.changes) : new jr(this.source, 1);
  }
  handleChange(t) {
    return t.changes.touchesRange(Ya(t.startState)) ? new jr(this.source, 0) : this.map(t.changes);
  }
  map(t) {
    return t.empty || this.explicitPos < 0 ? this : new jr(this.source, this.state, t.mapPos(this.explicitPos));
  }
}
class mh extends jr {
  constructor(t, n, r, i, s) {
    super(t, 2, n), this.result = r, this.from = i, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(t, n, r) {
    var i;
    let s = t.changes.mapPos(this.from), o = t.changes.mapPos(this.to, 1), a = Ya(t.state);
    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || n == "delete" && Ya(t.startState) == this.from)
      return new jr(this.source, n == "input" && r.activateOnTyping ? 1 : 0);
    let l = this.explicitPos < 0 ? -1 : t.changes.mapPos(this.explicitPos), h;
    return NG(this.result.validFor, t.state, s, o) ? new mh(this.source, l, this.result, s, o) : this.result.update && (h = this.result.update(this.result, s, o, new Ew(t.state, a, l >= 0))) ? new mh(this.source, l, h, h.from, (i = h.to) !== null && i !== void 0 ? i : Ya(t.state)) : new jr(this.source, 1, l);
  }
  handleChange(t) {
    return t.changes.touchesRange(this.from, this.to) ? new jr(this.source, 0) : this.map(t.changes);
  }
  map(t) {
    return t.empty ? this : new mh(this.source, this.explicitPos < 0 ? -1 : t.mapPos(this.explicitPos), this.result, t.mapPos(this.from), t.mapPos(this.to, 1));
  }
}
function NG(e, t, n, r) {
  if (!e)
    return !1;
  let i = t.sliceDoc(n, r);
  return typeof e == "function" ? e(i, n, r, t) : KD(e, !0).test(i);
}
const tL = /* @__PURE__ */ le.define({
  map(e, t) {
    return e.map((n) => n.map(t));
  }
}), eL = /* @__PURE__ */ le.define(), pi = /* @__PURE__ */ bn.define({
  create() {
    return jg.start();
  },
  update(e, t) {
    return e.update(t);
  },
  provide: (e) => [
    hw.from(e, (t) => t.tooltip),
    Pt.contentAttributes.from(e, (t) => t.attrs)
  ]
});
function nL(e, t) {
  const n = t.completion.apply || t.completion.label;
  let r = e.state.field(pi).active.find((i) => i.source == t.source);
  return r instanceof mh ? (typeof n == "string" ? e.dispatch(Object.assign(Object.assign({}, SG(e.state, n, r.from, r.to)), { annotations: JD.of(t.completion) })) : n(e, t.completion, r.from, r.to), !0) : !1;
}
const BG = /* @__PURE__ */ DG(pi, nL);
function Q0(e, t = "option") {
  return (n) => {
    let r = n.state.field(pi, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Tr).interactionDelay)
      return !1;
    let i = 1, s;
    t == "page" && (s = PP(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (e ? 1 : -1) : e ? 0 : o - 1;
    return a < 0 ? a = t == "page" ? 0 : o - 1 : a >= o && (a = t == "page" ? o - 1 : 0), n.dispatch({ effects: eL.of(a) }), !0;
  };
}
const FG = (e) => {
  let t = e.state.field(pi, !1);
  return e.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < e.state.facet(Tr).interactionDelay ? !1 : nL(e, t.open.options[t.open.selected]);
}, QG = (e) => e.state.field(pi, !1) ? (e.dispatch({ effects: Aw.of(!0) }), !0) : !1, ZG = (e) => {
  let t = e.state.field(pi, !1);
  return !t || !t.active.some((n) => n.state != 0) ? !1 : (e.dispatch({ effects: Ad.of(null) }), !0);
};
class VG {
  constructor(t, n) {
    this.active = t, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const YG = 50, zG = 1e3, qG = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    this.view = e, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let t of e.state.field(pi).active)
      t.state == 1 && this.startQuery(t);
  }
  update(e) {
    let t = e.state.field(pi);
    if (!e.selectionSet && !e.docChanged && e.startState.field(pi) == t)
      return;
    let n = e.transactions.some((r) => (r.selection || r.docChanged) && !$v(r));
    for (let r = 0; r < this.running.length; r++) {
      let i = this.running[r];
      if (n || i.updates.length + e.transactions.length > YG && Date.now() - i.time > zG) {
        for (let s of i.context.abortListeners)
          try {
            s();
          } catch (o) {
            Qi(this.view.state, o);
          }
        i.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        i.updates.push(...e.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = t.active.some((r) => r.state == 1 && !this.running.some((i) => i.active.source == r.source)) ? setTimeout(() => this.startUpdate(), 50) : -1, this.composing != 0)
      for (let r of e.transactions)
        $v(r) == "input" ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: e } = this.view, t = e.field(pi);
    for (let n of t.active)
      n.state == 1 && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
  }
  startQuery(e) {
    let { state: t } = this.view, n = Ya(t), r = new Ew(t, n, e.explicitPos == n), i = new VG(e, r);
    this.running.push(i), Promise.resolve(e.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: Ad.of(null) }), Qi(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((e) => e.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Tr).updateSyncTime));
  }
  accept() {
    var e;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], n = this.view.state.facet(Tr);
    for (let r = 0; r < this.running.length; r++) {
      let i = this.running[r];
      if (i.done === void 0)
        continue;
      if (this.running.splice(r--, 1), i.done) {
        let o = new mh(i.active.source, i.active.explicitPos, i.done, i.done.from, (e = i.done.to) !== null && e !== void 0 ? e : Ya(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let a of i.updates)
          o = o.update(a, n);
        if (o.hasResult()) {
          t.push(o);
          continue;
        }
      }
      let s = this.view.state.field(pi).active.find((o) => o.source == i.active.source);
      if (s && s.state == 1)
        if (i.done == null) {
          let o = new jr(i.active.source, 0);
          for (let a of i.updates)
            o = o.update(a, n);
          o.state != 1 && t.push(o);
        } else
          this.startQuery(s);
    }
    t.length && this.view.dispatch({ effects: tL.of(t) });
  }
}, {
  eventHandlers: {
    blur(e) {
      let t = this.view.state.field(pi, !1);
      if (t && t.tooltip && this.view.state.facet(Tr).closeOnBlur) {
        let n = t.open && PP(this.view, t.open.tooltip);
        (!n || !n.dom.contains(e.relatedTarget)) && this.view.dispatch({ effects: Ad.of(null) });
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Aw.of(!1) }), 20), this.composing = 0;
    }
  }
}), rL = /* @__PURE__ */ Pt.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class WG {
  constructor(t, n, r, i) {
    this.field = t, this.line = n, this.from = r, this.to = i;
  }
}
class Pw {
  constructor(t, n, r) {
    this.field = t, this.from = n, this.to = r;
  }
  map(t) {
    let n = t.mapPos(this.from, -1, Gn.TrackDel), r = t.mapPos(this.to, 1, Gn.TrackDel);
    return n == null || r == null ? null : new Pw(this.field, n, r);
  }
}
class Dw {
  constructor(t, n) {
    this.lines = t, this.fieldPositions = n;
  }
  instantiate(t, n) {
    let r = [], i = [n], s = t.doc.lineAt(n), o = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let h = o, u = /^\t*/.exec(l)[0].length;
        for (let f = 0; f < u; f++)
          h += t.facet(Np);
        i.push(n + h.length - u), l = h + l.slice(u);
      }
      r.push(l), n += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new Pw(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(t) {
    let n = [], r = [], i = [], s;
    for (let o of t.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || "", h = -1;
        for (let u = 0; u < n.length; u++)
          (a != null ? n[u].seq == a : l ? n[u].name == l : !1) && (h = u);
        if (h < 0) {
          let u = 0;
          for (; u < n.length && (a == null || n[u].seq != null && n[u].seq < a); )
            u++;
          n.splice(u, 0, { seq: a, name: l }), h = u;
          for (let f of i)
            f.field >= h && f.field++;
        }
        i.push(new WG(h, r.length, s.index, s.index + l.length)), o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length);
      }
      for (let a; a = /\\([{}])/.exec(o); ) {
        o = o.slice(0, a.index) + a[1] + o.slice(a.index + a[0].length);
        for (let l of i)
          l.line == r.length && l.from > a.index && (l.from--, l.to--);
      }
      r.push(o);
    }
    return new Dw(r, i);
  }
}
let UG = /* @__PURE__ */ Bt.widget({ widget: /* @__PURE__ */ new class extends si {
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-snippetFieldPosition", e;
  }
  ignoreEvent() {
    return !1;
  }
}() }), jG = /* @__PURE__ */ Bt.mark({ class: "cm-snippetField" });
class Du {
  constructor(t, n) {
    this.ranges = t, this.active = n, this.deco = Bt.set(t.map((r) => (r.from == r.to ? UG : jG).range(r.from, r.to)));
  }
  map(t) {
    let n = [];
    for (let r of this.ranges) {
      let i = r.map(t);
      if (!i)
        return null;
      n.push(i);
    }
    return new Du(n, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));
  }
}
const Vp = /* @__PURE__ */ le.define({
  map(e, t) {
    return e && e.map(t);
  }
}), XG = /* @__PURE__ */ le.define(), Pd = /* @__PURE__ */ bn.define({
  create() {
    return null;
  },
  update(e, t) {
    for (let n of t.effects) {
      if (n.is(Vp))
        return n.value;
      if (n.is(XG) && e)
        return new Du(e.ranges, n.value);
    }
    return e && t.docChanged && (e = e.map(t.changes)), e && t.selection && !e.selectionInsideField(t.selection) && (e = null), e;
  },
  provide: (e) => Pt.decorations.from(e, (t) => t ? t.deco : Bt.none)
});
function Lw(e, t) {
  return mt.create(e.filter((n) => n.field == t).map((n) => mt.range(n.from, n.to)));
}
function GG(e) {
  let t = Dw.parse(e);
  return (n, r, i, s) => {
    let { text: o, ranges: a } = t.instantiate(n.state, i), l = {
      changes: { from: i, to: s, insert: Be.of(o) },
      scrollIntoView: !0,
      annotations: r ? JD.of(r) : void 0
    };
    if (a.length && (l.selection = Lw(a, 0)), a.length > 1) {
      let h = new Du(a, 0), u = l.effects = [Vp.of(h)];
      n.state.field(Pd, !1) === void 0 && u.push(le.appendConfig.of([Pd, eH, nH, rL]));
    }
    n.dispatch(n.state.update(l));
  };
}
function iL(e) {
  return ({ state: t, dispatch: n }) => {
    let r = t.field(Pd, !1);
    if (!r || e < 0 && r.active == 0)
      return !1;
    let i = r.active + e, s = e > 0 && !r.ranges.some((o) => o.field == i + e);
    return n(t.update({
      selection: Lw(r.ranges, i),
      effects: Vp.of(s ? null : new Du(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const HG = ({ state: e, dispatch: t }) => e.field(Pd, !1) ? (t(e.update({ effects: Vp.of(null) })), !0) : !1, KG = /* @__PURE__ */ iL(1), JG = /* @__PURE__ */ iL(-1), tH = [
  { key: "Tab", run: KG, shift: JG },
  { key: "Escape", run: HG }
], $C = /* @__PURE__ */ Ft.define({
  combine(e) {
    return e.length ? e[0] : tH;
  }
}), eH = /* @__PURE__ */ Ts.highest(/* @__PURE__ */ Ko.compute([$C], (e) => e.facet($C)));
function Ur(e, t) {
  return Object.assign(Object.assign({}, t), { apply: GG(e) });
}
const nH = /* @__PURE__ */ Pt.domEventHandlers({
  mousedown(e, t) {
    let n = t.state.field(Pd, !1), r;
    if (!n || (r = t.posAtCoords({ x: e.clientX, y: e.clientY })) == null)
      return !1;
    let i = n.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == n.active ? !1 : (t.dispatch({
      selection: Lw(n.ranges, i.field),
      effects: Vp.of(n.ranges.some((s) => s.field > i.field) ? new Du(n.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Dd = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Zl = /* @__PURE__ */ le.define({
  map(e, t) {
    let n = t.mapPos(e, -1, Gn.TrackAfter);
    return n == null ? void 0 : n;
  }
}), Mw = /* @__PURE__ */ new class extends nc {
}();
Mw.startSide = 1;
Mw.endSide = -1;
const sL = /* @__PURE__ */ bn.define({
  create() {
    return Ne.empty;
  },
  update(e, t) {
    if (e = e.map(t.changes), t.selection) {
      let n = t.state.doc.lineAt(t.selection.main.head);
      e = e.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of t.effects)
      n.is(Zl) && (e = e.update({ add: [Mw.range(n.value, n.value + 1)] }));
    return e;
  }
});
function rH() {
  return [sH, sL];
}
const Fb = "()[]{}<>";
function oL(e) {
  for (let t = 0; t < Fb.length; t += 2)
    if (Fb.charCodeAt(t) == e)
      return Fb.charAt(t + 1);
  return Jk(e < 128 ? e : e + 1);
}
function aL(e, t) {
  return e.languageDataAt("closeBrackets", t)[0] || Dd;
}
const iH = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), sH = /* @__PURE__ */ Pt.inputHandler.of((e, t, n, r) => {
  if ((iH ? e.composing : e.compositionStarted) || e.state.readOnly)
    return !1;
  let i = e.state.selection.main;
  if (r.length > 2 || r.length == 2 && Mi(pr(r, 0)) == 1 || t != i.from || n != i.to)
    return !1;
  let s = lH(e.state, r);
  return s ? (e.dispatch(s), !0) : !1;
}), oH = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = aL(e, e.selection.main.head).brackets || Dd.brackets, i = null, s = e.changeByRange((o) => {
    if (o.empty) {
      let a = cH(e.doc, o.head);
      for (let l of r)
        if (l == a && W2(e.doc, o.head) == oL(pr(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: mt.cursor(o.head - l.length)
          };
    }
    return { range: i = o };
  });
  return i || t(e.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, aH = [
  { key: "Backspace", run: oH }
];
function lH(e, t) {
  let n = aL(e, e.selection.main.head), r = n.brackets || Dd.brackets;
  for (let i of r) {
    let s = oL(pr(i, 0));
    if (t == i)
      return s == i ? fH(e, i, r.indexOf(i + i + i) > -1, n) : hH(e, i, s, n.before || Dd.before);
    if (t == s && lL(e, e.selection.main.from))
      return uH(e, i, s);
  }
  return null;
}
function lL(e, t) {
  let n = !1;
  return e.field(sL).between(0, e.doc.length, (r) => {
    r == t && (n = !0);
  }), n;
}
function W2(e, t) {
  let n = e.sliceString(t, t + 2);
  return n.slice(0, Mi(pr(n, 0)));
}
function cH(e, t) {
  let n = e.sliceString(t - 2, t);
  return Mi(pr(n, 0)) == n.length ? n : n.slice(1);
}
function hH(e, t, n, r) {
  let i = null, s = e.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: t, from: o.from }, { insert: n, from: o.to }],
        effects: Zl.of(o.to + t.length),
        range: mt.range(o.anchor + t.length, o.head + t.length)
      };
    let a = W2(e.doc, o.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: t + n, from: o.head },
      effects: Zl.of(o.head + t.length),
      range: mt.cursor(o.head + t.length)
    } : { range: i = o };
  });
  return i ? null : e.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function uH(e, t, n) {
  let r = null, i = e.changeByRange((s) => s.empty && W2(e.doc, s.head) == n ? {
    changes: { from: s.head, to: s.head + n.length, insert: n },
    range: mt.cursor(s.head + n.length)
  } : r = { range: s });
  return r ? null : e.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function fH(e, t, n, r) {
  let i = r.stringPrefixes || Dd.stringPrefixes, s = null, o = e.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: t, from: a.from }, { insert: t, from: a.to }],
        effects: Zl.of(a.to + t.length),
        range: mt.range(a.anchor + t.length, a.head + t.length)
      };
    let l = a.head, h = W2(e.doc, l), u;
    if (h == t) {
      if (IC(e, l))
        return {
          changes: { insert: t + t, from: l },
          effects: Zl.of(l + t.length),
          range: mt.cursor(l + t.length)
        };
      if (lL(e, l)) {
        let d = n && e.sliceDoc(l, l + t.length * 3) == t + t + t ? t + t + t : t;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: mt.cursor(l + d.length)
        };
      }
    } else {
      if (n && e.sliceDoc(l - 2 * t.length, l) == t + t && (u = NC(e, l - 2 * t.length, i)) > -1 && IC(e, u))
        return {
          changes: { insert: t + t + t + t, from: l },
          effects: Zl.of(l + t.length),
          range: mt.cursor(l + t.length)
        };
      if (e.charCategorizer(l)(h) != hn.Word && NC(e, l, i) > -1 && !dH(e, l, t, i))
        return {
          changes: { insert: t + t, from: l },
          effects: Zl.of(l + t.length),
          range: mt.cursor(l + t.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : e.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function IC(e, t) {
  let n = en(e).resolveInner(t + 1);
  return n.parent && n.from == t;
}
function dH(e, t, n, r) {
  let i = en(e).resolveInner(t, -1), s = r.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = e.sliceDoc(i.from, Math.min(i.to, i.from + n.length + s)), l = a.indexOf(n);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {
        if (e.sliceDoc(u.to - n.length, u.to) == n)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let h = i.to == t && i.parent;
    if (!h)
      break;
    i = h;
  }
  return !1;
}
function NC(e, t, n) {
  let r = e.charCategorizer(t);
  if (r(e.sliceDoc(t - 1, t)) != hn.Word)
    return t;
  for (let i of n) {
    let s = t - i.length;
    if (e.sliceDoc(s, t) == i && r(e.sliceDoc(s - 1, s)) != hn.Word)
      return s;
  }
  return -1;
}
function pH(e = {}) {
  return [
    pi,
    Tr.of(e),
    qG,
    gH,
    rL
  ];
}
const cL = [
  { key: "Ctrl-Space", run: QG },
  { key: "Escape", run: ZG },
  { key: "ArrowDown", run: /* @__PURE__ */ Q0(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Q0(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Q0(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Q0(!1, "page") },
  { key: "Enter", run: FG }
], gH = /* @__PURE__ */ Ts.highest(/* @__PURE__ */ Ko.computeN([Tr], (e) => e.facet(Tr).defaultKeymap ? [cL] : []));
class mH {
  constructor(t, n, r) {
    this.from = t, this.to = n, this.diagnostic = r;
  }
}
class Ml {
  constructor(t, n, r) {
    this.diagnostics = t, this.panel = n, this.selected = r;
  }
  static init(t, n, r) {
    let i = t, s = r.facet(fL).markerFilter;
    s && (i = s(i));
    let o = Bt.set(i.map((a) => a.from == a.to || a.from == a.to - 1 && r.doc.lineAt(a.from).to == a.from ? Bt.widget({
      widget: new SH(a),
      diagnostic: a
    }).range(a.from) : Bt.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity + (a.markClass ? " " + a.markClass : "") },
      diagnostic: a
    }).range(a.from, a.to)), !0);
    return new Ml(o, n, Yh(o));
  }
}
function Yh(e, t = null, n = 0) {
  let r = null;
  return e.between(n, 1e9, (i, s, { spec: o }) => {
    if (!(t && o.diagnostic != t))
      return r = new mH(i, s, o.diagnostic), !1;
  }), r;
}
function yH(e, t) {
  let n = e.startState.doc.lineAt(t.pos);
  return !!(e.effects.some((r) => r.is(hL)) || e.changes.touchesRange(n.from, n.to));
}
function bH(e, t) {
  return e.field(yi, !1) ? t : t.concat(le.appendConfig.of(EH));
}
const hL = /* @__PURE__ */ le.define(), Rw = /* @__PURE__ */ le.define(), uL = /* @__PURE__ */ le.define(), yi = /* @__PURE__ */ bn.define({
  create() {
    return new Ml(Bt.none, null, null);
  },
  update(e, t) {
    if (t.docChanged) {
      let n = e.diagnostics.map(t.changes), r = null;
      if (e.selected) {
        let i = t.changes.mapPos(e.selected.from, 1);
        r = Yh(n, e.selected.diagnostic, i) || Yh(n, null, i);
      }
      e = new Ml(n, e.panel, r);
    }
    for (let n of t.effects)
      n.is(hL) ? e = Ml.init(n.value, e.panel, t.state) : n.is(Rw) ? e = new Ml(e.diagnostics, n.value ? U2.open : null, e.selected) : n.is(uL) && (e = new Ml(e.diagnostics, e.panel, n.value));
    return e;
  },
  provide: (e) => [
    _d.from(e, (t) => t.panel),
    Pt.decorations.from(e, (t) => t.diagnostics)
  ]
}), OH = /* @__PURE__ */ Bt.mark({ class: "cm-lintRange cm-lintRange-active" });
function xH(e, t, n) {
  let { diagnostics: r } = e.state.field(yi), i = [], s = 2e8, o = 0;
  r.between(t - (n < 0 ? 1 : 0), t + (n > 0 ? 1 : 0), (l, h, { spec: u }) => {
    t >= l && t <= h && (l == h || (t > l || n > 0) && (t < h || n < 0)) && (i.push(u.diagnostic), s = Math.min(l, s), o = Math.max(h, o));
  });
  let a = e.state.facet(fL).tooltipFilter;
  return a && (i = a(i)), i.length ? {
    pos: s,
    end: o,
    above: e.state.doc.lineAt(s).to < o,
    create() {
      return { dom: vH(e, i) };
    }
  } : null;
}
function vH(e, t) {
  return Je("ul", { class: "cm-tooltip-lint" }, t.map((n) => pL(e, n, !1)));
}
const _H = (e) => {
  let t = e.state.field(yi, !1);
  (!t || !t.panel) && e.dispatch({ effects: bH(e.state, [Rw.of(!0)]) });
  let n = vd(e, U2.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, BC = (e) => {
  let t = e.state.field(yi, !1);
  return !t || !t.panel ? !1 : (e.dispatch({ effects: Rw.of(!1) }), !0);
}, kH = (e) => {
  let t = e.state.field(yi, !1);
  if (!t)
    return !1;
  let n = e.state.selection.main, r = t.diagnostics.iter(n.to + 1);
  return !r.value && (r = t.diagnostics.iter(0), !r.value || r.from == n.from && r.to == n.to) ? !1 : (e.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, wH = [
  { key: "Mod-Shift-m", run: _H, preventDefault: !0 },
  { key: "F8", run: kH }
], fL = /* @__PURE__ */ Ft.define({
  combine(e) {
    return Object.assign({ sources: e.map((t) => t.source) }, Oo(e.map((t) => t.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (t, n) => t ? n ? (r) => t(r) || n(r) : t : n
    }));
  }
});
function dL(e) {
  let t = [];
  if (e)
    t:
      for (let { name: n } of e) {
        for (let r = 0; r < n.length; r++) {
          let i = n[r];
          if (/[a-zA-Z]/.test(i) && !t.some((s) => s.toLowerCase() == i.toLowerCase())) {
            t.push(i);
            continue t;
          }
        }
        t.push("");
      }
  return t;
}
function pL(e, t, n) {
  var r;
  let i = n ? dL(t.actions) : [];
  return Je("li", { class: "cm-diagnostic cm-diagnostic-" + t.severity }, Je("span", { class: "cm-diagnosticText" }, t.renderMessage ? t.renderMessage() : t.message), (r = t.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let a = !1, l = (d) => {
      if (d.preventDefault(), a)
        return;
      a = !0;
      let p = Yh(e.state.field(yi).diagnostics, t);
      p && s.apply(e, p.from, p.to);
    }, { name: h } = s, u = i[o] ? h.indexOf(i[o]) : -1, f = u < 0 ? h : [
      h.slice(0, u),
      Je("u", h.slice(u, u + 1)),
      h.slice(u + 1)
    ];
    return Je("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${h}${u < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, f);
  }), t.source && Je("div", { class: "cm-diagnosticSource" }, t.source));
}
class SH extends si {
  constructor(t) {
    super(), this.diagnostic = t;
  }
  eq(t) {
    return t.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Je("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class FC {
  constructor(t, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = pL(t, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class U2 {
  constructor(t) {
    this.view = t, this.items = [];
    let n = (i) => {
      if (i.keyCode == 27)
        BC(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = dL(s.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == i.keyCode) {
            let l = Yh(this.view.state.field(yi).diagnostics, s);
            l && s.actions[a].apply(t, l.from, l.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = Je("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: r
    }), this.dom = Je("div", { class: "cm-panel-lint" }, this.list, Je("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => BC(this.view)
    }, "\xD7")), this.update();
  }
  get selectedIndex() {
    let t = this.view.state.field(yi).selected;
    if (!t)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == t.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: t, selected: n } = this.view.state.field(yi), r = 0, i = !1, s = null;
    for (t.between(0, this.view.state.doc.length, (o, a, { spec: l }) => {
      let h = -1, u;
      for (let f = r; f < this.items.length; f++)
        if (this.items[f].diagnostic == l.diagnostic) {
          h = f;
          break;
        }
      h < 0 ? (u = new FC(this.view, l.diagnostic), this.items.splice(r, 0, u), i = !0) : (u = this.items[h], h > r && (this.items.splice(r, h - r), i = !0)), n && u.diagnostic == n.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), s = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), r++;
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new FC(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: a }) => {
        let l = a.height / this.list.offsetHeight;
        o.top < a.top ? this.list.scrollTop -= (a.top - o.top) / l : o.bottom > a.bottom && (this.list.scrollTop += (o.bottom - a.bottom) / l);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let t = this.list.firstChild;
    function n() {
      let r = t;
      t = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; t != r.dom; )
          n();
        t = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, t);
    for (; t; )
      n();
  }
  moveSelection(t) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(yi), r = Yh(n.diagnostics, this.items[t].diagnostic);
    !r || this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: uL.of(r)
    });
  }
  static open(t) {
    return new U2(t);
  }
}
function CH(e, t = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`;
}
function Z0(e) {
  return CH(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const TH = /* @__PURE__ */ Pt.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Z0("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Z0("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Z0("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Z0("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), EH = [
  yi,
  /* @__PURE__ */ Pt.decorations.compute([yi], (e) => {
    let { selected: t, panel: n } = e.field(yi);
    return !t || !n || t.from == t.to ? Bt.none : Bt.set([
      OH.range(t.from, t.to)
    ]);
  }),
  /* @__PURE__ */ kU(xH, { hideOn: yH }),
  TH
], AH = /* @__PURE__ */ (() => [
  DU(),
  RU(),
  TP(),
  _w(),
  Cj(),
  wP(),
  GW(),
  De.allowMultipleSelections.of(!0),
  pj(),
  tD(eD, { fallback: !0 }),
  Ij(),
  rH(),
  pH(),
  fU(),
  gU(),
  EP(),
  tG(),
  Ko.of([
    ...aH,
    ...FD,
    ...OG,
    ...fD,
    ..._j,
    ...cL,
    ...wH
  ])
])(), PH = /* @__PURE__ */ (() => [
  TP(),
  _w(),
  wP(),
  tD(eD, { fallback: !0 }),
  Ko.of([
    ...FD,
    ...fD
  ])
])(), ds = () => /* @__PURE__ */ new Map(), Iv = (e) => {
  const t = ds();
  return e.forEach((n, r) => {
    t.set(r, n);
  }), t;
}, ma = (e, t, n) => {
  let r = e.get(t);
  return r === void 0 && e.set(t, r = n()), r;
}, DH = (e, t) => {
  const n = [];
  for (const [r, i] of e)
    n.push(t(i, r));
  return n;
}, LH = (e, t) => {
  for (const [n, r] of e)
    if (t(r, n))
      return !0;
  return !1;
}, sc = () => /* @__PURE__ */ new Set(), Qb = (e) => e[e.length - 1], MH = (e, t) => {
  for (let n = 0; n < t.length; n++)
    e.push(t[n]);
}, rl = Array.from, RH = (e, t) => {
  for (let n = 0; n < e.length; n++)
    if (t(e[n], n, e))
      return !0;
  return !1;
}, Nv = Array.isArray;
class j2 {
  constructor() {
    this._observers = ds();
  }
  on(t, n) {
    ma(this._observers, t, sc).add(n);
  }
  once(t, n) {
    const r = (...i) => {
      this.off(t, r), n(...i);
    };
    this.on(t, r);
  }
  off(t, n) {
    const r = this._observers.get(t);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(t));
  }
  emit(t, n) {
    return rl((this._observers.get(t) || ds()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = ds();
  }
}
const ca = Math.floor, Z1 = Math.abs, X2 = (e, t) => e < t ? e : t, dl = (e, t) => e > t ? e : t, $H = Math.pow, gL = (e) => e !== 0 ? e < 0 : 1 / e < 0, QC = 1, ZC = 2, Zb = 4, Vb = 8, Ld = 32, ta = 64, bi = 128, G2 = 31, Bv = 63, Ul = 127, IH = 2147483647, mL = Number.MAX_SAFE_INTEGER, NH = Number.isInteger || ((e) => typeof e == "number" && isFinite(e) && ca(e) === e), BH = String.fromCharCode, FH = (e) => e.toLowerCase(), QH = /^\s*/g, ZH = (e) => e.replace(QH, ""), VH = /([A-Z])/g, VC = (e, t) => ZH(e.replace(VH, (n) => `${t}${FH(n)}`)), YH = (e) => {
  const t = unescape(encodeURIComponent(e)), n = t.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = t.codePointAt(i);
  return r;
}, Md = typeof TextEncoder < "u" ? new TextEncoder() : null, zH = (e) => Md.encode(e), qH = Md ? zH : YH;
let qf = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
qf && qf.decode(new Uint8Array()).length === 1 && (qf = null);
class Yp {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const wr = () => new Yp(), $w = (e) => {
  let t = e.cpos;
  for (let n = 0; n < e.bufs.length; n++)
    t += e.bufs[n].length;
  return t;
}, gn = (e) => {
  const t = new Uint8Array($w(e));
  let n = 0;
  for (let r = 0; r < e.bufs.length; r++) {
    const i = e.bufs[r];
    t.set(i, n), n += i.length;
  }
  return t.set(new Uint8Array(e.cbuf.buffer, 0, e.cpos), n), t;
}, WH = (e, t) => {
  const n = e.cbuf.length;
  n - e.cpos < t && (e.bufs.push(new Uint8Array(e.cbuf.buffer, 0, e.cpos)), e.cbuf = new Uint8Array(dl(n, t) * 2), e.cpos = 0);
}, rr = (e, t) => {
  const n = e.cbuf.length;
  e.cpos === n && (e.bufs.push(e.cbuf), e.cbuf = new Uint8Array(n * 2), e.cpos = 0), e.cbuf[e.cpos++] = t;
}, Fv = rr, ee = (e, t) => {
  for (; t > Ul; )
    rr(e, bi | Ul & t), t = ca(t / 128);
  rr(e, Ul & t);
}, Iw = (e, t) => {
  const n = gL(t);
  for (n && (t = -t), rr(e, (t > Bv ? bi : 0) | (n ? ta : 0) | Bv & t), t = ca(t / 64); t > 0; )
    rr(e, (t > Ul ? bi : 0) | Ul & t), t = ca(t / 128);
}, Qv = new Uint8Array(3e4), UH = Qv.length / 3, jH = (e, t) => {
  if (t.length < UH) {
    const n = Md.encodeInto(t, Qv).written || 0;
    ee(e, n);
    for (let r = 0; r < n; r++)
      rr(e, Qv[r]);
  } else
    Sn(e, qH(t));
}, XH = (e, t) => {
  const n = unescape(encodeURIComponent(t)), r = n.length;
  ee(e, r);
  for (let i = 0; i < r; i++)
    rr(e, n.codePointAt(i));
}, jl = Md && Md.encodeInto ? jH : XH, H2 = (e, t) => {
  const n = e.cbuf.length, r = e.cpos, i = X2(n - r, t.length), s = t.length - i;
  e.cbuf.set(t.subarray(0, i), r), e.cpos += i, s > 0 && (e.bufs.push(e.cbuf), e.cbuf = new Uint8Array(dl(n * 2, s)), e.cbuf.set(t.subarray(i)), e.cpos = s);
}, Sn = (e, t) => {
  ee(e, t.byteLength), H2(e, t);
}, Nw = (e, t) => {
  WH(e, t);
  const n = new DataView(e.cbuf.buffer, e.cpos, t);
  return e.cpos += t, n;
}, GH = (e, t) => Nw(e, 4).setFloat32(0, t, !1), HH = (e, t) => Nw(e, 8).setFloat64(0, t, !1), KH = (e, t) => Nw(e, 8).setBigInt64(0, t, !1), YC = new DataView(new ArrayBuffer(4)), JH = (e) => (YC.setFloat32(0, e), YC.getFloat32(0) === e), Rd = (e, t) => {
  switch (typeof t) {
    case "string":
      rr(e, 119), jl(e, t);
      break;
    case "number":
      NH(t) && Z1(t) <= IH ? (rr(e, 125), Iw(e, t)) : JH(t) ? (rr(e, 124), GH(e, t)) : (rr(e, 123), HH(e, t));
      break;
    case "bigint":
      rr(e, 122), KH(e, t);
      break;
    case "object":
      if (t === null)
        rr(e, 126);
      else if (Nv(t)) {
        rr(e, 117), ee(e, t.length);
        for (let n = 0; n < t.length; n++)
          Rd(e, t[n]);
      } else if (t instanceof Uint8Array)
        rr(e, 116), Sn(e, t);
      else {
        rr(e, 118);
        const n = Object.keys(t);
        ee(e, n.length);
        for (let r = 0; r < n.length; r++) {
          const i = n[r];
          jl(e, i), Rd(e, t[i]);
        }
      }
      break;
    case "boolean":
      rr(e, t ? 120 : 121);
      break;
    default:
      rr(e, 127);
  }
};
class zC extends Yp {
  constructor(t) {
    super(), this.w = t, this.s = null, this.count = 0;
  }
  write(t) {
    this.s === t ? this.count++ : (this.count > 0 && ee(this, this.count - 1), this.count = 1, this.w(this, t), this.s = t);
  }
}
const qC = (e) => {
  e.count > 0 && (Iw(e.encoder, e.count === 1 ? e.s : -e.s), e.count > 1 && ee(e.encoder, e.count - 2));
};
class V1 {
  constructor() {
    this.encoder = new Yp(), this.s = 0, this.count = 0;
  }
  write(t) {
    this.s === t ? this.count++ : (qC(this), this.count = 1, this.s = t);
  }
  toUint8Array() {
    return qC(this), gn(this.encoder);
  }
}
const WC = (e) => {
  if (e.count > 0) {
    const t = e.diff * 2 + (e.count === 1 ? 0 : 1);
    Iw(e.encoder, t), e.count > 1 && ee(e.encoder, e.count - 2);
  }
};
class Yb {
  constructor() {
    this.encoder = new Yp(), this.s = 0, this.count = 0, this.diff = 0;
  }
  write(t) {
    this.diff === t - this.s ? (this.s = t, this.count++) : (WC(this), this.count = 1, this.diff = t - this.s, this.s = t);
  }
  toUint8Array() {
    return WC(this), gn(this.encoder);
  }
}
class tK {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new V1();
  }
  write(t) {
    this.s += t, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(t.length);
  }
  toUint8Array() {
    const t = new Yp();
    return this.sarr.push(this.s), this.s = "", jl(t, this.sarr.join("")), H2(t, this.lensE.toUint8Array()), gn(t);
  }
}
const il = (e) => new Error(e), ao = () => {
  throw il("Method unimplemented");
}, _s = () => {
  throw il("Unexpected case");
}, yL = il("Unexpected end of array"), bL = il("Integer out of Range");
class K2 {
  constructor(t) {
    this.arr = t, this.pos = 0;
  }
}
const pl = (e) => new K2(e), eK = (e) => e.pos !== e.arr.length, nK = (e, t) => {
  const n = new Uint8Array(e.arr.buffer, e.pos + e.arr.byteOffset, t);
  return e.pos += t, n;
}, _r = (e) => nK(e, xe(e)), zh = (e) => e.arr[e.pos++], xe = (e) => {
  let t = 0, n = 1;
  const r = e.arr.length;
  for (; e.pos < r; ) {
    const i = e.arr[e.pos++];
    if (t = t + (i & Ul) * n, n *= 128, i < bi)
      return t;
    if (t > mL)
      throw bL;
  }
  throw yL;
}, Bw = (e) => {
  let t = e.arr[e.pos++], n = t & Bv, r = 64;
  const i = (t & ta) > 0 ? -1 : 1;
  if ((t & bi) === 0)
    return i * n;
  const s = e.arr.length;
  for (; e.pos < s; ) {
    if (t = e.arr[e.pos++], n = n + (t & Ul) * r, r *= 128, t < bi)
      return i * n;
    if (n > mL)
      throw bL;
  }
  throw yL;
}, rK = (e) => {
  let t = xe(e);
  if (t === 0)
    return "";
  {
    let n = String.fromCodePoint(zh(e));
    if (--t < 100)
      for (; t--; )
        n += String.fromCodePoint(zh(e));
    else
      for (; t > 0; ) {
        const r = t < 1e4 ? t : 1e4, i = e.arr.subarray(e.pos, e.pos + r);
        e.pos += r, n += String.fromCodePoint.apply(null, i), t -= r;
      }
    return decodeURIComponent(escape(n));
  }
}, iK = (e) => qf.decode(_r(e)), za = qf ? iK : rK, Fw = (e, t) => {
  const n = new DataView(e.arr.buffer, e.arr.byteOffset + e.pos, t);
  return e.pos += t, n;
}, sK = (e) => Fw(e, 4).getFloat32(0, !1), oK = (e) => Fw(e, 8).getFloat64(0, !1), aK = (e) => Fw(e, 8).getBigInt64(0, !1), lK = [
  (e) => {
  },
  (e) => null,
  Bw,
  sK,
  oK,
  aK,
  (e) => !1,
  (e) => !0,
  za,
  (e) => {
    const t = xe(e), n = {};
    for (let r = 0; r < t; r++) {
      const i = za(e);
      n[i] = $d(e);
    }
    return n;
  },
  (e) => {
    const t = xe(e), n = [];
    for (let r = 0; r < t; r++)
      n.push($d(e));
    return n;
  },
  _r
], $d = (e) => lK[127 - zh(e)](e);
class UC extends K2 {
  constructor(t, n) {
    super(t), this.reader = n, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), eK(this) ? this.count = xe(this) + 1 : this.count = -1), this.count--, this.s;
  }
}
class Y1 extends K2 {
  constructor(t) {
    super(t), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Bw(this);
      const t = gL(this.s);
      this.count = 1, t && (this.s = -this.s, this.count = xe(this) + 2);
    }
    return this.count--, this.s;
  }
}
class zb extends K2 {
  constructor(t) {
    super(t), this.s = 0, this.count = 0, this.diff = 0;
  }
  read() {
    if (this.count === 0) {
      const t = Bw(this), n = t & 1;
      this.diff = ca(t / 2), this.count = 1, n && (this.count = xe(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class cK {
  constructor(t) {
    this.decoder = new Y1(t), this.str = za(this.decoder), this.spos = 0;
  }
  read() {
    const t = this.spos + this.decoder.read(), n = this.str.slice(this.spos, t);
    return this.spos = t, n;
  }
}
const hK = crypto.getRandomValues.bind(crypto), OL = () => hK(new Uint32Array(1))[0], uK = [1e7] + -1e3 + -4e3 + -8e3 + -1e11, fK = () => uK.replace(
  /[018]/g,
  (e) => (e ^ OL() & 15 >> e / 4).toString(16)
), sl = Date.now, jC = (e) => new Promise(e);
Promise.all.bind(Promise);
const XC = (e) => e === void 0 ? null : e;
class dK {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  setItem(t, n) {
    this.map.set(t, n);
  }
  getItem(t) {
    return this.map.get(t);
  }
}
let xL = new dK(), Qw = !0;
try {
  typeof localStorage < "u" && localStorage && (xL = localStorage, Qw = !1);
} catch {
}
const vL = xL, pK = (e) => Qw || addEventListener("storage", e), gK = (e) => Qw || removeEventListener("storage", e), mK = Object.assign, yK = Object.keys, bK = (e, t) => {
  for (const n in e)
    t(e[n], n);
}, OK = (e, t) => {
  const n = [];
  for (const r in e)
    n.push(t(e[r], r));
  return n;
}, Xg = (e) => yK(e).length, xK = (e) => {
  for (const t in e)
    return !1;
  return !0;
}, vK = (e, t) => {
  for (const n in e)
    if (!t(e[n], n))
      return !1;
  return !0;
}, _L = (e, t) => Object.prototype.hasOwnProperty.call(e, t), _K = (e, t) => e === t || Xg(e) === Xg(t) && vK(e, (n, r) => (n !== void 0 || _L(t, r)) && t[r] === n), Zw = (e, t, n = 0) => {
  try {
    for (; n < e.length; n++)
      e[n](...t);
  } finally {
    n < e.length && Zw(e, t, n + 1);
  }
}, kK = (e) => e, wK = (e, t) => e === t, Wf = (e, t) => {
  if (e == null || t == null)
    return wK(e, t);
  if (e.constructor !== t.constructor)
    return !1;
  if (e === t)
    return !0;
  switch (e.constructor) {
    case ArrayBuffer:
      e = new Uint8Array(e), t = new Uint8Array(t);
    case Uint8Array: {
      if (e.byteLength !== t.byteLength)
        return !1;
      for (let n = 0; n < e.length; n++)
        if (e[n] !== t[n])
          return !1;
      break;
    }
    case Set: {
      if (e.size !== t.size)
        return !1;
      for (const n of e)
        if (!t.has(n))
          return !1;
      break;
    }
    case Map: {
      if (e.size !== t.size)
        return !1;
      for (const n of e.keys())
        if (!t.has(n) || !Wf(e.get(n), t.get(n)))
          return !1;
      break;
    }
    case Object:
      if (Xg(e) !== Xg(t))
        return !1;
      for (const n in e)
        if (!_L(e, n) || !Wf(e[n], t[n]))
          return !1;
      break;
    case Array:
      if (e.length !== t.length)
        return !1;
      for (let n = 0; n < e.length; n++)
        if (!Wf(e[n], t[n]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, SK = (e, t) => t.includes(e), qh = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", kL = typeof window < "u" && typeof document < "u" && !qh;
typeof navigator < "u" && /Mac/.test(navigator.platform);
let Vs;
const CK = () => {
  if (Vs === void 0)
    if (qh) {
      Vs = ds();
      const e = process.argv;
      let t = null;
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        r[0] === "-" ? (t !== null && Vs.set(t, ""), t = r) : t !== null && (Vs.set(t, r), t = null);
      }
      t !== null && Vs.set(t, "");
    } else
      typeof location == "object" ? (Vs = ds(), (location.search || "?").slice(1).split("&").forEach((e) => {
        if (e.length !== 0) {
          const [t, n] = e.split("=");
          Vs.set(`--${VC(t, "-")}`, n), Vs.set(`-${VC(t, "-")}`, n);
        }
      })) : Vs = ds();
  return Vs;
}, Zv = (e) => CK().has(e), Vv = (e) => XC(qh ? {}[e.toUpperCase()] : vL.getItem(e)), TK = (e) => Zv("--" + e) || Vv(e) !== null;
TK("production");
const GC = qh && SK({}.FORCE_COLOR, ["true", "1", "2"]), EK = !Zv("no-colors") && (!qh || process.stdout.isTTY || GC) && (!qh || Zv("color") || GC || Vv("COLORTERM") !== null || (Vv("TERM") || "").includes("color")), wL = (e) => new Uint8Array(e), AK = (e, t, n) => new Uint8Array(e, t, n), PK = (e) => new Uint8Array(e), DK = (e) => {
  let t = "";
  for (let n = 0; n < e.byteLength; n++)
    t += BH(e[n]);
  return btoa(t);
}, LK = (e) => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("base64"), MK = (e) => {
  const t = atob(e), n = wL(t.length);
  for (let r = 0; r < t.length; r++)
    n[r] = t.charCodeAt(r);
  return n;
}, RK = (e) => {
  const t = Buffer.from(e, "base64");
  return AK(t.buffer, t.byteOffset, t.byteLength);
}, $K = kL ? DK : LK, IK = kL ? MK : RK, NK = (e) => {
  const t = wL(e.byteLength);
  return t.set(e), t;
};
class BK {
  constructor(t, n) {
    this.left = t, this.right = n;
  }
}
const ui = (e, t) => new BK(e, t), FK = (e, t) => e.forEach((n) => t(n.left, n.right)), vo = typeof document < "u" ? document : {}, QK = (e) => vo.createElement(e), ZK = () => vo.createDocumentFragment(), VK = (e) => vo.createTextNode(e);
typeof DOMParser < "u" && new DOMParser();
const YK = (e, t) => (FK(t, (n, r) => {
  r === !1 ? e.removeAttribute(n) : r === !0 ? e.setAttribute(n, "") : e.setAttribute(n, r);
}), e), zK = (e) => {
  const t = ZK();
  for (let n = 0; n < e.length; n++)
    SL(t, e[n]);
  return t;
}, qK = (e, t) => (SL(e, zK(t)), e), qb = (e, t = [], n = []) => qK(YK(QK(e), t), n), V0 = VK, WK = (e) => DH(e, (t, n) => `${n}:${t};`).join(""), SL = (e, t) => e.appendChild(t);
vo.ELEMENT_NODE;
vo.TEXT_NODE;
vo.CDATA_SECTION_NODE;
vo.COMMENT_NODE;
vo.DOCUMENT_NODE;
vo.DOCUMENT_TYPE_NODE;
vo.DOCUMENT_FRAGMENT_NODE;
const ya = Symbol, CL = ya(), TL = ya(), UK = ya(), jK = ya(), XK = ya(), EL = ya(), GK = ya(), Vw = ya(), HK = ya(), KK = (e) => {
  const t = [];
  let n = 0;
  for (; n < e.length; n++) {
    const r = e[n];
    r.constructor === String || r.constructor === Number || r.constructor === Object && t.push(JSON.stringify(r));
  }
  return t;
}, JK = {
  [CL]: ui("font-weight", "bold"),
  [TL]: ui("font-weight", "normal"),
  [UK]: ui("color", "blue"),
  [XK]: ui("color", "green"),
  [jK]: ui("color", "grey"),
  [EL]: ui("color", "red"),
  [GK]: ui("color", "purple"),
  [Vw]: ui("color", "orange"),
  [HK]: ui("color", "black")
}, tJ = (e) => {
  const t = [], n = [], r = ds();
  let i = [], s = 0;
  for (; s < e.length; s++) {
    const o = e[s], a = JK[o];
    if (a !== void 0)
      r.set(a.left, a.right);
    else if (o.constructor === String || o.constructor === Number) {
      const l = WK(r);
      s > 0 || l.length > 0 ? (t.push("%c" + o), n.push(l)) : t.push(o);
    } else
      break;
  }
  for (s > 0 && (i = n, i.unshift(t.join(""))); s < e.length; s++) {
    const o = e[s];
    o instanceof Symbol || i.push(o);
  }
  return i;
}, AL = EK ? tJ : KK, eJ = (...e) => {
  console.log(...AL(e)), PL.forEach((t) => t.print(e));
}, nJ = (...e) => {
  console.warn(...AL(e)), e.unshift(Vw), PL.forEach((t) => t.print(e));
}, PL = sc(), DL = (e) => ({
  [Symbol.iterator]() {
    return this;
  },
  next: e
}), rJ = (e, t) => DL(() => {
  let n;
  do
    n = e.next();
  while (!n.done && !t(n.value));
  return n;
}), Wb = (e, t) => DL(() => {
  const { done: n, value: r } = e.next();
  return { done: n, value: n ? void 0 : t(r) };
});
class Yw {
  constructor(t, n) {
    this.clock = t, this.len = n;
  }
}
class Lu {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const Wh = (e, t, n) => t.clients.forEach((r, i) => {
  const s = e.doc.store.clients.get(i);
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    WL(e, s, a.clock, a.len, n);
  }
}), iJ = (e, t) => {
  let n = 0, r = e.length - 1;
  for (; n <= r; ) {
    const i = ca((n + r) / 2), s = e[i], o = s.clock;
    if (o <= t) {
      if (t < o + s.len)
        return i;
      n = i + 1;
    } else
      r = i - 1;
  }
  return null;
}, zp = (e, t) => {
  const n = e.clients.get(t.client);
  return n !== void 0 && iJ(n, t.clock) !== null;
}, zw = (e) => {
  e.clients.forEach((t) => {
    t.sort((i, s) => i.clock - s.clock);
    let n, r;
    for (n = 1, r = 1; n < t.length; n++) {
      const i = t[r - 1], s = t[n];
      i.clock + i.len >= s.clock ? i.len = dl(i.len, s.clock + s.len - i.clock) : (r < n && (t[r] = s), r++);
    }
    t.length = r;
  });
}, Yv = (e) => {
  const t = new Lu();
  for (let n = 0; n < e.length; n++)
    e[n].clients.forEach((r, i) => {
      if (!t.clients.has(i)) {
        const s = r.slice();
        for (let o = n + 1; o < e.length; o++)
          MH(s, e[o].clients.get(i) || []);
        t.clients.set(i, s);
      }
    });
  return zw(t), t;
}, Id = (e, t, n, r) => {
  ma(e.clients, t, () => []).push(new Yw(n, r));
}, LL = () => new Lu(), sJ = (e) => {
  const t = LL();
  return e.clients.forEach((n, r) => {
    const i = [];
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      if (o.deleted) {
        const a = o.id.clock;
        let l = o.length;
        if (s + 1 < n.length)
          for (let h = n[s + 1]; s + 1 < n.length && h.deleted; h = n[++s + 1])
            l += h.length;
        i.push(new Yw(a, l));
      }
    }
    i.length > 0 && t.clients.set(r, i);
  }), t;
}, Mu = (e, t) => {
  ee(e.restEncoder, t.clients.size), rl(t.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    e.resetDsCurVal(), ee(e.restEncoder, n);
    const i = r.length;
    ee(e.restEncoder, i);
    for (let s = 0; s < i; s++) {
      const o = r[s];
      e.writeDsClock(o.clock), e.writeDsLen(o.len);
    }
  });
}, qw = (e) => {
  const t = new Lu(), n = xe(e.restDecoder);
  for (let r = 0; r < n; r++) {
    e.resetDsCurVal();
    const i = xe(e.restDecoder), s = xe(e.restDecoder);
    if (s > 0) {
      const o = ma(t.clients, i, () => []);
      for (let a = 0; a < s; a++)
        o.push(new Yw(e.readDsClock(), e.readDsLen()));
    }
  }
  return t;
}, HC = (e, t, n) => {
  const r = new Lu(), i = xe(e.restDecoder);
  for (let s = 0; s < i; s++) {
    e.resetDsCurVal();
    const o = xe(e.restDecoder), a = xe(e.restDecoder), l = n.clients.get(o) || [], h = Ln(n, o);
    for (let u = 0; u < a; u++) {
      const f = e.readDsClock(), d = f + e.readDsLen();
      if (f < h) {
        h < d && Id(r, o, h, d - h);
        let p = go(l, f), g = l[p];
        for (!g.deleted && g.id.clock < f && (l.splice(p + 1, 0, rm(t, g, f - g.id.clock)), p++); p < l.length && (g = l[p++], g.id.clock < d); )
          g.deleted || (d < g.id.clock + g.length && l.splice(p, 0, rm(t, g, d - g.id.clock)), g.delete(t));
      } else
        Id(r, o, f, d - f);
    }
  }
  if (r.clients.size > 0) {
    const s = new oc();
    return ee(s.restEncoder, 0), Mu(s, r), s.toUint8Array();
  }
  return null;
}, ML = OL;
class Ru extends j2 {
  constructor({ guid: t = fK(), collectionid: n = null, gc: r = !0, gcFilter: i = () => !0, meta: s = null, autoLoad: o = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = i, this.clientID = ML(), this.guid = t, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new zL(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = o, this.meta = s, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = jC((h) => {
      this.on("load", () => {
        this.isLoaded = !0, h(this);
      });
    });
    const l = () => jC((h) => {
      const u = (f) => {
        (f === void 0 || f === !0) && (this.off("sync", u), h());
      };
      this.on("sync", u);
    });
    this.on("sync", (h) => {
      h === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = h === void 0 || h === !0, this.isSynced && !this.isLoaded && this.emit("load", []);
    }), this.whenSynced = l();
  }
  load() {
    const t = this._item;
    t !== null && !this.shouldLoad && Xe(t.parent.doc, (n) => {
      n.subdocsLoaded.add(this);
    }, null, !0), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(rl(this.subdocs).map((t) => t.guid));
  }
  transact(t, n = null) {
    return Xe(this, t, n);
  }
  get(t, n = yr) {
    const r = ma(this.share, t, () => {
      const s = new n();
      return s._integrate(this, null), s;
    }), i = r.constructor;
    if (n !== yr && i !== n)
      if (i === yr) {
        const s = new n();
        s._map = r._map, r._map.forEach((o) => {
          for (; o !== null; o = o.left)
            o.parent = s;
        }), s._start = r._start;
        for (let o = s._start; o !== null; o = o.right)
          o.parent = s;
        return s._length = r._length, this.share.set(t, s), s._integrate(this, null), s;
      } else
        throw new Error(`Type with the name ${t} has already been defined with a different constructor`);
    return r;
  }
  getArray(t = "") {
    return this.get(t, bh);
  }
  getText(t = "") {
    return this.get(t, jh);
  }
  getMap(t = "") {
    return this.get(t, ea);
  }
  getXmlFragment(t = "") {
    return this.get(t, ac);
  }
  toJSON() {
    const t = {};
    return this.share.forEach((n, r) => {
      t[r] = n.toJSON();
    }), t;
  }
  destroy() {
    rl(this.subdocs).forEach((n) => n.destroy());
    const t = this._item;
    if (t !== null) {
      this._item = null;
      const n = t.content;
      n.doc = new Ru({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = t, Xe(t.parent.doc, (r) => {
        const i = n.doc;
        t.deleted || r.subdocsAdded.add(i), r.subdocsRemoved.add(this);
      }, null, !0);
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
  on(t, n) {
    super.on(t, n);
  }
  off(t, n) {
    super.off(t, n);
  }
}
class RL {
  constructor(t) {
    this.restDecoder = t;
  }
  resetDsCurVal() {
  }
  readDsClock() {
    return xe(this.restDecoder);
  }
  readDsLen() {
    return xe(this.restDecoder);
  }
}
class $L extends RL {
  readLeftID() {
    return Se(xe(this.restDecoder), xe(this.restDecoder));
  }
  readRightID() {
    return Se(xe(this.restDecoder), xe(this.restDecoder));
  }
  readClient() {
    return xe(this.restDecoder);
  }
  readInfo() {
    return zh(this.restDecoder);
  }
  readString() {
    return za(this.restDecoder);
  }
  readParentInfo() {
    return xe(this.restDecoder) === 1;
  }
  readTypeRef() {
    return xe(this.restDecoder);
  }
  readLen() {
    return xe(this.restDecoder);
  }
  readAny() {
    return $d(this.restDecoder);
  }
  readBuf() {
    return NK(_r(this.restDecoder));
  }
  readJSON() {
    return JSON.parse(za(this.restDecoder));
  }
  readKey() {
    return za(this.restDecoder);
  }
}
class oJ {
  constructor(t) {
    this.dsCurrVal = 0, this.restDecoder = t;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  readDsClock() {
    return this.dsCurrVal += xe(this.restDecoder), this.dsCurrVal;
  }
  readDsLen() {
    const t = xe(this.restDecoder) + 1;
    return this.dsCurrVal += t, t;
  }
}
class Uh extends oJ {
  constructor(t) {
    super(t), this.keys = [], xe(t), this.keyClockDecoder = new zb(_r(t)), this.clientDecoder = new Y1(_r(t)), this.leftClockDecoder = new zb(_r(t)), this.rightClockDecoder = new zb(_r(t)), this.infoDecoder = new UC(_r(t), zh), this.stringDecoder = new cK(_r(t)), this.parentInfoDecoder = new UC(_r(t), zh), this.typeRefDecoder = new Y1(_r(t)), this.lenDecoder = new Y1(_r(t));
  }
  readLeftID() {
    return new yh(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  readRightID() {
    return new yh(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  readClient() {
    return this.clientDecoder.read();
  }
  readInfo() {
    return this.infoDecoder.read();
  }
  readString() {
    return this.stringDecoder.read();
  }
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  readLen() {
    return this.lenDecoder.read();
  }
  readAny() {
    return $d(this.restDecoder);
  }
  readBuf() {
    return _r(this.restDecoder);
  }
  readJSON() {
    return $d(this.restDecoder);
  }
  readKey() {
    const t = this.keyClockDecoder.read();
    if (t < this.keys.length)
      return this.keys[t];
    {
      const n = this.stringDecoder.read();
      return this.keys.push(n), n;
    }
  }
}
class IL {
  constructor() {
    this.restEncoder = wr();
  }
  toUint8Array() {
    return gn(this.restEncoder);
  }
  resetDsCurVal() {
  }
  writeDsClock(t) {
    ee(this.restEncoder, t);
  }
  writeDsLen(t) {
    ee(this.restEncoder, t);
  }
}
class qp extends IL {
  writeLeftID(t) {
    ee(this.restEncoder, t.client), ee(this.restEncoder, t.clock);
  }
  writeRightID(t) {
    ee(this.restEncoder, t.client), ee(this.restEncoder, t.clock);
  }
  writeClient(t) {
    ee(this.restEncoder, t);
  }
  writeInfo(t) {
    Fv(this.restEncoder, t);
  }
  writeString(t) {
    jl(this.restEncoder, t);
  }
  writeParentInfo(t) {
    ee(this.restEncoder, t ? 1 : 0);
  }
  writeTypeRef(t) {
    ee(this.restEncoder, t);
  }
  writeLen(t) {
    ee(this.restEncoder, t);
  }
  writeAny(t) {
    Rd(this.restEncoder, t);
  }
  writeBuf(t) {
    Sn(this.restEncoder, t);
  }
  writeJSON(t) {
    jl(this.restEncoder, JSON.stringify(t));
  }
  writeKey(t) {
    jl(this.restEncoder, t);
  }
}
class NL {
  constructor() {
    this.restEncoder = wr(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return gn(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  writeDsClock(t) {
    const n = t - this.dsCurrVal;
    this.dsCurrVal = t, ee(this.restEncoder, n);
  }
  writeDsLen(t) {
    t === 0 && _s(), ee(this.restEncoder, t - 1), this.dsCurrVal += t;
  }
}
class oc extends NL {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Yb(), this.clientEncoder = new V1(), this.leftClockEncoder = new Yb(), this.rightClockEncoder = new Yb(), this.infoEncoder = new zC(Fv), this.stringEncoder = new tK(), this.parentInfoEncoder = new zC(Fv), this.typeRefEncoder = new V1(), this.lenEncoder = new V1();
  }
  toUint8Array() {
    const t = wr();
    return ee(t, 0), Sn(t, this.keyClockEncoder.toUint8Array()), Sn(t, this.clientEncoder.toUint8Array()), Sn(t, this.leftClockEncoder.toUint8Array()), Sn(t, this.rightClockEncoder.toUint8Array()), Sn(t, gn(this.infoEncoder)), Sn(t, this.stringEncoder.toUint8Array()), Sn(t, gn(this.parentInfoEncoder)), Sn(t, this.typeRefEncoder.toUint8Array()), Sn(t, this.lenEncoder.toUint8Array()), H2(t, gn(this.restEncoder)), gn(t);
  }
  writeLeftID(t) {
    this.clientEncoder.write(t.client), this.leftClockEncoder.write(t.clock);
  }
  writeRightID(t) {
    this.clientEncoder.write(t.client), this.rightClockEncoder.write(t.clock);
  }
  writeClient(t) {
    this.clientEncoder.write(t);
  }
  writeInfo(t) {
    this.infoEncoder.write(t);
  }
  writeString(t) {
    this.stringEncoder.write(t);
  }
  writeParentInfo(t) {
    this.parentInfoEncoder.write(t ? 1 : 0);
  }
  writeTypeRef(t) {
    this.typeRefEncoder.write(t);
  }
  writeLen(t) {
    this.lenEncoder.write(t);
  }
  writeAny(t) {
    Rd(this.restEncoder, t);
  }
  writeBuf(t) {
    Sn(this.restEncoder, t);
  }
  writeJSON(t) {
    Rd(this.restEncoder, t);
  }
  writeKey(t) {
    const n = this.keyMap.get(t);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(t)) : this.keyClockEncoder.write(n);
  }
}
const aJ = (e, t, n, r) => {
  r = dl(r, t[0].id.clock);
  const i = go(t, r);
  ee(e.restEncoder, t.length - i), e.writeClient(n), ee(e.restEncoder, r);
  const s = t[i];
  s.write(e, r - s.id.clock);
  for (let o = i + 1; o < t.length; o++)
    t[o].write(e, 0);
}, Ww = (e, t, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((i, s) => {
    Ln(t, s) > i && r.set(s, i);
  }), J2(t).forEach((i, s) => {
    n.has(s) || r.set(s, 0);
  }), ee(e.restEncoder, r.size), rl(r.entries()).sort((i, s) => s[0] - i[0]).forEach(([i, s]) => {
    aJ(e, t.clients.get(i), i, s);
  });
}, lJ = (e, t) => {
  const n = ds(), r = xe(e.restDecoder);
  for (let i = 0; i < r; i++) {
    const s = xe(e.restDecoder), o = new Array(s), a = e.readClient();
    let l = xe(e.restDecoder);
    n.set(a, { i: 0, refs: o });
    for (let h = 0; h < s; h++) {
      const u = e.readInfo();
      switch (G2 & u) {
        case 0: {
          const f = e.readLen();
          o[h] = new Ri(Se(a, l), f), l += f;
          break;
        }
        case 10: {
          const f = xe(e.restDecoder);
          o[h] = new $i(Se(a, l), f), l += f;
          break;
        }
        default: {
          const f = (u & (ta | bi)) === 0, d = new Ge(
            Se(a, l),
            null,
            (u & bi) === bi ? e.readLeftID() : null,
            null,
            (u & ta) === ta ? e.readRightID() : null,
            f ? e.readParentInfo() ? t.get(e.readString()) : e.readLeftID() : null,
            f && (u & Ld) === Ld ? e.readString() : null,
            fM(e, u)
          );
          o[h] = d, l += d.length;
        }
      }
    }
  }
  return n;
}, cJ = (e, t, n) => {
  const r = [];
  let i = rl(n.keys()).sort((p, g) => p - g);
  if (i.length === 0)
    return null;
  const s = () => {
    if (i.length === 0)
      return null;
    let p = n.get(i[i.length - 1]);
    for (; p.refs.length === p.i; )
      if (i.pop(), i.length > 0)
        p = n.get(i[i.length - 1]);
      else
        return null;
    return p;
  };
  let o = s();
  if (o === null)
    return null;
  const a = new zL(), l = /* @__PURE__ */ new Map(), h = (p, g) => {
    const m = l.get(p);
    (m == null || m > g) && l.set(p, g);
  };
  let u = o.refs[o.i++];
  const f = /* @__PURE__ */ new Map(), d = () => {
    for (const p of r) {
      const g = p.id.client, m = n.get(g);
      m ? (m.i--, a.clients.set(g, m.refs.slice(m.i)), n.delete(g), m.i = 0, m.refs = []) : a.clients.set(g, [p]), i = i.filter((y) => y !== g);
    }
    r.length = 0;
  };
  for (; ; ) {
    if (u.constructor !== $i) {
      const g = ma(f, u.id.client, () => Ln(t, u.id.client)) - u.id.clock;
      if (g < 0)
        r.push(u), h(u.id.client, u.id.clock - 1), d();
      else {
        const m = u.getMissing(e, t);
        if (m !== null) {
          r.push(u);
          const y = n.get(m) || { refs: [], i: 0 };
          if (y.refs.length === y.i)
            h(m, Ln(t, m)), d();
          else {
            u = y.refs[y.i++];
            continue;
          }
        } else
          (g === 0 || g < u.length) && (u.integrate(e, g), f.set(u.id.client, u.id.clock + u.length));
      }
    }
    if (r.length > 0)
      u = r.pop();
    else if (o !== null && o.i < o.refs.length)
      u = o.refs[o.i++];
    else {
      if (o = s(), o === null)
        break;
      u = o.refs[o.i++];
    }
  }
  if (a.clients.size > 0) {
    const p = new oc();
    return Ww(p, a, /* @__PURE__ */ new Map()), ee(p.restEncoder, 0), { missing: l, update: p.toUint8Array() };
  }
  return null;
}, hJ = (e, t) => Ww(e, t.doc.store, t.beforeState), uJ = (e, t, n, r = new Uh(e)) => Xe(t, (i) => {
  i.local = !1;
  let s = !1;
  const o = i.doc, a = o.store, l = lJ(r, o), h = cJ(i, a, l), u = a.pendingStructs;
  if (u) {
    for (const [d, p] of u.missing)
      if (p < Ln(a, d)) {
        s = !0;
        break;
      }
    if (h) {
      for (const [d, p] of h.missing) {
        const g = u.missing.get(d);
        (g == null || g > p) && u.missing.set(d, p);
      }
      u.update = Hg([u.update, h.update]);
    }
  } else
    a.pendingStructs = h;
  const f = HC(r, i, a);
  if (a.pendingDs) {
    const d = new Uh(pl(a.pendingDs));
    xe(d.restDecoder);
    const p = HC(d, i, a);
    f && p ? a.pendingDs = Hg([f, p]) : a.pendingDs = f || p;
  } else
    a.pendingDs = f;
  if (s) {
    const d = a.pendingStructs.update;
    a.pendingStructs = null, BL(i.doc, d);
  }
}, n, !1), BL = (e, t, n, r = Uh) => {
  const i = pl(t);
  uJ(i, e, n, new r(i));
}, fJ = (e, t, n) => BL(e, t, n, $L), dJ = (e, t, n = /* @__PURE__ */ new Map()) => {
  Ww(e, t.store, n), Mu(e, sJ(t.store));
}, pJ = (e, t = new Uint8Array([0]), n = new oc()) => {
  const r = FL(t);
  dJ(n, e, r);
  const i = [n.toUint8Array()];
  if (e.store.pendingDs && i.push(e.store.pendingDs), e.store.pendingStructs && i.push(RJ(e.store.pendingStructs.update, t)), i.length > 1) {
    if (n.constructor === qp)
      return LJ(i.map((s, o) => o === 0 ? s : IJ(s)));
    if (n.constructor === oc)
      return Hg(i);
  }
  return i[0];
}, gJ = (e, t) => pJ(e, t, new qp()), mJ = (e) => {
  const t = /* @__PURE__ */ new Map(), n = xe(e.restDecoder);
  for (let r = 0; r < n; r++) {
    const i = xe(e.restDecoder), s = xe(e.restDecoder);
    t.set(i, s);
  }
  return t;
}, FL = (e) => mJ(new RL(pl(e))), QL = (e, t) => (ee(e.restEncoder, t.size), rl(t.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
  ee(e.restEncoder, n), ee(e.restEncoder, r);
}), e), yJ = (e, t) => QL(e, J2(t.store)), bJ = (e, t = new NL()) => (e instanceof Map ? QL(t, e) : yJ(t, e), t.toUint8Array()), OJ = (e) => bJ(e, new IL());
class xJ {
  constructor() {
    this.l = [];
  }
}
const KC = () => new xJ(), JC = (e, t) => e.l.push(t), tT = (e, t) => {
  const n = e.l, r = n.length;
  e.l = n.filter((i) => t !== i), r === e.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, ZL = (e, t, n) => Zw(e.l, [t, n]);
class yh {
  constructor(t, n) {
    this.client = t, this.clock = n;
  }
}
const Jc = (e, t) => e === t || e !== null && t !== null && e.client === t.client && e.clock === t.clock, Se = (e, t) => new yh(e, t), VL = (e) => {
  for (const [t, n] of e.doc.share.entries())
    if (n === e)
      return t;
  throw _s();
}, Gg = (e, t) => {
  for (; t !== null; ) {
    if (t.parent === e)
      return !0;
    t = t.parent._item;
  }
  return !1;
};
class YL {
  constructor(t, n, r, i = 0) {
    this.type = t, this.tname = n, this.item = r, this.assoc = i;
  }
}
const eT = (e) => {
  const t = {};
  return e.type && (t.type = e.type), e.tname && (t.tname = e.tname), e.item && (t.item = e.item), e.assoc != null && (t.assoc = e.assoc), t;
}, Nd = (e) => new YL(e.type == null ? null : Se(e.type.client, e.type.clock), e.tname || null, e.item == null ? null : Se(e.item.client, e.item.clock), e.assoc == null ? 0 : e.assoc);
class vJ {
  constructor(t, n, r = 0) {
    this.type = t, this.index = n, this.assoc = r;
  }
}
const _J = (e, t, n = 0) => new vJ(e, t, n), Y0 = (e, t, n) => {
  let r = null, i = null;
  return e._item === null ? i = VL(e) : r = Se(e._item.id.client, e._item.id.clock), new YL(r, i, t, n);
}, Bd = (e, t, n = 0) => {
  let r = e._start;
  if (n < 0) {
    if (t === 0)
      return Y0(e, null, n);
    t--;
  }
  for (; r !== null; ) {
    if (!r.deleted && r.countable) {
      if (r.length > t)
        return Y0(e, Se(r.id.client, r.id.clock + t), n);
      t -= r.length;
    }
    if (r.right === null && n < 0)
      return Y0(e, r.lastId, n);
    r = r.right;
  }
  return Y0(e, null, n);
}, zv = (e, t) => {
  const n = t.store, r = e.item, i = e.type, s = e.tname, o = e.assoc;
  let a = null, l = 0;
  if (r !== null) {
    if (Ln(n, r.client) <= r.clock)
      return null;
    const h = jv(n, r), u = h.item;
    if (!(u instanceof Ge))
      return null;
    if (a = u.parent, a._item === null || !a._item.deleted) {
      l = u.deleted || !u.countable ? 0 : h.diff + (o >= 0 ? 0 : 1);
      let f = u.left;
      for (; f !== null; )
        !f.deleted && f.countable && (l += f.length), f = f.left;
    }
  } else {
    if (s !== null)
      a = t.get(s);
    else if (i !== null) {
      if (Ln(n, i.client) <= i.clock)
        return null;
      const { item: h } = jv(n, i);
      if (h instanceof Ge && h.content instanceof _o)
        a = h.content.type;
      else
        return null;
    } else
      throw _s();
    o >= 0 ? l = a._length : l = 0;
  }
  return _J(a, l, e.assoc);
}, nT = (e, t) => e === t || e !== null && t !== null && e.tname === t.tname && Jc(e.item, t.item) && Jc(e.type, t.type) && e.assoc === t.assoc;
class kJ {
  constructor(t, n) {
    this.ds = t, this.sv = n;
  }
}
const wJ = (e, t) => new kJ(e, t);
wJ(LL(), /* @__PURE__ */ new Map());
const Wc = (e, t) => t === void 0 ? !e.deleted : t.sv.has(e.id.client) && (t.sv.get(e.id.client) || 0) > e.id.clock && !zp(t.ds, e.id), qv = (e, t) => {
  const n = ma(e.meta, qv, sc), r = e.doc.store;
  n.has(t) || (t.sv.forEach((i, s) => {
    i < Ln(r, s) && Hr(e, Se(s, i));
  }), Wh(e, t.ds, (i) => {
  }), n.add(t));
};
class zL {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const J2 = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.clients.forEach((n, r) => {
    const i = n[n.length - 1];
    t.set(r, i.id.clock + i.length);
  }), t;
}, Ln = (e, t) => {
  const n = e.clients.get(t);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, qL = (e, t) => {
  let n = e.clients.get(t.id.client);
  if (n === void 0)
    n = [], e.clients.set(t.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== t.id.clock)
      throw _s();
  }
  n.push(t);
}, go = (e, t) => {
  let n = 0, r = e.length - 1, i = e[r], s = i.id.clock;
  if (s === t)
    return r;
  let o = ca(t / (s + i.length - 1) * r);
  for (; n <= r; ) {
    if (i = e[o], s = i.id.clock, s <= t) {
      if (t < s + i.length)
        return o;
      n = o + 1;
    } else
      r = o - 1;
    o = ca((n + r) / 2);
  }
  throw _s();
}, SJ = (e, t) => {
  const n = e.clients.get(t.client);
  return n[go(n, t.clock)];
}, z1 = SJ, Wv = (e, t, n) => {
  const r = go(t, n), i = t[r];
  return i.id.clock < n && i instanceof Ge ? (t.splice(r + 1, 0, rm(e, i, n - i.id.clock)), r + 1) : r;
}, Hr = (e, t) => {
  const n = e.doc.store.clients.get(t.client);
  return n[Wv(e, n, t.clock)];
}, rT = (e, t, n) => {
  const r = t.clients.get(n.client), i = go(r, n.clock), s = r[i];
  return n.clock !== s.id.clock + s.length - 1 && s.constructor !== Ri && r.splice(i + 1, 0, rm(e, s, n.clock - s.id.clock + 1)), s;
}, CJ = (e, t, n) => {
  const r = e.clients.get(t.id.client);
  r[go(r, t.id.clock)] = n;
}, WL = (e, t, n, r, i) => {
  if (r === 0)
    return;
  const s = n + r;
  let o = Wv(e, t, n), a;
  do
    a = t[o++], s < a.id.clock + a.length && Wv(e, t, s), i(a);
  while (o < t.length && t[o].id.clock < s);
};
class TJ {
  constructor(t, n, r) {
    this.doc = t, this.deleteSet = new Lu(), this.beforeState = J2(t.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const iT = (e, t) => t.deleteSet.clients.size === 0 && !LH(t.afterState, (n, r) => t.beforeState.get(r) !== n) ? !1 : (zw(t.deleteSet), hJ(e, t), Mu(e, t.deleteSet), !0), sT = (e, t, n) => {
  const r = t._item;
  (r === null || r.id.clock < (e.beforeState.get(r.id.client) || 0) && !r.deleted) && ma(e.changed, t, sc).add(n);
}, q1 = (e, t) => {
  let n = e[t], r = e[t - 1], i = t;
  for (; i > 0; n = r, r = e[--i - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof Ge && n.parentSub !== null && n.parent._map.get(n.parentSub) === n && n.parent._map.set(n.parentSub, r);
      continue;
    }
    break;
  }
  const s = t - i;
  return s && e.splice(t + 1 - s, s), s;
}, EJ = (e, t, n) => {
  for (const [r, i] of e.clients.entries()) {
    const s = t.clients.get(r);
    for (let o = i.length - 1; o >= 0; o--) {
      const a = i[o], l = a.clock + a.len;
      for (let h = go(s, a.clock), u = s[h]; h < s.length && u.id.clock < l; u = s[++h]) {
        const f = s[h];
        if (a.clock + a.len <= f.id.clock)
          break;
        f instanceof Ge && f.deleted && !f.keep && n(f) && f.gc(t, !1);
      }
    }
  }
}, AJ = (e, t) => {
  e.clients.forEach((n, r) => {
    const i = t.clients.get(r);
    for (let s = n.length - 1; s >= 0; s--) {
      const o = n[s], a = X2(i.length - 1, 1 + go(i, o.clock + o.len - 1));
      for (let l = a, h = i[l]; l > 0 && h.id.clock >= o.clock; h = i[l])
        l -= 1 + q1(i, l);
    }
  });
}, UL = (e, t) => {
  if (t < e.length) {
    const n = e[t], r = n.doc, i = r.store, s = n.deleteSet, o = n._mergeStructs;
    try {
      zw(s), n.afterState = J2(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const a = [];
      n.changed.forEach(
        (l, h) => a.push(() => {
          (h._item === null || !h._item.deleted) && h._callObserver(n, l);
        })
      ), a.push(() => {
        n.changedParentTypes.forEach((l, h) => {
          h._dEH.l.length > 0 && (h._item === null || !h._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = h, u._path = null;
          }), l.sort((u, f) => u.path.length - f.path.length), ZL(h._dEH, l, n));
        });
      }), a.push(() => r.emit("afterTransaction", [n, r])), Zw(a, []), n._needFormattingCleanup && GJ(n);
    } finally {
      r.gc && EJ(s, i, r.gcFilter), AJ(s, i), n.afterState.forEach((u, f) => {
        const d = n.beforeState.get(f) || 0;
        if (d !== u) {
          const p = i.clients.get(f), g = dl(go(p, d), 1);
          for (let m = p.length - 1; m >= g; )
            m -= 1 + q1(p, m);
        }
      });
      for (let u = o.length - 1; u >= 0; u--) {
        const { client: f, clock: d } = o[u].id, p = i.clients.get(f), g = go(p, d);
        g + 1 < p.length && q1(p, g + 1) > 1 || g > 0 && q1(p, g);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (eJ(Vw, CL, "[yjs] ", TL, EL, "Changed the client-id because another client seems to be using it."), r.clientID = ML()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const u = new qp();
        iT(u, n) && r.emit("update", [u.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const u = new oc();
        iT(u, n) && r.emit("updateV2", [u.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: h } = n;
      (a.size > 0 || h.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = r.clientID, u.collectionid == null && (u.collectionid = r.collectionid), r.subdocs.add(u);
      }), h.forEach((u) => r.subdocs.delete(u)), r.emit("subdocs", [{ loaded: l, added: a, removed: h }, r, n]), h.forEach((u) => u.destroy())), e.length <= t + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, e])) : UL(e, t + 1);
    }
  }
}, Xe = (e, t, n = null, r = !0) => {
  const i = e._transactionCleanups;
  let s = !1, o = null;
  e._transaction === null && (s = !0, e._transaction = new TJ(e, n, r), i.push(e._transaction), i.length === 1 && e.emit("beforeAllTransactions", [e]), e.emit("beforeTransaction", [e._transaction, e]));
  try {
    o = t(e._transaction);
  } finally {
    if (s) {
      const a = e._transaction === i[0];
      e._transaction = null, a && UL(i, 0);
    }
  }
  return o;
};
class PJ {
  constructor(t, n) {
    this.insertions = n, this.deletions = t, this.meta = /* @__PURE__ */ new Map();
  }
}
const oT = (e, t, n) => {
  Wh(e, n.deletions, (r) => {
    r instanceof Ge && t.scope.some((i) => Gg(i, r)) && e3(r, !1);
  });
}, aT = (e, t, n) => {
  let r = null, i = null;
  const s = e.doc, o = e.scope;
  if (Xe(s, (a) => {
    for (; t.length > 0 && r === null; ) {
      const l = s.store, h = t.pop(), u = /* @__PURE__ */ new Set(), f = [];
      let d = !1;
      Wh(a, h.insertions, (p) => {
        if (p instanceof Ge) {
          if (p.redone !== null) {
            let { item: g, diff: m } = jv(l, p.id);
            m > 0 && (g = Hr(a, Se(g.id.client, g.id.clock + m))), p = g;
          }
          !p.deleted && o.some((g) => Gg(g, p)) && f.push(p);
        }
      }), Wh(a, h.deletions, (p) => {
        p instanceof Ge && o.some((g) => Gg(g, p)) && !zp(h.insertions, p.id) && u.add(p);
      }), u.forEach((p) => {
        d = uM(a, p, u, h.insertions, e.ignoreRemoteMapChanges, e) !== null || d;
      });
      for (let p = f.length - 1; p >= 0; p--) {
        const g = f[p];
        e.deleteFilter(g) && (g.delete(a), d = !0);
      }
      r = d ? h : null;
    }
    a.changed.forEach((l, h) => {
      l.has(null) && h._searchMarker && (h._searchMarker.length = 0);
    }), i = a;
  }, e), r != null) {
    const a = i.changedParentTypes;
    e.emit("stack-item-popped", [{ stackItem: r, type: n, changedParentTypes: a }, e]);
  }
  return r;
};
class Uw extends j2 {
  constructor(t, {
    captureTimeout: n = 500,
    captureTransaction: r = (l) => !0,
    deleteFilter: i = () => !0,
    trackedOrigins: s = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: o = !1,
    doc: a = Nv(t) ? t[0].doc : t.doc
  } = {}) {
    super(), this.scope = [], this.doc = a, this.addToScope(t), this.deleteFilter = i, s.add(this), this.trackedOrigins = s, this.captureTransaction = r, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.lastChange = 0, this.ignoreRemoteMapChanges = o, this.captureTimeout = n, this.afterTransactionHandler = (l) => {
      if (!this.captureTransaction(l) || !this.scope.some((y) => l.changedParentTypes.has(y)) || !this.trackedOrigins.has(l.origin) && (!l.origin || !this.trackedOrigins.has(l.origin.constructor)))
        return;
      const h = this.undoing, u = this.redoing, f = h ? this.redoStack : this.undoStack;
      h ? this.stopCapturing() : u || this.clear(!1, !0);
      const d = new Lu();
      l.afterState.forEach((y, O) => {
        const x = l.beforeState.get(O) || 0, _ = y - x;
        _ > 0 && Id(d, O, x, _);
      });
      const p = sl();
      let g = !1;
      if (this.lastChange > 0 && p - this.lastChange < this.captureTimeout && f.length > 0 && !h && !u) {
        const y = f[f.length - 1];
        y.deletions = Yv([y.deletions, l.deleteSet]), y.insertions = Yv([y.insertions, d]);
      } else
        f.push(new PJ(l.deleteSet, d)), g = !0;
      !h && !u && (this.lastChange = p), Wh(l, l.deleteSet, (y) => {
        y instanceof Ge && this.scope.some((O) => Gg(O, y)) && e3(y, !0);
      });
      const m = [{ stackItem: f[f.length - 1], origin: l.origin, type: h ? "redo" : "undo", changedParentTypes: l.changedParentTypes }, this];
      g ? this.emit("stack-item-added", m) : this.emit("stack-item-updated", m);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  addToScope(t) {
    t = Nv(t) ? t : [t], t.forEach((n) => {
      this.scope.every((r) => r !== n) && (n.doc !== this.doc && nJ("[yjs#509] Not same Y.Doc"), this.scope.push(n));
    });
  }
  addTrackedOrigin(t) {
    this.trackedOrigins.add(t);
  }
  removeTrackedOrigin(t) {
    this.trackedOrigins.delete(t);
  }
  clear(t = !0, n = !0) {
    (t && this.canUndo() || n && this.canRedo()) && this.doc.transact((r) => {
      t && (this.undoStack.forEach((i) => oT(r, this, i)), this.undoStack = []), n && (this.redoStack.forEach((i) => oT(r, this, i)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: t, redoStackCleared: n }]);
    });
  }
  stopCapturing() {
    this.lastChange = 0;
  }
  undo() {
    this.undoing = !0;
    let t;
    try {
      t = aT(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return t;
  }
  redo() {
    this.redoing = !0;
    let t;
    try {
      t = aT(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return t;
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* DJ(e) {
  const t = xe(e.restDecoder);
  for (let n = 0; n < t; n++) {
    const r = xe(e.restDecoder), i = e.readClient();
    let s = xe(e.restDecoder);
    for (let o = 0; o < r; o++) {
      const a = e.readInfo();
      if (a === 10) {
        const l = xe(e.restDecoder);
        yield new $i(Se(i, s), l), s += l;
      } else if ((G2 & a) !== 0) {
        const l = (a & (ta | bi)) === 0, h = new Ge(
          Se(i, s),
          null,
          (a & bi) === bi ? e.readLeftID() : null,
          null,
          (a & ta) === ta ? e.readRightID() : null,
          l ? e.readParentInfo() ? e.readString() : e.readLeftID() : null,
          l && (a & Ld) === Ld ? e.readString() : null,
          fM(e, a)
        );
        yield h, s += h.length;
      } else {
        const l = e.readLen();
        yield new Ri(Se(i, s), l), s += l;
      }
    }
  }
}
class jw {
  constructor(t, n) {
    this.gen = DJ(t), this.curr = null, this.done = !1, this.filterSkips = n, this.next();
  }
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === $i);
    return this.curr;
  }
}
class Xw {
  constructor(t) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = t, this.clientStructs = [];
  }
}
const LJ = (e) => Hg(e, $L, qp), MJ = (e, t) => {
  if (e.constructor === Ri) {
    const { client: n, clock: r } = e.id;
    return new Ri(Se(n, r + t), e.length - t);
  } else if (e.constructor === $i) {
    const { client: n, clock: r } = e.id;
    return new $i(Se(n, r + t), e.length - t);
  } else {
    const n = e, { client: r, clock: i } = n.id;
    return new Ge(
      Se(r, i + t),
      null,
      Se(r, i + t - 1),
      null,
      n.rightOrigin,
      n.parent,
      n.parentSub,
      n.content.splice(t)
    );
  }
}, Hg = (e, t = Uh, n = oc) => {
  if (e.length === 1)
    return e[0];
  const r = e.map((u) => new t(pl(u)));
  let i = r.map((u) => new jw(u, !0)), s = null;
  const o = new n(), a = new Xw(o);
  for (; i = i.filter((d) => d.curr !== null), i.sort(
    (d, p) => {
      if (d.curr.id.client === p.curr.id.client) {
        const g = d.curr.id.clock - p.curr.id.clock;
        return g === 0 ? d.curr.constructor === p.curr.constructor ? 0 : d.curr.constructor === $i ? 1 : -1 : g;
      } else
        return p.curr.id.client - d.curr.id.client;
    }
  ), i.length !== 0; ) {
    const u = i[0], f = u.curr.id.client;
    if (s !== null) {
      let d = u.curr, p = !1;
      for (; d !== null && d.id.clock + d.length <= s.struct.id.clock + s.struct.length && d.id.client >= s.struct.id.client; )
        d = u.next(), p = !0;
      if (d === null || d.id.client !== f || p && d.id.clock > s.struct.id.clock + s.struct.length)
        continue;
      if (f !== s.struct.id.client)
        Da(a, s.struct, s.offset), s = { struct: d, offset: 0 }, u.next();
      else if (s.struct.id.clock + s.struct.length < d.id.clock)
        if (s.struct.constructor === $i)
          s.struct.length = d.id.clock + d.length - s.struct.id.clock;
        else {
          Da(a, s.struct, s.offset);
          const g = d.id.clock - s.struct.id.clock - s.struct.length;
          s = { struct: new $i(Se(f, s.struct.id.clock + s.struct.length), g), offset: 0 };
        }
      else {
        const g = s.struct.id.clock + s.struct.length - d.id.clock;
        g > 0 && (s.struct.constructor === $i ? s.struct.length -= g : d = MJ(d, g)), s.struct.mergeWith(d) || (Da(a, s.struct, s.offset), s = { struct: d, offset: 0 }, u.next());
      }
    } else
      s = { struct: u.curr, offset: 0 }, u.next();
    for (let d = u.curr; d !== null && d.id.client === f && d.id.clock === s.struct.id.clock + s.struct.length && d.constructor !== $i; d = u.next())
      Da(a, s.struct, s.offset), s = { struct: d, offset: 0 };
  }
  s !== null && (Da(a, s.struct, s.offset), s = null), Gw(a);
  const l = r.map((u) => qw(u)), h = Yv(l);
  return Mu(o, h), o.toUint8Array();
}, RJ = (e, t, n = Uh, r = oc) => {
  const i = FL(t), s = new r(), o = new Xw(s), a = new n(pl(e)), l = new jw(a, !1);
  for (; l.curr; ) {
    const u = l.curr, f = u.id.client, d = i.get(f) || 0;
    if (l.curr.constructor === $i) {
      l.next();
      continue;
    }
    if (u.id.clock + u.length > d)
      for (Da(o, u, dl(d - u.id.clock, 0)), l.next(); l.curr && l.curr.id.client === f; )
        Da(o, l.curr, 0), l.next();
    else
      for (; l.curr && l.curr.id.client === f && l.curr.id.clock + l.curr.length <= d; )
        l.next();
  }
  Gw(o);
  const h = qw(a);
  return Mu(s, h), s.toUint8Array();
}, jL = (e) => {
  e.written > 0 && (e.clientStructs.push({ written: e.written, restEncoder: gn(e.encoder.restEncoder) }), e.encoder.restEncoder = wr(), e.written = 0);
}, Da = (e, t, n) => {
  e.written > 0 && e.currClient !== t.id.client && jL(e), e.written === 0 && (e.currClient = t.id.client, e.encoder.writeClient(t.id.client), ee(e.encoder.restEncoder, t.id.clock + n)), t.write(e.encoder, n), e.written++;
}, Gw = (e) => {
  jL(e);
  const t = e.encoder.restEncoder;
  ee(t, e.clientStructs.length);
  for (let n = 0; n < e.clientStructs.length; n++) {
    const r = e.clientStructs[n];
    ee(t, r.written), H2(t, r.restEncoder);
  }
}, $J = (e, t, n, r) => {
  const i = new n(pl(e)), s = new jw(i, !1), o = new r(), a = new Xw(o);
  for (let h = s.curr; h !== null; h = s.next())
    Da(a, t(h), 0);
  Gw(a);
  const l = qw(i);
  return Mu(o, l), o.toUint8Array();
}, IJ = (e) => $J(e, kK, Uh, qp), lT = "You must not compute changes after the event-handler fired.";
class ty {
  constructor(t, n) {
    this.target = t, this.currentTarget = t, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  get path() {
    return this._path || (this._path = NJ(this.currentTarget, this.target));
  }
  deletes(t) {
    return zp(this.transaction.deleteSet, t.id);
  }
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw il(lT);
      const t = /* @__PURE__ */ new Map(), n = this.target;
      this.transaction.changed.get(n).forEach((i) => {
        if (i !== null) {
          const s = n._map.get(i);
          let o, a;
          if (this.adds(s)) {
            let l = s.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(s))
              if (l !== null && this.deletes(l))
                o = "delete", a = Qb(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (o = "update", a = Qb(l.content.getContent())) : (o = "add", a = void 0);
          } else if (this.deletes(s))
            o = "delete", a = Qb(s.content.getContent());
          else
            return;
          t.set(i, { action: o, oldValue: a });
        }
      }), this._keys = t;
    }
    return this._keys;
  }
  get delta() {
    return this.changes.delta;
  }
  adds(t) {
    return t.id.clock >= (this.transaction.beforeState.get(t.id.client) || 0);
  }
  get changes() {
    let t = this._changes;
    if (t === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw il(lT);
      const n = this.target, r = sc(), i = sc(), s = [];
      if (t = {
        added: r,
        deleted: i,
        delta: s,
        keys: this.keys
      }, this.transaction.changed.get(n).has(null)) {
        let a = null;
        const l = () => {
          a && s.push(a);
        };
        for (let h = n._start; h !== null; h = h.right)
          h.deleted ? this.deletes(h) && !this.adds(h) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += h.length, i.add(h)) : this.adds(h) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(h.content.getContent()), r.add(h)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += h.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = t;
    }
    return t;
  }
}
const NJ = (e, t) => {
  const n = [];
  for (; t._item !== null && t !== e; ) {
    if (t._item.parentSub !== null)
      n.unshift(t._item.parentSub);
    else {
      let r = 0, i = t._item.parent._start;
      for (; i !== t._item && i !== null; )
        i.deleted || r++, i = i.right;
      n.unshift(r);
    }
    t = t._item.parent;
  }
  return n;
}, XL = 80;
let Hw = 0;
class BJ {
  constructor(t, n) {
    t.marker = !0, this.p = t, this.index = n, this.timestamp = Hw++;
  }
}
const FJ = (e) => {
  e.timestamp = Hw++;
}, GL = (e, t, n) => {
  e.p.marker = !1, e.p = t, t.marker = !0, e.index = n, e.timestamp = Hw++;
}, QJ = (e, t, n) => {
  if (e.length >= XL) {
    const r = e.reduce((i, s) => i.timestamp < s.timestamp ? i : s);
    return GL(r, t, n), r;
  } else {
    const r = new BJ(t, n);
    return e.push(r), r;
  }
}, ey = (e, t) => {
  if (e._start === null || t === 0 || e._searchMarker === null)
    return null;
  const n = e._searchMarker.length === 0 ? null : e._searchMarker.reduce((s, o) => Z1(t - s.index) < Z1(t - o.index) ? s : o);
  let r = e._start, i = 0;
  for (n !== null && (r = n.p, i = n.index, FJ(n)); r.right !== null && i < t; ) {
    if (!r.deleted && r.countable) {
      if (t < i + r.length)
        break;
      i += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && i > t; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  return n !== null && Z1(n.index - i) < r.parent.length / XL ? (GL(n, r, i), n) : QJ(e._searchMarker, r, i);
}, Fd = (e, t, n) => {
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    if (n > 0) {
      let s = i.p;
      for (s.marker = !1; s && (s.deleted || !s.countable); )
        s = s.left, s && !s.deleted && s.countable && (i.index -= s.length);
      if (s === null || s.marker === !0) {
        e.splice(r, 1);
        continue;
      }
      i.p = s, s.marker = !0;
    }
    (t < i.index || n > 0 && t === i.index) && (i.index = dl(t, i.index + n));
  }
}, ny = (e, t, n) => {
  const r = e, i = t.changedParentTypes;
  for (; ma(i, e, () => []).push(n), e._item !== null; )
    e = e._item.parent;
  ZL(r._eH, n, t);
};
class yr {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = KC(), this._dEH = KC(), this._searchMarker = null;
  }
  get parent() {
    return this._item ? this._item.parent : null;
  }
  _integrate(t, n) {
    this.doc = t, this._item = n;
  }
  _copy() {
    throw ao();
  }
  clone() {
    throw ao();
  }
  _write(t) {
  }
  get _first() {
    let t = this._start;
    for (; t !== null && t.deleted; )
      t = t.right;
    return t;
  }
  _callObserver(t, n) {
    !t.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  observe(t) {
    JC(this._eH, t);
  }
  observeDeep(t) {
    JC(this._dEH, t);
  }
  unobserve(t) {
    tT(this._eH, t);
  }
  unobserveDeep(t) {
    tT(this._dEH, t);
  }
  toJSON() {
  }
}
const HL = (e, t, n) => {
  t < 0 && (t = e._length + t), n < 0 && (n = e._length + n);
  let r = n - t;
  const i = [];
  let s = e._start;
  for (; s !== null && r > 0; ) {
    if (s.countable && !s.deleted) {
      const o = s.content.getContent();
      if (o.length <= t)
        t -= o.length;
      else {
        for (let a = t; a < o.length && r > 0; a++)
          i.push(o[a]), r--;
        t = 0;
      }
    }
    s = s.right;
  }
  return i;
}, KL = (e) => {
  const t = [];
  let n = e._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let i = 0; i < r.length; i++)
        t.push(r[i]);
    }
    n = n.right;
  }
  return t;
}, Qd = (e, t) => {
  let n = 0, r = e._start;
  for (; r !== null; ) {
    if (r.countable && !r.deleted) {
      const i = r.content.getContent();
      for (let s = 0; s < i.length; s++)
        t(i[s], n++, e);
    }
    r = r.right;
  }
}, JL = (e, t) => {
  const n = [];
  return Qd(e, (r, i) => {
    n.push(t(r, i, e));
  }), n;
}, ZJ = (e) => {
  let t = e._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; t !== null && t.deleted; )
          t = t.right;
        if (t === null)
          return {
            done: !0,
            value: void 0
          };
        n = t.content.getContent(), r = 0, t = t.right;
      }
      const i = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: i
      };
    }
  };
}, tM = (e, t) => {
  const n = ey(e, t);
  let r = e._start;
  for (n !== null && (r = n.p, t -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (t < r.length)
        return r.content.getContent()[t];
      t -= r.length;
    }
}, Kg = (e, t, n, r) => {
  let i = n;
  const s = e.doc, o = s.clientID, a = s.store, l = n === null ? t._start : n.right;
  let h = [];
  const u = () => {
    h.length > 0 && (i = new Ge(Se(o, Ln(a, o)), i, i && i.lastId, l, l && l.id, t, null, new lc(h)), i.integrate(e, 0), h = []);
  };
  r.forEach((f) => {
    if (f === null)
      h.push(f);
    else
      switch (f.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          h.push(f);
          break;
        default:
          switch (u(), f.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new Ge(Se(o, Ln(a, o)), i, i && i.lastId, l, l && l.id, t, null, new Wp(new Uint8Array(f))), i.integrate(e, 0);
              break;
            case Ru:
              i = new Ge(Se(o, Ln(a, o)), i, i && i.lastId, l, l && l.id, t, null, new Up(f)), i.integrate(e, 0);
              break;
            default:
              if (f instanceof yr)
                i = new Ge(Se(o, Ln(a, o)), i, i && i.lastId, l, l && l.id, t, null, new _o(f)), i.integrate(e, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, eM = () => il("Length exceeded!"), nM = (e, t, n, r) => {
  if (n > t._length)
    throw eM();
  if (n === 0)
    return t._searchMarker && Fd(t._searchMarker, n, r.length), Kg(e, t, null, r);
  const i = n, s = ey(t, n);
  let o = t._start;
  for (s !== null && (o = s.p, n -= s.index, n === 0 && (o = o.prev, n += o && o.countable && !o.deleted ? o.length : 0)); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (n <= o.length) {
        n < o.length && Hr(e, Se(o.id.client, o.id.clock + n));
        break;
      }
      n -= o.length;
    }
  return t._searchMarker && Fd(t._searchMarker, i, r.length), Kg(e, t, o, r);
}, VJ = (e, t, n) => {
  let i = (t._searchMarker || []).reduce((s, o) => o.index > s.index ? o : s, { index: 0, p: t._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return Kg(e, t, i, n);
}, rM = (e, t, n, r) => {
  if (r === 0)
    return;
  const i = n, s = r, o = ey(t, n);
  let a = t._start;
  for (o !== null && (a = o.p, n -= o.index); a !== null && n > 0; a = a.right)
    !a.deleted && a.countable && (n < a.length && Hr(e, Se(a.id.client, a.id.clock + n)), n -= a.length);
  for (; r > 0 && a !== null; )
    a.deleted || (r < a.length && Hr(e, Se(a.id.client, a.id.clock + r)), a.delete(e), r -= a.length), a = a.right;
  if (r > 0)
    throw eM();
  t._searchMarker && Fd(t._searchMarker, i, -s + r);
}, Jg = (e, t, n) => {
  const r = t._map.get(n);
  r !== void 0 && r.delete(e);
}, Kw = (e, t, n, r) => {
  const i = t._map.get(n) || null, s = e.doc, o = s.clientID;
  let a;
  if (r == null)
    a = new lc([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        a = new lc([r]);
        break;
      case Uint8Array:
        a = new Wp(r);
        break;
      case Ru:
        a = new Up(r);
        break;
      default:
        if (r instanceof yr)
          a = new _o(r);
        else
          throw new Error("Unexpected content type");
    }
  new Ge(Se(o, Ln(s.store, o)), i, i && i.lastId, null, null, t, n, a).integrate(e, 0);
}, Jw = (e, t) => {
  const n = e._map.get(t);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, iM = (e) => {
  const t = {};
  return e._map.forEach((n, r) => {
    n.deleted || (t[r] = n.content.getContent()[n.length - 1]);
  }), t;
}, sM = (e, t) => {
  const n = e._map.get(t);
  return n !== void 0 && !n.deleted;
}, YJ = (e, t) => {
  const n = {};
  return e._map.forEach((r, i) => {
    let s = r;
    for (; s !== null && (!t.sv.has(s.id.client) || s.id.clock >= (t.sv.get(s.id.client) || 0)); )
      s = s.left;
    s !== null && Wc(s, t) && (n[i] = s.content.getContent()[s.length - 1]);
  }), n;
}, z0 = (e) => rJ(e.entries(), (t) => !t[1].deleted);
class zJ extends ty {
  constructor(t, n) {
    super(t, n), this._transaction = n;
  }
}
class bh extends yr {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  static from(t) {
    const n = new bh();
    return n.push(t), n;
  }
  _integrate(t, n) {
    super._integrate(t, n), this.insert(0, this._prelimContent), this._prelimContent = null;
  }
  _copy() {
    return new bh();
  }
  clone() {
    const t = new bh();
    return t.insert(0, this.toArray().map(
      (n) => n instanceof yr ? n.clone() : n
    )), t;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  _callObserver(t, n) {
    super._callObserver(t, n), ny(this, t, new zJ(this, t));
  }
  insert(t, n) {
    this.doc !== null ? Xe(this.doc, (r) => {
      nM(r, this, t, n);
    }) : this._prelimContent.splice(t, 0, ...n);
  }
  push(t) {
    this.doc !== null ? Xe(this.doc, (n) => {
      VJ(n, this, t);
    }) : this._prelimContent.push(...t);
  }
  unshift(t) {
    this.insert(0, t);
  }
  delete(t, n = 1) {
    this.doc !== null ? Xe(this.doc, (r) => {
      rM(r, this, t, n);
    }) : this._prelimContent.splice(t, n);
  }
  get(t) {
    return tM(this, t);
  }
  toArray() {
    return KL(this);
  }
  slice(t = 0, n = this.length) {
    return HL(this, t, n);
  }
  toJSON() {
    return this.map((t) => t instanceof yr ? t.toJSON() : t);
  }
  map(t) {
    return JL(this, t);
  }
  forEach(t) {
    Qd(this, t);
  }
  [Symbol.iterator]() {
    return ZJ(this);
  }
  _write(t) {
    t.writeTypeRef(ptt);
  }
}
const qJ = (e) => new bh();
class WJ extends ty {
  constructor(t, n, r) {
    super(t, n), this.keysChanged = r;
  }
}
class ea extends yr {
  constructor(t) {
    super(), this._prelimContent = null, t === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(t);
  }
  _integrate(t, n) {
    super._integrate(t, n), this._prelimContent.forEach((r, i) => {
      this.set(i, r);
    }), this._prelimContent = null;
  }
  _copy() {
    return new ea();
  }
  clone() {
    const t = new ea();
    return this.forEach((n, r) => {
      t.set(r, n instanceof yr ? n.clone() : n);
    }), t;
  }
  _callObserver(t, n) {
    ny(this, t, new WJ(this, t, n));
  }
  toJSON() {
    const t = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const i = n.content.getContent()[n.length - 1];
        t[r] = i instanceof yr ? i.toJSON() : i;
      }
    }), t;
  }
  get size() {
    return [...z0(this._map)].length;
  }
  keys() {
    return Wb(z0(this._map), (t) => t[0]);
  }
  values() {
    return Wb(z0(this._map), (t) => t[1].content.getContent()[t[1].length - 1]);
  }
  entries() {
    return Wb(z0(this._map), (t) => [t[0], t[1].content.getContent()[t[1].length - 1]]);
  }
  forEach(t) {
    this._map.forEach((n, r) => {
      n.deleted || t(n.content.getContent()[n.length - 1], r, this);
    });
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  delete(t) {
    this.doc !== null ? Xe(this.doc, (n) => {
      Jg(n, this, t);
    }) : this._prelimContent.delete(t);
  }
  set(t, n) {
    return this.doc !== null ? Xe(this.doc, (r) => {
      Kw(r, this, t, n);
    }) : this._prelimContent.set(t, n), n;
  }
  get(t) {
    return Jw(this, t);
  }
  has(t) {
    return sM(this, t);
  }
  clear() {
    this.doc !== null ? Xe(this.doc, (t) => {
      this.forEach(function(n, r, i) {
        Jg(t, i, r);
      });
    }) : this._prelimContent.clear();
  }
  _write(t) {
    t.writeTypeRef(gtt);
  }
}
const UJ = (e) => new ea(), Ba = (e, t) => e === t || typeof e == "object" && typeof t == "object" && e && t && _K(e, t);
class Uv {
  constructor(t, n, r, i) {
    this.left = t, this.right = n, this.index = r, this.currentAttributes = i;
  }
  forward() {
    switch (this.right === null && _s(), this.right.content.constructor) {
      case tr:
        this.right.deleted || $u(this.currentAttributes, this.right.content);
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const cT = (e, t, n) => {
  for (; t.right !== null && n > 0; ) {
    switch (t.right.content.constructor) {
      case tr:
        t.right.deleted || $u(t.currentAttributes, t.right.content);
        break;
      default:
        t.right.deleted || (n < t.right.length && Hr(e, Se(t.right.id.client, t.right.id.clock + n)), t.index += t.right.length, n -= t.right.length);
        break;
    }
    t.left = t.right, t.right = t.right.right;
  }
  return t;
}, q0 = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = ey(t, n);
  if (i) {
    const s = new Uv(i.p.left, i.p, i.index, r);
    return cT(e, s, n - i.index);
  } else {
    const s = new Uv(null, t._start, 0, r);
    return cT(e, s, n);
  }
}, oM = (e, t, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === tr && Ba(r.get(n.right.content.key), n.right.content.value)); )
    n.right.deleted || r.delete(n.right.content.key), n.forward();
  const i = e.doc, s = i.clientID;
  r.forEach((o, a) => {
    const l = n.left, h = n.right, u = new Ge(Se(s, Ln(i.store, s)), l, l && l.lastId, h, h && h.id, t, null, new tr(a, o));
    u.integrate(e, 0), n.right = u, n.forward();
  });
}, $u = (e, t) => {
  const { key: n, value: r } = t;
  r === null ? e.delete(n) : e.set(n, r);
}, aM = (e, t) => {
  for (; e.right !== null; ) {
    if (!(e.right.deleted || e.right.content.constructor === tr && Ba(t[e.right.content.key] || null, e.right.content.value)))
      break;
    e.forward();
  }
}, lM = (e, t, n, r) => {
  const i = e.doc, s = i.clientID, o = /* @__PURE__ */ new Map();
  for (const a in r) {
    const l = r[a], h = n.currentAttributes.get(a) || null;
    if (!Ba(h, l)) {
      o.set(a, h);
      const { left: u, right: f } = n;
      n.right = new Ge(Se(s, Ln(i.store, s)), u, u && u.lastId, f, f && f.id, t, null, new tr(a, l)), n.right.integrate(e, 0), n.forward();
    }
  }
  return o;
}, Ub = (e, t, n, r, i) => {
  n.currentAttributes.forEach((d, p) => {
    i[p] === void 0 && (i[p] = null);
  });
  const s = e.doc, o = s.clientID;
  aM(n, i);
  const a = lM(e, t, n, i), l = r.constructor === String ? new mo(r) : r instanceof yr ? new _o(r) : new Cc(r);
  let { left: h, right: u, index: f } = n;
  t._searchMarker && Fd(t._searchMarker, n.index, l.getLength()), u = new Ge(Se(o, Ln(s.store, o)), h, h && h.lastId, u, u && u.id, t, null, l), u.integrate(e, 0), n.right = u, n.index = f, n.forward(), oM(e, t, n, a);
}, hT = (e, t, n, r, i) => {
  const s = e.doc, o = s.clientID;
  aM(n, i);
  const a = lM(e, t, n, i);
  t:
    for (; n.right !== null && (r > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === tr)); ) {
      if (!n.right.deleted)
        switch (n.right.content.constructor) {
          case tr: {
            const { key: l, value: h } = n.right.content, u = i[l];
            if (u !== void 0) {
              if (Ba(u, h))
                a.delete(l);
              else {
                if (r === 0)
                  break t;
                a.set(l, h);
              }
              n.right.delete(e);
            } else
              n.currentAttributes.set(l, h);
            break;
          }
          default:
            r < n.right.length && Hr(e, Se(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
            break;
        }
      n.forward();
    }
  if (r > 0) {
    let l = "";
    for (; r > 0; r--)
      l += `
`;
    n.right = new Ge(Se(o, Ln(s.store, o)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, t, null, new mo(l)), n.right.integrate(e, 0), n.forward();
  }
  oM(e, t, n, a);
}, cM = (e, t, n, r, i) => {
  let s = t;
  const o = ds();
  for (; s && (!s.countable || s.deleted); ) {
    if (!s.deleted && s.content.constructor === tr) {
      const h = s.content;
      o.set(h.key, h);
    }
    s = s.right;
  }
  let a = 0, l = !1;
  for (; t !== s; ) {
    if (n === t && (l = !0), !t.deleted) {
      const h = t.content;
      switch (h.constructor) {
        case tr: {
          const { key: u, value: f } = h, d = r.get(u) || null;
          (o.get(u) !== h || d === f) && (t.delete(e), a++, !l && (i.get(u) || null) === f && d !== f && (d === null ? i.delete(u) : i.set(u, d))), !l && !t.deleted && $u(i, h);
          break;
        }
      }
    }
    t = t.right;
  }
  return a;
}, jJ = (e, t) => {
  for (; t && t.right && (t.right.deleted || !t.right.countable); )
    t = t.right;
  const n = /* @__PURE__ */ new Set();
  for (; t && (t.deleted || !t.countable); ) {
    if (!t.deleted && t.content.constructor === tr) {
      const r = t.content.key;
      n.has(r) ? t.delete(e) : n.add(r);
    }
    t = t.left;
  }
}, XJ = (e) => {
  let t = 0;
  return Xe(e.doc, (n) => {
    let r = e._start, i = e._start, s = ds();
    const o = Iv(s);
    for (; i; ) {
      if (i.deleted === !1)
        switch (i.content.constructor) {
          case tr:
            $u(o, i.content);
            break;
          default:
            t += cM(n, r, i, s, o), s = Iv(o), r = i;
            break;
        }
      i = i.right;
    }
  }), t;
}, GJ = (e) => {
  const t = /* @__PURE__ */ new Set(), n = e.doc;
  for (const [r, i] of e.afterState.entries()) {
    const s = e.beforeState.get(r) || 0;
    i !== s && WL(e, n.store.clients.get(r), s, i, (o) => {
      !o.deleted && o.content.constructor === tr && o.constructor !== Ri && t.add(o.parent);
    });
  }
  Xe(n, (r) => {
    Wh(e, e.deleteSet, (i) => {
      if (i instanceof Ri || !i.parent._hasFormatting || t.has(i.parent))
        return;
      const s = i.parent;
      i.content.constructor === tr ? t.add(s) : jJ(r, i);
    });
    for (const i of t)
      XJ(i);
  });
}, uT = (e, t, n) => {
  const r = n, i = Iv(t.currentAttributes), s = t.right;
  for (; n > 0 && t.right !== null; ) {
    if (t.right.deleted === !1)
      switch (t.right.content.constructor) {
        case _o:
        case Cc:
        case mo:
          n < t.right.length && Hr(e, Se(t.right.id.client, t.right.id.clock + n)), n -= t.right.length, t.right.delete(e);
          break;
      }
    t.forward();
  }
  s && cM(e, s, t.right, i, t.currentAttributes);
  const o = (t.left || t.right).parent;
  return o._searchMarker && Fd(o._searchMarker, t.index, -r + n), t;
};
class HJ extends ty {
  constructor(t, n, r) {
    super(t, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  get changes() {
    if (this._changes === null) {
      const t = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = t;
    }
    return this._changes;
  }
  get delta() {
    if (this._delta === null) {
      const t = this.target.doc, n = [];
      Xe(t, (r) => {
        const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
        let o = this.target._start, a = null;
        const l = {};
        let h = "", u = 0, f = 0;
        const d = () => {
          if (a !== null) {
            let p = null;
            switch (a) {
              case "delete":
                f > 0 && (p = { delete: f }), f = 0;
                break;
              case "insert":
                (typeof h == "object" || h.length > 0) && (p = { insert: h }, i.size > 0 && (p.attributes = {}, i.forEach((g, m) => {
                  g !== null && (p.attributes[m] = g);
                }))), h = "";
                break;
              case "retain":
                u > 0 && (p = { retain: u }, xK(l) || (p.attributes = mK({}, l))), u = 0;
                break;
            }
            p && n.push(p), a = null;
          }
        };
        for (; o !== null; ) {
          switch (o.content.constructor) {
            case _o:
            case Cc:
              this.adds(o) ? this.deletes(o) || (d(), a = "insert", h = o.content.getContent()[0], d()) : this.deletes(o) ? (a !== "delete" && (d(), a = "delete"), f += 1) : o.deleted || (a !== "retain" && (d(), a = "retain"), u += 1);
              break;
            case mo:
              this.adds(o) ? this.deletes(o) || (a !== "insert" && (d(), a = "insert"), h += o.content.str) : this.deletes(o) ? (a !== "delete" && (d(), a = "delete"), f += o.length) : o.deleted || (a !== "retain" && (d(), a = "retain"), u += o.length);
              break;
            case tr: {
              const { key: p, value: g } = o.content;
              if (this.adds(o)) {
                if (!this.deletes(o)) {
                  const m = i.get(p) || null;
                  Ba(m, g) ? g !== null && o.delete(r) : (a === "retain" && d(), Ba(g, s.get(p) || null) ? delete l[p] : l[p] = g);
                }
              } else if (this.deletes(o)) {
                s.set(p, g);
                const m = i.get(p) || null;
                Ba(m, g) || (a === "retain" && d(), l[p] = m);
              } else if (!o.deleted) {
                s.set(p, g);
                const m = l[p];
                m !== void 0 && (Ba(m, g) ? m !== null && o.delete(r) : (a === "retain" && d(), g === null ? delete l[p] : l[p] = g));
              }
              o.deleted || (a === "insert" && d(), $u(i, o.content));
              break;
            }
          }
          o = o.right;
        }
        for (d(); n.length > 0; ) {
          const p = n[n.length - 1];
          if (p.retain !== void 0 && p.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return this._delta;
  }
}
class jh extends yr {
  constructor(t) {
    super(), this._pending = t !== void 0 ? [() => this.insert(0, t)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  get length() {
    return this._length;
  }
  _integrate(t, n) {
    super._integrate(t, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new jh();
  }
  clone() {
    const t = new jh();
    return t.applyDelta(this.toDelta()), t;
  }
  _callObserver(t, n) {
    super._callObserver(t, n);
    const r = new HJ(this, t, n);
    ny(this, t, r), !t.local && this._hasFormatting && (t._needFormattingCleanup = !0);
  }
  toString() {
    let t = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === mo && (t += n.content.str), n = n.right;
    return t;
  }
  toJSON() {
    return this.toString();
  }
  applyDelta(t, { sanitize: n = !0 } = {}) {
    this.doc !== null ? Xe(this.doc, (r) => {
      const i = new Uv(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let s = 0; s < t.length; s++) {
        const o = t[s];
        if (o.insert !== void 0) {
          const a = !n && typeof o.insert == "string" && s === t.length - 1 && i.right === null && o.insert.slice(-1) === `
` ? o.insert.slice(0, -1) : o.insert;
          (typeof a != "string" || a.length > 0) && Ub(r, this, i, a, o.attributes || {});
        } else
          o.retain !== void 0 ? hT(r, this, i, o.retain, o.attributes || {}) : o.delete !== void 0 && uT(r, i, o.delete);
      }
    }) : this._pending.push(() => this.applyDelta(t));
  }
  toDelta(t, n, r) {
    const i = [], s = /* @__PURE__ */ new Map(), o = this.doc;
    let a = "", l = this._start;
    function h() {
      if (a.length > 0) {
        const f = {};
        let d = !1;
        s.forEach((g, m) => {
          d = !0, f[m] = g;
        });
        const p = { insert: a };
        d && (p.attributes = f), i.push(p), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (Wc(l, t) || n !== void 0 && Wc(l, n))
          switch (l.content.constructor) {
            case mo: {
              const f = s.get("ychange");
              t !== void 0 && !Wc(l, t) ? (f === void 0 || f.user !== l.id.client || f.type !== "removed") && (h(), s.set("ychange", r ? r("removed", l.id) : { type: "removed" })) : n !== void 0 && !Wc(l, n) ? (f === void 0 || f.user !== l.id.client || f.type !== "added") && (h(), s.set("ychange", r ? r("added", l.id) : { type: "added" })) : f !== void 0 && (h(), s.delete("ychange")), a += l.content.str;
              break;
            }
            case _o:
            case Cc: {
              h();
              const f = {
                insert: l.content.getContent()[0]
              };
              if (s.size > 0) {
                const d = {};
                f.attributes = d, s.forEach((p, g) => {
                  d[g] = p;
                });
              }
              i.push(f);
              break;
            }
            case tr:
              Wc(l, t) && (h(), $u(s, l.content));
              break;
          }
        l = l.right;
      }
      h();
    };
    return t || n ? Xe(o, (f) => {
      t && qv(f, t), n && qv(f, n), u();
    }, "cleanup") : u(), i;
  }
  insert(t, n, r) {
    if (n.length <= 0)
      return;
    const i = this.doc;
    i !== null ? Xe(i, (s) => {
      const o = q0(s, this, t);
      r || (r = {}, o.currentAttributes.forEach((a, l) => {
        r[l] = a;
      })), Ub(s, this, o, n, r);
    }) : this._pending.push(() => this.insert(t, n, r));
  }
  insertEmbed(t, n, r = {}) {
    const i = this.doc;
    i !== null ? Xe(i, (s) => {
      const o = q0(s, this, t);
      Ub(s, this, o, n, r);
    }) : this._pending.push(() => this.insertEmbed(t, n, r));
  }
  delete(t, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? Xe(r, (i) => {
      uT(i, q0(i, this, t), n);
    }) : this._pending.push(() => this.delete(t, n));
  }
  format(t, n, r) {
    if (n === 0)
      return;
    const i = this.doc;
    i !== null ? Xe(i, (s) => {
      const o = q0(s, this, t);
      o.right !== null && hT(s, this, o, n, r);
    }) : this._pending.push(() => this.format(t, n, r));
  }
  removeAttribute(t) {
    this.doc !== null ? Xe(this.doc, (n) => {
      Jg(n, this, t);
    }) : this._pending.push(() => this.removeAttribute(t));
  }
  setAttribute(t, n) {
    this.doc !== null ? Xe(this.doc, (r) => {
      Kw(r, this, t, n);
    }) : this._pending.push(() => this.setAttribute(t, n));
  }
  getAttribute(t) {
    return Jw(this, t);
  }
  getAttributes() {
    return iM(this);
  }
  _write(t) {
    t.writeTypeRef(mtt);
  }
}
const KJ = (e) => new jh();
class jb {
  constructor(t, n = () => !0) {
    this._filter = n, this._root = t, this._currentNode = t._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let t = this._currentNode, n = t && t.content && t.content.type;
    if (t !== null && (!this._firstCall || t.deleted || !this._filter(n)))
      do
        if (n = t.content.type, !t.deleted && (n.constructor === Zd || n.constructor === ac) && n._start !== null)
          t = n._start;
        else
          for (; t !== null; )
            if (t.right !== null) {
              t = t.right;
              break;
            } else
              t.parent === this._root ? t = null : t = t.parent._item;
      while (t !== null && (t.deleted || !this._filter(t.content.type)));
    return this._firstCall = !1, t === null ? { value: void 0, done: !0 } : (this._currentNode = t, { value: t.content.type, done: !1 });
  }
}
class ac extends yr {
  constructor() {
    super(), this._prelimContent = [];
  }
  get firstChild() {
    const t = this._first;
    return t ? t.content.getContent()[0] : null;
  }
  _integrate(t, n) {
    super._integrate(t, n), this.insert(0, this._prelimContent), this._prelimContent = null;
  }
  _copy() {
    return new ac();
  }
  clone() {
    const t = new ac();
    return t.insert(0, this.toArray().map((n) => n instanceof yr ? n.clone() : n)), t;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  createTreeWalker(t) {
    return new jb(this, t);
  }
  querySelector(t) {
    t = t.toUpperCase();
    const r = new jb(this, (i) => i.nodeName && i.nodeName.toUpperCase() === t).next();
    return r.done ? null : r.value;
  }
  querySelectorAll(t) {
    return t = t.toUpperCase(), rl(new jb(this, (n) => n.nodeName && n.nodeName.toUpperCase() === t));
  }
  _callObserver(t, n) {
    ny(this, t, new ett(this, n, t));
  }
  toString() {
    return JL(this, (t) => t.toString()).join("");
  }
  toJSON() {
    return this.toString();
  }
  toDOM(t = document, n = {}, r) {
    const i = t.createDocumentFragment();
    return r !== void 0 && r._createAssociation(i, this), Qd(this, (s) => {
      i.insertBefore(s.toDOM(t, n, r), null);
    }), i;
  }
  insert(t, n) {
    this.doc !== null ? Xe(this.doc, (r) => {
      nM(r, this, t, n);
    }) : this._prelimContent.splice(t, 0, ...n);
  }
  insertAfter(t, n) {
    if (this.doc !== null)
      Xe(this.doc, (r) => {
        const i = t && t instanceof yr ? t._item : t;
        Kg(r, this, i, n);
      });
    else {
      const r = this._prelimContent, i = t === null ? 0 : r.findIndex((s) => s === t) + 1;
      if (i === 0 && t !== null)
        throw il("Reference item not found");
      r.splice(i, 0, ...n);
    }
  }
  delete(t, n = 1) {
    this.doc !== null ? Xe(this.doc, (r) => {
      rM(r, this, t, n);
    }) : this._prelimContent.splice(t, n);
  }
  toArray() {
    return KL(this);
  }
  push(t) {
    this.insert(this.length, t);
  }
  unshift(t) {
    this.insert(0, t);
  }
  get(t) {
    return tM(this, t);
  }
  slice(t = 0, n = this.length) {
    return HL(this, t, n);
  }
  forEach(t) {
    Qd(this, t);
  }
  _write(t) {
    t.writeTypeRef(btt);
  }
}
const JJ = (e) => new ac();
class Zd extends ac {
  constructor(t = "UNDEFINED") {
    super(), this.nodeName = t, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  get nextSibling() {
    const t = this._item ? this._item.next : null;
    return t ? t.content.type : null;
  }
  get prevSibling() {
    const t = this._item ? this._item.prev : null;
    return t ? t.content.type : null;
  }
  _integrate(t, n) {
    super._integrate(t, n), this._prelimAttrs.forEach((r, i) => {
      this.setAttribute(i, r);
    }), this._prelimAttrs = null;
  }
  _copy() {
    return new Zd(this.nodeName);
  }
  clone() {
    const t = new Zd(this.nodeName), n = this.getAttributes();
    return bK(n, (r, i) => {
      typeof r == "string" && t.setAttribute(i, r);
    }), t.insert(0, this.toArray().map((r) => r instanceof yr ? r.clone() : r)), t;
  }
  toString() {
    const t = this.getAttributes(), n = [], r = [];
    for (const a in t)
      r.push(a);
    r.sort();
    const i = r.length;
    for (let a = 0; a < i; a++) {
      const l = r[a];
      n.push(l + '="' + t[l] + '"');
    }
    const s = this.nodeName.toLocaleLowerCase(), o = n.length > 0 ? " " + n.join(" ") : "";
    return `<${s}${o}>${super.toString()}</${s}>`;
  }
  removeAttribute(t) {
    this.doc !== null ? Xe(this.doc, (n) => {
      Jg(n, this, t);
    }) : this._prelimAttrs.delete(t);
  }
  setAttribute(t, n) {
    this.doc !== null ? Xe(this.doc, (r) => {
      Kw(r, this, t, n);
    }) : this._prelimAttrs.set(t, n);
  }
  getAttribute(t) {
    return Jw(this, t);
  }
  hasAttribute(t) {
    return sM(this, t);
  }
  getAttributes(t) {
    return t ? YJ(this, t) : iM(this);
  }
  toDOM(t = document, n = {}, r) {
    const i = t.createElement(this.nodeName), s = this.getAttributes();
    for (const o in s) {
      const a = s[o];
      typeof a == "string" && i.setAttribute(o, a);
    }
    return Qd(this, (o) => {
      i.appendChild(o.toDOM(t, n, r));
    }), r !== void 0 && r._createAssociation(i, this), i;
  }
  _write(t) {
    t.writeTypeRef(ytt), t.writeKey(this.nodeName);
  }
}
const ttt = (e) => new Zd(e.readKey());
class ett extends ty {
  constructor(t, n, r) {
    super(t, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class tm extends ea {
  constructor(t) {
    super(), this.hookName = t;
  }
  _copy() {
    return new tm(this.hookName);
  }
  clone() {
    const t = new tm(this.hookName);
    return this.forEach((n, r) => {
      t.set(r, n);
    }), t;
  }
  toDOM(t = document, n = {}, r) {
    const i = n[this.hookName];
    let s;
    return i !== void 0 ? s = i.createDom(this) : s = document.createElement(this.hookName), s.setAttribute("data-yjs-hook", this.hookName), r !== void 0 && r._createAssociation(s, this), s;
  }
  _write(t) {
    t.writeTypeRef(Ott), t.writeKey(this.hookName);
  }
}
const ntt = (e) => new tm(e.readKey());
class em extends jh {
  get nextSibling() {
    const t = this._item ? this._item.next : null;
    return t ? t.content.type : null;
  }
  get prevSibling() {
    const t = this._item ? this._item.prev : null;
    return t ? t.content.type : null;
  }
  _copy() {
    return new em();
  }
  clone() {
    const t = new em();
    return t.applyDelta(this.toDelta()), t;
  }
  toDOM(t = document, n, r) {
    const i = t.createTextNode(this.toString());
    return r !== void 0 && r._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((t) => {
      const n = [];
      for (const i in t.attributes) {
        const s = [];
        for (const o in t.attributes[i])
          s.push({ key: o, value: t.attributes[i][o] });
        s.sort((o, a) => o.key < a.key ? -1 : 1), n.push({ nodeName: i, attrs: s });
      }
      n.sort((i, s) => i.nodeName < s.nodeName ? -1 : 1);
      let r = "";
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        r += `<${s.nodeName}`;
        for (let o = 0; o < s.attrs.length; o++) {
          const a = s.attrs[o];
          r += ` ${a.key}="${a.value}"`;
        }
        r += ">";
      }
      r += t.insert;
      for (let i = n.length - 1; i >= 0; i--)
        r += `</${n[i].nodeName}>`;
      return r;
    }).join("");
  }
  toJSON() {
    return this.toString();
  }
  _write(t) {
    t.writeTypeRef(xtt);
  }
}
const rtt = (e) => new em();
class t3 {
  constructor(t, n) {
    this.id = t, this.length = n;
  }
  get deleted() {
    throw ao();
  }
  mergeWith(t) {
    return !1;
  }
  write(t, n, r) {
    throw ao();
  }
  integrate(t, n) {
    throw ao();
  }
}
const itt = 0;
class Ri extends t3 {
  get deleted() {
    return !0;
  }
  delete() {
  }
  mergeWith(t) {
    return this.constructor !== t.constructor ? !1 : (this.length += t.length, !0);
  }
  integrate(t, n) {
    n > 0 && (this.id.clock += n, this.length -= n), qL(t.doc.store, this);
  }
  write(t, n) {
    t.writeInfo(itt), t.writeLen(this.length - n);
  }
  getMissing(t, n) {
    return null;
  }
}
class Wp {
  constructor(t) {
    this.content = t;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.content];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Wp(this.content);
  }
  splice(t) {
    throw ao();
  }
  mergeWith(t) {
    return !1;
  }
  integrate(t, n) {
  }
  delete(t) {
  }
  gc(t) {
  }
  write(t, n) {
    t.writeBuf(this.content);
  }
  getRef() {
    return 3;
  }
}
const stt = (e) => new Wp(e.readBuf());
class Vd {
  constructor(t) {
    this.len = t;
  }
  getLength() {
    return this.len;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return !1;
  }
  copy() {
    return new Vd(this.len);
  }
  splice(t) {
    const n = new Vd(this.len - t);
    return this.len = t, n;
  }
  mergeWith(t) {
    return this.len += t.len, !0;
  }
  integrate(t, n) {
    Id(t.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  delete(t) {
  }
  gc(t) {
  }
  write(t, n) {
    t.writeLen(this.len - n);
  }
  getRef() {
    return 1;
  }
}
const ott = (e) => new Vd(e.readLen()), hM = (e, t) => new Ru({ guid: e, ...t, shouldLoad: t.shouldLoad || t.autoLoad || !1 });
class Up {
  constructor(t) {
    t._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = t;
    const n = {};
    this.opts = n, t.gc || (n.gc = !1), t.autoLoad && (n.autoLoad = !0), t.meta !== null && (n.meta = t.meta);
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.doc];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Up(hM(this.doc.guid, this.opts));
  }
  splice(t) {
    throw ao();
  }
  mergeWith(t) {
    return !1;
  }
  integrate(t, n) {
    this.doc._item = n, t.subdocsAdded.add(this.doc), this.doc.shouldLoad && t.subdocsLoaded.add(this.doc);
  }
  delete(t) {
    t.subdocsAdded.has(this.doc) ? t.subdocsAdded.delete(this.doc) : t.subdocsRemoved.add(this.doc);
  }
  gc(t) {
  }
  write(t, n) {
    t.writeString(this.doc.guid), t.writeAny(this.opts);
  }
  getRef() {
    return 9;
  }
}
const att = (e) => new Up(hM(e.readString(), e.readAny()));
class Cc {
  constructor(t) {
    this.embed = t;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.embed];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Cc(this.embed);
  }
  splice(t) {
    throw ao();
  }
  mergeWith(t) {
    return !1;
  }
  integrate(t, n) {
  }
  delete(t) {
  }
  gc(t) {
  }
  write(t, n) {
    t.writeJSON(this.embed);
  }
  getRef() {
    return 5;
  }
}
const ltt = (e) => new Cc(e.readJSON());
class tr {
  constructor(t, n) {
    this.key = t, this.value = n;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return !1;
  }
  copy() {
    return new tr(this.key, this.value);
  }
  splice(t) {
    throw ao();
  }
  mergeWith(t) {
    return !1;
  }
  integrate(t, n) {
    const r = n.parent;
    r._searchMarker = null, r._hasFormatting = !0;
  }
  delete(t) {
  }
  gc(t) {
  }
  write(t, n) {
    t.writeKey(this.key), t.writeJSON(this.value);
  }
  getRef() {
    return 6;
  }
}
const ctt = (e) => new tr(e.readKey(), e.readJSON());
class nm {
  constructor(t) {
    this.arr = t;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new nm(this.arr);
  }
  splice(t) {
    const n = new nm(this.arr.slice(t));
    return this.arr = this.arr.slice(0, t), n;
  }
  mergeWith(t) {
    return this.arr = this.arr.concat(t.arr), !0;
  }
  integrate(t, n) {
  }
  delete(t) {
  }
  gc(t) {
  }
  write(t, n) {
    const r = this.arr.length;
    t.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const s = this.arr[i];
      t.writeString(s === void 0 ? "undefined" : JSON.stringify(s));
    }
  }
  getRef() {
    return 2;
  }
}
const htt = (e) => {
  const t = e.readLen(), n = [];
  for (let r = 0; r < t; r++) {
    const i = e.readString();
    i === "undefined" ? n.push(void 0) : n.push(JSON.parse(i));
  }
  return new nm(n);
};
class lc {
  constructor(t) {
    this.arr = t;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new lc(this.arr);
  }
  splice(t) {
    const n = new lc(this.arr.slice(t));
    return this.arr = this.arr.slice(0, t), n;
  }
  mergeWith(t) {
    return this.arr = this.arr.concat(t.arr), !0;
  }
  integrate(t, n) {
  }
  delete(t) {
  }
  gc(t) {
  }
  write(t, n) {
    const r = this.arr.length;
    t.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const s = this.arr[i];
      t.writeAny(s);
    }
  }
  getRef() {
    return 8;
  }
}
const utt = (e) => {
  const t = e.readLen(), n = [];
  for (let r = 0; r < t; r++)
    n.push(e.readAny());
  return new lc(n);
};
class mo {
  constructor(t) {
    this.str = t;
  }
  getLength() {
    return this.str.length;
  }
  getContent() {
    return this.str.split("");
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new mo(this.str);
  }
  splice(t) {
    const n = new mo(this.str.slice(t));
    this.str = this.str.slice(0, t);
    const r = this.str.charCodeAt(t - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, t - 1) + "\uFFFD", n.str = "\uFFFD" + n.str.slice(1)), n;
  }
  mergeWith(t) {
    return this.str += t.str, !0;
  }
  integrate(t, n) {
  }
  delete(t) {
  }
  gc(t) {
  }
  write(t, n) {
    t.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  getRef() {
    return 4;
  }
}
const ftt = (e) => new mo(e.readString()), dtt = [
  qJ,
  UJ,
  KJ,
  ttt,
  JJ,
  ntt,
  rtt
], ptt = 0, gtt = 1, mtt = 2, ytt = 3, btt = 4, Ott = 5, xtt = 6;
class _o {
  constructor(t) {
    this.type = t;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.type];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new _o(this.type._copy());
  }
  splice(t) {
    throw ao();
  }
  mergeWith(t) {
    return !1;
  }
  integrate(t, n) {
    this.type._integrate(t.doc, n);
  }
  delete(t) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (t.beforeState.get(n.id.client) || 0) && t._mergeStructs.push(n) : n.delete(t), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (t.beforeState.get(r.id.client) || 0) && t._mergeStructs.push(r) : r.delete(t);
    }), t.changed.delete(this.type);
  }
  gc(t) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(t, !0), n = n.right;
    this.type._start = null, this.type._map.forEach((r) => {
      for (; r !== null; )
        r.gc(t, !0), r = r.left;
    }), this.type._map = /* @__PURE__ */ new Map();
  }
  write(t, n) {
    this.type._write(t);
  }
  getRef() {
    return 7;
  }
}
const vtt = (e) => new _o(dtt[e.readTypeRef()](e)), jv = (e, t) => {
  let n = t, r = 0, i;
  do
    r > 0 && (n = Se(n.client, n.clock + r)), i = z1(e, n), r = n.clock - i.id.clock, n = i.redone;
  while (n !== null && i instanceof Ge);
  return {
    item: i,
    diff: r
  };
}, e3 = (e, t) => {
  for (; e !== null && e.keep !== t; )
    e.keep = t, e = e.parent._item;
}, rm = (e, t, n) => {
  const { client: r, clock: i } = t.id, s = new Ge(
    Se(r, i + n),
    t,
    Se(r, i + n - 1),
    t.right,
    t.rightOrigin,
    t.parent,
    t.parentSub,
    t.content.splice(n)
  );
  return t.deleted && s.markDeleted(), t.keep && (s.keep = !0), t.redone !== null && (s.redone = Se(t.redone.client, t.redone.clock + n)), t.right = s, s.right !== null && (s.right.left = s), e._mergeStructs.push(s), s.parentSub !== null && s.right === null && s.parent._map.set(s.parentSub, s), t.length = n, s;
}, fT = (e, t) => RH(e, (n) => zp(n.deletions, t)), uM = (e, t, n, r, i, s) => {
  const o = e.doc, a = o.store, l = o.clientID, h = t.redone;
  if (h !== null)
    return Hr(e, h);
  let u = t.parent._item, f = null, d;
  if (u !== null && u.deleted === !0) {
    if (u.redone === null && (!n.has(u) || uM(e, u, n, r, i, s) === null))
      return null;
    for (; u.redone !== null; )
      u = Hr(e, u.redone);
  }
  const p = u === null ? t.parent : u.content.type;
  if (t.parentSub === null) {
    for (f = t.left, d = t; f !== null; ) {
      let O = f;
      for (; O !== null && O.parent._item !== u; )
        O = O.redone === null ? null : Hr(e, O.redone);
      if (O !== null && O.parent._item === u) {
        f = O;
        break;
      }
      f = f.left;
    }
    for (; d !== null; ) {
      let O = d;
      for (; O !== null && O.parent._item !== u; )
        O = O.redone === null ? null : Hr(e, O.redone);
      if (O !== null && O.parent._item === u) {
        d = O;
        break;
      }
      d = d.right;
    }
  } else if (d = null, t.right && !i) {
    for (f = t; f !== null && f.right !== null && (f.right.redone || zp(r, f.right.id) || fT(s.undoStack, f.right.id) || fT(s.redoStack, f.right.id)); )
      for (f = f.right; f.redone; )
        f = Hr(e, f.redone);
    if (f && f.right !== null)
      return null;
  } else
    f = p._map.get(t.parentSub) || null;
  const g = Ln(a, l), m = Se(l, g), y = new Ge(
    m,
    f,
    f && f.lastId,
    d,
    d && d.id,
    p,
    t.parentSub,
    t.content.copy()
  );
  return t.redone = m, e3(y, !0), y.integrate(e, 0), y;
};
class Ge extends t3 {
  constructor(t, n, r, i, s, o, a, l) {
    super(t, l.getLength()), this.origin = r, this.left = n, this.right = i, this.rightOrigin = s, this.parent = o, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? ZC : 0;
  }
  set marker(t) {
    (this.info & Vb) > 0 !== t && (this.info ^= Vb);
  }
  get marker() {
    return (this.info & Vb) > 0;
  }
  get keep() {
    return (this.info & QC) > 0;
  }
  set keep(t) {
    this.keep !== t && (this.info ^= QC);
  }
  get countable() {
    return (this.info & ZC) > 0;
  }
  get deleted() {
    return (this.info & Zb) > 0;
  }
  set deleted(t) {
    this.deleted !== t && (this.info ^= Zb);
  }
  markDeleted() {
    this.info |= Zb;
  }
  getMissing(t, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Ln(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Ln(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === yh && this.id.client !== this.parent.client && this.parent.clock >= Ln(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = rT(t, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Hr(t, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === Ri || this.right && this.right.constructor === Ri)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === Ge && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === Ge && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === yh) {
      const r = z1(n, this.parent);
      r.constructor === Ri ? this.parent = null : this.parent = r.content.type;
    }
    return null;
  }
  integrate(t, n) {
    if (n > 0 && (this.id.clock += n, this.left = rT(t, t.doc.store, Se(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, i;
        if (r !== null)
          i = r.right;
        else if (this.parentSub !== null)
          for (i = this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = this.parent._start;
        const s = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (o.add(i), s.add(i), Jc(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              r = i, s.clear();
            else if (Jc(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && o.has(z1(t.doc.store, i.origin)))
            s.has(z1(t.doc.store, i.origin)) || (r = i, s.clear());
          else
            break;
          i = i.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(t)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), qL(t.doc.store, this), this.content.integrate(t, this), sT(t, this.parent, this.parentSub), (this.parent._item !== null && this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(t);
    } else
      new Ri(this.id, this.length).integrate(t, 0);
  }
  get next() {
    let t = this.right;
    for (; t !== null && t.deleted; )
      t = t.right;
    return t;
  }
  get prev() {
    let t = this.left;
    for (; t !== null && t.deleted; )
      t = t.left;
    return t;
  }
  get lastId() {
    return this.length === 1 ? this.id : Se(this.id.client, this.id.clock + this.length - 1);
  }
  mergeWith(t) {
    if (this.constructor === t.constructor && Jc(t.origin, this.lastId) && this.right === t && Jc(this.rightOrigin, t.rightOrigin) && this.id.client === t.id.client && this.id.clock + this.length === t.id.clock && this.deleted === t.deleted && this.redone === null && t.redone === null && this.content.constructor === t.content.constructor && this.content.mergeWith(t.content)) {
      const n = this.parent._searchMarker;
      return n && n.forEach((r) => {
        r.p === t && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), t.keep && (this.keep = !0), this.right = t.right, this.right !== null && (this.right.left = this), this.length += t.length, !0;
    }
    return !1;
  }
  delete(t) {
    if (!this.deleted) {
      const n = this.parent;
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), Id(t.deleteSet, this.id.client, this.id.clock, this.length), sT(t, n, this.parentSub), this.content.delete(t);
    }
  }
  gc(t, n) {
    if (!this.deleted)
      throw _s();
    this.content.gc(t), n ? CJ(t, this, new Ri(this.id, this.length)) : this.content = new Vd(this.length);
  }
  write(t, n) {
    const r = n > 0 ? Se(this.id.client, this.id.clock + n - 1) : this.origin, i = this.rightOrigin, s = this.parentSub, o = this.content.getRef() & G2 | (r === null ? 0 : bi) | (i === null ? 0 : ta) | (s === null ? 0 : Ld);
    if (t.writeInfo(o), r !== null && t.writeLeftID(r), i !== null && t.writeRightID(i), r === null && i === null) {
      const a = this.parent;
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const h = VL(a);
          t.writeParentInfo(!0), t.writeString(h);
        } else
          t.writeParentInfo(!1), t.writeLeftID(l.id);
      } else
        a.constructor === String ? (t.writeParentInfo(!0), t.writeString(a)) : a.constructor === yh ? (t.writeParentInfo(!1), t.writeLeftID(a)) : _s();
      s !== null && t.writeString(s);
    }
    this.content.write(t, n);
  }
}
const fM = (e, t) => _tt[t & G2](e), _tt = [
  () => {
    _s();
  },
  ott,
  htt,
  stt,
  ftt,
  ltt,
  ctt,
  vtt,
  utt,
  att,
  () => {
    _s();
  }
], ktt = 10;
class $i extends t3 {
  get deleted() {
    return !0;
  }
  delete() {
  }
  mergeWith(t) {
    return this.constructor !== t.constructor ? !1 : (this.length += t.length, !0);
  }
  integrate(t, n) {
    _s();
  }
  write(t, n) {
    t.writeInfo(ktt), ee(t.restEncoder, this.length - n);
  }
  getMissing(t, n) {
    return null;
  }
}
const dM = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}, pM = "__ $YJS$ __";
dM[pM] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
dM[pM] = !0;
class n3 {
  constructor(t, n) {
    this.yanchor = t, this.yhead = n;
  }
  toJSON() {
    return {
      yanchor: eT(this.yanchor),
      yhead: eT(this.yhead)
    };
  }
  static fromJSON(t) {
    return new n3(Nd(t.yanchor), Nd(t.yhead));
  }
}
class wtt {
  constructor(t, n) {
    this.ytext = t, this.awareness = n, this.undoManager = new Uw(t);
  }
  toYPos(t, n = 0) {
    return Bd(this.ytext, t, n);
  }
  fromYPos(t) {
    const n = zv(Nd(t), this.ytext.doc);
    if (n == null || n.type !== this.ytext)
      throw new Error("[y-codemirror] The position you want to retrieve was created by a different document");
    return {
      pos: n.index,
      assoc: n.assoc
    };
  }
  toYRange(t) {
    const n = t.assoc, r = this.toYPos(t.anchor, n), i = this.toYPos(t.head, n);
    return new n3(r, i);
  }
  fromYRange(t) {
    const n = this.fromYPos(t.yanchor), r = this.fromYPos(t.yhead);
    return n.pos === r.pos ? mt.cursor(r.pos, r.assoc) : mt.range(n.pos, r.pos);
  }
}
const ry = Ft.define({
  combine(e) {
    return e[e.length - 1];
  }
}), Xv = Es.define();
class Stt {
  constructor(t) {
    this.view = t, this.conf = t.state.facet(ry), this._observer = (n, r) => {
      if (r.origin !== this.conf) {
        const i = n.delta, s = [];
        let o = 0;
        for (let a = 0; a < i.length; a++) {
          const l = i[a];
          l.insert != null ? s.push({ from: o, to: o, insert: l.insert }) : l.delete != null ? (s.push({ from: o, to: o + l.delete, insert: "" }), o += l.delete) : o += l.retain;
        }
        t.dispatch({ changes: s, annotations: [Xv.of(this.conf)] });
      }
    }, this._ytext = this.conf.ytext, this._ytext.observe(this._observer);
  }
  update(t) {
    if (!t.docChanged || t.transactions.length > 0 && t.transactions[0].annotation(Xv) === this.conf)
      return;
    const n = this.conf.ytext;
    n.doc.transact(() => {
      let r = 0;
      t.changes.iterChanges((i, s, o, a, l) => {
        const h = l.sliceString(0, l.length, `
`);
        i !== s && n.delete(i + r, s - i), h.length > 0 && n.insert(i + r, h), r += h.length - (s - i);
      });
    }, this.conf);
  }
  destroy() {
    this._ytext.unobserve(this._observer);
  }
}
const Ctt = He.fromClass(Stt), Ttt = Pt.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
}), Ett = Es.define();
class Att extends si {
  constructor(t, n) {
    super(), this.color = t, this.name = n;
  }
  toDOM() {
    return qb("span", [ui("class", "cm-ySelectionCaret"), ui("style", `background-color: ${this.color}; border-color: ${this.color}`)], [
      V0("\u2060"),
      qb("div", [
        ui("class", "cm-ySelectionCaretDot")
      ]),
      V0("\u2060"),
      qb("div", [
        ui("class", "cm-ySelectionInfo")
      ], [
        V0(this.name)
      ]),
      V0("\u2060")
    ]);
  }
  eq(t) {
    return t.color === this.color;
  }
  compare(t) {
    return t.color === this.color;
  }
  updateDOM() {
    return !1;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return !0;
  }
}
class Ptt {
  constructor(t) {
    this.conf = t.state.facet(ry), this._listener = ({ added: n, updated: r, removed: i }, s, o) => {
      n.concat(r).concat(i).findIndex((l) => l !== this.conf.awareness.doc.clientID) >= 0 && t.dispatch({ annotations: [Ett.of([])] });
    }, this._awareness = this.conf.awareness, this._awareness.on("change", this._listener), this.decorations = Ne.of([]);
  }
  destroy() {
    this._awareness.off("change", this._listener);
  }
  update(t) {
    const n = this.conf.ytext, r = n.doc, i = this.conf.awareness, s = [], o = this.conf.awareness.getLocalState();
    if (o != null) {
      const a = t.view.hasFocus && t.view.dom.ownerDocument.hasFocus(), l = a ? t.state.selection.main : null, h = o.cursor == null ? null : Nd(o.cursor.anchor), u = o.cursor == null ? null : Nd(o.cursor.head);
      if (l != null) {
        const f = Bd(n, l.anchor), d = Bd(n, l.head);
        (o.cursor == null || !nT(h, f) || !nT(u, d)) && i.setLocalStateField("cursor", {
          anchor: f,
          head: d
        });
      } else
        o.cursor != null && a && i.setLocalStateField("cursor", null);
    }
    i.getStates().forEach((a, l) => {
      if (l === i.doc.clientID)
        return;
      const h = a.cursor;
      if (h == null || h.anchor == null || h.head == null)
        return;
      const u = zv(h.anchor, r), f = zv(h.head, r);
      if (u == null || f == null || u.type !== n || f.type !== n)
        return;
      const { color: d = "#30bced", name: p = "Anonymous" } = a.user || {}, g = a.user && a.user.colorLight || d + "33", m = X2(u.index, f.index), y = dl(u.index, f.index), O = t.view.state.doc.lineAt(m), x = t.view.state.doc.lineAt(y);
      if (O.number === x.number)
        s.push({
          from: m,
          to: y,
          value: Bt.mark({
            attributes: { style: `background-color: ${g}` },
            class: "cm-ySelection"
          })
        });
      else {
        s.push({
          from: m,
          to: O.from + O.length,
          value: Bt.mark({
            attributes: { style: `background-color: ${g}` },
            class: "cm-ySelection"
          })
        }), s.push({
          from: x.from,
          to: y,
          value: Bt.mark({
            attributes: { style: `background-color: ${g}` },
            class: "cm-ySelection"
          })
        });
        for (let _ = O.number + 1; _ < x.number; _++) {
          const w = t.view.state.doc.line(_).from;
          s.push({
            from: w,
            to: w,
            value: Bt.line({
              attributes: { style: `background-color: ${g}`, class: "cm-yLineSelection" }
            })
          });
        }
      }
      s.push({
        from: f.index,
        to: f.index,
        value: Bt.widget({
          side: f.index - u.index > 0 ? -1 : 1,
          block: !1,
          widget: new Att(d, p)
        })
      });
    }), this.decorations = Bt.set(s, !0);
  }
}
const Dtt = He.fromClass(Ptt, {
  decorations: (e) => e.decorations
}), Ltt = () => {
  let e = !0;
  return (t, n) => {
    if (e) {
      e = !1;
      try {
        t();
      } finally {
        e = !0;
      }
    } else
      n !== void 0 && n();
  };
};
class Mtt {
  constructor(t) {
    this.undoManager = t;
  }
  addTrackedOrigin(t) {
    this.undoManager.addTrackedOrigin(t);
  }
  removeTrackedOrigin(t) {
    this.undoManager.removeTrackedOrigin(t);
  }
  undo() {
    return this.undoManager.undo() != null;
  }
  redo() {
    return this.undoManager.redo() != null;
  }
}
const iy = Ft.define({
  combine(e) {
    return e[e.length - 1];
  }
});
class Rtt {
  constructor(t) {
    this.view = t, this.conf = t.state.facet(iy), this._undoManager = this.conf.undoManager, this.syncConf = t.state.facet(ry), this._beforeChangeSelection = null, this._mux = Ltt(), this._onStackItemAdded = ({ stackItem: n, changedParentTypes: r }) => {
      r.has(this.syncConf.ytext) && this._beforeChangeSelection && !n.meta.has(this) && n.meta.set(this, this._beforeChangeSelection);
    }, this._onStackItemPopped = ({ stackItem: n }) => {
      const r = n.meta.get(this);
      if (r) {
        const i = this.syncConf.fromYRange(r);
        t.dispatch(t.state.update({ selection: i })), this._storeSelection();
      }
    }, this._storeSelection = () => {
      this._beforeChangeSelection = this.syncConf.toYRange(this.view.state.selection.main);
    }, this._undoManager.on("stack-item-added", this._onStackItemAdded), this._undoManager.on("stack-item-popped", this._onStackItemPopped), this._undoManager.addTrackedOrigin(this.syncConf);
  }
  update(t) {
    t.selectionSet && (t.transactions.length === 0 || t.transactions[0].annotation(Xv) !== this.syncConf) && this._storeSelection();
  }
  destroy() {
    this._undoManager.off("stack-item-added", this._onStackItemAdded), this._undoManager.off("stack-item-popped", this._onStackItemPopped), this._undoManager.removeTrackedOrigin(this.syncConf);
  }
}
const $tt = He.fromClass(Rtt), Itt = ({ state: e, dispatch: t }) => e.facet(iy).undo() || !0, Ntt = ({ state: e, dispatch: t }) => e.facet(iy).redo() || !0, Btt = (e, t, { undoManager: n = new Uw(e) } = {}) => {
  const r = new wtt(e, t), i = [
    ry.of(r),
    Ctt
  ];
  return t && i.push(
    Ttt,
    Dtt
  ), n !== !1 && i.push(
    iy.of(new Mtt(n)),
    $tt,
    Pt.domEventHandlers({
      beforeinput(s, o) {
        return s.inputType === "historyUndo" ? Itt(o) : s.inputType === "historyRedo" ? Ntt(o) : !1;
      }
    })
  ), i;
};
class im {
  static create(t, n, r, i, s) {
    let o = i + (i << 8) + t + (n << 4) | 0;
    return new im(t, n, r, o, s, [], []);
  }
  constructor(t, n, r, i, s, o, a) {
    this.type = t, this.value = n, this.from = r, this.hash = i, this.end = s, this.children = o, this.positions = a, this.hashProp = [[_e.contextHash, i]];
  }
  addChild(t, n) {
    t.prop(_e.contextHash) != this.hash && (t = new ze(t.type, t.children, t.positions, t.length, this.hashProp)), this.children.push(t), this.positions.push(n);
  }
  toTree(t, n = this.end) {
    let r = this.children.length - 1;
    return r >= 0 && (n = Math.max(n, this.positions[r] + this.children[r].length + this.from)), new ze(t.types[this.type], this.children, this.positions, n - this.from).balance({
      makeTree: (i, s, o) => new ze(Jn.none, i, s, o, this.hashProp)
    });
  }
}
var Dt;
(function(e) {
  e[e.Document = 1] = "Document", e[e.CodeBlock = 2] = "CodeBlock", e[e.FencedCode = 3] = "FencedCode", e[e.Blockquote = 4] = "Blockquote", e[e.HorizontalRule = 5] = "HorizontalRule", e[e.BulletList = 6] = "BulletList", e[e.OrderedList = 7] = "OrderedList", e[e.ListItem = 8] = "ListItem", e[e.ATXHeading1 = 9] = "ATXHeading1", e[e.ATXHeading2 = 10] = "ATXHeading2", e[e.ATXHeading3 = 11] = "ATXHeading3", e[e.ATXHeading4 = 12] = "ATXHeading4", e[e.ATXHeading5 = 13] = "ATXHeading5", e[e.ATXHeading6 = 14] = "ATXHeading6", e[e.SetextHeading1 = 15] = "SetextHeading1", e[e.SetextHeading2 = 16] = "SetextHeading2", e[e.HTMLBlock = 17] = "HTMLBlock", e[e.LinkReference = 18] = "LinkReference", e[e.Paragraph = 19] = "Paragraph", e[e.CommentBlock = 20] = "CommentBlock", e[e.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", e[e.Escape = 22] = "Escape", e[e.Entity = 23] = "Entity", e[e.HardBreak = 24] = "HardBreak", e[e.Emphasis = 25] = "Emphasis", e[e.StrongEmphasis = 26] = "StrongEmphasis", e[e.Link = 27] = "Link", e[e.Image = 28] = "Image", e[e.InlineCode = 29] = "InlineCode", e[e.HTMLTag = 30] = "HTMLTag", e[e.Comment = 31] = "Comment", e[e.ProcessingInstruction = 32] = "ProcessingInstruction", e[e.URL = 33] = "URL", e[e.HeaderMark = 34] = "HeaderMark", e[e.QuoteMark = 35] = "QuoteMark", e[e.ListMark = 36] = "ListMark", e[e.LinkMark = 37] = "LinkMark", e[e.EmphasisMark = 38] = "EmphasisMark", e[e.CodeMark = 39] = "CodeMark", e[e.CodeText = 40] = "CodeText", e[e.CodeInfo = 41] = "CodeInfo", e[e.LinkTitle = 42] = "LinkTitle", e[e.LinkLabel = 43] = "LinkLabel";
})(Dt || (Dt = {}));
class Ftt {
  constructor(t, n) {
    this.start = t, this.content = n, this.marks = [], this.parsers = [];
  }
}
class Qtt {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  forwardInner() {
    let t = this.skipSpace(this.basePos);
    this.indent = this.countIndent(t, this.pos, this.indent), this.pos = t, this.next = t == this.text.length ? -1 : this.text.charCodeAt(t);
  }
  skipSpace(t) {
    return Uf(this.text, t);
  }
  reset(t) {
    for (this.text = t, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  moveBase(t) {
    this.basePos = t, this.baseIndent = this.countIndent(t, this.pos, this.indent);
  }
  moveBaseColumn(t) {
    this.baseIndent = t, this.basePos = this.findColumn(t);
  }
  addMarker(t) {
    this.markers.push(t);
  }
  countIndent(t, n = 0, r = 0) {
    for (let i = n; i < t; i++)
      r += this.text.charCodeAt(i) == 9 ? 4 - r % 4 : 1;
    return r;
  }
  findColumn(t) {
    let n = 0;
    for (let r = 0; n < this.text.length && r < t; n++)
      r += this.text.charCodeAt(n) == 9 ? 4 - r % 4 : 1;
    return n;
  }
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let t = "";
    for (let n = 0; n < this.basePos; n++)
      t += " ";
    return t + this.text.slice(this.basePos);
  }
}
function dT(e, t, n) {
  if (n.pos == n.text.length || e != t.block && n.indent >= t.stack[n.depth + 1].value + n.baseIndent)
    return !0;
  if (n.indent >= n.baseIndent + 4)
    return !1;
  let r = (e.type == Dt.OrderedList ? s3 : i3)(n, t, !1);
  return r > 0 && (e.type != Dt.BulletList || r3(n, t, !1) < 0) && n.text.charCodeAt(n.pos + r - 1) == e.value;
}
const gM = {
  [Dt.Blockquote](e, t, n) {
    return n.next != 62 ? !1 : (n.markers.push(Ze(Dt.QuoteMark, t.lineStart + n.pos, t.lineStart + n.pos + 1)), n.moveBase(n.pos + (Ki(n.text.charCodeAt(n.pos + 1)) ? 2 : 1)), e.end = t.lineStart + n.text.length, !0);
  },
  [Dt.ListItem](e, t, n) {
    return n.indent < n.baseIndent + e.value && n.next > -1 ? !1 : (n.moveBaseColumn(n.baseIndent + e.value), !0);
  },
  [Dt.OrderedList]: dT,
  [Dt.BulletList]: dT,
  [Dt.Document]() {
    return !0;
  }
};
function Ki(e) {
  return e == 32 || e == 9 || e == 10 || e == 13;
}
function Uf(e, t = 0) {
  for (; t < e.length && Ki(e.charCodeAt(t)); )
    t++;
  return t;
}
function pT(e, t, n) {
  for (; t > n && Ki(e.charCodeAt(t - 1)); )
    t--;
  return t;
}
function mM(e) {
  if (e.next != 96 && e.next != 126)
    return -1;
  let t = e.pos + 1;
  for (; t < e.text.length && e.text.charCodeAt(t) == e.next; )
    t++;
  if (t < e.pos + 3)
    return -1;
  if (e.next == 96) {
    for (let n = t; n < e.text.length; n++)
      if (e.text.charCodeAt(n) == 96)
        return -1;
  }
  return t;
}
function yM(e) {
  return e.next != 62 ? -1 : e.text.charCodeAt(e.pos + 1) == 32 ? 2 : 1;
}
function r3(e, t, n) {
  if (e.next != 42 && e.next != 45 && e.next != 95)
    return -1;
  let r = 1;
  for (let i = e.pos + 1; i < e.text.length; i++) {
    let s = e.text.charCodeAt(i);
    if (s == e.next)
      r++;
    else if (!Ki(s))
      return -1;
  }
  return n && e.next == 45 && xM(e) > -1 && e.depth == t.stack.length || r < 3 ? -1 : 1;
}
function bM(e, t) {
  for (let n = e.stack.length - 1; n >= 0; n--)
    if (e.stack[n].type == t)
      return !0;
  return !1;
}
function i3(e, t, n) {
  return (e.next == 45 || e.next == 43 || e.next == 42) && (e.pos == e.text.length - 1 || Ki(e.text.charCodeAt(e.pos + 1))) && (!n || bM(t, Dt.BulletList) || e.skipSpace(e.pos + 2) < e.text.length) ? 1 : -1;
}
function s3(e, t, n) {
  let r = e.pos, i = e.next;
  for (; i >= 48 && i <= 57; ) {
    r++;
    if (r == e.text.length)
      return -1;
    i = e.text.charCodeAt(r);
  }
  return r == e.pos || r > e.pos + 9 || i != 46 && i != 41 || r < e.text.length - 1 && !Ki(e.text.charCodeAt(r + 1)) || n && !bM(t, Dt.OrderedList) && (e.skipSpace(r + 1) == e.text.length || r > e.pos + 1 || e.next != 49) ? -1 : r + 1 - e.pos;
}
function OM(e) {
  if (e.next != 35)
    return -1;
  let t = e.pos + 1;
  for (; t < e.text.length && e.text.charCodeAt(t) == 35; )
    t++;
  if (t < e.text.length && e.text.charCodeAt(t) != 32)
    return -1;
  let n = t - e.pos;
  return n > 6 ? -1 : n;
}
function xM(e) {
  if (e.next != 45 && e.next != 61 || e.indent >= e.baseIndent + 4)
    return -1;
  let t = e.pos + 1;
  for (; t < e.text.length && e.text.charCodeAt(t) == e.next; )
    t++;
  let n = t;
  for (; t < e.text.length && Ki(e.text.charCodeAt(t)); )
    t++;
  return t == e.text.length ? n : -1;
}
const Gv = /^[ \t]*$/, vM = /-->/, _M = /\?>/, Hv = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, vM],
  [/^\s*<\?/, _M],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Gv],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Gv]
];
function kM(e, t, n) {
  if (e.next != 60)
    return -1;
  let r = e.text.slice(e.pos);
  for (let i = 0, s = Hv.length - (n ? 1 : 0); i < s; i++)
    if (Hv[i][0].test(r))
      return i;
  return -1;
}
function gT(e, t) {
  let n = e.countIndent(t, e.pos, e.indent), r = e.countIndent(e.skipSpace(t), t, n);
  return r >= n + 5 ? n + 1 : r;
}
function vl(e, t, n) {
  let r = e.length - 1;
  r >= 0 && e[r].to == t && e[r].type == Dt.CodeText ? e[r].to = n : e.push(Ze(Dt.CodeText, t, n));
}
const W0 = {
  LinkReference: void 0,
  IndentedCode(e, t) {
    let n = t.baseIndent + 4;
    if (t.indent < n)
      return !1;
    let r = t.findColumn(n), i = e.lineStart + r, s = e.lineStart + t.text.length, o = [], a = [];
    for (vl(o, i, s); e.nextLine() && t.depth >= e.stack.length; )
      if (t.pos == t.text.length) {
        vl(a, e.lineStart - 1, e.lineStart);
        for (let l of t.markers)
          a.push(l);
      } else {
        if (t.indent < n)
          break;
        {
          if (a.length) {
            for (let h of a)
              h.type == Dt.CodeText ? vl(o, h.from, h.to) : o.push(h);
            a = [];
          }
          vl(o, e.lineStart - 1, e.lineStart);
          for (let h of t.markers)
            o.push(h);
          s = e.lineStart + t.text.length;
          let l = e.lineStart + t.findColumn(t.baseIndent + 4);
          l < s && vl(o, l, s);
        }
      }
    return a.length && (a = a.filter((l) => l.type != Dt.CodeText), a.length && (t.markers = a.concat(t.markers))), e.addNode(e.buffer.writeElements(o, -i).finish(Dt.CodeBlock, s - i), i), !0;
  },
  FencedCode(e, t) {
    let n = mM(t);
    if (n < 0)
      return !1;
    let r = e.lineStart + t.pos, i = t.next, s = n - t.pos, o = t.skipSpace(n), a = pT(t.text, t.text.length, o), l = [Ze(Dt.CodeMark, r, r + s)];
    o < a && l.push(Ze(Dt.CodeInfo, e.lineStart + o, e.lineStart + a));
    for (let h = !0; e.nextLine() && t.depth >= e.stack.length; h = !1) {
      let u = t.pos;
      if (t.indent - t.baseIndent < 4)
        for (; u < t.text.length && t.text.charCodeAt(u) == i; )
          u++;
      if (u - t.pos >= s && t.skipSpace(u) == t.text.length) {
        for (let f of t.markers)
          l.push(f);
        l.push(Ze(Dt.CodeMark, e.lineStart + t.pos, e.lineStart + u)), e.nextLine();
        break;
      } else {
        h || vl(l, e.lineStart - 1, e.lineStart);
        for (let p of t.markers)
          l.push(p);
        let f = e.lineStart + t.basePos, d = e.lineStart + t.text.length;
        f < d && vl(l, f, d);
      }
    }
    return e.addNode(e.buffer.writeElements(l, -r).finish(Dt.FencedCode, e.prevLineEnd() - r), r), !0;
  },
  Blockquote(e, t) {
    let n = yM(t);
    return n < 0 ? !1 : (e.startContext(Dt.Blockquote, t.pos), e.addNode(Dt.QuoteMark, e.lineStart + t.pos, e.lineStart + t.pos + 1), t.moveBase(t.pos + n), null);
  },
  HorizontalRule(e, t) {
    if (r3(t, e, !1) < 0)
      return !1;
    let n = e.lineStart + t.pos;
    return e.nextLine(), e.addNode(Dt.HorizontalRule, n), !0;
  },
  BulletList(e, t) {
    let n = i3(t, e, !1);
    if (n < 0)
      return !1;
    e.block.type != Dt.BulletList && e.startContext(Dt.BulletList, t.basePos, t.next);
    let r = gT(t, t.pos + 1);
    return e.startContext(Dt.ListItem, t.basePos, r - t.baseIndent), e.addNode(Dt.ListMark, e.lineStart + t.pos, e.lineStart + t.pos + n), t.moveBaseColumn(r), null;
  },
  OrderedList(e, t) {
    let n = s3(t, e, !1);
    if (n < 0)
      return !1;
    e.block.type != Dt.OrderedList && e.startContext(Dt.OrderedList, t.basePos, t.text.charCodeAt(t.pos + n - 1));
    let r = gT(t, t.pos + n);
    return e.startContext(Dt.ListItem, t.basePos, r - t.baseIndent), e.addNode(Dt.ListMark, e.lineStart + t.pos, e.lineStart + t.pos + n), t.moveBaseColumn(r), null;
  },
  ATXHeading(e, t) {
    let n = OM(t);
    if (n < 0)
      return !1;
    let r = t.pos, i = e.lineStart + r, s = pT(t.text, t.text.length, r), o = s;
    for (; o > r && t.text.charCodeAt(o - 1) == t.next; )
      o--;
    (o == s || o == r || !Ki(t.text.charCodeAt(o - 1))) && (o = t.text.length);
    let a = e.buffer.write(Dt.HeaderMark, 0, n).writeElements(e.parser.parseInline(t.text.slice(r + n + 1, o), i + n + 1), -i);
    o < t.text.length && a.write(Dt.HeaderMark, o - r, s - r);
    let l = a.finish(Dt.ATXHeading1 - 1 + n, t.text.length - r);
    return e.nextLine(), e.addNode(l, i), !0;
  },
  HTMLBlock(e, t) {
    let n = kM(t, e, !1);
    if (n < 0)
      return !1;
    let r = e.lineStart + t.pos, i = Hv[n][1], s = [], o = i != Gv;
    for (; !i.test(t.text) && e.nextLine(); ) {
      if (t.depth < e.stack.length) {
        o = !1;
        break;
      }
      for (let h of t.markers)
        s.push(h);
    }
    o && e.nextLine();
    let a = i == vM ? Dt.CommentBlock : i == _M ? Dt.ProcessingInstructionBlock : Dt.HTMLBlock, l = e.prevLineEnd();
    return e.addNode(e.buffer.writeElements(s, -r).finish(a, l - r), r), !0;
  },
  SetextHeading: void 0
};
class Ztt {
  constructor(t) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = t.start, this.advance(t.content);
  }
  nextLine(t, n, r) {
    if (this.stage == -1)
      return !1;
    let i = r.content + `
` + n.scrub(), s = this.advance(i);
    return s > -1 && s < i.length ? this.complete(t, r, s) : !1;
  }
  finish(t, n) {
    return (this.stage == 2 || this.stage == 3) && Uf(n.content, this.pos) == n.content.length ? this.complete(t, n, n.content.length) : !1;
  }
  complete(t, n, r) {
    return t.addLeafElement(n, Ze(Dt.LinkReference, this.start, this.start + r, this.elts)), !0;
  }
  nextStage(t) {
    return t ? (this.pos = t.to - this.start, this.elts.push(t), this.stage++, !0) : (t === !1 && (this.stage = -1), !1);
  }
  advance(t) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(LM(t, this.pos, this.start, !0)))
          return -1;
        if (t.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(Ze(Dt.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(PM(t, Uf(t, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let n = Uf(t, this.pos), r = 0;
        if (n > this.pos) {
          let i = DM(t, n, this.start);
          if (i) {
            let s = Xb(t, i.to - this.start);
            s > 0 && (this.nextStage(i), r = s);
          }
        }
        return r || (r = Xb(t, this.pos)), r > 0 && r < t.length ? r : -1;
      } else
        return Xb(t, this.pos);
    }
  }
}
function Xb(e, t) {
  for (; t < e.length; t++) {
    let n = e.charCodeAt(t);
    if (n == 10)
      break;
    if (!Ki(n))
      return -1;
  }
  return t;
}
class Vtt {
  nextLine(t, n, r) {
    let i = n.depth < t.stack.length ? -1 : xM(n), s = n.next;
    if (i < 0)
      return !1;
    let o = Ze(Dt.HeaderMark, t.lineStart + n.pos, t.lineStart + i);
    return t.nextLine(), t.addLeafElement(r, Ze(s == 61 ? Dt.SetextHeading1 : Dt.SetextHeading2, r.start, t.prevLineEnd(), [
      ...t.parser.parseInline(r.content, r.start),
      o
    ])), !0;
  }
  finish() {
    return !1;
  }
}
const Ytt = {
  LinkReference(e, t) {
    return t.content.charCodeAt(0) == 91 ? new Ztt(t) : null;
  },
  SetextHeading() {
    return new Vtt();
  }
}, ztt = [
  (e, t) => OM(t) >= 0,
  (e, t) => mM(t) >= 0,
  (e, t) => yM(t) >= 0,
  (e, t) => i3(t, e, !0) >= 0,
  (e, t) => s3(t, e, !0) >= 0,
  (e, t) => r3(t, e, !0) >= 0,
  (e, t) => kM(t, e, !0) >= 0
], qtt = { text: "", end: 0 };
class Wtt {
  constructor(t, n, r, i) {
    this.parser = t, this.input = n, this.ranges = i, this.line = new Qtt(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = i[i.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = i[0].from, this.block = im.create(Dt.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = r.length ? new Gtt(r, n) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: t } = this;
    for (; ; ) {
      for (let r = 0; ; ) {
        let i = t.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; r < t.markers.length && (!i || t.markers[r].from < i.end); ) {
          let s = t.markers[r++];
          this.addNode(s.type, s.from, s.to);
        }
        if (!i)
          break;
        this.finishContext();
      }
      if (t.pos < t.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(t.basePos))
      return null;
    t:
      for (; ; ) {
        for (let r of this.parser.blockParsers)
          if (r) {
            let i = r(this, t);
            if (i != !1) {
              if (i == !0)
                return null;
              t.forward();
              continue t;
            }
          }
        break;
      }
    let n = new Ftt(this.lineStart + t.pos, t.text.slice(t.pos));
    for (let r of this.parser.leafBlockParsers)
      if (r) {
        let i = r(this, n);
        i && n.parsers.push(i);
      }
    t:
      for (; this.nextLine() && t.pos != t.text.length; ) {
        if (t.indent < t.baseIndent + 4) {
          for (let r of this.parser.endLeafBlock)
            if (r(this, t, n))
              break t;
        }
        for (let r of n.parsers)
          if (r.nextLine(this, t, n))
            return null;
        n.content += `
` + t.scrub();
        for (let r of t.markers)
          n.marks.push(r);
      }
    return this.finishLeaf(n), null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  reuseFragment(t) {
    if (!this.fragments.moveTo(this.absoluteLineStart + t, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let n = this.fragments.takeNodes(this);
    return n ? (this.absoluteLineStart += n, this.lineStart = MM(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  get depth() {
    return this.stack.length;
  }
  parentType(t = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[t].type];
  }
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  scanLine(t) {
    let n = qtt;
    if (n.end = t, t >= this.to)
      n.text = "";
    else if (n.text = this.lineChunkAt(t), n.end += n.text.length, this.ranges.length > 1) {
      let r = this.absoluteLineStart, i = this.rangeI;
      for (; this.ranges[i].to < n.end; ) {
        i++;
        let s = this.ranges[i].from, o = this.lineChunkAt(s);
        n.end = s + o.length, n.text = n.text.slice(0, this.ranges[i - 1].to - r) + o, r = n.end - n.text.length;
      }
    }
    return n;
  }
  readLine() {
    let { line: t } = this, { text: n, end: r } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = r, t.reset(n); t.depth < this.stack.length; t.depth++) {
      let i = this.stack[t.depth], s = this.parser.skipContextMarkup[i.type];
      if (!s)
        throw new Error("Unhandled block context " + Dt[i.type]);
      if (!s(i, this, t))
        break;
      t.forward();
    }
  }
  lineChunkAt(t) {
    let n = this.input.chunk(t), r;
    if (this.input.lineChunks)
      r = n == `
` ? "" : n;
    else {
      let i = n.indexOf(`
`);
      r = i < 0 ? n : n.slice(0, i);
    }
    return t + r.length > this.to ? r.slice(0, this.to - t) : r;
  }
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  startContext(t, n, r = 0) {
    this.block = im.create(t, r, this.lineStart + n, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  startComposite(t, n, r = 0) {
    this.startContext(this.parser.getNodeType(t), n, r);
  }
  addNode(t, n, r) {
    typeof t == "number" && (t = new ze(this.parser.nodeSet.types[t], Xh, Xh, (r != null ? r : this.prevLineEnd()) - n)), this.block.addChild(t, n - this.block.from);
  }
  addElement(t) {
    this.block.addChild(t.toTree(this.parser.nodeSet), t.from - this.block.from);
  }
  addLeafElement(t, n) {
    this.addNode(this.buffer.writeElements(Jv(n.children, t.marks), -n.from).finish(n.type, n.to - n.from), n.from);
  }
  finishContext() {
    let t = this.stack.pop(), n = this.stack[this.stack.length - 1];
    n.addChild(t.toTree(this.parser.nodeSet), t.from - n.from), this.block = n;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(t) {
    return this.ranges.length > 1 ? wM(this.ranges, 0, t.topNode, this.ranges[0].from, this.reusePlaceholders) : t;
  }
  finishLeaf(t) {
    for (let r of t.parsers)
      if (r.finish(this, t))
        return;
    let n = Jv(this.parser.parseInline(t.content, t.start), t.marks);
    this.addNode(this.buffer.writeElements(n, -t.start).finish(Dt.Paragraph, t.content.length), t.start);
  }
  elt(t, n, r, i) {
    return typeof t == "string" ? Ze(this.parser.getNodeType(t), n, r, i) : new TM(t, n);
  }
  get buffer() {
    return new CM(this.parser.nodeSet);
  }
}
function wM(e, t, n, r, i) {
  let s = e[t].to, o = [], a = [], l = n.from + r;
  function h(u, f) {
    for (; f ? u >= s : u > s; ) {
      let d = e[t + 1].from - s;
      r += d, u += d, t++, s = e[t].to;
    }
  }
  for (let u = n.firstChild; u; u = u.nextSibling) {
    h(u.from + r, !0);
    let f = u.from + r, d, p = i.get(u.tree);
    p ? d = p : u.to + r > s ? (d = wM(e, t, u, r, i), h(u.to + r, !1)) : d = u.toTree(), o.push(d), a.push(f - l);
  }
  return h(n.to + r, !1), new ze(n.type, o, a, n.to + r - l, n.tree ? n.tree.propValues : void 0);
}
class sy extends pw {
  constructor(t, n, r, i, s, o, a, l, h) {
    super(), this.nodeSet = t, this.blockParsers = n, this.leafBlockParsers = r, this.blockNames = i, this.endLeafBlock = s, this.skipContextMarkup = o, this.inlineParsers = a, this.inlineNames = l, this.wrappers = h, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let u of t.types)
      this.nodeTypes[u.name] = u.id;
  }
  createParse(t, n, r) {
    let i = new Wtt(this, t, n, r);
    for (let s of this.wrappers)
      i = s(i, t, n, r);
    return i;
  }
  configure(t) {
    let n = Kv(t);
    if (!n)
      return this;
    let { nodeSet: r, skipContextMarkup: i } = this, s = this.blockParsers.slice(), o = this.leafBlockParsers.slice(), a = this.blockNames.slice(), l = this.inlineParsers.slice(), h = this.inlineNames.slice(), u = this.endLeafBlock.slice(), f = this.wrappers;
    if (rf(n.defineNodes)) {
      i = Object.assign({}, i);
      let d = r.types.slice(), p;
      for (let g of n.defineNodes) {
        let { name: m, block: y, composite: O, style: x } = typeof g == "string" ? { name: g } : g;
        if (d.some((E) => E.name == m))
          continue;
        O && (i[d.length] = (E, T, S) => O(T, S, E.value));
        let _ = d.length, w = O ? ["Block", "BlockContext"] : y ? _ >= Dt.ATXHeading1 && _ <= Dt.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        d.push(Jn.define({
          id: _,
          name: m,
          props: w && [[_e.group, w]]
        })), x && (p || (p = {}), Array.isArray(x) || x instanceof is ? p[m] = x : Object.assign(p, x));
      }
      r = new Ip(d), p && (r = r.extend(Tu(p)));
    }
    if (rf(n.props) && (r = r.extend(...n.props)), rf(n.remove))
      for (let d of n.remove) {
        let p = this.blockNames.indexOf(d), g = this.inlineNames.indexOf(d);
        p > -1 && (s[p] = o[p] = void 0), g > -1 && (l[g] = void 0);
      }
    if (rf(n.parseBlock))
      for (let d of n.parseBlock) {
        let p = a.indexOf(d.name);
        if (p > -1)
          s[p] = d.parse, o[p] = d.leaf;
        else {
          let g = d.before ? U0(a, d.before) : d.after ? U0(a, d.after) + 1 : a.length - 1;
          s.splice(g, 0, d.parse), o.splice(g, 0, d.leaf), a.splice(g, 0, d.name);
        }
        d.endLeaf && u.push(d.endLeaf);
      }
    if (rf(n.parseInline))
      for (let d of n.parseInline) {
        let p = h.indexOf(d.name);
        if (p > -1)
          l[p] = d.parse;
        else {
          let g = d.before ? U0(h, d.before) : d.after ? U0(h, d.after) + 1 : h.length - 1;
          l.splice(g, 0, d.parse), h.splice(g, 0, d.name);
        }
      }
    return n.wrap && (f = f.concat(n.wrap)), new sy(r, s, o, a, u, i, l, h, f);
  }
  getNodeType(t) {
    let n = this.nodeTypes[t];
    if (n == null)
      throw new RangeError(`Unknown node type '${t}'`);
    return n;
  }
  parseInline(t, n) {
    let r = new jtt(this, t, n);
    t:
      for (let i = n; i < r.end; ) {
        let s = r.char(i);
        for (let o of this.inlineParsers)
          if (o) {
            let a = o(r, s, i);
            if (a >= 0) {
              i = a;
              continue t;
            }
          }
        i++;
      }
    return r.resolveMarkers(0);
  }
}
function rf(e) {
  return e != null && e.length > 0;
}
function Kv(e) {
  if (!Array.isArray(e))
    return e;
  if (e.length == 0)
    return null;
  let t = Kv(e[0]);
  if (e.length == 1)
    return t;
  let n = Kv(e.slice(1));
  if (!n || !t)
    return t || n;
  let r = (o, a) => (o || Xh).concat(a || Xh), i = t.wrap, s = n.wrap;
  return {
    props: r(t.props, n.props),
    defineNodes: r(t.defineNodes, n.defineNodes),
    parseBlock: r(t.parseBlock, n.parseBlock),
    parseInline: r(t.parseInline, n.parseInline),
    remove: r(t.remove, n.remove),
    wrap: i ? s ? (o, a, l, h) => i(s(o, a, l, h), a, l, h) : i : s
  };
}
function U0(e, t) {
  let n = e.indexOf(t);
  if (n < 0)
    throw new RangeError(`Position specified relative to unknown parser ${t}`);
  return n;
}
let SM = [Jn.none];
for (let e = 1, t; t = Dt[e]; e++)
  SM[e] = Jn.define({
    id: e,
    name: t,
    props: e >= Dt.Escape ? [] : [[_e.group, e in gM ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: t == "Document"
  });
const Xh = [];
class CM {
  constructor(t) {
    this.nodeSet = t, this.content = [], this.nodes = [];
  }
  write(t, n, r, i = 0) {
    return this.content.push(t, n, r, 4 + i * 4), this;
  }
  writeElements(t, n = 0) {
    for (let r of t)
      r.writeTo(this, n);
    return this;
  }
  finish(t, n) {
    return ze.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: t,
      length: n
    });
  }
}
class Yd {
  constructor(t, n, r, i = Xh) {
    this.type = t, this.from = n, this.to = r, this.children = i;
  }
  writeTo(t, n) {
    let r = t.content.length;
    t.writeElements(this.children, n), t.content.push(this.type, this.from + n, this.to + n, t.content.length + 4 - r);
  }
  toTree(t) {
    return new CM(t).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}
class TM {
  constructor(t, n) {
    this.tree = t, this.from = n;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Xh;
  }
  writeTo(t, n) {
    t.nodes.push(this.tree), t.content.push(t.nodes.length - 1, this.from + n, this.to + n, -1);
  }
  toTree() {
    return this.tree;
  }
}
function Ze(e, t, n, r) {
  return new Yd(e, t, n, r);
}
const EM = { resolve: "Emphasis", mark: "EmphasisMark" }, AM = { resolve: "Emphasis", mark: "EmphasisMark" }, sf = {}, mT = {};
class ss {
  constructor(t, n, r, i) {
    this.type = t, this.from = n, this.to = r, this.side = i;
  }
}
const yT = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let zd = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  zd = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {
}
const Gb = {
  Escape(e, t, n) {
    if (t != 92 || n == e.end - 1)
      return -1;
    let r = e.char(n + 1);
    for (let i = 0; i < yT.length; i++)
      if (yT.charCodeAt(i) == r)
        return e.append(Ze(Dt.Escape, n, n + 2));
    return -1;
  },
  Entity(e, t, n) {
    if (t != 38)
      return -1;
    let r = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(e.slice(n + 1, n + 31));
    return r ? e.append(Ze(Dt.Entity, n, n + 1 + r[0].length)) : -1;
  },
  InlineCode(e, t, n) {
    if (t != 96 || n && e.char(n - 1) == 96)
      return -1;
    let r = n + 1;
    for (; r < e.end && e.char(r) == 96; )
      r++;
    let i = r - n, s = 0;
    for (; r < e.end; r++)
      if (e.char(r) == 96) {
        if (s++, s == i && e.char(r + 1) != 96)
          return e.append(Ze(Dt.InlineCode, n, r + 1, [
            Ze(Dt.CodeMark, n, n + i),
            Ze(Dt.CodeMark, r + 1 - i, r + 1)
          ]));
      } else
        s = 0;
    return -1;
  },
  HTMLTag(e, t, n) {
    if (t != 60 || n == e.end - 1)
      return -1;
    let r = e.slice(n + 1, e.end), i = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(r);
    if (i)
      return e.append(Ze(Dt.URL, n, n + 1 + i[0].length));
    let s = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(r);
    if (s)
      return e.append(Ze(Dt.Comment, n, n + 1 + s[0].length));
    let o = /^\?[^]*?\?>/.exec(r);
    if (o)
      return e.append(Ze(Dt.ProcessingInstruction, n, n + 1 + o[0].length));
    let a = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(r);
    return a ? e.append(Ze(Dt.HTMLTag, n, n + 1 + a[0].length)) : -1;
  },
  Emphasis(e, t, n) {
    if (t != 95 && t != 42)
      return -1;
    let r = n + 1;
    for (; e.char(r) == t; )
      r++;
    let i = e.slice(n - 1, n), s = e.slice(r, r + 1), o = zd.test(i), a = zd.test(s), l = /\s|^$/.test(i), h = /\s|^$/.test(s), u = !h && (!a || l || o), f = !l && (!o || h || a), d = u && (t == 42 || !f || o), p = f && (t == 42 || !u || a);
    return e.append(new ss(t == 95 ? EM : AM, n, r, (d ? 1 : 0) | (p ? 2 : 0)));
  },
  HardBreak(e, t, n) {
    if (t == 92 && e.char(n + 1) == 10)
      return e.append(Ze(Dt.HardBreak, n, n + 2));
    if (t == 32) {
      let r = n + 1;
      for (; e.char(r) == 32; )
        r++;
      if (e.char(r) == 10 && r >= n + 2)
        return e.append(Ze(Dt.HardBreak, n, r + 1));
    }
    return -1;
  },
  Link(e, t, n) {
    return t == 91 ? e.append(new ss(sf, n, n + 1, 1)) : -1;
  },
  Image(e, t, n) {
    return t == 33 && e.char(n + 1) == 91 ? e.append(new ss(mT, n, n + 2, 1)) : -1;
  },
  LinkEnd(e, t, n) {
    if (t != 93)
      return -1;
    for (let r = e.parts.length - 1; r >= 0; r--) {
      let i = e.parts[r];
      if (i instanceof ss && (i.type == sf || i.type == mT)) {
        if (!i.side || e.skipSpace(i.to) == n && !/[(\[]/.test(e.slice(n + 1, n + 2)))
          return e.parts[r] = null, -1;
        let s = e.takeContent(r), o = e.parts[r] = Utt(e, s, i.type == sf ? Dt.Link : Dt.Image, i.from, n + 1);
        if (i.type == sf)
          for (let a = 0; a < r; a++) {
            let l = e.parts[a];
            l instanceof ss && l.type == sf && (l.side = 0);
          }
        return o.to;
      }
    }
    return -1;
  }
};
function Utt(e, t, n, r, i) {
  let { text: s } = e, o = e.char(i), a = i;
  if (t.unshift(Ze(Dt.LinkMark, r, r + (n == Dt.Image ? 2 : 1))), t.push(Ze(Dt.LinkMark, i - 1, i)), o == 40) {
    let l = e.skipSpace(i + 1), h = PM(s, l - e.offset, e.offset), u;
    h && (l = e.skipSpace(h.to), u = DM(s, l - e.offset, e.offset), u && (l = e.skipSpace(u.to))), e.char(l) == 41 && (t.push(Ze(Dt.LinkMark, i, i + 1)), a = l + 1, h && t.push(h), u && t.push(u), t.push(Ze(Dt.LinkMark, l, a)));
  } else if (o == 91) {
    let l = LM(s, i - e.offset, e.offset, !1);
    l && (t.push(l), a = l.to);
  }
  return Ze(n, r, a, t);
}
function PM(e, t, n) {
  if (e.charCodeAt(t) == 60) {
    for (let i = t + 1; i < e.length; i++) {
      let s = e.charCodeAt(i);
      if (s == 62)
        return Ze(Dt.URL, t + n, i + 1 + n);
      if (s == 60 || s == 10)
        return !1;
    }
    return null;
  } else {
    let i = 0, s = t;
    for (let o = !1; s < e.length; s++) {
      let a = e.charCodeAt(s);
      if (Ki(a))
        break;
      if (o)
        o = !1;
      else if (a == 40)
        i++;
      else if (a == 41) {
        if (!i)
          break;
        i--;
      } else
        a == 92 && (o = !0);
    }
    return s > t ? Ze(Dt.URL, t + n, s + n) : s == e.length ? null : !1;
  }
}
function DM(e, t, n) {
  let r = e.charCodeAt(t);
  if (r != 39 && r != 34 && r != 40)
    return !1;
  let i = r == 40 ? 41 : r;
  for (let s = t + 1, o = !1; s < e.length; s++) {
    let a = e.charCodeAt(s);
    if (o)
      o = !1;
    else {
      if (a == i)
        return Ze(Dt.LinkTitle, t + n, s + 1 + n);
      a == 92 && (o = !0);
    }
  }
  return null;
}
function LM(e, t, n, r) {
  for (let i = !1, s = t + 1, o = Math.min(e.length, s + 999); s < o; s++) {
    let a = e.charCodeAt(s);
    if (i)
      i = !1;
    else {
      if (a == 93)
        return r ? !1 : Ze(Dt.LinkLabel, t + n, s + 1 + n);
      if (r && !Ki(a) && (r = !1), a == 91)
        return !1;
      a == 92 && (i = !0);
    }
  }
  return null;
}
class jtt {
  constructor(t, n, r) {
    this.parser = t, this.text = n, this.offset = r, this.parts = [];
  }
  char(t) {
    return t >= this.end ? -1 : this.text.charCodeAt(t - this.offset);
  }
  get end() {
    return this.offset + this.text.length;
  }
  slice(t, n) {
    return this.text.slice(t - this.offset, n - this.offset);
  }
  append(t) {
    return this.parts.push(t), t.to;
  }
  addDelimiter(t, n, r, i, s) {
    return this.append(new ss(t, n, r, (i ? 1 : 0) | (s ? 2 : 0)));
  }
  addElement(t) {
    return this.append(t);
  }
  resolveMarkers(t) {
    for (let r = t; r < this.parts.length; r++) {
      let i = this.parts[r];
      if (!(i instanceof ss && i.type.resolve && i.side & 2))
        continue;
      let s = i.type == EM || i.type == AM, o = i.to - i.from, a, l = r - 1;
      for (; l >= t; l--) {
        let m = this.parts[l];
        if (m instanceof ss && m.side & 1 && m.type == i.type && !(s && (i.side & 1 || m.side & 2) && (m.to - m.from + o) % 3 == 0 && ((m.to - m.from) % 3 || o % 3))) {
          a = m;
          break;
        }
      }
      if (!a)
        continue;
      let h = i.type.resolve, u = [], f = a.from, d = i.to;
      if (s) {
        let m = Math.min(2, a.to - a.from, o);
        f = a.to - m, d = i.from + m, h = m == 1 ? "Emphasis" : "StrongEmphasis";
      }
      a.type.mark && u.push(this.elt(a.type.mark, f, a.to));
      for (let m = l + 1; m < r; m++)
        this.parts[m] instanceof Yd && u.push(this.parts[m]), this.parts[m] = null;
      i.type.mark && u.push(this.elt(i.type.mark, i.from, d));
      let p = this.elt(h, f, d, u);
      this.parts[l] = s && a.from != f ? new ss(a.type, a.from, f, a.side) : null, (this.parts[r] = s && i.to != d ? new ss(i.type, d, i.to, i.side) : null) ? this.parts.splice(r, 0, p) : this.parts[r] = p;
    }
    let n = [];
    for (let r = t; r < this.parts.length; r++) {
      let i = this.parts[r];
      i instanceof Yd && n.push(i);
    }
    return n;
  }
  findOpeningDelimiter(t) {
    for (let n = this.parts.length - 1; n >= 0; n--) {
      let r = this.parts[n];
      if (r instanceof ss && r.type == t)
        return n;
    }
    return null;
  }
  takeContent(t) {
    let n = this.resolveMarkers(t);
    return this.parts.length = t, n;
  }
  skipSpace(t) {
    return Uf(this.text, t - this.offset) + this.offset;
  }
  elt(t, n, r, i) {
    return typeof t == "string" ? Ze(this.parser.getNodeType(t), n, r, i) : new TM(t, n);
  }
}
function Jv(e, t) {
  if (!t.length)
    return e;
  if (!e.length)
    return t;
  let n = e.slice(), r = 0;
  for (let i of t) {
    for (; r < n.length && n[r].to < i.to; )
      r++;
    if (r < n.length && n[r].from < i.from) {
      let s = n[r];
      s instanceof Yd && (n[r] = new Yd(s.type, s.from, s.to, Jv(s.children, [i])));
    } else
      n.splice(r++, 0, i);
  }
  return n;
}
const Xtt = [Dt.CodeBlock, Dt.ListItem, Dt.OrderedList, Dt.BulletList];
class Gtt {
  constructor(t, n) {
    this.fragments = t, this.input = n, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, t.length && (this.fragment = t[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(t, n) {
    for (; this.fragment && this.fragment.to <= t; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (t ? t - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let s = this.fragment.to;
      for (; s > 0 && this.input.read(s - 1, s) != `
`; )
        s--;
      this.fragmentEnd = s ? s - 1 : 0;
    }
    let r = this.cursor;
    r || (r = this.cursor = this.fragment.tree.cursor(), r.firstChild());
    let i = t + this.fragment.offset;
    for (; r.to <= i; )
      if (!r.parent())
        return !1;
    for (; ; ) {
      if (r.from >= i)
        return this.fragment.from <= n;
      if (!r.childAfter(i))
        return !1;
    }
  }
  matches(t) {
    let n = this.cursor.tree;
    return n && n.prop(_e.contextHash) == t;
  }
  takeNodes(t) {
    let n = this.cursor, r = this.fragment.offset, i = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), s = t.absoluteLineStart, o = s, a = t.block.children.length, l = o, h = a;
    for (; ; ) {
      if (n.to - r > i) {
        if (n.type.isAnonymous && n.firstChild())
          continue;
        break;
      }
      let u = MM(n.from - r, t.ranges);
      if (n.to - r <= t.ranges[t.rangeI].to)
        t.addNode(n.tree, u);
      else {
        let f = new ze(t.parser.nodeSet.types[Dt.Paragraph], [], [], 0, t.block.hashProp);
        t.reusePlaceholders.set(f, n.tree), t.addNode(f, u);
      }
      if (n.type.is("Block") && (Xtt.indexOf(n.type.id) < 0 ? (o = n.to - r, a = t.block.children.length) : (o = l, a = h, l = n.to - r, h = t.block.children.length)), !n.nextSibling())
        break;
    }
    for (; t.block.children.length > a; )
      t.block.children.pop(), t.block.positions.pop();
    return o - s;
  }
}
function MM(e, t) {
  let n = e;
  for (let r = 1; r < t.length; r++) {
    let i = t[r - 1].to, s = t[r].from;
    i < e && (n -= s - i);
  }
  return n;
}
const Htt = Tu({
  "Blockquote/...": j.quote,
  HorizontalRule: j.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": j.heading1,
  "ATXHeading2/... SetextHeading2/...": j.heading2,
  "ATXHeading3/...": j.heading3,
  "ATXHeading4/...": j.heading4,
  "ATXHeading5/...": j.heading5,
  "ATXHeading6/...": j.heading6,
  "Comment CommentBlock": j.comment,
  Escape: j.escape,
  Entity: j.character,
  "Emphasis/...": j.emphasis,
  "StrongEmphasis/...": j.strong,
  "Link/... Image/...": j.link,
  "OrderedList/... BulletList/...": j.list,
  "BlockQuote/...": j.quote,
  "InlineCode CodeText": j.monospace,
  URL: j.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": j.processingInstruction,
  "CodeInfo LinkLabel": j.labelName,
  LinkTitle: j.string,
  Paragraph: j.content
}), Ktt = new sy(new Ip(SM).extend(Htt), Object.keys(W0).map((e) => W0[e]), Object.keys(W0).map((e) => Ytt[e]), Object.keys(W0), ztt, gM, Object.keys(Gb).map((e) => Gb[e]), Object.keys(Gb), []);
function Jtt(e, t, n) {
  let r = [];
  for (let i = e.firstChild, s = t; ; i = i.nextSibling) {
    let o = i ? i.from : n;
    if (o > s && r.push({ from: s, to: o }), !i)
      break;
    s = i.to;
  }
  return r;
}
function tet(e) {
  let { codeParser: t, htmlParser: n } = e;
  return { wrap: FP((i, s) => {
    let o = i.type.id;
    if (t && (o == Dt.CodeBlock || o == Dt.FencedCode)) {
      let a = "";
      if (o == Dt.FencedCode) {
        let h = i.node.getChild(Dt.CodeInfo);
        h && (a = s.read(h.from, h.to));
      }
      let l = t(a);
      if (l)
        return { parser: l, overlay: (h) => h.type.id == Dt.CodeText };
    } else if (n && (o == Dt.HTMLBlock || o == Dt.HTMLTag))
      return { parser: n, overlay: Jtt(i.node, i.from, i.to) };
    return null;
  }) };
}
const eet = { resolve: "Strikethrough", mark: "StrikethroughMark" }, net = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": j.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: j.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(e, t, n) {
      if (t != 126 || e.char(n + 1) != 126 || e.char(n + 2) == 126)
        return -1;
      let r = e.slice(n - 1, n), i = e.slice(n + 2, n + 3), s = /\s|^$/.test(r), o = /\s|^$/.test(i), a = zd.test(r), l = zd.test(i);
      return e.addDelimiter(eet, n, n + 2, !o && (!l || s || a), !s && (!a || o || l));
    },
    after: "Emphasis"
  }]
};
function jf(e, t, n = 0, r, i = 0) {
  let s = 0, o = !0, a = -1, l = -1, h = !1, u = () => {
    r.push(e.elt("TableCell", i + a, i + l, e.parser.parseInline(t.slice(a, l), i + a)));
  };
  for (let f = n; f < t.length; f++) {
    let d = t.charCodeAt(f);
    d == 124 && !h ? ((!o || a > -1) && s++, o = !1, r && (a > -1 && u(), r.push(e.elt("TableDelimiter", f + i, f + i + 1))), a = l = -1) : (h || d != 32 && d != 9) && (a < 0 && (a = f), l = f + 1), h = !h && d == 92;
  }
  return a > -1 && (s++, r && u()), s;
}
function bT(e, t) {
  for (let n = t; n < e.length; n++) {
    let r = e.charCodeAt(n);
    if (r == 124)
      return !0;
    r == 92 && n++;
  }
  return !1;
}
const RM = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class OT {
  constructor() {
    this.rows = null;
  }
  nextLine(t, n, r) {
    if (this.rows == null) {
      this.rows = !1;
      let i;
      if ((n.next == 45 || n.next == 58 || n.next == 124) && RM.test(i = n.text.slice(n.pos))) {
        let s = [];
        jf(t, r.content, 0, s, r.start) == jf(t, i, n.pos) && (this.rows = [
          t.elt("TableHeader", r.start, r.start + r.content.length, s),
          t.elt("TableDelimiter", t.lineStart + n.pos, t.lineStart + n.text.length)
        ]);
      }
    } else if (this.rows) {
      let i = [];
      jf(t, n.text, n.pos, i, t.lineStart), this.rows.push(t.elt("TableRow", t.lineStart + n.pos, t.lineStart + n.text.length, i));
    }
    return !1;
  }
  finish(t, n) {
    return this.rows ? (t.addLeafElement(n, t.elt("Table", n.start, n.start + n.content.length, this.rows)), !0) : !1;
  }
}
const ret = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": j.heading } },
    "TableRow",
    { name: "TableCell", style: j.content },
    { name: "TableDelimiter", style: j.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(e, t) {
      return bT(t.content, 0) ? new OT() : null;
    },
    endLeaf(e, t, n) {
      if (n.parsers.some((i) => i instanceof OT) || !bT(t.text, t.basePos))
        return !1;
      let r = e.scanLine(e.absoluteLineEnd + 1).text;
      return RM.test(r) && jf(e, t.text, t.basePos) == jf(e, r, t.basePos);
    },
    before: "SetextHeading"
  }]
};
class iet {
  nextLine() {
    return !1;
  }
  finish(t, n) {
    return t.addLeafElement(n, t.elt("Task", n.start, n.start + n.content.length, [
      t.elt("TaskMarker", n.start, n.start + 3),
      ...t.parser.parseInline(n.content.slice(3), n.start + 3)
    ])), !0;
  }
}
const set = {
  defineNodes: [
    { name: "Task", block: !0, style: j.list },
    { name: "TaskMarker", style: j.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(e, t) {
      return /^\[[ xX]\][ \t]/.test(t.content) && e.parentType().name == "ListItem" ? new iet() : null;
    },
    after: "SetextHeading"
  }]
}, xT = /(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy, vT = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, oet = /[\w-]+\.[\w-]+($|\/)/, _T = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, kT = /\/[a-zA-Z\d@.]+/gy;
function wT(e, t, n, r) {
  let i = 0;
  for (let s = t; s < n; s++)
    e[s] == r && i++;
  return i;
}
function aet(e, t) {
  vT.lastIndex = t;
  let n = vT.exec(e);
  if (!n || oet.exec(n[0])[0].indexOf("_") > -1)
    return -1;
  let r = t + n[0].length;
  for (; ; ) {
    let i = e[r - 1], s;
    if (/[?!.,:*_~]/.test(i) || i == ")" && wT(e, t, r, ")") > wT(e, t, r, "("))
      r--;
    else if (i == ";" && (s = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(e.slice(t, r))))
      r = t + s.index;
    else
      break;
  }
  return r;
}
function ST(e, t) {
  _T.lastIndex = t;
  let n = _T.exec(e);
  if (!n)
    return -1;
  let r = n[0][n[0].length - 1];
  return r == "_" || r == "-" ? -1 : t + n[0].length - (r == "." ? 1 : 0);
}
const cet = {
  parseInline: [{
    name: "Autolink",
    parse(e, t, n) {
      let r = n - e.offset;
      xT.lastIndex = r;
      let i = xT.exec(e.text), s = -1;
      return !i || (i[1] || i[2] ? s = aet(e.text, r + i[0].length) : i[3] ? s = ST(e.text, r) : (s = ST(e.text, r + i[0].length), s > -1 && i[0] == "xmpp:" && (kT.lastIndex = s, i = kT.exec(e.text), i && (s = i.index + i[0].length))), s < 0) ? -1 : (e.addElement(e.elt("URL", n, s + e.offset)), s + e.offset);
    }
  }]
}, het = [ret, set, net, cet];
function $M(e, t, n) {
  return (r, i, s) => {
    if (i != e || r.char(s + 1) == e)
      return -1;
    let o = [r.elt(n, s, s + 1)];
    for (let a = s + 1; a < r.end; a++) {
      let l = r.char(a);
      if (l == e)
        return r.addElement(r.elt(t, s, a + 1, o.concat(r.elt(n, a, a + 1))));
      if (l == 92 && o.push(r.elt("Escape", a, a++ + 2)), Ki(l))
        break;
    }
    return -1;
  };
}
const uet = {
  defineNodes: [
    { name: "Superscript", style: j.special(j.content) },
    { name: "SuperscriptMark", style: j.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: $M(94, "Superscript", "SuperscriptMark")
  }]
}, fet = {
  defineNodes: [
    { name: "Subscript", style: j.special(j.content) },
    { name: "SubscriptMark", style: j.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: $M(126, "Subscript", "SubscriptMark")
  }]
}, det = {
  defineNodes: [{ name: "Emoji", style: j.character }],
  parseInline: [{
    name: "Emoji",
    parse(e, t, n) {
      let r;
      return t != 58 || !(r = /^[a-zA-Z_0-9]+:/.exec(e.slice(n + 1, e.end))) ? -1 : e.addElement(e.elt("Emoji", n, n + 1 + r[0].length));
    }
  }]
};
class sm {
  constructor(t, n, r, i, s, o, a, l, h, u = 0, f) {
    this.p = t, this.stack = n, this.state = r, this.reducePos = i, this.pos = s, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = h, this.lookAhead = u, this.parent = f;
  }
  toString() {
    return `[${this.stack.filter((t, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(t, n, r = 0) {
    let i = t.parser.context;
    return new sm(t, [], n, r, r, 0, [], 0, i ? new CT(i, i.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(t, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = t;
  }
  reduce(t) {
    var n;
    let r = t >> 19, i = t & 65535, { parser: s } = this.p, o = s.dynamicPrecedence(i);
    if (o && (this.score += o), r == 0) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos), i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let a = this.stack.length - (r - 1) * 3 - (t & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, h = this.reducePos - l;
    h >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = h));
    let u = a ? this.stack[a - 1] : 0, f = this.bufferBase + this.buffer.length - u;
    if (i < s.minRepeatTerm || t & 131072) {
      let d = s.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(i, l, d, f + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[a];
    else {
      let d = this.stack[a - 3];
      this.state = s.getGoto(d, i, !0);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(i, l);
  }
  storeNode(t, n, r, i = 4, s = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, a = this.buffer.length;
      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {
        if (n == r)
          return;
        if (o.buffer[a - 2] >= n) {
          o.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!s || this.pos == r)
      this.buffer.push(t, n, r, i);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > r; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, i > 4 && (i -= 4);
      this.buffer[o] = t, this.buffer[o + 1] = n, this.buffer[o + 2] = r, this.buffer[o + 3] = i;
    }
  }
  shift(t, n, r, i) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let s = t, { parser: o } = this.p;
      (i > this.pos || n <= o.maxNode) && (this.pos = i, o.stateFlag(s, 1) || (this.reducePos = i)), this.pushState(s, r), this.shiftContext(n, r), n <= o.maxNode && this.buffer.push(n, r, i, 4);
    } else
      this.pos = i, this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
  }
  apply(t, n, r, i) {
    t & 65536 ? this.reduce(t) : this.shift(t, n, r, i);
  }
  useNode(t, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != t) && (this.p.reused.push(t), r++);
    let i = this.pos;
    this.reducePos = this.pos = i + t.length, this.pushState(n, i), this.buffer.push(r, i, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  split() {
    let t = this, n = t.buffer.length;
    for (; n > 0 && t.buffer[n - 2] > t.reducePos; )
      n -= 4;
    let r = t.buffer.slice(n), i = t.bufferBase + n;
    for (; t && i == t.bufferBase; )
      t = t.parent;
    return new sm(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, t);
  }
  recoverByDelete(t, n) {
    let r = t <= this.p.parser.maxNode;
    r && this.storeNode(t, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  canShift(t) {
    for (let n = new pet(this); ; ) {
      let r = this.p.parser.stateSlot(n.state, 4) || this.p.parser.hasAction(n.state, t);
      if (r == 0)
        return !1;
      if ((r & 65536) == 0)
        return !0;
      n.reduce(r);
    }
  }
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 4 << 1 || this.stack.length >= 120) {
      let i = [];
      for (let s = 0, o; s < n.length; s += 2)
        (o = n[s + 1]) != this.state && this.p.parser.hasAction(o, t) && i.push(n[s], o);
      if (this.stack.length < 120)
        for (let s = 0; i.length < 4 << 1 && s < n.length; s += 2) {
          let o = n[s + 1];
          i.some((a, l) => l & 1 && a == o) || i.push(n[s], o);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let s = n[i + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(n[i], this.pos), o.reducePos = this.pos, o.score -= 200, r.push(o);
    }
    return r;
  }
  forceReduce() {
    let { parser: t } = this.p, n = t.stateSlot(this.state, 5);
    if ((n & 65536) == 0)
      return !1;
    if (!t.validAction(this.state, n)) {
      let r = n >> 19, i = n & 65535, s = this.stack.length - r * 3;
      if (s < 0 || t.getGoto(this.stack[s], i, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        n = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  findForcedReduction() {
    let { parser: t } = this.p, n = [], r = (i, s) => {
      if (!n.includes(i))
        return n.push(i), t.allActions(i, (o) => {
          if (!(o & 393216))
            if (o & 65536) {
              let a = (o >> 19) - s;
              if (a > 1) {
                let l = o & 65535, h = this.stack.length - a * 3;
                if (h >= 0 && t.getGoto(this.stack[h], l, !1) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = r(o, s + 1);
              if (a != null)
                return a;
            }
        });
    };
    return r(this.state, 0);
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(this.state, 1)] == 65535 && !t.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != t.stack[n])
        return !1;
    return !0;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  reduceContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let n = new CT(this.curContext.tracker, t);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class CT {
  constructor(t, n) {
    this.tracker = t, this.context = n, this.hash = t.strict ? t.hash(n) : 0;
  }
}
class pet {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let n = t & 65535, r = t >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class om {
  constructor(t, n, r) {
    this.stack = t, this.pos = n, this.index = r, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, n = t.bufferBase + t.buffer.length) {
    return new om(t, n, n - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new om(this.stack, this.pos, this.index);
  }
}
function Ef(e, t = Uint16Array) {
  if (typeof e != "string")
    return e;
  let n = null;
  for (let r = 0, i = 0; r < e.length; ) {
    let s = 0;
    for (; ; ) {
      let o = e.charCodeAt(r++), a = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, a = !0), s += l, a)
        break;
      s *= 46;
    }
    n ? n[i++] = s : n = new t(s);
  }
  return n;
}
class W1 {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const TT = new W1();
class get {
  constructor(t, n) {
    this.input = t, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = TT, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  resolveOffset(t, n) {
    let r = this.range, i = this.rangeIndex, s = this.pos + t;
    for (; s < r.from; ) {
      if (!i)
        return null;
      let o = this.ranges[--i];
      s -= r.from - o.to, r = o;
    }
    for (; n < 0 ? s > r.to : s >= r.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let o = this.ranges[++i];
      s += o.from - r.to, r = o;
    }
    return s;
  }
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let n of this.ranges)
      if (n.to > t)
        return Math.max(t, n.from);
    return this.end;
  }
  peek(t) {
    let n = this.chunkOff + t, r, i;
    if (n >= 0 && n < this.chunk.length)
      r = this.pos + t, i = this.chunk.charCodeAt(n);
    else {
      let s = this.resolveOffset(t, 1);
      if (s == null)
        return -1;
      if (r = s, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let o = this.rangeIndex, a = this.range;
        for (; a.to <= r; )
          a = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), i = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  acceptToken(t, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), n = this.pos + t.length;
      this.chunk = n > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  reset(t, n) {
    if (n ? (this.token = n, n.start = t, n.lookAhead = t + 1, n.value = n.extended = -1) : this.token = TT, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  read(t, n) {
    if (t >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, n - this.chunkPos);
    if (t >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, n - this.chunk2Pos);
    if (t >= this.range.from && n <= this.range.to)
      return this.input.read(t, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n)
        break;
      i.to > t && (r += this.input.read(Math.max(i.from, t), Math.min(i.to, n)));
    }
    return r;
  }
}
class Oh {
  constructor(t, n) {
    this.data = t, this.id = n;
  }
  token(t, n) {
    let { parser: r } = n.p;
    IM(this.data, t, n, this.id, r.data, r.tokenPrecTable);
  }
}
Oh.prototype.contextual = Oh.prototype.fallback = Oh.prototype.extend = !1;
class am {
  constructor(t, n, r) {
    this.precTable = n, this.elseToken = r, this.data = typeof t == "string" ? Ef(t) : t;
  }
  token(t, n) {
    let r = t.pos, i = 0;
    for (; ; ) {
      let s = t.next < 0, o = t.resolveOffset(1, 1);
      if (IM(this.data, t, n, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || i++, o == null)
        break;
      t.reset(o, t.token);
    }
    i && (t.reset(r, t.token), t.acceptToken(this.elseToken, i));
  }
}
am.prototype.contextual = Oh.prototype.fallback = Oh.prototype.extend = !1;
class Ps {
  constructor(t, n = {}) {
    this.token = t, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function IM(e, t, n, r, i, s) {
  let o = 0, a = 1 << r, { dialect: l } = n.p.parser;
  t:
    for (; (a & e[o]) != 0; ) {
      let h = e[o + 1];
      for (let p = o + 3; p < h; p += 2)
        if ((e[p + 1] & a) > 0) {
          let g = e[p];
          if (l.allows(g) && (t.token.value == -1 || t.token.value == g || met(g, t.token.value, i, s))) {
            t.acceptToken(g);
            break;
          }
        }
      let u = t.next, f = 0, d = e[o + 2];
      if (t.next < 0 && d > f && e[h + d * 3 - 3] == 65535) {
        o = e[h + d * 3 - 1];
        continue t;
      }
      for (; f < d; ) {
        let p = f + d >> 1, g = h + p + (p << 1), m = e[g], y = e[g + 1] || 65536;
        if (u < m)
          d = p;
        else if (u >= y)
          f = p + 1;
        else {
          o = e[g + 2], t.advance();
          continue t;
        }
      }
      break;
    }
}
function ET(e, t, n) {
  for (let r = t, i; (i = e[r]) != 65535; r++)
    if (i == n)
      return r - t;
  return -1;
}
function met(e, t, n, r) {
  let i = ET(n, r, t);
  return i < 0 || ET(n, r, e) < i;
}
const li = typeof process < "u" && {} && /\bparse\b/.test({}.LOG);
let Hb = null;
function AT(e, t, n) {
  let r = e.cursor(tn.IncludeAnonymous);
  for (r.moveTo(t); ; )
    if (!(n < 0 ? r.childBefore(t) : r.childAfter(t)))
      for (; ; ) {
        if ((n < 0 ? r.to < t : r.from > t) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(r.to - 1, t - 25)) : Math.min(e.length, Math.max(r.from + 1, t + 25));
        if (n < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return n < 0 ? 0 : e.length;
      }
}
class yet {
  constructor(t, n) {
    this.fragments = t, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? AT(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? AT(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let r = this.trees[n], i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = r.children[i], o = this.start[n] + r.positions[i];
      if (o > t)
        return this.nextStart = o, null;
      if (s instanceof ze) {
        if (o == t) {
          if (o < this.safeFrom)
            return null;
          let a = o + s.length;
          if (a <= this.safeTo) {
            let l = s.prop(_e.lookAhead);
            if (!l || a + l < this.fragment.to)
              return s;
          }
        }
        this.index[n]++, o + s.length >= Math.max(this.safeFrom, t) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = o + s.length;
    }
  }
}
class bet {
  constructor(t, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((r) => new W1());
  }
  getActions(t) {
    let n = 0, r = null, { parser: i } = t.p, { tokenizers: s } = i, o = i.stateSlot(t.state, 3), a = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let h = 0; h < s.length; h++) {
      if ((1 << h & o) == 0)
        continue;
      let u = s[h], f = this.tokens[h];
      if (!(r && !u.fallback) && ((u.contextual || f.start != t.pos || f.mask != o || f.context != a) && (this.updateCachedToken(f, u, t), f.mask = o, f.context = a), f.lookAhead > f.end + 25 && (l = Math.max(f.lookAhead, l)), f.value != 0)) {
        let d = n;
        if (f.extended > -1 && (n = this.addActions(t, f.extended, f.end, n)), n = this.addActions(t, f.value, f.end, n), !u.extend && (r = f, n > d))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return l && t.setLookAhead(l), !r && t.pos == this.stream.end && (r = new W1(), r.value = t.p.parser.eofTerm, r.start = r.end = t.pos, n = this.addActions(t, r.value, r.end, n)), this.mainToken = r, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let n = new W1(), { pos: r, p: i } = t;
    return n.start = r, n.end = Math.min(r + 1, i.stream.end), n.value = r == i.stream.end ? i.parser.eofTerm : 0, n;
  }
  updateCachedToken(t, n, r) {
    let i = this.stream.clipPos(r.pos);
    if (n.token(this.stream.reset(i, t), r), t.value > -1) {
      let { parser: s } = r.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == t.value) {
          let a = s.specializers[o](this.stream.read(t.start, t.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            (a & 1) == 0 ? t.value = a >> 1 : t.extended = a >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(i + 1);
  }
  putAction(t, n, r, i) {
    for (let s = 0; s < i; s += 3)
      if (this.actions[s] == t)
        return i;
    return this.actions[i++] = t, this.actions[i++] = n, this.actions[i++] = r, i;
  }
  addActions(t, n, r, i) {
    let { state: s } = t, { parser: o } = t.p, { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let h = o.stateSlot(s, l ? 2 : 1); ; h += 3) {
        if (a[h] == 65535)
          if (a[h + 1] == 1)
            h = Fo(a, h + 2);
          else {
            i == 0 && a[h + 1] == 2 && (i = this.putAction(Fo(a, h + 2), n, r, i));
            break;
          }
        a[h] == n && (i = this.putAction(Fo(a, h + 1), n, r, i));
      }
    return i;
  }
}
class Oet {
  constructor(t, n, r, i) {
    this.parser = t, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new get(n, i), this.tokens = new bet(t, this.stream), this.topTerm = t.top[1];
    let { from: s } = i[0];
    this.stacks = [sm.start(this, t.top[0], s)], this.fragments = r.length && this.stream.end - s > t.bufferLength * 4 ? new yet(r, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let t = this.stacks, n = this.minStackPos, r = this.stacks = [], i, s;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [o] = t;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < t.length; o++) {
      let a = t[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > n)
          r.push(a);
        else {
          if (this.advanceStack(a, r, t))
            continue;
          {
            i || (i = [], s = []), i.push(a);
            let l = this.tokens.getMainToken(a);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let o = i && vet(i);
      if (o)
        return li && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw li && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let o = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, r);
      if (o)
        return li && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > o)
        for (r.sort((a, l) => l.score - a.score); r.length > o; )
          r.pop();
      r.some((a) => a.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      t:
        for (let o = 0; o < r.length - 1; o++) {
          let a = r[o];
          for (let l = o + 1; l < r.length; l++) {
            let h = r[l];
            if (a.sameState(h) || a.buffer.length > 500 && h.buffer.length > 500)
              if ((a.score - h.score || a.buffer.length - h.buffer.length) > 0)
                r.splice(l--, 1);
              else {
                r.splice(o--, 1);
                continue t;
              }
          }
        }
      r.length > 12 && r.splice(12, r.length - 12);
    }
    this.minStackPos = r[0].pos;
    for (let o = 1; o < r.length; o++)
      r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  advanceStack(t, n, r) {
    let i = t.pos, { parser: s } = this, o = li ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let h = t.curContext && t.curContext.tracker.strict, u = h ? t.curContext.hash : 0;
      for (let f = this.fragments.nodeAt(i); f; ) {
        let d = this.parser.nodeSet.types[f.type.id] == f.type ? s.getGoto(t.state, f.type.id) : -1;
        if (d > -1 && f.length && (!h || (f.prop(_e.contextHash) || 0) == u))
          return t.useNode(f, d), li && console.log(o + this.stackID(t) + ` (via reuse of ${s.getName(f.type.id)})`), !0;
        if (!(f instanceof ze) || f.children.length == 0 || f.positions[0] > 0)
          break;
        let p = f.children[0];
        if (p instanceof ze && f.positions[0] == 0)
          f = p;
        else
          break;
      }
    }
    let a = s.stateSlot(t.state, 4);
    if (a > 0)
      return t.reduce(a), li && console.log(o + this.stackID(t) + ` (via always-reduce ${s.getName(a & 65535)})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let h = 0; h < l.length; ) {
      let u = l[h++], f = l[h++], d = l[h++], p = h == l.length || !r, g = p ? t : t.split(), m = this.tokens.mainToken;
      if (g.apply(u, f, m ? m.start : g.pos, d), li && console.log(o + this.stackID(g) + ` (via ${(u & 65536) == 0 ? "shift" : `reduce of ${s.getName(u & 65535)}`} for ${s.getName(f)} @ ${i}${g == t ? "" : ", split"})`), p)
        return !0;
      g.pos > i ? n.push(g) : r.push(g);
    }
    return !1;
  }
  advanceFully(t, n) {
    let r = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > r)
        return PT(t, n), !0;
    }
  }
  runRecovery(t, n, r) {
    let i = null, s = !1;
    for (let o = 0; o < t.length; o++) {
      let a = t[o], l = n[o << 1], h = n[(o << 1) + 1], u = li ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (s || (s = !0, a.restart(), li && console.log(u + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let f = a.split(), d = u;
      for (let p = 0; f.forceReduce() && p < 10 && (li && console.log(d + this.stackID(f) + " (via force-reduce)"), !this.advanceFully(f, r)); p++)
        li && (d = this.stackID(f) + " -> ");
      for (let p of a.recoverByInsert(l))
        li && console.log(u + this.stackID(p) + " (via recover-insert)"), this.advanceFully(p, r);
      this.stream.end > a.pos ? (h == a.pos && (h++, l = 0), a.recoverByDelete(l, h), li && console.log(u + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), PT(a, r)) : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  stackToTree(t) {
    return t.close(), ze.build({
      buffer: om.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let n = (Hb || (Hb = /* @__PURE__ */ new WeakMap())).get(t);
    return n || Hb.set(t, n = String.fromCodePoint(this.nextStackID++)), n + t;
  }
}
function PT(e, t) {
  for (let n = 0; n < t.length; n++) {
    let r = t[n];
    if (r.pos == e.pos && r.sameState(e)) {
      t[n].score < e.score && (t[n] = e);
      return;
    }
  }
  t.push(e);
}
class xet {
  constructor(t, n, r) {
    this.source = t, this.flags = n, this.disabled = r;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}
const Kb = (e) => e;
class NM {
  constructor(t) {
    this.start = t.start, this.shift = t.shift || Kb, this.reduce = t.reduce || Kb, this.reuse = t.reuse || Kb, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}
class Gh extends pw {
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (${14})`);
    let n = t.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let a = 0; a < t.repeatNodeCount; a++)
      n.push("");
    let r = Object.keys(t.topRules).map((a) => t.topRules[a][1]), i = [];
    for (let a = 0; a < n.length; a++)
      i.push([]);
    function s(a, l, h) {
      i[a].push([l, l.deserialize(String(h))]);
    }
    if (t.nodeProps)
      for (let a of t.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = _e[l]);
        for (let h = 1; h < a.length; ) {
          let u = a[h++];
          if (u >= 0)
            s(u, l, a[h++]);
          else {
            let f = a[h + -u];
            for (let d = -u; d > 0; d--)
              s(a[h++], l, f);
            h++;
          }
        }
      }
    this.nodeSet = new Ip(n.map((a, l) => Jn.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: i[l],
      top: r.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = RP;
    let o = Ef(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(DT), this.states = Ef(t.states, Uint32Array), this.data = Ef(t.stateData), this.goto = Ef(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((a) => typeof a == "number" ? new Oh(o, a) : a), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, n, r) {
    let i = new Oet(this, t, n, r);
    for (let s of this.wrappers)
      i = s(i, t, n, r);
    return i;
  }
  getGoto(t, n, r = !1) {
    let i = this.goto;
    if (n >= i[0])
      return -1;
    for (let s = i[n + 1]; ; ) {
      let o = i[s++], a = o & 1, l = i[s++];
      if (a && r)
        return l;
      for (let h = s + (o >> 1); s < h; s++)
        if (i[s] == t)
          return l;
      if (a)
        return -1;
    }
  }
  hasAction(t, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(t, i ? 2 : 1), o; ; s += 3) {
        if ((o = r[s]) == 65535)
          if (r[s + 1] == 1)
            o = r[s = Fo(r, s + 2)];
          else {
            if (r[s + 1] == 2)
              return Fo(r, s + 2);
            break;
          }
        if (o == n || o == 0)
          return Fo(r, s + 1);
      }
    return 0;
  }
  stateSlot(t, n) {
    return this.states[t * 6 + n];
  }
  stateFlag(t, n) {
    return (this.stateSlot(t, 0) & n) > 0;
  }
  validAction(t, n) {
    return !!this.allActions(t, (r) => r == n ? !0 : null);
  }
  allActions(t, n) {
    let r = this.stateSlot(t, 4), i = r ? n(r) : void 0;
    for (let s = this.stateSlot(t, 1); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = Fo(this.data, s + 2);
        else
          break;
      i = n(Fo(this.data, s + 1));
    }
    return i;
  }
  nextStates(t) {
    let n = [];
    for (let r = this.stateSlot(t, 1); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Fo(this.data, r + 2);
        else
          break;
      if ((this.data[r + 2] & 1) == 0) {
        let i = this.data[r + 1];
        n.some((s, o) => o & 1 && s == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  configure(t) {
    let n = Object.assign(Object.create(Gh.prototype), this);
    if (t.props && (n.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let r = this.topRules[t.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      n.top = r;
    }
    return t.tokenizers && (n.tokenizers = this.tokenizers.map((r) => {
      let i = t.tokenizers.find((s) => s.from == r);
      return i ? i.to : r;
    })), t.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((r, i) => {
      let s = t.specializers.find((a) => a.from == r.external);
      if (!s)
        return r;
      let o = Object.assign(Object.assign({}, r), { external: s.to });
      return n.specializers[i] = DT(o), o;
    })), t.contextTracker && (n.context = t.contextTracker), t.dialect && (n.dialect = this.parseDialect(t.dialect)), t.strict != null && (n.strict = t.strict), t.wrap && (n.wrappers = n.wrappers.concat(t.wrap)), t.bufferLength != null && (n.bufferLength = t.bufferLength), n;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(t) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[t] || 0;
  }
  parseDialect(t) {
    let n = Object.keys(this.dialects), r = n.map(() => !1);
    if (t)
      for (let s of t.split(" ")) {
        let o = n.indexOf(s);
        o >= 0 && (r[o] = !0);
      }
    let i = null;
    for (let s = 0; s < n.length; s++)
      if (!r[s])
        for (let o = this.dialects[n[s]], a; (a = this.data[o++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new xet(t, r, i);
  }
  static deserialize(t) {
    return new Gh(t);
  }
}
function Fo(e, t) {
  return e[t] | e[t + 1] << 16;
}
function vet(e) {
  let t = null;
  for (let n of e) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || r != null && n.pos > r) && n.p.parser.stateFlag(n.state, 2) && (!t || t.score < n.score) && (t = n);
  }
  return t;
}
function DT(e) {
  if (e.external) {
    let t = e.extend ? 1 : 0;
    return (n, r) => e.external(n, r) << 1 | t;
  }
  return e.get;
}
const _et = 54, ket = 1, wet = 55, Cet = 2, Tet = 56, Eet = 3, LT = 4, Aet = 5, lm = 6, BM = 7, FM = 8, QM = 9, ZM = 10, Pet = 11, Det = 12, Let = 13, Jb = 57, Met = 14, MT = 58, VM = 20, Ret = 22, YM = 23, $et = 24, t_ = 26, zM = 27, Iet = 28, Net = 31, Bet = 34, Fet = 36, Qet = 37, Zet = 0, Vet = 1, Yet = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, zet = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, RT = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function qet(e) {
  return e == 45 || e == 46 || e == 58 || e >= 65 && e <= 90 || e == 95 || e >= 97 && e <= 122 || e >= 161;
}
function qM(e) {
  return e == 9 || e == 10 || e == 13 || e == 32;
}
let $T = null, IT = null, NT = 0;
function e_(e, t) {
  let n = e.pos + t;
  if (NT == n && IT == e)
    return $T;
  let r = e.peek(t);
  for (; qM(r); )
    r = e.peek(++t);
  let i = "";
  for (; qet(r); )
    i += String.fromCharCode(r), r = e.peek(++t);
  return IT = e, NT = n, $T = i ? i.toLowerCase() : r == Wet || r == Uet ? void 0 : null;
}
const WM = 60, cm = 62, o3 = 47, Wet = 63, Uet = 33, jet = 45;
function BT(e, t) {
  this.name = e, this.parent = t, this.hash = t ? t.hash : 0;
  for (let n = 0; n < e.length; n++)
    this.hash += (this.hash << 4) + e.charCodeAt(n) + (e.charCodeAt(n) << 8);
}
const Xet = [lm, ZM, BM, FM, QM], Get = new NM({
  start: null,
  shift(e, t, n, r) {
    return Xet.indexOf(t) > -1 ? new BT(e_(r, 1) || "", e) : e;
  },
  reduce(e, t) {
    return t == VM && e ? e.parent : e;
  },
  reuse(e, t, n, r) {
    let i = t.type.id;
    return i == lm || i == Fet ? new BT(e_(r, 1) || "", e) : e;
  },
  hash(e) {
    return e ? e.hash : 0;
  },
  strict: !1
}), Het = new Ps((e, t) => {
  if (e.next != WM) {
    e.next < 0 && t.context && e.acceptToken(Jb);
    return;
  }
  e.advance();
  let n = e.next == o3;
  n && e.advance();
  let r = e_(e, 0);
  if (r === void 0)
    return;
  if (!r)
    return e.acceptToken(n ? Met : lm);
  let i = t.context ? t.context.name : null;
  if (n) {
    if (r == i)
      return e.acceptToken(Pet);
    if (i && zet[i])
      return e.acceptToken(Jb, -2);
    if (t.dialectEnabled(Zet))
      return e.acceptToken(Det);
    for (let s = t.context; s; s = s.parent)
      if (s.name == r)
        return;
    e.acceptToken(Let);
  } else {
    if (r == "script")
      return e.acceptToken(BM);
    if (r == "style")
      return e.acceptToken(FM);
    if (r == "textarea")
      return e.acceptToken(QM);
    if (Yet.hasOwnProperty(r))
      return e.acceptToken(ZM);
    i && RT[i] && RT[i][r] ? e.acceptToken(Jb, -1) : e.acceptToken(lm);
  }
}, { contextual: !0 }), Ket = new Ps((e) => {
  for (let t = 0, n = 0; ; n++) {
    if (e.next < 0) {
      n && e.acceptToken(MT);
      break;
    }
    if (e.next == jet)
      t++;
    else if (e.next == cm && t >= 2) {
      n >= 3 && e.acceptToken(MT, -2);
      break;
    } else
      t = 0;
    e.advance();
  }
});
function Jet(e) {
  for (; e; e = e.parent)
    if (e.name == "svg" || e.name == "math")
      return !0;
  return !1;
}
const tnt = new Ps((e, t) => {
  if (e.next == o3 && e.peek(1) == cm) {
    let n = t.dialectEnabled(Vet) || Jet(t.context);
    e.acceptToken(n ? Aet : LT, 2);
  } else
    e.next == cm && e.acceptToken(LT, 1);
});
function a3(e, t, n) {
  let r = 2 + e.length;
  return new Ps((i) => {
    for (let s = 0, o = 0, a = 0; ; a++) {
      if (i.next < 0) {
        a && i.acceptToken(t);
        break;
      }
      if (s == 0 && i.next == WM || s == 1 && i.next == o3 || s >= 2 && s < r && i.next == e.charCodeAt(s - 2))
        s++, o++;
      else if ((s == 2 || s == r) && qM(i.next))
        o++;
      else if (s == r && i.next == cm) {
        a > o ? i.acceptToken(t, -o) : i.acceptToken(n, -(o - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && a) {
        i.acceptToken(t, 1);
        break;
      } else
        s = o = 0;
      i.advance();
    }
  });
}
const ent = a3("script", _et, ket), nnt = a3("style", wet, Cet), rnt = a3("textarea", Tet, Eet), int = Tu({
  "Text RawText": j.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": j.angleBracket,
  TagName: j.tagName,
  "MismatchedCloseTag/TagName": [j.tagName, j.invalid],
  AttributeName: j.attributeName,
  "AttributeValue UnquotedAttributeValue": j.attributeValue,
  Is: j.definitionOperator,
  "EntityReference CharacterReference": j.character,
  Comment: j.blockComment,
  ProcessingInst: j.processingInstruction,
  DoctypeDecl: j.documentMeta
}), snt = Gh.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: Get,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [int],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [ent, nnt, rnt, tnt, Het, Ket, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function UM(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r of e.getChildren(YM)) {
    let i = r.getChild($et), s = r.getChild(t_) || r.getChild(zM);
    i && (n[t.read(i.from, i.to)] = s ? s.type.id == t_ ? t.read(s.from + 1, s.to - 1) : t.read(s.from, s.to) : "");
  }
  return n;
}
function FT(e, t) {
  let n = e.getChild(Ret);
  return n ? t.read(n.from, n.to) : " ";
}
function tO(e, t, n) {
  let r;
  for (let i of n)
    if (!i.attrs || i.attrs(r || (r = UM(e.node.parent.firstChild, t))))
      return { parser: i.parser };
  return null;
}
function jM(e = [], t = []) {
  let n = [], r = [], i = [], s = [];
  for (let a of e)
    (a.tag == "script" ? n : a.tag == "style" ? r : a.tag == "textarea" ? i : s).push(a);
  let o = t.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of t)
    (o[a.name] || (o[a.name] = [])).push(a);
  return FP((a, l) => {
    let h = a.type.id;
    if (h == Iet)
      return tO(a, l, n);
    if (h == Net)
      return tO(a, l, r);
    if (h == Bet)
      return tO(a, l, i);
    if (h == VM && s.length) {
      let u = a.node, f = u.firstChild, d = f && FT(f, l), p;
      if (d) {
        for (let g of s)
          if (g.tag == d && (!g.attrs || g.attrs(p || (p = UM(u, l))))) {
            let m = u.lastChild, y = m.type.id == Qet ? m.from : u.to;
            if (y > f.to)
              return { parser: g.parser, overlay: [{ from: f.to, to: y }] };
          }
      }
    }
    if (o && h == YM) {
      let u = a.node, f;
      if (f = u.firstChild) {
        let d = o[l.read(f.from, f.to)];
        if (d)
          for (let p of d) {
            if (p.tagName && p.tagName != FT(u.parent, l))
              continue;
            let g = u.lastChild;
            if (g.type.id == t_) {
              let m = g.from + 1, y = g.lastChild, O = g.to - (y && y.isError ? 0 : 1);
              if (O > m)
                return { parser: p.parser, overlay: [{ from: m, to: O }] };
            } else if (g.type.id == zM)
              return { parser: p.parser, overlay: [{ from: g.from, to: g.to }] };
          }
      }
    }
    return null;
  });
}
const ont = 96, QT = 1, ant = 97, lnt = 98, ZT = 2, XM = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], cnt = 58, hnt = 40, GM = 95, unt = 91, U1 = 45, fnt = 46, dnt = 35, pnt = 37, gnt = 38, mnt = 92, ynt = 10;
function hm(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 161;
}
function bnt(e) {
  return e >= 48 && e <= 57;
}
const Ont = new Ps((e, t) => {
  for (let n = !1, r = 0, i = 0; ; i++) {
    let { next: s } = e;
    if (hm(s) || s == U1 || s == GM || n && bnt(s))
      !n && (s != U1 || i > 0) && (n = !0), r === i && s == U1 && r++, e.advance();
    else if (s == mnt && e.peek(1) != ynt)
      e.advance(), e.next > -1 && e.advance(), n = !0;
    else {
      n && e.acceptToken(s == hnt ? ant : r == 2 && t.canShift(ZT) ? ZT : lnt);
      break;
    }
  }
}), xnt = new Ps((e) => {
  if (XM.includes(e.peek(-1))) {
    let { next: t } = e;
    (hm(t) || t == GM || t == dnt || t == fnt || t == unt || t == cnt || t == U1 || t == gnt) && e.acceptToken(ont);
  }
}), vnt = new Ps((e) => {
  if (!XM.includes(e.peek(-1))) {
    let { next: t } = e;
    if (t == pnt && (e.advance(), e.acceptToken(QT)), hm(t)) {
      do
        e.advance();
      while (hm(e.next));
      e.acceptToken(QT);
    }
  }
}), _nt = Tu({
  "AtKeyword import charset namespace keyframes media supports": j.definitionKeyword,
  "from to selector": j.keyword,
  NamespaceName: j.namespace,
  KeyframeName: j.labelName,
  KeyframeRangeName: j.operatorKeyword,
  TagName: j.tagName,
  ClassName: j.className,
  PseudoClassName: j.constant(j.className),
  IdName: j.labelName,
  "FeatureName PropertyName": j.propertyName,
  AttributeName: j.attributeName,
  NumberLiteral: j.number,
  KeywordQuery: j.keyword,
  UnaryQueryOp: j.operatorKeyword,
  "CallTag ValueName": j.atom,
  VariableName: j.variableName,
  Callee: j.operatorKeyword,
  Unit: j.unit,
  "UniversalSelector NestingSelector": j.definitionOperator,
  MatchOp: j.compareOperator,
  "ChildOp SiblingOp, LogicOp": j.logicOperator,
  BinOp: j.arithmeticOperator,
  Important: j.modifier,
  Comment: j.blockComment,
  ColorLiteral: j.color,
  "ParenthesizedContent StringLiteral": j.string,
  ":": j.punctuation,
  "PseudoOp #": j.derefOperator,
  "; ,": j.separator,
  "( )": j.paren,
  "[ ]": j.squareBracket,
  "{ }": j.brace
}), knt = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, wnt = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, Snt = { __proto__: null, not: 128, only: 128 }, Cnt = Gh.deserialize({
  version: 14,
  states: "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c",
  stateData: ":k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~",
  goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`",
  nodeNames: "\u26A0 Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 114,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [_nt],
  skippedNodes: [0, 3, 85],
  repeatNodeCount: 10,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [xnt, vnt, Ont, 1, 2, 3, 4, new am("m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~", 28, 102)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 97, get: (e) => knt[e] || -1 }, { term: 56, get: (e) => wnt[e] || -1 }, { term: 98, get: (e) => Snt[e] || -1 }],
  tokenPrec: 1169
});
let eO = null;
function nO() {
  if (!eO && typeof document == "object" && document.body) {
    let { style: e } = document.body, t = [], n = /* @__PURE__ */ new Set();
    for (let r in e)
      r != "cssText" && r != "cssFloat" && typeof e[r] == "string" && (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), n.has(r) || (t.push(r), n.add(r)));
    eO = t.sort().map((r) => ({ type: "property", label: r }));
  }
  return eO || [];
}
const VT = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((e) => ({ type: "class", label: e })), YT = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((e) => ({ type: "keyword", label: e })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((e) => ({ type: "constant", label: e }))), Tnt = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((e) => ({ type: "type", label: e })), wa = /^(\w[\w-]*|-\w[\w-]*|)$/, Ent = /^-(-[\w-]*)?$/;
function Ant(e, t) {
  var n;
  if ((e.name == "(" || e.type.isError) && (e = e.parent || e), e.name != "ArgList")
    return !1;
  let r = (n = e.parent) === null || n === void 0 ? void 0 : n.firstChild;
  return (r == null ? void 0 : r.name) != "Callee" ? !1 : t.sliceString(r.from, r.to) == "var";
}
const zT = /* @__PURE__ */ new BP(), Pnt = ["Declaration"];
function Dnt(e) {
  for (let t = e; ; ) {
    if (t.type.isTop)
      return t;
    if (!(t = t.parent))
      return e;
  }
}
function HM(e, t, n) {
  if (t.to - t.from > 4096) {
    let r = zT.get(t);
    if (r)
      return r;
    let i = [], s = /* @__PURE__ */ new Set(), o = t.cursor(tn.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let a of HM(e, o.node, n))
          s.has(a.label) || (s.add(a.label), i.push(a));
      while (o.nextSibling());
    return zT.set(t, i), i;
  } else {
    let r = [], i = /* @__PURE__ */ new Set();
    return t.cursor().iterate((s) => {
      var o;
      if (n(s) && s.matchContext(Pnt) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let a = e.sliceString(s.from, s.to);
        i.has(a) || (i.add(a), r.push({ label: a, type: "variable" }));
      }
    }), r;
  }
}
const Lnt = (e) => (t) => {
  let { state: n, pos: r } = t, i = en(n).resolveInner(r, -1), s = i.type.isError && i.from == i.to - 1 && n.doc.sliceString(i.from, i.to) == "-";
  if (i.name == "PropertyName" || (s || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name))
    return { from: i.from, options: nO(), validFor: wa };
  if (i.name == "ValueName")
    return { from: i.from, options: YT, validFor: wa };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: VT, validFor: wa };
  if (e(i) || (t.explicit || s) && Ant(i, n.doc))
    return {
      from: e(i) || s ? i.from : r,
      options: HM(n.doc, Dnt(i), e),
      validFor: Ent
    };
  if (i.name == "TagName") {
    for (let { parent: l } = i; l; l = l.parent)
      if (l.name == "Block")
        return { from: i.from, options: nO(), validFor: wa };
    return { from: i.from, options: Tnt, validFor: wa };
  }
  if (!t.explicit)
    return null;
  let o = i.resolve(r), a = o.childBefore(r);
  return a && a.name == ":" && o.name == "PseudoClassSelector" ? { from: r, options: VT, validFor: wa } : a && a.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: r, options: YT, validFor: wa } : o.name == "Block" || o.name == "Styles" ? { from: r, options: nO(), validFor: wa } : null;
}, Mnt = /* @__PURE__ */ Lnt((e) => e.name == "VariableName"), um = /* @__PURE__ */ Qh.define({
  name: "css",
  parser: /* @__PURE__ */ Cnt.configure({
    props: [
      /* @__PURE__ */ Bp.add({
        Declaration: /* @__PURE__ */ Q1()
      }),
      /* @__PURE__ */ Eu.add({
        "Block KeyframeList": WP
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function Rnt() {
  return new Cd(um, um.data.of({ autocomplete: Mnt }));
}
const $nt = 309, qT = 1, Int = 2, Nnt = 3, Bnt = 310, Fnt = 312, Qnt = 313, Znt = 4, Vnt = 5, Ynt = 0, n_ = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], KM = 125, znt = 59, r_ = 47, qnt = 42, Wnt = 43, Unt = 45, jnt = 60, Xnt = 44, Gnt = new NM({
  start: !1,
  shift(e, t) {
    return t == Znt || t == Vnt || t == Fnt ? e : t == Qnt;
  },
  strict: !1
}), Hnt = new Ps((e, t) => {
  let { next: n } = e;
  (n == KM || n == -1 || t.context) && e.acceptToken(Bnt);
}, { contextual: !0, fallback: !0 }), Knt = new Ps((e, t) => {
  let { next: n } = e, r;
  n_.indexOf(n) > -1 || n == r_ && ((r = e.peek(1)) == r_ || r == qnt) || n != KM && n != znt && n != -1 && !t.context && e.acceptToken($nt);
}, { contextual: !0 }), Jnt = new Ps((e, t) => {
  let { next: n } = e;
  if ((n == Wnt || n == Unt) && (e.advance(), n == e.next)) {
    e.advance();
    let r = !t.context && t.canShift(qT);
    e.acceptToken(r ? qT : Int);
  }
}, { contextual: !0 });
function rO(e, t) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e == 95 || e >= 192 || !t && e >= 48 && e <= 57;
}
const trt = new Ps((e, t) => {
  if (e.next != jnt || !t.dialectEnabled(Ynt) || (e.advance(), e.next == r_))
    return;
  let n = 0;
  for (; n_.indexOf(e.next) > -1; )
    e.advance(), n++;
  if (rO(e.next, !0)) {
    for (e.advance(), n++; rO(e.next, !1); )
      e.advance(), n++;
    for (; n_.indexOf(e.next) > -1; )
      e.advance(), n++;
    if (e.next == Xnt)
      return;
    for (let r = 0; ; r++) {
      if (r == 7) {
        if (!rO(e.next, !0))
          return;
        break;
      }
      if (e.next != "extends".charCodeAt(r))
        break;
      e.advance(), n++;
    }
  }
  e.acceptToken(Nnt, -n);
}), ert = Tu({
  "get set async static": j.modifier,
  "for while do if else switch try catch finally return throw break continue default case": j.controlKeyword,
  "in of await yield void typeof delete instanceof": j.operatorKeyword,
  "let var const using function class extends": j.definitionKeyword,
  "import export from": j.moduleKeyword,
  "with debugger as new": j.keyword,
  TemplateString: j.special(j.string),
  super: j.atom,
  BooleanLiteral: j.bool,
  this: j.self,
  null: j.null,
  Star: j.modifier,
  VariableName: j.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": j.function(j.variableName),
  VariableDefinition: j.definition(j.variableName),
  Label: j.labelName,
  PropertyName: j.propertyName,
  PrivatePropertyName: j.special(j.propertyName),
  "CallExpression/MemberExpression/PropertyName": j.function(j.propertyName),
  "FunctionDeclaration/VariableDefinition": j.function(j.definition(j.variableName)),
  "ClassDeclaration/VariableDefinition": j.definition(j.className),
  PropertyDefinition: j.definition(j.propertyName),
  PrivatePropertyDefinition: j.definition(j.special(j.propertyName)),
  UpdateOp: j.updateOperator,
  "LineComment Hashbang": j.lineComment,
  BlockComment: j.blockComment,
  Number: j.number,
  String: j.string,
  Escape: j.escape,
  ArithOp: j.arithmeticOperator,
  LogicOp: j.logicOperator,
  BitOp: j.bitwiseOperator,
  CompareOp: j.compareOperator,
  RegExp: j.regexp,
  Equals: j.definitionOperator,
  Arrow: j.function(j.punctuation),
  ": Spread": j.punctuation,
  "( )": j.paren,
  "[ ]": j.squareBracket,
  "{ }": j.brace,
  "InterpolationStart InterpolationEnd": j.special(j.brace),
  ".": j.derefOperator,
  ", ;": j.separator,
  "@": j.meta,
  TypeName: j.typeName,
  TypeDefinition: j.definition(j.typeName),
  "type enum interface implements namespace module declare": j.definitionKeyword,
  "abstract global Privacy readonly override": j.modifier,
  "is keyof unique infer": j.operatorKeyword,
  JSXAttributeValue: j.attributeValue,
  JSXText: j.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": j.angleBracket,
  "JSXIdentifier JSXNameSpacedName": j.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": j.attributeName,
  "JSXBuiltin/JSXIdentifier": j.standard(j.tagName)
}), nrt = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, rrt = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, irt = { __proto__: null, "<": 143 }, srt = Gh.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>pQ08SO1G0{O#>wQ08SO1G0{O#@oQ08SO1G0{O#CoQ(CYO'#ChO#EmQ(CYO1G1^O#EtQ(CYO'#JjO!,lQWO1G1dO#FUQ08SO,5?TOOQ07`-E<g-E<gO#FxQ08SO1G0{OOQ07b1G0{1G0{O#ITQ08SO1G1aO#IwQ&jO,5<TO#JPQ&jO,5<UO#JXQ&jO'#FlO#JpQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#JuQ&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#KWQ(CYO'#JiO#KbQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KgQ`O'#J}OOQ07b,5<a,5<aO#KoQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KtO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LPQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LoQ7[O,5=RO!(SQ7[O'#IpO#MbQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MlQpO'#CqO#NPQpO,5<nO#NWQWO'#KRO9aQWO'#KRO#NfQWO,5<pO!(SQ7[O,5<oO#NkQWO'#GUO#NvQWO,5<oO#N{QpO'#GRO$ YQpO'#KSO$ dQWO'#KSO!&dQ7[O'#KSO$ iQWO,5<sO$ nQ`O'#G^O!4eQ`O'#G^O$!PQWO'#G`O$!UQWO'#GbO!3fQWO'#GeO$!ZQ07hO'#ImO$!fQ`O,5<wOOQ07f,5<w,5<wO$!mQ`O'#G^O$!{Q`O'#G_O$#TQ`O'#G_O$#YQ7[O,5=RO$#jQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$#zQWO'#IrO$$VQWO,5?|O$$_QWO,59`O$%OQ7[O,59qOOQ07b,59q,59qO$%qQ7[O,5<fO$&dQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&nQWO,5<qO$&sQ7[O,5<vO$'TQWO'#JuO!$aQ^O1G1}O$'YQWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'_Q07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)dQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+hQ7[O'#EgOOQ07`,5?{,5?{O$+rQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,TQWO1G0qO$,YQWO'#ChO$,eQWO'#K[O$,mQWO,5=uO$,rQWO'#K[O$,wQWO'#K[O$-VQWO'#IzO$-eQWO,5@uO$-mQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-tQWO1G3`O$-yQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.OQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.TQWO1G2|O$.]Q`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.eQ7[O,5=nO9aQWO,5=nO$!UQWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.sQWO'#KYO$/OQWO,5=qOOQU1G.j1G.jO$/TQ07hO1G.jO@bQWO1G.jO$/`QWO1G.jO9kQ07hO1G.jO$1eQrO,5@wO$1uQWO,5@wO9ZQWO,5@wO$2QQ^O,5=xO$2XQWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2^Q^O1G3nO$6bQ^O'#HmOOQU1G3q1G3qO$6oQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6wQ^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;OQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;TQ(CYO,5:UOOQO,5;[,5;[O$;_Q`O'#I^O$;uQWO,5@WOOQ07b1G/o1G/oO$;}Q`O'#IdO$<XQWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<aQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<hQ07hO1G0iO$<sQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=RQ07hO1G0iOOQO1G0]1G0]O$=gQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=qQpO,5<eO$=yQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>TQWO1G5qO$>]QWO1G6OO$>eQrO1G6PO9ZQWO,5>}O$>oQ08SO1G5|O%[Q^O1G5|O$?PQ07hO1G5|O$?bQWO1G5{O$?bQWO1G5{O9ZQWO1G5{O$?jQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@OQWO,5?QO$'TQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@^QWO7+(_O$@iQ7[O7+(_O$@wQ08SO,5=RO$CSQ08SO,5=TO$E_Q08SO,5=RO$GpQ08SO,5=TO$JRQ08SO,59qO$LZQ08SO,5<fO$NfQ08SO,5<hO%!qQ08SO,5<vOOQ07b7+&]7+&]O%%SQ08SO7+&]O%%vQ7[O'#I_O%&QQWO,5@YOOQ07b1G/y1G/yO%&YQ^O'#I`O%&gQWO,5@ZO%&oQrO,5@ZOOQ07b1G0O1G0OO%&yQWO7+&fOOQ07b7+&f7+&fO%'OQ(CYO,5:eO%[Q^O7+&xO%'YQ(CYO,5:]O%'gQ(CYO,5:iO%'qQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%'{QtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(WQWO1G1yOOQ07b1G1{1G1{O%(]QpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(dQ08SO7+'hOOQ07b,5?V,5?VO%)WQpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)vQ7[O,5?YOOQ07b-E<l-E<lO%*iQ7[O,5?[OOQ07b-E<n-E<nO%*sQpO1G2qOOQ07b1G2Y1G2YO%*zQWO'#IjO%+YQWO,5@mO%+YQWO,5@mO%+bQWO,5@mO%+mQWO,5@mOOQO1G2[1G2[O%+{Q7[O1G2ZO!(SQ7[O1G2ZO%,]Q!LQO'#IlO%,mQWO,5@nO!&dQ7[O,5@nO%,uQpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'TQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-PQWO,5<zOOQ07`,5<|,5<|O$'TQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-XQWO,5<yO$!PQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%-{Q7[O1G2mO!(SQ7[O'#IpO%.nQ7[O1G2oO%.xQ7[O1G5iO%/SQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/aQWO1G2UO!(SQ7[O1G2]O%/fQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0YQWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0_QpO'#KTO#%sQWO7+(_O%0iQrO7+(_O$@aQWO7+(_O%0pQ08QO'#ChO%1TQ08QO,5<}O%1uQWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%1zQWO'#IyO%2cQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2cQWO,5@vO%2kQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2pQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2uQ08QO7+(gO!&dQ7[O7+(gO%3PQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3WQWO'#KXO%3cQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4rQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%4yQWO1G3YO%5UQ7[O1G3YO9kQ07hO1G3[O$!UQWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5dQWO'#IxO%5xQWO,5@tO%6QQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6]QWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6bQ07hO1G6cO%6lQ^O1G3dO%6sQWO1G3dO%6xQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7PQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7^QWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7cQ`O1G5sO%7wQ(CYO1G0vO%8RQWO1G0vOOQO1G/p1G/pO%8^Q(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=gQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8hQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8sQ07hO7+&TO%9RQ08SO7++hO%[Q^O7++hO%9cQWO7++gO%9cQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9kQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0iQrO<<KyO%9yQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:RQWO<<KyO%:^Q08SO,5?YO%<iQ08SO,5?[O%>tQ08SO1G2ZO%AVQ08SO1G2mO%CbQ08SO1G2oO%EmQ7[O,5>yOOQO-E<]-E<]O%EwQrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FRQWO1G5uOOQ07b<<JQ<<JQO%FZQ(CYO1G0qO%HeQ(CYO1G0{O%HlQ(CYO1G0{O%JpQ(CYO1G0{O%JwQ(CYO1G0{O%LlQ(CYO1G0{O%MSQ(CYO1G0{O& gQ(CYO1G0{O& nQ(CYO1G0{O&#rQ(CYO1G0{O&#yQ(CYO1G0{O&%qQ(CYO1G0{O&&UQ08SO<<JdO&'ZQ(CYO1G0{O&)PQ(CYO'#JdO&+SQ(CYO1G1aO&+aQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+kQWO1G1qO&+pQ(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&+zQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,YQWO1G6XO&,YQWO1G6XO&,bQWO1G6XO&,mQ7[O7+'uO&,}QpO,5?WO&-XQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-^QpO1G6YO&-hQWO1G6YOOQ07`1G2e1G2eO$'TQWO1G2eOOQ07`1G2d1G2dO&-pQWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&-uQWO1G2fO&-}QWO1G2eO&.qQ7[O,5?YOOQ07b-E<m-E<mO&/dQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/nQWO1G/_OOQ07b7+'p7+'pO&/sQ7[O7+'wO&0TQ08SO<<KTOOQ07b<<KT<<KTO&0wQWO1G0vO!&dQ7[O'#IsO&0|QWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1UQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&1xQWO,5?eO&1}QWO,5?eOOQO-E<w-E<wO&2]QWO1G6bO&2]QWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2eQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2uQ08QO<<LROOQU<<LS<<LSO%3PQpO<<LSO&2jQ`O'#IuO&2uQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&2}Q^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3XQ`O,5=oOOQU,5=o,5=oO&3`Q`O'#EcO&3tQWO7+(tO&3yQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4RQWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$!UQWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4^QWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4iQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4qQWO7++}O&4vQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&4{QWO7+)OO&5QQ^O7+)OO&5XQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5^QWO,5>YOOQU,5>[,5>[O&5cQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5hQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=gQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&5rQ07hO<<IoO&5}Q08SO<= SO&6_QWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6gQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0iQrOANAeO%[Q^OANAeO&6oQ08SO7+'uO&9QQ08SO,5?YO&;]Q08SO,5?[O&=hQ08SO7+'wO&?yQrO1G4fO&@TQ(CYO7+&]O&BXQ(CYO,5=RO&D`Q(CYO,5=TO&DpQ(CYO,5=RO&EQQ(CYO,5=TO&EbQ(CYO,59qO&GeQ(CYO,5<fO&IhQ(CYO,5<hO&KkQ(CYO,5<vO&MaQ(CYO7+'hO&MnQ(CYO7+'iO&M{QWO,5<YOOQO7+']7+']O&NQQ7[O<<KwOOQO1G4p1G4pO&NXQWO1G4pO&NdQWO1G4pO&NrQWO7++sO&NrQWO7++sO!&dQ7[O1G4rO&NzQpO1G4rO' UQWO7++tOOQ07`7+(P7+(PO$'TQWO7+(QO' ^QpO7+(QOOQ07`7+(O7+(OO$'TQWO7+(PO' eQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' jQ7[O<<NoOOQ07b7+$y7+$yO' tQpO,5?_OOQO-E<q-E<qO'!OQ08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!`QWO1G5PO'!eQWO7++|O'!eQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!mQWO,5?aOOQO-E<s-E<sO'!xQ(CYO1G6_O'%YQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&2}Q^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&3tQWO<<L`O'%dQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$!UQWO<<LbO9UQWO<<LbO'%lQ`O1G5OO'%wQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&PQWO<= iO'&UQWO<= jOOQU<<Lj<<LjO'&ZQWO<<LjO'&`Q^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&gQWO<<I|O'&rQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=gQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO'&|QWOG27PO%0iQrOG27PO''UQ(CYO<<JdO''cQ(CYO1G2ZO')XQ(CYO,5?YO'+[Q(CYO,5?[O'-_Q(CYO1G2mO'/bQ(CYO1G2oO'1eQ(CYO<<KTO'1rQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2PQWO7+*[O'2[QWO<= _O'2dQpO7+*^OOQ07`<<Kl<<KlO$'TQWO<<KlOOQ07`<<Kk<<KkO'2nQpO<<KlO$'TQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'2uQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'2}QWO7++yO&3tQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3VQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$!UQWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3_QWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=gQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3dQWOLD,kO'3lQ(CYO7+'uO'5bQ(CYO,5?YO'7eQ(CYO,5?[O'9hQ(CYO7+'wO';^Q7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'TQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';nQ(CYO7+*gOOQUG27fG27fO&3tQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO';xQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<SQ08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&3tQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>eQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@ZQrO'#JiO!*fQ^O'#DqO'@bQ^O'#D}O'@iQrO'#ChO'CPQrO'#ChO!*fQ^O'#EPO'CaQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EdQWO,5<eO'ElQ7[O,5;aO'GVQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ElQ7[O'#GgO!&dQ7[O'#GiO'ElQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ElQ7[O'#FzO!&dQ7[O'#F|O'ElQ7[O'#F|O!&dQ7[O'#G[O'ElQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CaQ^O1G0qO'G^Q(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O,5<oO'ElQ7[O,5<oO'CaQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ElQ7[O1G2ZO!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O1G2]O'ElQ7[O1G2]O'CaQ^O7+'iO'CaQ^O7+&]O!&dQ7[OANAcO'ElQ7[OANAcO'GhQWO'#EkO'GmQWO'#EkO'GuQWO'#FZO'GzQWO'#EuO'HPQWO'#JyO'H[QWO'#JwO'HgQWO,5;VO'HlQ7[O,5<bO'HsQWO'#GTO'HxQWO'#GTO'H}QWO,5<cO'IVQWO,5;VO'I_Q(CYO1G1^O'IfQWO,5<oO'IkQWO,5<oO'IpQWO,5<qO'IuQWO,5<qO'IzQWO1G1}O'JPQWO1G0qO'JUQ7[O<<KwO'J]Q7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*sQpO1G2qO%*sQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Ka~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#v#ii#x#ii#y#ii'r#ii(h#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(o#ii~P#9lO(o#|O~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO(XVO(o#|O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(p#ii~P#<^O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?OOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AiOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#CvO#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#CvO!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#LWO(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#LyO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$dO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%YO|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$%{O#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'jOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*TO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/kO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#CvOo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#LWO#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#LyO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$dO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%YO#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$%{O#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#CvO#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)_O|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*QO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-dO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.VOf(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3hOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#CvO#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#CvO`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)_O#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*QO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-dO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.VOf'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#CvOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FhO#j:lO~P%FhOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HsOn:nO~P%HsOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KOOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KOOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#v#ii#x#ii#y#ii#|#ii(h#ii(p#ii!Y#ii!Z#ii~O(o#ii~P%MjO(o#|O~P%MjOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO(XVO(o#|O#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O(p#ii~P& uO(p#}O~P& uOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$QO`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&&xO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#CvO#|!qi!Z!qi~P$'jO!Z6|O~O!Y']a!Z']a~P#CvO!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.YO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&.{O!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3hOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#CvO`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.YO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&.{O#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#CvO(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@bO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BiOj<gO|)zO!P){O(p%PO~P&@bOj<gO|)zO!P){O(o$}O~P&BiO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&&xO#|$jq!Y$jq!Z$jq~P#CvO#|$kq!Y$kq!Z$kq~P#CvO!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#CvOP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#SO![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#CvO!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#CvOP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&&xO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#CvO#|#_y!Y#_y!Z#_y~P#CvO!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&&xO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&&xOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#CvO!Y#d!Z!Z#d!Z~P#CvO#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&&xOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#SOP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'@vOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ElO!Z[X!ZeX~P'@vO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#CvO#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AuPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!f$Uc#X%n'|(S(n(u)U)V)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:r)Z)l-O.t2W2Z3_3g3h3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!b$Wc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:t)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "\u26A0 ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: Gnt,
  nodeProps: [
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [ert],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [Knt, Jnt, trt, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, Hnt, new am("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new am("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14602 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (e) => nrt[e] || -1 }, { term: 334, get: (e) => rrt[e] || -1 }, { term: 70, get: (e) => irt[e] || -1 }],
  tokenPrec: 14626
}), JM = [
  /* @__PURE__ */ Ur("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], ort = /* @__PURE__ */ JM.concat([
  /* @__PURE__ */ Ur("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Ur("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), WT = /* @__PURE__ */ new BP(), tR = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function of(e) {
  return (t, n) => {
    let r = t.node.getChild("VariableDefinition");
    return r && n(r, e), !0;
  };
}
const art = ["FunctionDeclaration"], lrt = {
  FunctionDeclaration: /* @__PURE__ */ of("function"),
  ClassDeclaration: /* @__PURE__ */ of("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ of("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ of("type"),
  NamespaceDeclaration: /* @__PURE__ */ of("namespace"),
  VariableDefinition(e, t) {
    e.matchContext(art) || t(e, "variable");
  },
  TypeDefinition(e, t) {
    t(e, "type");
  },
  __proto__: null
};
function eR(e, t) {
  let n = WT.get(t);
  if (n)
    return n;
  let r = [], i = !0;
  function s(o, a) {
    let l = e.sliceString(o.from, o.to);
    r.push({ label: l, type: a });
  }
  return t.cursor(tn.IncludeAnonymous).iterate((o) => {
    if (i)
      i = !1;
    else if (o.name) {
      let a = lrt[o.name];
      if (a && a(o, s) || tR.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let a of eR(e, o.node))
        r.push(a);
      return !1;
    }
  }), WT.set(t, r), r;
}
const UT = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, nR = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function crt(e) {
  let t = en(e.state).resolveInner(e.pos, -1);
  if (nR.indexOf(t.name) > -1)
    return null;
  let n = t.name == "VariableName" || t.to - t.from < 20 && UT.test(e.state.sliceDoc(t.from, t.to));
  if (!n && !e.explicit)
    return null;
  let r = [];
  for (let i = t; i; i = i.parent)
    tR.has(i.name) && (r = r.concat(eR(e.state.doc, i)));
  return {
    options: r,
    from: n ? t.from : e.pos,
    validFor: UT
  };
}
const lo = /* @__PURE__ */ Qh.define({
  name: "javascript",
  parser: /* @__PURE__ */ srt.configure({
    props: [
      /* @__PURE__ */ Bp.add({
        IfStatement: /* @__PURE__ */ Q1({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Q1({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: fj,
        SwitchBody: (e) => {
          let t = e.textAfter, n = /^\s*\}/.test(t), r = /^\s*(case|default)\b/.test(t);
          return e.baseIndent + (n ? 0 : r ? 1 : 2) * e.unit;
        },
        Block: /* @__PURE__ */ uj({ closing: "}" }),
        ArrowFunction: (e) => e.baseIndent + e.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Q1({ except: /^{/ }),
        JSXElement(e) {
          let t = /^\s*<\//.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        JSXEscape(e) {
          let t = /\s*\}/.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        }
      }),
      /* @__PURE__ */ Eu.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": WP,
        BlockComment(e) {
          return { from: e.from + 2, to: e.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), rR = {
  test: (e) => /^JSX/.test(e.name),
  facet: /* @__PURE__ */ gw({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, iR = /* @__PURE__ */ lo.configure({ dialect: "ts" }, "typescript"), sR = /* @__PURE__ */ lo.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ mw.add((e) => e.isTop ? [rR] : void 0)]
}), oR = /* @__PURE__ */ lo.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ mw.add((e) => e.isTop ? [rR] : void 0)]
}, "typescript");
let aR = (e) => ({ label: e, type: "keyword" });
const lR = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(aR), hrt = /* @__PURE__ */ lR.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(aR));
function urt(e = {}) {
  let t = e.jsx ? e.typescript ? oR : sR : e.typescript ? iR : lo, n = e.typescript ? ort.concat(hrt) : JM.concat(lR);
  return new Cd(t, [
    lo.data.of({
      autocomplete: wG(nR, HD(n))
    }),
    lo.data.of({
      autocomplete: crt
    }),
    e.jsx ? prt : []
  ]);
}
function frt(e) {
  for (; ; ) {
    if (e.name == "JSXOpenTag" || e.name == "JSXSelfClosingTag" || e.name == "JSXFragmentTag")
      return e;
    if (e.name == "JSXEscape" || !e.parent)
      return null;
    e = e.parent;
  }
}
function jT(e, t, n = e.length) {
  for (let r = t == null ? void 0 : t.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return e.sliceString(r.from, Math.min(r.to, n));
  return "";
}
const drt = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), prt = /* @__PURE__ */ Pt.inputHandler.of((e, t, n, r, i) => {
  if ((drt ? e.composing : e.compositionStarted) || e.state.readOnly || t != n || r != ">" && r != "/" || !lo.isActiveAt(e.state, t, -1))
    return !1;
  let s = i(), { state: o } = s, a = o.changeByRange((l) => {
    var h;
    let { head: u } = l, f = en(o).resolveInner(u - 1, -1), d;
    if (f.name == "JSXStartTag" && (f = f.parent), !(o.doc.sliceString(u - 1, u) != r || f.name == "JSXAttributeValue" && f.to > u)) {
      if (r == ">" && f.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (r == "/" && f.name == "JSXStartCloseTag") {
        let p = f.parent, g = p.parent;
        if (g && p.from == u - 2 && ((d = jT(o.doc, g.firstChild, u)) || ((h = g.firstChild) === null || h === void 0 ? void 0 : h.name) == "JSXFragmentTag")) {
          let m = `${d}>`;
          return { range: mt.cursor(u + m.length, -1), changes: { from: u, insert: m } };
        }
      } else if (r == ">") {
        let p = frt(f);
        if (p && !/^\/?>|^<\//.test(o.doc.sliceString(u, u + 2)) && (d = jT(o.doc, p, u)))
          return { range: l, changes: { from: u, insert: `</${d}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (e.dispatch([
    s,
    o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), af = ["_blank", "_self", "_top", "_parent"], iO = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], sO = ["get", "post", "put", "delete"], oO = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], ci = ["true", "false"], jt = {}, grt = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: af,
      hreflang: null
    }
  },
  abbr: jt,
  address: jt,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: jt,
  aside: jt,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: jt,
  base: { attrs: { href: null, target: af } },
  bdi: jt,
  bdo: jt,
  blockquote: { attrs: { cite: null } },
  body: jt,
  br: jt,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: oO,
      formmethod: sO,
      formnovalidate: ["novalidate"],
      formtarget: af,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: jt,
  center: jt,
  cite: jt,
  code: jt,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: jt,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: jt,
  div: jt,
  dl: jt,
  dt: jt,
  em: jt,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: jt,
  figure: jt,
  footer: jt,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": iO,
      autocomplete: ["on", "off"],
      enctype: oO,
      method: sO,
      novalidate: ["novalidate"],
      target: af
    }
  },
  h1: jt,
  h2: jt,
  h3: jt,
  h4: jt,
  h5: jt,
  h6: jt,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: jt,
  hgroup: jt,
  hr: jt,
  html: {
    attrs: { manifest: null }
  },
  i: jt,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: oO,
      formmethod: sO,
      formnovalidate: ["novalidate"],
      formtarget: af,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: jt,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: jt,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: jt,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: iO,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: jt,
  noscript: jt,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: jt,
  param: { attrs: { name: null, value: null } },
  pre: jt,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: jt,
  rt: jt,
  ruby: jt,
  samp: jt,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: iO
    }
  },
  section: jt,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: jt,
  source: { attrs: { src: null, type: null, media: null } },
  span: jt,
  strong: jt,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: jt,
  summary: jt,
  sup: jt,
  table: jt,
  tbody: jt,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: jt,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: jt,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: jt,
  time: { attrs: { datetime: null } },
  title: jt,
  tr: jt,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: jt,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: jt
}, cR = {
  accesskey: null,
  class: null,
  contenteditable: ci,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: ci,
  autocorrect: ci,
  autocapitalize: ci,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": ci,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": ci,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": ci,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": ci,
  "aria-hidden": ci,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": ci,
  "aria-multiselectable": ci,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": ci,
  "aria-relevant": null,
  "aria-required": ci,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, hR = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((e) => "on" + e);
for (let e of hR)
  cR[e] = null;
class qd {
  constructor(t, n) {
    this.tags = Object.assign(Object.assign({}, grt), t), this.globalAttrs = Object.assign(Object.assign({}, cR), n), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
qd.default = /* @__PURE__ */ new qd();
function Hh(e, t, n = e.length) {
  if (!t)
    return "";
  let r = t.firstChild, i = r && r.getChild("TagName");
  return i ? e.sliceString(i.from, Math.min(i.to, n)) : "";
}
function Kh(e, t = !1) {
  for (; e; e = e.parent)
    if (e.name == "Element")
      if (t)
        t = !1;
      else
        return e;
  return null;
}
function uR(e, t, n) {
  let r = n.tags[Hh(e, Kh(t))];
  return (r == null ? void 0 : r.children) || n.allTags;
}
function l3(e, t) {
  let n = [];
  for (let r = Kh(t); r && !r.type.isTop; r = Kh(r.parent)) {
    let i = Hh(e, r);
    if (i && r.lastChild.name == "CloseTag")
      break;
    i && n.indexOf(i) < 0 && (t.name == "EndTag" || t.from >= r.firstChild.to) && n.push(i);
  }
  return n;
}
const fR = /^[:\-\.\w\u00b7-\uffff]*$/;
function XT(e, t, n, r, i) {
  let s = /\s*>/.test(e.sliceDoc(i, i + 5)) ? "" : ">", o = Kh(n, !0);
  return {
    from: r,
    to: i,
    options: uR(e.doc, o, t).map((a) => ({ label: a, type: "type" })).concat(l3(e.doc, n).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + s,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function GT(e, t, n, r) {
  let i = /\s*>/.test(e.sliceDoc(r, r + 5)) ? "" : ">";
  return {
    from: n,
    to: r,
    options: l3(e.doc, t).map((s, o) => ({ label: s, apply: s + i, type: "type", boost: 99 - o })),
    validFor: fR
  };
}
function mrt(e, t, n, r) {
  let i = [], s = 0;
  for (let o of uR(e.doc, n, t))
    i.push({ label: "<" + o, type: "type" });
  for (let o of l3(e.doc, n))
    i.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
  return { from: r, to: r, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function yrt(e, t, n, r, i) {
  let s = Kh(n), o = s ? t.tags[Hh(e.doc, s)] : null, a = o && o.attrs ? Object.keys(o.attrs) : [], l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(t.globalAttrNames) : t.globalAttrNames;
  return {
    from: r,
    to: i,
    options: l.map((h) => ({ label: h, type: "property" })),
    validFor: fR
  };
}
function brt(e, t, n, r, i) {
  var s;
  let o = (s = n.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), a = [], l;
  if (o) {
    let h = e.sliceDoc(o.from, o.to), u = t.globalAttrs[h];
    if (!u) {
      let f = Kh(n), d = f ? t.tags[Hh(e.doc, f)] : null;
      u = (d == null ? void 0 : d.attrs) && d.attrs[h];
    }
    if (u) {
      let f = e.sliceDoc(r, i).toLowerCase(), d = '"', p = '"';
      /^['"]/.test(f) ? (l = f[0] == '"' ? /^[^"]*$/ : /^[^']*$/, d = "", p = e.sliceDoc(i, i + 1) == f[0] ? "" : f[0], f = f.slice(1), r++) : l = /^[^\s<>='"]*$/;
      for (let g of u)
        a.push({ label: g, apply: d + g + p, type: "constant" });
    }
  }
  return { from: r, to: i, options: a, validFor: l };
}
function dR(e, t) {
  let { state: n, pos: r } = t, i = en(n).resolveInner(r, -1), s = i.resolve(r);
  for (let o = r, a; s == i && (a = i.childBefore(o)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    s = i = a, o = l.from;
  }
  return i.name == "TagName" ? i.parent && /CloseTag$/.test(i.parent.name) ? GT(n, i, i.from, r) : XT(n, e, i, i.from, r) : i.name == "StartTag" ? XT(n, e, i, r, r) : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag" ? GT(n, i, r, r) : t.explicit && (i.name == "OpenTag" || i.name == "SelfClosingTag") || i.name == "AttributeName" ? yrt(n, e, i, i.name == "AttributeName" ? i.from : r, r) : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue" ? brt(n, e, i, i.name == "Is" ? r : i.from, r) : t.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? mrt(n, e, i, r) : null;
}
function Ort(e) {
  return dR(qd.default, e);
}
function xrt(e) {
  let { extraTags: t, extraGlobalAttributes: n } = e, r = n || t ? new qd(t, n) : qd.default;
  return (i) => dR(r, i);
}
const vrt = /* @__PURE__ */ lo.parser.configure({ top: "SingleExpression" }), pR = [
  {
    tag: "script",
    attrs: (e) => e.type == "text/typescript" || e.lang == "ts",
    parser: iR.parser
  },
  {
    tag: "script",
    attrs: (e) => e.type == "text/babel" || e.type == "text/jsx",
    parser: sR.parser
  },
  {
    tag: "script",
    attrs: (e) => e.type == "text/typescript-jsx",
    parser: oR.parser
  },
  {
    tag: "script",
    attrs(e) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(e.type);
    },
    parser: vrt
  },
  {
    tag: "script",
    attrs(e) {
      return !e.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(e.type);
    },
    parser: lo.parser
  },
  {
    tag: "style",
    attrs(e) {
      return (!e.lang || e.lang == "css") && (!e.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(e.type));
    },
    parser: um.parser
  }
], gR = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ um.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ hR.map((e) => ({ name: e, parser: lo.parser }))), mR = /* @__PURE__ */ Qh.define({
  name: "html",
  parser: /* @__PURE__ */ snt.configure({
    props: [
      /* @__PURE__ */ Bp.add({
        Element(e) {
          let t = /^(\s*)(<\/)?/.exec(e.textAfter);
          return e.node.to <= e.pos + t[0].length ? e.continue() : e.lineIndent(e.node.from) + (t[2] ? 0 : e.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        },
        Document(e) {
          if (e.pos + /\s*/.exec(e.textAfter)[0].length < e.node.to)
            return e.continue();
          let t = null, n;
          for (let r = e.node; ; ) {
            let i = r.lastChild;
            if (!i || i.name != "Element" || i.to != r.to)
              break;
            t = r = i;
          }
          return t && !((n = t.lastChild) && (n.name == "CloseTag" || n.name == "SelfClosingTag")) ? e.lineIndent(t.from) + e.unit : null;
        }
      }),
      /* @__PURE__ */ Eu.add({
        Element(e) {
          let t = e.firstChild, n = e.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: n.name == "CloseTag" ? n.from : e.to };
        }
      }),
      /* @__PURE__ */ sD.add({
        "OpenTag CloseTag": (e) => e.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), j1 = /* @__PURE__ */ mR.configure({
  wrap: /* @__PURE__ */ jM(pR, gR)
});
function _rt(e = {}) {
  let t = "", n;
  e.matchClosingTags === !1 && (t = "noMatch"), e.selfClosingTags === !0 && (t = (t ? t + " " : "") + "selfClosing"), (e.nestedLanguages && e.nestedLanguages.length || e.nestedAttributes && e.nestedAttributes.length) && (n = jM((e.nestedLanguages || []).concat(pR), (e.nestedAttributes || []).concat(gR)));
  let r = n ? mR.configure({ wrap: n, dialect: t }) : t ? j1.configure({ dialect: t }) : j1;
  return new Cd(r, [
    j1.data.of({ autocomplete: xrt(e) }),
    e.autoCloseTags !== !1 ? krt : [],
    urt().support,
    Rnt().support
  ]);
}
const HT = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), krt = /* @__PURE__ */ Pt.inputHandler.of((e, t, n, r, i) => {
  if (e.composing || e.state.readOnly || t != n || r != ">" && r != "/" || !j1.isActiveAt(e.state, t, -1))
    return !1;
  let s = i(), { state: o } = s, a = o.changeByRange((l) => {
    var h, u, f;
    let d = o.doc.sliceString(l.from - 1, l.to) == r, { head: p } = l, g = en(o).resolveInner(p - 1, -1), m;
    if ((g.name == "TagName" || g.name == "StartTag") && (g = g.parent), d && r == ">" && g.name == "OpenTag") {
      if (((u = (h = g.parent) === null || h === void 0 ? void 0 : h.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (m = Hh(o.doc, g.parent, p)) && !HT.has(m)) {
        let y = p + (o.doc.sliceString(p, p + 1) === ">" ? 1 : 0), O = `</${m}>`;
        return { range: l, changes: { from: p, to: y, insert: O } };
      }
    } else if (d && r == "/" && g.name == "IncompleteCloseTag") {
      let y = g.parent;
      if (g.from == p - 2 && ((f = y.lastChild) === null || f === void 0 ? void 0 : f.name) != "CloseTag" && (m = Hh(o.doc, y, p)) && !HT.has(m)) {
        let O = p + (o.doc.sliceString(p, p + 1) === ">" ? 1 : 0), x = `${m}>`;
        return {
          range: mt.cursor(p + x.length, -1),
          changes: { from: p, to: O, insert: x }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (e.dispatch([
    s,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), yR = /* @__PURE__ */ gw({ commentTokens: { block: { open: "<!--", close: "-->" } } }), bR = /* @__PURE__ */ new _e(), OR = /* @__PURE__ */ Ktt.configure({
  props: [
    /* @__PURE__ */ Eu.add((e) => !e.is("Block") || e.is("Document") || i_(e) != null ? void 0 : (t, n) => ({ from: n.doc.lineAt(t.from).to, to: t.to })),
    /* @__PURE__ */ bR.add(i_),
    /* @__PURE__ */ Bp.add({
      Document: () => null
    }),
    /* @__PURE__ */ Ql.add({
      Document: yR
    })
  ]
});
function i_(e) {
  let t = /^(?:ATX|Setext)Heading(\d)$/.exec(e.name);
  return t ? +t[1] : void 0;
}
function wrt(e, t) {
  let n = e;
  for (; ; ) {
    let r = n.nextSibling, i;
    if (!r || (i = i_(r.type)) != null && i <= t)
      break;
    n = r;
  }
  return n.to;
}
const Srt = /* @__PURE__ */ qP.of((e, t, n) => {
  for (let r = en(e).resolveInner(n, -1); r && !(r.from < t); r = r.parent) {
    let i = r.type.prop(bR);
    if (i == null)
      continue;
    let s = wrt(r, i);
    if (s > n)
      return { from: n, to: s };
  }
  return null;
});
function c3(e) {
  return new Ni(yR, e, [Srt], "markdown");
}
const Crt = /* @__PURE__ */ c3(OR), Trt = /* @__PURE__ */ OR.configure([het, fet, uet, det, {
  props: [
    /* @__PURE__ */ Eu.add({
      Table: (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to })
    })
  ]
}]), xR = /* @__PURE__ */ c3(Trt);
function Ert(e, t) {
  return (n) => {
    if (n && e) {
      let r = null;
      if (n = /\S*/.exec(n)[0], typeof e == "function" ? r = e(n) : r = Ig.matchLanguageName(e, n, !0), r instanceof Ig)
        return r.support ? r.support.language.parser : Sd.getSkippingParser(r.load());
      if (r)
        return r.parser;
    }
    return t ? t.parser : null;
  };
}
class j0 {
  constructor(t, n, r, i, s, o, a) {
    this.node = t, this.from = n, this.to = r, this.spaceBefore = i, this.spaceAfter = s, this.type = o, this.item = a;
  }
  blank(t, n = !0) {
    let r = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (t != null) {
      for (; r.length < t; )
        r += " ";
      return r;
    } else {
      for (let i = this.to - this.from - r.length - this.spaceAfter.length; i > 0; i--)
        r += " ";
      return r + (n ? this.spaceAfter : "");
    }
  }
  marker(t, n) {
    let r = this.node.name == "OrderedList" ? String(+_R(this.item, t)[2] + n) : "";
    return this.spaceBefore + r + this.type + this.spaceAfter;
  }
}
function vR(e, t) {
  let n = [];
  for (let i = e; i && i.name != "Document"; i = i.parent)
    (i.name == "ListItem" || i.name == "Blockquote" || i.name == "FencedCode") && n.push(i);
  let r = [];
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i], o, a = t.lineAt(s.from), l = s.from - a.from;
    if (s.name == "FencedCode")
      r.push(new j0(s, l, l, "", "", "", null));
    else if (s.name == "Blockquote" && (o = /^ *>( ?)/.exec(a.text.slice(l))))
      r.push(new j0(s, l, l + o[0].length, "", o[1], ">", null));
    else if (s.name == "ListItem" && s.parent.name == "OrderedList" && (o = /^( *)\d+([.)])( *)/.exec(a.text.slice(l)))) {
      let h = o[3], u = o[0].length;
      h.length >= 4 && (h = h.slice(0, h.length - 4), u -= 4), r.push(new j0(s.parent, l, l + u, o[1], h, o[2], s));
    } else if (s.name == "ListItem" && s.parent.name == "BulletList" && (o = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(a.text.slice(l)))) {
      let h = o[4], u = o[0].length;
      h.length > 4 && (h = h.slice(0, h.length - 4), u -= 4);
      let f = o[2];
      o[3] && (f += o[3].replace(/[xX]/, " ")), r.push(new j0(s.parent, l, l + u, o[1], h, f, s));
    }
  }
  return r;
}
function _R(e, t) {
  return /^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(e.from, e.from + 10));
}
function aO(e, t, n, r = 0) {
  for (let i = -1, s = e; ; ) {
    if (s.name == "ListItem") {
      let a = _R(s, t), l = +a[2];
      if (i >= 0) {
        if (l != i + 1)
          return;
        n.push({ from: s.from + a[1].length, to: s.from + a[0].length, insert: String(i + 2 + r) });
      }
      i = l;
    }
    let o = s.nextSibling;
    if (!o)
      break;
    s = o;
  }
}
function s_(e, t) {
  let n = /^[ \t]*/.exec(e)[0].length;
  if (!n || t.facet(Np) != "	")
    return e;
  let r = Os(e, 4, n), i = "";
  for (let s = r; s > 0; )
    s >= 4 ? (i += "	", s -= 4) : (i += " ", s--);
  return i + e.slice(n);
}
const Art = ({ state: e, dispatch: t }) => {
  let n = en(e), { doc: r } = e, i = null, s = e.changeByRange((o) => {
    if (!o.empty || !xR.isActiveAt(e, o.from))
      return i = { range: o };
    let a = o.from, l = r.lineAt(a), h = vR(n.resolveInner(a, -1), r);
    for (; h.length && h[h.length - 1].from > a - l.from; )
      h.pop();
    if (!h.length)
      return i = { range: o };
    let u = h[h.length - 1];
    if (u.to - u.spaceAfter.length > a - l.from)
      return i = { range: o };
    let f = a >= u.to - u.spaceAfter.length && !/\S/.test(l.text.slice(u.to));
    if (u.item && f)
      if (u.node.firstChild.to >= a || l.from > 0 && !/[^\s>]/.test(r.lineAt(l.from - 1).text)) {
        let y = h.length > 1 ? h[h.length - 2] : null, O, x = "";
        y && y.item ? (O = l.from + y.from, x = y.marker(r, 1)) : O = l.from + (y ? y.to : 0);
        let _ = [{ from: O, to: a, insert: x }];
        return u.node.name == "OrderedList" && aO(u.item, r, _, -2), y && y.node.name == "OrderedList" && aO(y.item, r, _), { range: mt.cursor(O + x.length), changes: _ };
      } else {
        let y = "";
        for (let O = 0, x = h.length - 2; O <= x; O++)
          y += h[O].blank(O < x ? Os(l.text, 4, h[O + 1].from) - y.length : null, O < x);
        return y = s_(y, e), {
          range: mt.cursor(a + y.length + 1),
          changes: { from: l.from, insert: y + e.lineBreak }
        };
      }
    if (u.node.name == "Blockquote" && f && l.from) {
      let y = r.lineAt(l.from - 1), O = />\s*$/.exec(y.text);
      if (O && O.index == u.from) {
        let x = e.changes([
          { from: y.from + O.index, to: y.to },
          { from: l.from + u.from, to: l.to }
        ]);
        return { range: o.map(x), changes: x };
      }
    }
    let d = [];
    u.node.name == "OrderedList" && aO(u.item, r, d);
    let p = u.item && u.item.from < l.from, g = "";
    if (!p || /^[\s\d.)\-+*>]*/.exec(l.text)[0].length >= u.to)
      for (let y = 0, O = h.length - 1; y <= O; y++)
        g += y == O && !p ? h[y].marker(r, 1) : h[y].blank(y < O ? Os(l.text, 4, h[y + 1].from) - g.length : null);
    let m = a;
    for (; m > l.from && /\s/.test(l.text.charAt(m - l.from - 1)); )
      m--;
    return g = s_(g, e), d.push({ from: m, to: a, insert: e.lineBreak + g }), { range: mt.cursor(m + g.length + 1), changes: d };
  });
  return i ? !1 : (t(e.update(s, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function KT(e) {
  return e.name == "QuoteMark" || e.name == "ListMark";
}
function Prt(e, t) {
  let n = e.resolveInner(t, -1), r = t;
  KT(n) && (r = n.from, n = n.parent);
  for (let i; i = n.childBefore(r); )
    if (KT(i))
      r = i.from;
    else if (i.name == "OrderedList" || i.name == "BulletList")
      n = i.lastChild, r = n.to;
    else
      break;
  return n;
}
const Drt = ({ state: e, dispatch: t }) => {
  let n = en(e), r = null, i = e.changeByRange((s) => {
    let o = s.from, { doc: a } = e;
    if (s.empty && xR.isActiveAt(e, s.from)) {
      let l = a.lineAt(o), h = vR(Prt(n, o), a);
      if (h.length) {
        let u = h[h.length - 1], f = u.to - u.spaceAfter.length + (u.spaceAfter ? 1 : 0);
        if (o - l.from > f && !/\S/.test(l.text.slice(f, o - l.from)))
          return {
            range: mt.cursor(l.from + f),
            changes: { from: l.from + f, to: o }
          };
        if (o - l.from == f && (!u.item || l.from <= u.item.from || !/\S/.test(l.text.slice(0, u.to)))) {
          let d = l.from + u.from;
          if (u.item && u.node.from < u.item.from && /\S/.test(l.text.slice(u.from, u.to))) {
            let p = u.blank(Os(l.text, 4, u.to) - Os(l.text, 4, u.from));
            return d == l.from && (p = s_(p, e)), {
              range: mt.cursor(d + p.length),
              changes: { from: d, to: l.from + u.to, insert: p }
            };
          }
          if (d < o)
            return { range: mt.cursor(d), changes: { from: d, to: o } };
        }
      }
    }
    return r = { range: s };
  });
  return r ? !1 : (t(e.update(i, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, Lrt = [
  { key: "Enter", run: Art },
  { key: "Backspace", run: Drt }
], o_ = /* @__PURE__ */ _rt({ matchClosingTags: !1 });
function Mrt(e = {}) {
  let { codeLanguages: t, defaultCodeLanguage: n, addKeymap: r = !0, base: { parser: i } = Crt, completeHTMLTags: s = !0 } = e;
  if (!(i instanceof sy))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let o = e.extensions ? [e.extensions] : [], a = [o_.support], l;
  n instanceof Cd ? (a.push(n.support), l = n.language) : n && (l = n);
  let h = t || l ? Ert(t, l) : void 0;
  o.push(tet({ codeParser: h, htmlParser: o_.language.parser })), r && a.push(Ts.high(Ko.of(Lrt)));
  let u = c3(i.configure(o));
  return s && a.push(u.data.of({ autocomplete: Rrt })), new Cd(u, a);
}
function Rrt(e) {
  let { state: t, pos: n } = e, r = /<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(n - 25, n));
  if (!r)
    return null;
  let i = en(t).resolveInner(n, -1);
  for (; i && !i.type.isTop; ) {
    if (i.name == "CodeBlock" || i.name == "FencedCode" || i.name == "ProcessingInstructionBlock" || i.name == "CommentBlock" || i.name == "Link" || i.name == "Image")
      return null;
    i = i.parent;
  }
  return {
    from: n - r[0].length,
    to: n,
    options: $rt(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
let lO = null;
function $rt() {
  if (lO)
    return lO;
  let e = Ort(new Ew(De.create({ extensions: o_ }), 0, !0));
  return lO = e ? e.options : [];
}
function Irt(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var kR = { exports: {} };
const Nrt = {}, Brt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Nrt
}, Symbol.toStringTag, { value: "Module" })), Frt = /* @__PURE__ */ F7(Brt);
(function(e) {
  var t;
  (function() {
    t = function(n, r, i, s) {
      s = s || {}, this.dictionary = null, this.rules = {}, this.dictionaryTable = {}, this.compoundRules = [], this.compoundRuleCodes = {}, this.replacementTable = [], this.flags = s.flags || {}, this.memoized = {}, this.loaded = !1;
      var o = this, a, l, h, u, f;
      n && (o.dictionary = n, r && i ? m() : typeof window < "u" && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension ? (s.dictionaryPath ? a = s.dictionaryPath : a = "typo/dictionaries", r || d(chrome.extension.getURL(a + "/" + n + "/" + n + ".aff"), p), i || d(chrome.extension.getURL(a + "/" + n + "/" + n + ".dic"), g)) : (s.dictionaryPath ? a = s.dictionaryPath : typeof __dirname < "u" ? a = __dirname + "/dictionaries" : a = "./dictionaries", r || d(a + "/" + n + "/" + n + ".aff", p), i || d(a + "/" + n + "/" + n + ".dic", g)));
      function d(y, O) {
        var x = o._readFile(y, null, s.asyncLoad);
        s.asyncLoad ? x.then(function(_) {
          O(_);
        }) : O(x);
      }
      function p(y) {
        r = y, i && m();
      }
      function g(y) {
        i = y, r && m();
      }
      function m() {
        for (o.rules = o._parseAFF(r), o.compoundRuleCodes = {}, l = 0, u = o.compoundRules.length; l < u; l++) {
          var y = o.compoundRules[l];
          for (h = 0, f = y.length; h < f; h++)
            o.compoundRuleCodes[y[h]] = [];
        }
        "ONLYINCOMPOUND" in o.flags && (o.compoundRuleCodes[o.flags.ONLYINCOMPOUND] = []), o.dictionaryTable = o._parseDIC(i);
        for (l in o.compoundRuleCodes)
          o.compoundRuleCodes[l].length === 0 && delete o.compoundRuleCodes[l];
        for (l = 0, u = o.compoundRules.length; l < u; l++) {
          var O = o.compoundRules[l], x = "";
          for (h = 0, f = O.length; h < f; h++) {
            var _ = O[h];
            _ in o.compoundRuleCodes ? x += "(" + o.compoundRuleCodes[_].join("|") + ")" : x += _;
          }
          o.compoundRules[l] = new RegExp(x, "i");
        }
        o.loaded = !0, s.asyncLoad && s.loadedCallback && s.loadedCallback(o);
      }
      return this;
    }, t.prototype = {
      load: function(n) {
        for (var r in n)
          n.hasOwnProperty(r) && (this[r] = n[r]);
        return this;
      },
      _readFile: function(n, r, i) {
        if (r = r || "utf8", typeof XMLHttpRequest < "u") {
          var s, o = new XMLHttpRequest();
          return o.open("GET", n, i), i && (s = new Promise(function(l, h) {
            o.onload = function() {
              o.status === 200 ? l(o.responseText) : h(o.statusText);
            }, o.onerror = function() {
              h(o.statusText);
            };
          })), o.overrideMimeType && o.overrideMimeType("text/plain; charset=" + r), o.send(null), i ? s : o.responseText;
        } else if (typeof Irt < "u") {
          var a = Frt;
          try {
            if (a.existsSync(n))
              return a.readFileSync(n, r);
            console.log("Path " + n + " does not exist.");
          } catch (l) {
            return console.log(l), "";
          }
        }
      },
      _parseAFF: function(n) {
        var r = {}, i, s, o, a, l, h, u, f, d = n.split(/\r?\n/);
        for (l = 0, u = d.length; l < u; l++)
          if (i = this._removeAffixComments(d[l]), i = i.trim(), !!i) {
            var p = i.split(/\s+/), g = p[0];
            if (g == "PFX" || g == "SFX") {
              var m = p[1], y = p[2];
              o = parseInt(p[3], 10);
              var O = [];
              for (h = l + 1, f = l + 1 + o; h < f; h++) {
                s = d[h], a = s.split(/\s+/);
                var x = a[2], _ = a[3].split("/"), w = _[0];
                w === "0" && (w = "");
                var E = this.parseRuleCodes(_[1]), T = a[4], S = {};
                S.add = w, E.length > 0 && (S.continuationClasses = E), T !== "." && (g === "SFX" ? S.match = new RegExp(T + "$") : S.match = new RegExp("^" + T)), x != "0" && (g === "SFX" ? S.remove = new RegExp(x + "$") : S.remove = x), O.push(S);
              }
              r[m] = { type: g, combineable: y == "Y", entries: O }, l += o;
            } else if (g === "COMPOUNDRULE") {
              for (o = parseInt(p[1], 10), h = l + 1, f = l + 1 + o; h < f; h++)
                i = d[h], a = i.split(/\s+/), this.compoundRules.push(a[1]);
              l += o;
            } else
              g === "REP" ? (a = i.split(/\s+/), a.length === 3 && this.replacementTable.push([a[1], a[2]])) : this.flags[g] = p[1];
          }
        return r;
      },
      _removeAffixComments: function(n) {
        return n.match(/^\s*#/, "") ? "" : n;
      },
      _parseDIC: function(n) {
        n = this._removeDicComments(n);
        var r = n.split(/\r?\n/), i = {};
        function s(C, k) {
          i.hasOwnProperty(C) || (i[C] = null), k.length > 0 && (i[C] === null && (i[C] = []), i[C].push(k));
        }
        for (var o = 1, a = r.length; o < a; o++) {
          var l = r[o];
          if (!!l) {
            var h = l.split("/", 2), u = h[0];
            if (h.length > 1) {
              var f = this.parseRuleCodes(h[1]);
              (!("NEEDAFFIX" in this.flags) || f.indexOf(this.flags.NEEDAFFIX) == -1) && s(u, f);
              for (var d = 0, p = f.length; d < p; d++) {
                var g = f[d], m = this.rules[g];
                if (m)
                  for (var y = this._applyRule(u, m), O = 0, x = y.length; O < x; O++) {
                    var _ = y[O];
                    if (s(_, []), m.combineable)
                      for (var w = d + 1; w < p; w++) {
                        var E = f[w], T = this.rules[E];
                        if (T && T.combineable && m.type != T.type)
                          for (var S = this._applyRule(_, T), R = 0, A = S.length; R < A; R++) {
                            var P = S[R];
                            s(P, []);
                          }
                      }
                  }
                g in this.compoundRuleCodes && this.compoundRuleCodes[g].push(u);
              }
            } else
              s(u.trim(), []);
          }
        }
        return i;
      },
      _removeDicComments: function(n) {
        return n = n.replace(/^\t.*$/mg, ""), n;
      },
      parseRuleCodes: function(n) {
        if (n)
          if ("FLAG" in this.flags)
            if (this.flags.FLAG === "long") {
              for (var r = [], i = 0, s = n.length; i < s; i += 2)
                r.push(n.substr(i, 2));
              return r;
            } else
              return this.flags.FLAG === "num" ? n.split(",") : this.flags.FLAG === "UTF-8" ? Array.from(n) : n.split("");
          else
            return n.split("");
        else
          return [];
      },
      _applyRule: function(n, r) {
        for (var i = r.entries, s = [], o = 0, a = i.length; o < a; o++) {
          var l = i[o];
          if (!l.match || n.match(l.match)) {
            var h = n;
            if (l.remove && (h = h.replace(l.remove, "")), r.type === "SFX" ? h = h + l.add : h = l.add + h, s.push(h), "continuationClasses" in l)
              for (var u = 0, f = l.continuationClasses.length; u < f; u++) {
                var d = this.rules[l.continuationClasses[u]];
                d && (s = s.concat(this._applyRule(h, d)));
              }
          }
        }
        return s;
      },
      check: function(n) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        var r = n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        if (this.checkExact(r))
          return !0;
        if (r.toUpperCase() === r) {
          var i = r[0] + r.substring(1).toLowerCase();
          if (this.hasFlag(i, "KEEPCASE"))
            return !1;
          if (this.checkExact(i) || this.checkExact(r.toLowerCase()))
            return !0;
        }
        var s = r[0].toLowerCase() + r.substring(1);
        if (s !== r) {
          if (this.hasFlag(s, "KEEPCASE"))
            return !1;
          if (this.checkExact(s))
            return !0;
        }
        return !1;
      },
      checkExact: function(n) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        var r = this.dictionaryTable[n], i, s;
        if (typeof r > "u") {
          if ("COMPOUNDMIN" in this.flags && n.length >= this.flags.COMPOUNDMIN) {
            for (i = 0, s = this.compoundRules.length; i < s; i++)
              if (n.match(this.compoundRules[i]))
                return !0;
          }
        } else {
          if (r === null)
            return !0;
          if (typeof r == "object") {
            for (i = 0, s = r.length; i < s; i++)
              if (!this.hasFlag(n, "ONLYINCOMPOUND", r[i]))
                return !0;
          }
        }
        return !1;
      },
      hasFlag: function(n, r, i) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        return !!(r in this.flags && (typeof i > "u" && (i = Array.prototype.concat.apply([], this.dictionaryTable[n])), i && i.indexOf(this.flags[r]) !== -1));
      },
      alphabet: "",
      suggest: function(n, r) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        if (r = r || 5, this.memoized.hasOwnProperty(n)) {
          var i = this.memoized[n].limit;
          if (r <= i || this.memoized[n].suggestions.length < i)
            return this.memoized[n].suggestions.slice(0, r);
        }
        if (this.check(n))
          return [];
        for (var s = 0, o = this.replacementTable.length; s < o; s++) {
          var a = this.replacementTable[s];
          if (n.indexOf(a[0]) !== -1) {
            var l = n.replace(a[0], a[1]);
            if (this.check(l))
              return [l];
          }
        }
        if (!this.alphabet) {
          this.alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "TRY" in this.flags && (this.alphabet += this.flags.TRY), "WORDCHARS" in this.flags && (this.alphabet += this.flags.WORDCHARS);
          var h = this.alphabet.split("");
          h.sort();
          for (var u = {}, s = 0; s < h.length; s++)
            u[h[s]] = !0;
          this.alphabet = "";
          for (var s in u)
            this.alphabet += s;
        }
        var f = this;
        function d(g, m) {
          var y = {}, O, x, _, w, E = f.alphabet.length;
          if (typeof g == "string") {
            var T = g;
            g = {}, g[T] = !0;
          }
          for (var T in g)
            for (O = 0, _ = T.length + 1; O < _; O++) {
              var S = [T.substring(0, O), T.substring(O)];
              if (S[1] && (w = S[0] + S[1].substring(1), (!m || f.check(w)) && (w in y ? y[w] += 1 : y[w] = 1)), S[1].length > 1 && S[1][1] !== S[1][0] && (w = S[0] + S[1][1] + S[1][0] + S[1].substring(2), (!m || f.check(w)) && (w in y ? y[w] += 1 : y[w] = 1)), S[1]) {
                var R = S[1].substring(0, 1).toUpperCase() === S[1].substring(0, 1) ? "uppercase" : "lowercase";
                for (x = 0; x < E; x++) {
                  var A = f.alphabet[x];
                  R === "uppercase" && (A = A.toUpperCase()), A != S[1].substring(0, 1) && (w = S[0] + A + S[1].substring(1), (!m || f.check(w)) && (w in y ? y[w] += 1 : y[w] = 1));
                }
              }
              if (S[1])
                for (x = 0; x < E; x++) {
                  var R = S[0].substring(-1).toUpperCase() === S[0].substring(-1) && S[1].substring(0, 1).toUpperCase() === S[1].substring(0, 1) ? "uppercase" : "lowercase", A = f.alphabet[x];
                  R === "uppercase" && (A = A.toUpperCase()), w = S[0] + A + S[1], (!m || f.check(w)) && (w in y ? y[w] += 1 : y[w] = 1);
                }
            }
          return y;
        }
        function p(g) {
          var m = d(g), y = d(m, !0), O = y;
          for (var x in m)
            !f.check(x) || (x in O ? O[x] += m[x] : O[x] = m[x]);
          var _, w = [];
          for (_ in O)
            O.hasOwnProperty(_) && w.push([_, O[_]]);
          function E(A, P) {
            var C = A[1], k = P[1];
            return C < k ? -1 : C > k ? 1 : P[0].localeCompare(A[0]);
          }
          w.sort(E).reverse();
          var T = [], S = "lowercase";
          g.toUpperCase() === g ? S = "uppercase" : g.substr(0, 1).toUpperCase() + g.substr(1).toLowerCase() === g && (S = "capitalized");
          var R = r;
          for (_ = 0; _ < Math.min(R, w.length); _++)
            S === "uppercase" ? w[_][0] = w[_][0].toUpperCase() : S === "capitalized" && (w[_][0] = w[_][0].substr(0, 1).toUpperCase() + w[_][0].substr(1)), !f.hasFlag(w[_][0], "NOSUGGEST") && T.indexOf(w[_][0]) == -1 ? T.push(w[_][0]) : R++;
          return T;
        }
        return this.memoized[n] = {
          suggestions: p(n),
          limit: r
        }, this.memoized[n].suggestions;
      }
    };
  })(), e.exports = t;
})(kR);
const Qrt = kR.exports, wR = Ft.define({
  combine: (e) => e[e.length - 1]
}), Zrt = Bt.mark({
  class: "cm-error"
}), Vrt = (e) => Object.keys(e.rules).length > 0;
function JT(e) {
  var s, o;
  let t = ((s = e.visibleRanges[0]) == null ? void 0 : s.from) || 0, n = ((o = e.visibleRanges[0]) == null ? void 0 : o.to) || void 0;
  const r = new cr(), i = e.state.facet(wR);
  return Vrt(i) && e.state.doc.sliceString(t, n).replaceAll(/\w+/g, (a, l) => !i.check(a) && r.add(t + l, t + l + a.length, Zrt)), r.finish();
}
const Yrt = He.fromClass(class {
  constructor(e) {
    this.decorations = JT(e);
  }
  update(e) {
    (e.docChanged || e.viewportChanged) && (this.decorations = JT(e.view));
  }
}, {
  decorations: (e) => e.decorations
});
function zrt(e) {
  if (!e)
    return [];
  let {
    dict: t = "en_US",
    dictionaryPath: n = "/dictionaries"
  } = e;
  return [wR.of(new Qrt(t, null, null, {
    dictionaryPath: n
  })), Yrt];
}
const qrt = "cm-link", Wrt = [{
  target: /`[^`\n]+`/g,
  cssClass: "cm-mono"
}];
function t6(e, t, n, r) {
  var l, h;
  let i = ((l = e.visibleRanges[0]) == null ? void 0 : l.from) || 0, s = ((h = e.visibleRanges[0]) == null ? void 0 : h.to) || void 0;
  const o = new cr(), a = e.state.doc.sliceString(i, s);
  return t.flatMap((u) => {
    const f = u.id ? e.state.doc.line(parseInt(r.get(u.id))).text : a, d = u.id ? e.state.doc.line(parseInt(r.get(u.id))).from : i;
    return [...f.matchAll(u.target)].map((p) => ({
      match: p,
      hl: {
        ...u,
        from: d
      }
    }));
  }).sort((u, f) => u.hl.from + u.match.index - (f.hl.from + f.match.index)).forEach(({
    hl: u,
    match: f
  }) => {
    let d = {
      class: qrt
    };
    u.cssClass && (d.class = u.cssClass);
    let p;
    n && (p = n({
      builder: o,
      from: u.from,
      match: f,
      hl: u,
      markParams: d,
      view: e
    })), o.add(u.from + f.index, u.from + f.index + f[0].length, Bt.mark(d)), p == null || p();
  }), o.finish();
}
const h3 = (e, t, n) => {
  e || (e = []);
  const r = e.concat(Wrt);
  return He.fromClass(class {
    constructor(i) {
      this.decorations = t6(i, r, t, n);
    }
    update(i) {
      (i.docChanged || i.viewportChanged) && (this.decorations = t6(i.view, r, t, n));
    }
  }, {
    decorations: (i) => i.decorations
  });
}, SR = /* @__PURE__ */ new Map();
class Urt {
  constructor(t) {
    this.room = t, this.onmessage = null, this._onChange = (n) => n.key === t && this.onmessage !== null && this.onmessage({ data: IK(n.newValue || "") }), pK(this._onChange);
  }
  postMessage(t) {
    vL.setItem(this.room, $K(PK(t)));
  }
  close() {
    gK(this._onChange);
  }
}
const jrt = typeof BroadcastChannel > "u" ? Urt : BroadcastChannel, u3 = (e) => ma(SR, e, () => {
  const t = sc(), n = new jrt(e);
  return n.onmessage = (r) => t.forEach((i) => i(r.data, "broadcastchannel")), {
    bc: n,
    subs: t
  };
}), Xrt = (e, t) => (u3(e).subs.add(t), t), Grt = (e, t) => {
  const n = u3(e), r = n.subs.delete(t);
  return r && n.subs.size === 0 && (n.bc.close(), SR.delete(e)), r;
}, Uc = (e, t, n = null) => {
  const r = u3(e);
  r.bc.postMessage(t), r.subs.forEach((i) => i(t, n));
}, CR = 0, f3 = 1, TR = 2, a_ = (e, t) => {
  ee(e, CR);
  const n = OJ(t);
  Sn(e, n);
}, ER = (e, t, n) => {
  ee(e, f3), Sn(e, gJ(t, n));
}, Hrt = (e, t, n) => ER(t, n, _r(e)), AR = (e, t, n) => {
  try {
    fJ(t, _r(e), n);
  } catch (r) {
    console.error("Caught error while handling a Yjs update", r);
  }
}, Krt = (e, t) => {
  ee(e, TR), Sn(e, t);
}, Jrt = AR, tit = (e, t, n, r) => {
  const i = xe(e);
  switch (i) {
    case CR:
      Hrt(e, t, n);
      break;
    case f3:
      AR(e, n, r);
      break;
    case TR:
      Jrt(e, n, r);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return i;
}, eit = 0, nit = (e, t, n) => {
  switch (xe(e)) {
    case eit:
      n(t, za(e));
  }
}, cO = 3e4;
class PR extends j2 {
  constructor(t) {
    super(), this.doc = t, this.clientID = t.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = setInterval(() => {
      const n = sl();
      this.getLocalState() !== null && cO / 2 <= n - this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const r = [];
      this.meta.forEach((i, s) => {
        s !== this.clientID && cO <= n - i.lastUpdated && this.states.has(s) && r.push(s);
      }), r.length > 0 && d3(this, r, "timeout");
    }, ca(cO / 10)), t.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  setLocalState(t) {
    const n = this.clientID, r = this.meta.get(n), i = r === void 0 ? 0 : r.clock + 1, s = this.states.get(n);
    t === null ? this.states.delete(n) : this.states.set(n, t), this.meta.set(n, {
      clock: i,
      lastUpdated: sl()
    });
    const o = [], a = [], l = [], h = [];
    t === null ? h.push(n) : s == null ? t != null && o.push(n) : (a.push(n), Wf(s, t) || l.push(n)), (o.length > 0 || l.length > 0 || h.length > 0) && this.emit("change", [{ added: o, updated: l, removed: h }, "local"]), this.emit("update", [{ added: o, updated: a, removed: h }, "local"]);
  }
  setLocalStateField(t, n) {
    const r = this.getLocalState();
    r !== null && this.setLocalState({
      ...r,
      [t]: n
    });
  }
  getStates() {
    return this.states;
  }
}
const d3 = (e, t, n) => {
  const r = [];
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    if (e.states.has(s)) {
      if (e.states.delete(s), s === e.clientID) {
        const o = e.meta.get(s);
        e.meta.set(s, {
          clock: o.clock + 1,
          lastUpdated: sl()
        });
      }
      r.push(s);
    }
  }
  r.length > 0 && (e.emit("change", [{ added: [], updated: [], removed: r }, n]), e.emit("update", [{ added: [], updated: [], removed: r }, n]));
}, Xf = (e, t, n = e.states) => {
  const r = t.length, i = wr();
  ee(i, r);
  for (let s = 0; s < r; s++) {
    const o = t[s], a = n.get(o) || null, l = e.meta.get(o).clock;
    ee(i, o), ee(i, l), jl(i, JSON.stringify(a));
  }
  return gn(i);
}, rit = (e, t, n) => {
  const r = pl(t), i = sl(), s = [], o = [], a = [], l = [], h = xe(r);
  for (let u = 0; u < h; u++) {
    const f = xe(r);
    let d = xe(r);
    const p = JSON.parse(za(r)), g = e.meta.get(f), m = e.states.get(f), y = g === void 0 ? 0 : g.clock;
    (y < d || y === d && p === null && e.states.has(f)) && (p === null ? f === e.clientID && e.getLocalState() != null ? d++ : e.states.delete(f) : e.states.set(f, p), e.meta.set(f, {
      clock: d,
      lastUpdated: i
    }), g === void 0 && p !== null ? s.push(f) : g !== void 0 && p === null ? l.push(f) : p !== null && (Wf(p, m) || a.push(f), o.push(f)));
  }
  (s.length > 0 || a.length > 0 || l.length > 0) && e.emit("change", [{
    added: s,
    updated: a,
    removed: l
  }, n]), (s.length > 0 || o.length > 0 || l.length > 0) && e.emit("update", [{
    added: s,
    updated: o,
    removed: l
  }, n]);
}, iit = (e) => OK(e, (t, n) => `${encodeURIComponent(n)}=${encodeURIComponent(t)}`).join("&"), Vl = 0, DR = 3, xh = 1, sit = 2, jp = [];
jp[Vl] = (e, t, n, r, i) => {
  ee(e, Vl);
  const s = tit(
    t,
    e,
    n.doc,
    n
  );
  r && s === f3 && !n.synced && (n.synced = !0);
};
jp[DR] = (e, t, n, r, i) => {
  ee(e, xh), Sn(
    e,
    Xf(
      n.awareness,
      Array.from(n.awareness.getStates().keys())
    )
  );
};
jp[xh] = (e, t, n, r, i) => {
  rit(
    n.awareness,
    _r(t),
    n
  );
};
jp[sit] = (e, t, n, r, i) => {
  nit(
    t,
    n.doc,
    (s, o) => oit(n, o)
  );
};
const e6 = 3e4, oit = (e, t) => console.warn(`Permission denied to access ${e.url}.
${t}`), LR = (e, t, n) => {
  const r = pl(t), i = wr(), s = xe(r), o = e.messageHandlers[s];
  return o ? o(i, r, e, n, s) : console.error("Unable to compute message"), i;
}, MR = (e) => {
  if (e.shouldConnect && e.ws === null) {
    const t = new e._WS(e.url);
    t.binaryType = "arraybuffer", e.ws = t, e.wsconnecting = !0, e.wsconnected = !1, e.synced = !1, t.onmessage = (n) => {
      e.wsLastMessageReceived = sl();
      const r = LR(e, new Uint8Array(n.data), !0);
      $w(r) > 1 && t.send(gn(r));
    }, t.onerror = (n) => {
      e.emit("connection-error", [n, e]);
    }, t.onclose = (n) => {
      e.emit("connection-close", [n, e]), e.ws = null, e.wsconnecting = !1, e.wsconnected ? (e.wsconnected = !1, e.synced = !1, d3(
        e.awareness,
        Array.from(e.awareness.getStates().keys()).filter(
          (r) => r !== e.doc.clientID
        ),
        e
      ), e.emit("status", [{
        status: "disconnected"
      }])) : e.wsUnsuccessfulReconnects++, setTimeout(
        MR,
        X2(
          $H(2, e.wsUnsuccessfulReconnects) * 100,
          e.maxBackoffTime
        ),
        e
      );
    }, t.onopen = () => {
      e.wsLastMessageReceived = sl(), e.wsconnecting = !1, e.wsconnected = !0, e.wsUnsuccessfulReconnects = 0, e.emit("status", [{
        status: "connected"
      }]);
      const n = wr();
      if (ee(n, Vl), a_(n, e.doc), t.send(gn(n)), e.awareness.getLocalState() !== null) {
        const r = wr();
        ee(r, xh), Sn(
          r,
          Xf(e.awareness, [
            e.doc.clientID
          ])
        ), t.send(gn(r));
      }
    }, e.emit("status", [{
      status: "connecting"
    }]);
  }
}, hO = (e, t) => {
  const n = e.ws;
  e.wsconnected && n && n.readyState === n.OPEN && n.send(t), e.bcconnected && Uc(e.bcChannel, t, e);
};
class RR extends j2 {
  constructor(t, n, r, {
    connect: i = !0,
    awareness: s = new PR(r),
    params: o = {},
    WebSocketPolyfill: a = WebSocket,
    resyncInterval: l = -1,
    maxBackoffTime: h = 2500,
    disableBc: u = !1
  } = {}) {
    for (super(); t[t.length - 1] === "/"; )
      t = t.slice(0, t.length - 1);
    const f = iit(o);
    this.maxBackoffTime = h, this.bcChannel = t + "/" + n, this.url = t + "/" + n + (f.length === 0 ? "" : "?" + f), this.roomname = n, this.doc = r, this._WS = a, this.awareness = s, this.wsconnected = !1, this.wsconnecting = !1, this.bcconnected = !1, this.disableBc = u, this.wsUnsuccessfulReconnects = 0, this.messageHandlers = jp.slice(), this._synced = !1, this.ws = null, this.wsLastMessageReceived = 0, this.shouldConnect = i, this._resyncInterval = 0, l > 0 && (this._resyncInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        const d = wr();
        ee(d, Vl), a_(d, r), this.ws.send(gn(d));
      }
    }, l)), this._bcSubscriber = (d, p) => {
      if (p !== this) {
        const g = LR(this, new Uint8Array(d), !1);
        $w(g) > 1 && Uc(this.bcChannel, gn(g), this);
      }
    }, this._updateHandler = (d, p) => {
      if (p !== this) {
        const g = wr();
        ee(g, Vl), Krt(g, d), hO(this, gn(g));
      }
    }, this.doc.on("update", this._updateHandler), this._awarenessUpdateHandler = ({ added: d, updated: p, removed: g }, m) => {
      const y = d.concat(p).concat(g), O = wr();
      ee(O, xh), Sn(
        O,
        Xf(s, y)
      ), hO(this, gn(O));
    }, this._unloadHandler = () => {
      d3(
        this.awareness,
        [r.clientID],
        "window unload"
      );
    }, typeof window < "u" ? window.addEventListener("unload", this._unloadHandler) : typeof process < "u" && process.on("exit", this._unloadHandler), s.on("update", this._awarenessUpdateHandler), this._checkInterval = setInterval(() => {
      this.wsconnected && e6 < sl() - this.wsLastMessageReceived && this.ws.close();
    }, e6 / 10), i && this.connect();
  }
  get synced() {
    return this._synced;
  }
  set synced(t) {
    this._synced !== t && (this._synced = t, this.emit("synced", [t]), this.emit("sync", [t]));
  }
  destroy() {
    this._resyncInterval !== 0 && clearInterval(this._resyncInterval), clearInterval(this._checkInterval), this.disconnect(), typeof window < "u" ? window.removeEventListener("unload", this._unloadHandler) : typeof process < "u" && process.off("exit", this._unloadHandler), this.awareness.off("update", this._awarenessUpdateHandler), this.doc.off("update", this._updateHandler), super.destroy();
  }
  connectBc() {
    if (this.disableBc)
      return;
    this.bcconnected || (Xrt(this.bcChannel, this._bcSubscriber), this.bcconnected = !0);
    const t = wr();
    ee(t, Vl), a_(t, this.doc), Uc(this.bcChannel, gn(t), this);
    const n = wr();
    ee(n, Vl), ER(n, this.doc), Uc(this.bcChannel, gn(n), this);
    const r = wr();
    ee(r, DR), Uc(
      this.bcChannel,
      gn(r),
      this
    );
    const i = wr();
    ee(i, xh), Sn(
      i,
      Xf(this.awareness, [
        this.doc.clientID
      ])
    ), Uc(
      this.bcChannel,
      gn(i),
      this
    );
  }
  disconnectBc() {
    const t = wr();
    ee(t, xh), Sn(
      t,
      Xf(this.awareness, [
        this.doc.clientID
      ], /* @__PURE__ */ new Map())
    ), hO(this, gn(t)), this.bcconnected && (Grt(this.bcChannel, this._bcSubscriber), this.bcconnected = !1);
  }
  disconnect() {
    this.shouldConnect = !1, this.disconnectBc(), this.ws !== null && this.ws.close();
  }
  connect() {
    this.shouldConnect = !0, !this.wsconnected && this.ws === null && (MR(this), this.connectBc());
  }
}
le.define();
const $R = new Sc();
function ait(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function lit({
  commentId: e,
  text: t,
  color: n
}) {
  const r = [];
  for (; t !== ""; ) {
    t = t.slice(t.indexOf("|") + 1);
    const i = t.indexOf("|");
    if (i === -1)
      break;
    let s = t.slice(0, i), o = "";
    s.includes("->") && (o = s.slice(s.indexOf("->") + 2).trimStart(), s = s.slice(0, s.indexOf("->")).trimEnd()), s.length !== 0 && r.push({
      targetRegexSrc: `(?<=^|[ \\t\\r\\.]|\\b)${ait(s)}(?=$|[\\s\\.]|\\b)`,
      targetRegexFlags: "gm",
      id: e,
      cssClass: "cm-suggestion",
      replacement: o,
      color: n
    }), t = t.slice(i + 1);
  }
  return r;
}
function cit({
  builder: e,
  from: t,
  match: n,
  hl: r,
  markParams: i,
  view: s
}) {
  if (r.color && (i.attributes = {
    style: `color: ${r.color}`
  }), r.replacement)
    return i.class += " replaced", () => {
      e.add(t + n.index + n[0].length, t + n.index + n[0].length, Bt.widget({
        widget: new hit({
          text: r.replacement,
          color: r.color,
          from: t + n.index,
          to: t + n.index + n[0].length,
          view: s
        })
      }));
    };
}
class hit extends si {
  constructor({
    text: t,
    color: n,
    from: r,
    to: i,
    view: s
  }) {
    super(), this.text = t, this.color = n, this.from = r, this.to = i, this.view = s;
  }
  toDOM() {
    const t = document.createElement("span");
    return t.innerText = this.text, t.style.color = this.color, t.classList.add("cm-replacement"), t.title = "Accept suggestion", t.addEventListener("mouseup", () => {
      this.view.dispatch({
        changes: {
          from: this.from,
          to: this.to,
          insert: this.text
        }
      });
    }), t;
  }
}
const uit = () => "comment-" + Math.random().toString().replace(".", "");
class fit {
  constructor(t, n, r, i) {
    this.user = n.awareness.getLocalState().user, this.lineAuthors = t.getArray(i + "/commentLineAuthors"), this.ydoc = t, this.getAvatar = r, this.commentId = i;
  }
  get(t) {
    var r;
    const n = (r = this.lineAuthors.get(t - 1)) == null ? void 0 : r.get("author");
    if (!!n)
      return n.avatar = this.getAvatar(n.name), n;
  }
  appendFrom(t) {
    this.lineAuthors.length !== 0 && this.lineAuthors.delete(this.lineAuthors.length - 1), this.lineAuthors.push(t.toArray().map((n) => n.clone()));
  }
  delete() {
    this.lineAuthors.delete(0, this.lineAuthors.length);
  }
  mark(t) {
    for (; t >= this.lineAuthors.length; )
      this.lineAuthors.push([new ea()]);
    this.lineAuthors.get(t - 1).set("author", this.user);
  }
  remove(t, n) {
    this.lineAuthors.delete(t - 1, n);
  }
  insert(t, n) {
    t - 1 > this.lineAuthors.length && this.lineAuthors.push(
      [...Array(t - 1 - this.lineAuthors.length).keys()].map((r) => new ea())
    ), this.lineAuthors.insert(t - 1, [...Array(n).keys()].map((r) => new ea([["author", this.user]])));
  }
  firstLineOfSection(t) {
    const n = this.get(t).name;
    return this.lineAuthors.slice(0, t).map((r, i) => ({
      ...r.get("author"),
      lineNumber: i + 1
    })).reduceRight(
      (r, {
        name: i,
        lineNumber: s
      }) => i == n && s == r - 1 ? s : r,
      t
    );
  }
}
class dit {
  constructor(t, n) {
    this.commentPositions = t.getMap(Gf.dataPath), this.ycomments = n;
  }
  iter() {
    return [...this.commentPositions.entries()].map(([t, n]) => ({
      commentId: t,
      lineNumber: parseInt(n)
    }));
  }
  move(t, n, r = !0) {
    n > 0 && !this.isOccupied(n) && this.commentPositions.set(t, n), r && this.ycomments.syncSuggestions(t);
  }
  shift(t, n, r, i) {
    n < 0 && this.iter().filter((o) => t + n < o.lineNumber && o.lineNumber <= t).forEach((o) => this.del(o.commentId));
    const s = this.iter().filter((o) => i ? o.lineNumber > t : o.lineNumber >= t).filter((o) => o.lineNumber + n <= r);
    s.forEach((o) => this.move(o.commentId, o.lineNumber + n, !1)), this.ycomments.syncSuggestions(...s.map((o) => o.commentId));
  }
  isOccupied(t) {
    return this.iter().some((n) => n.lineNumber == t);
  }
  get(t) {
    return this.commentPositions.get(t);
  }
  set(t, n) {
    return this.commentPositions.set(t, n);
  }
  del(t) {
    this.commentPositions.delete(t);
  }
}
class pit {
  constructor() {
    this.comments = {}, this._onUpdate = () => {
    };
  }
  onUpdate(t) {
    this._onUpdate = t;
  }
  switchVisibility(t) {
    const r = !this.isShown(t);
    return this.setVisibility(t, r), r;
  }
  setVisibility(t, n) {
    this.update((r) => (r[t] || (r[t] = {}), r[t].isShown = n, r));
  }
  setHeight(t, n) {
    this.update((r) => (r[t] || (r[t] = {}), r[t].height = n, r));
  }
  offset(t) {
    return this.comments[t].top;
  }
  isShown(t) {
    return this.comments[t] ? this.comments[t].isShown && this.comments[t].top : !0;
  }
  del(t) {
    this.update((n) => (delete n[t], n));
  }
  new(t) {
    this.update((n) => (n[t] = {
      height: 18,
      isShown: !1
    }, n));
  }
  update(t) {
    t && (this.comments = t(this.comments)), this._onUpdate();
  }
  show(t) {
    this.setVisibility(t, !0);
  }
}
class git {
  constructor(t, n) {
    this.user = t.awareness.getLocalState().user, this.resolvedComments = n.getMap("resolved-comments");
  }
  resolve(t, n, r, i) {
    this.resolvedComments.set(t, JSON.stringify({
      resolvedLine: n,
      lineNumber: r,
      resolvedBy: this.user,
      resolvedDate: Date.now(),
      pos: i
    }));
  }
  delete(t) {
    this.resolvedComments.delete(t);
  }
  resolved() {
    return [...this.resolvedComments.entries()].map(([t, n]) => ({
      commentId: t,
      ...JSON.parse(n)
    }));
  }
  updateComment(t, n) {
    this.resolvedComments.set(t, JSON.stringify({
      ...JSON.parse(this.resolvedComments.get(t)),
      ...n
    }));
  }
  onUpdate(t) {
    this.resolvedComments.observe(() => t(this.resolved()));
  }
}
const fS = class {
  constructor(t, n, r) {
    this.ydoc = t, this.provider = n, this.getAvatar = r, this.mainCodeMirror = null, this.newLocalComment = !1, this.positionManager = new dit(t, this), this.displayManager = new pit(n), this.commentResolver = new git(n, t), this.draggedComment = null, this.commentWithPopup = null, this.suggestions = t.getMap("suggestions"), this.suggestions.observe(() => {
      if (!this.mainCodeMirror)
        return;
      const i = [...this.suggestions.values()].flat().map((s) => ({
        ...s,
        target: new RegExp(s.targetRegexSrc, s.targetRegexFlags)
      }));
      this.mainCodeMirror.dispatch({
        effects: $R.reconfigure(h3(i, cit, this.positions())),
        annotations: Zn.userEvent.of("suggestion")
      });
    }), this.positionManager.commentPositions.observeDeep(() => this.updateMainCodeMirror());
  }
  lineAuthors(t) {
    return new fit(this.ydoc, this.provider, this.getAvatar, t);
  }
  positions() {
    return this.positionManager;
  }
  display() {
    return this.displayManager;
  }
  resolver() {
    return this.commentResolver;
  }
  registerCodeMirror(t) {
    this.mainCodeMirror = t;
  }
  marginLeft() {
    return this.mainCodeMirror.dom.querySelector(".cm-gutters").offsetWidth;
  }
  getTextForComment(t) {
    return this.ydoc.getText(fS.commentsPrefix + t);
  }
  delText(t) {
    let n = this.getTextForComment(t);
    n != null && n.parent && n.delete();
  }
  newComment(t) {
    const n = uit();
    return this.positions().set(n, t.toString()), this.display().new(n), this.lineAuthors(n).mark(1), this.newLocalComment = !0, n;
  }
  deleteComment(t) {
    this.positions().del(t), this.display().del(t), this.delText(t), this.suggestions.set(t, []);
  }
  resolveComment(t) {
    const n = this.positions().get(t), r = this.mainCodeMirror.state.doc.line(n).from;
    this.positions().del(t), this.display().del(t);
    const i = this.mainCodeMirror.state.doc.line(n);
    this.resolver().resolve(t, i.text, n, r);
  }
  isEmpty(t) {
    return this.getTextForComment(t).length === 0;
  }
  findCommentOn(t) {
    return this.positions().iter().find((n) => n.lineNumber == t);
  }
  parentLineHeight(t) {
    var i, s;
    let n = (i = this.mainCodeMirror.dom.querySelector("#" + t)) == null ? void 0 : i.previousSibling;
    if (n)
      return n.clientHeight;
    let r = this.positionManager.get(t);
    return (s = [...this.mainCodeMirror.dom.querySelectorAll(".cm-gutterElement")].find((o) => o.textContent == r)) == null ? void 0 : s.clientHeight;
  }
  updateHeight(t, n) {
    this.display().setHeight(t, n), this.updateMainCodeMirror();
  }
  syncCommentLocations(t) {
    this.display().update(
      (n) => (t.view.dom.querySelectorAll(".comment-box").forEach((r) => {
        var i;
        n[i = r.id] || (n[i] = {}), n[r.id].top = r.offsetTop;
      }), n)
    );
  }
  syncRemoteComments() {
    this.display().update((t) => (this.positions().iter().filter((n) => !t[n.commentId] || t[n.commentId].isShown == null).forEach((n) => {
      t[n.commentId] = {
        isShown: !0,
        height: 17
      }, this.updateMainCodeMirror();
    }), t));
  }
  removeLocalComments() {
    let t = this.positions().iter().map((n) => n.commentId);
    this.display().update((n) => {
      for (let r in n)
        t.includes(r) || (delete n[r], this.suggestions.set(r, []));
      return n;
    });
  }
  syncComments(t) {
    t.transactions.some((n) => n.isUserEvent("suggestion")) || (this.syncCommentLocations(t), this.syncRemoteComments(), this.removeLocalComments(), this.syncResolvedComments(t));
  }
  iterComments() {
    const t = ({
      lineNumber: n,
      commentId: r
    }) => ({
      ...this.displayManager.comments[r],
      lineNumber: n,
      commentId: r
    });
    return this.positions().iter().map(t);
  }
  syncSuggestions(...t) {
    let n = {};
    for (const r of t) {
      const i = this.getTextForComment(r).toString();
      parseInt(this.positions().get(r));
      const s = this.lineAuthors(r), o = i.split(`
`).map((a, l) => {
        var h, u;
        return {
          text: a,
          commentId: r,
          color: (u = (h = s.get(l + 1)) == null ? void 0 : h.color) != null ? u : "#111"
        };
      });
      n[r] = o.flatMap(lit);
    }
    this.suggestions.doc.transact(() => {
      for (const [r, i] of Object.entries(n))
        this.suggestions.set(r, i);
    });
  }
  updateMainCodeMirror() {
    this.mainCodeMirror ? this.mainCodeMirror.dispatch({
      effects: Wd.of(null)
    }) : console.warn("[YComments] Failed to update the main CodeMirror instance since it doesn't exist.");
  }
  syncResolvedComments(t) {
    if (!t.docChanged && !t.transactions.some((r) => r.effects.some((i) => i.is(Wd))))
      return;
    const n = this.resolver().resolved();
    for (const r of n) {
      let i = !0;
      if (t.changes.iterChanges((u) => {
        t.startState.doc.lineAt(u).number <= r.lineNumber && (i = !1);
      }), r.occupied !== this.positions().isOccupied(r.lineNumber) && (i = !1), i)
        continue;
      const s = t.startState.doc.line(r.lineNumber).from, o = t.changes.mapPos(s, 1), a = t.state.doc.lineAt(o).number, l = t.changes.mapPos(s, 1, Gn.TrackDel) == null, h = t.changes.mapPos(s, 1, Gn.TrackBefore) == null && t.startState.doc.line(r.lineNumber).text == "";
      if (l || h) {
        this.resolver().updateComment(r.commentId, {
          orphaned: !0
        });
        continue;
      }
      if (this.resolver().updateComment(r.commentId, {
        occupied: this.positions().isOccupied(a)
      }), !r.orphaned) {
        this.resolver().updateComment(r.commentId, {
          lineNumber: a
        });
        const u = t.state.doc.line(a).text;
        this.resolver().updateComment(r.commentId, {
          resolvedLine: u
        });
      }
    }
  }
  restoreComment(t) {
    const n = this.lineAuthors(t.commentId), r = this.getTextForComment(t.commentId), i = t.orphaned ? this.mainCodeMirror.state.doc.lines : t.lineNumber;
    if (this.resolver().delete(t.commentId), this.positions().isOccupied(i)) {
      const s = this.findCommentOn(i).commentId;
      this.lineAuthors(s).appendFrom(n.lineAuthors);
      const o = this.getTextForComment(s);
      o.insert(o.length, `
` + r.toString()), this.display().setVisibility(s, !0);
    } else {
      const s = this.newComment(i);
      this.lineAuthors(s).delete(), this.lineAuthors(s).appendFrom(n.lineAuthors), this.getTextForComment(s).insert(0, r.toString()), this.display().setVisibility(s, !0);
    }
  }
  moveOrMerge(t, n) {
    if (!this.positions().isOccupied(n))
      this.positions().move(t, n);
    else {
      const r = this.findCommentOn(n).commentId;
      this.lineAuthors(r).appendFrom(this.lineAuthors(t).lineAuthors);
      const i = this.getTextForComment(r);
      i.insert(i.length, `
` + this.getTextForComment(t).toString()), this.deleteComment(t), this.display().setVisibility(r, !0);
    }
  }
};
let Gf = fS;
Gu(Gf, "commentsPrefix", "comments/");
const oy = Ft.define({
  combine: (e) => e[e.length - 1],
  static: !0
}), Wd = le.define();
class mit extends si {
  constructor(t, n, r) {
    super(), this.height = t, this.commentId = n, this.isShown = r;
  }
  toDOM() {
    const t = document.createElement("div");
    return t.id = this.commentId, t.classList = "comment-box", this.isShown || (t.classList += " comment-box-hidden"), t.style.height = this.height + "px", t;
  }
}
const yit = (e, t, n) => Bt.widget({
  widget: new mit(e, t, n),
  side: 1e4,
  inlineOrder: !1,
  block: n
}), bit = (e, t) => e.lineNumber - t.lineNumber, Oit = (e) => e.docChanged || e.effects.some((t) => t.is(Wd)), xit = (e) => [(t, {
  commentId: n,
  lineNumber: r,
  height: i,
  isShown: s
}) => {
  try {
    const o = e.newDoc.line(r).to;
    t.add(o, o, yit(i, n, s));
  } catch (o) {
    console.warn(o), console.warn(`An error occured when rendering comment ${n}. Comment will not be shown.`);
  }
  return t;
}, new cr()], vit = (e, t) => {
  if (e.isUserEvent("input") || e.isUserEvent("delete")) {
    const n = e.state.doc.lines - e.startState.doc.lines;
    if (n != 0 && e.selection != null) {
      const r = e.state.doc.lines, i = e.state.doc.lineAt(e.selection.main.from).number - n, s = e.selection.main.from === e.state.doc.lineAt(e.selection.main.from).to;
      t.positions().shift(i, n, r, s);
    }
  }
}, _it = bn.define({
  create() {
    return new cr().finish();
  },
  update(e, t) {
    if (Oit(t)) {
      const n = t.state.facet(oy);
      return vit(t, n), n.iterComments().sort(bit).reduce(...xit(t)).finish();
    }
    return e;
  },
  provide(e) {
    return Pt.decorations.from(e);
  }
}), Nl = class extends Yi {
  constructor(t, n) {
    var r;
    super(), this.gutterMarker = null, this.icon = null, n && t && (this.ycomments = n.state.facet(oy), this.lineNumber = n.state.doc.lineAt(t.to).number, this.commentId = (r = this.ycomments.findCommentOn(this.lineNumber)) == null ? void 0 : r.commentId);
  }
  hasComments() {
    return Boolean(this.commentId);
  }
  createGutterMarker() {
    this.gutterMarker = document.createElement("div"), this.gutterMarker.classList.add(Nl.MAIN_CLASS), this.lineNumber && (this.gutterMarker.style.width = this.lineNumber.toString().length * 7 + "px", this.gutterMarker.ondrop = () => this.ycomments.moveOrMerge(this.ycomments.draggedComment, this.lineNumber), this.gutterMarker.ondragover = (t) => t.preventDefault());
  }
  createPopupIcon() {
    this.icon = document.createElement("section"), this.icon.classList = Nl.ICON_CLASS, !this.draggedComment && !this.commentId ? (this.icon.onmouseenter = () => this.icon.classList.add(Nl.COMMENT_IMAGE_CLASS), this.icon.onmouseleave = () => this.icon.classList.remove(Nl.COMMENT_IMAGE_CLASS)) : (this.icon.onmouseup = () => this.ycomments.display().switchVisibility(this.commentId), this.icon.onmouseenter = () => {
      this.ycomments.commentWithPopup = this.commentId, this.ycomments.updateMainCodeMirror();
    });
  }
  markHasComments() {
    this.icon.classList.add(Nl.COMMENT_IMAGE_CLASS);
  }
  toDOM() {
    return this.createGutterMarker(), this.createPopupIcon(), this.hasComments() && this.markHasComments(), this.gutterMarker.appendChild(this.icon), this.gutterMarker;
  }
};
let Rl = Nl;
Gu(Rl, "MAIN_CLASS", "comment-gutter"), Gu(Rl, "ICON_CLASS", "comment-gutter-icon"), Gu(Rl, "COMMENT_IMAGE_CLASS", "comment-image");
const kit = (e, t, n) => {
  var s;
  const r = e.state.doc.lineAt(t.to).number, i = (s = n.findCommentOn(r)) == null ? void 0 : s.commentId;
  return i || n.newComment(r);
}, wit = B2({
  lineMarker(e, t) {
    return new Rl(t, e);
  },
  lineMarkerChange: (e) => e.transactions.some((t) => t.effects.some((n) => n.is(Wd))),
  initialSpacer: () => new Rl(null, null),
  domEventHandlers: {
    mouseup(e, t) {
      let n = e.state.facet(oy.reader), r = kit(e, t, n);
      n.display().switchVisibility(r), e.dispatch({
        effects: Wd.of(null)
      });
    }
  }
}), Sit = (e) => [oy.of(e), _it, wit, Pt.updateListener.of((t) => e.syncComments(t))], Cit = (e) => ["input", "delete", "undo", "redo"].some((t) => e.isUserEvent(t)), Ud = Ft.define({
  combine: (e) => e[e.length - 1],
  static: !0
}), Tit = He.fromClass(class {
  constructor(e) {
    this.decorations = this.colorEditorLines(e);
  }
  markAuthor(e, t) {
    return Bt.line({
      attributes: {
        "data-line-number": t,
        style: `
            --bg: ${e.color + "99"};
            border-left: 2px solid ${e.color};
            position: relative;
          `
      },
      class: "cm-comment-author-colored"
    });
  }
  colorEditorLines(e) {
    const t = e.state.facet(Ud), n = new cr();
    for (let r = 1; r <= e.state.doc.lines; r++) {
      const i = e.state.doc.line(r), s = t.get(r);
      s && n.add(i.from, i.from, this.markAuthor(s, r));
    }
    return n.finish();
  }
  markLinesEditedInTransaction(e) {
    const t = e.state.facet(Ud);
    e.changes.iterChangedRanges((n, r, i, s) => {
      const o = e.newDoc.lineAt(i), a = e.newDoc.lineAt(s), l = e.newDoc.slice(i, s).toString().trim().length == 0, h = e.state.doc.lines - e.startState.doc.lines;
      if (h > 0 && (l && !a.length ? t.insert(o.number + 1, h) : o.from == i ? t.insert(o.number, h) : (t.insert(o.number, h), t.mark(a.number))), h < 0) {
        const u = e.startState.doc.length > s ? e.startState.doc.lineAt(s) : null;
        l && a.to == i ? t.remove(o.number + 1, -h) : l && !(u != null && u.length) ? t.remove(o.number, -h) : (t.remove(o.number + 1, -h), t.mark(o.number));
      }
      h == 0 && !t.get(o.number) && t.mark(o.number);
    });
  }
  update(e) {
    (e.docChanged || e.viewportChanged) && (e.transactions.filter(Cit).forEach((t) => this.markLinesEditedInTransaction(t)), this.decorations = this.colorEditorLines(e.view)), e.view.dom.onmouseleave = () => e.view.dispatch({
      effects: l_.of(null)
    }), e.view.dom.querySelectorAll(".cm-line").forEach((t) => {
      t.onmouseenter = (n) => e.view.dispatch({
        effects: l_.of(parseInt(n.target.dataset.lineNumber))
      });
    });
  }
}, {
  decorations: (e) => e.decorations
}), l_ = le.define(), fm = bn.define({
  create() {
    return null;
  },
  update(e, t) {
    var i;
    const n = t.state.facet(Ud), r = (i = t.effects.find((s) => s.is(l_))) == null ? void 0 : i.value;
    return r ? n.firstLineOfSection(r) : null;
  }
});
class n6 extends Yi {
  constructor(t, n) {
    super(), n && t && (this.lineNumber = n.state.doc.lineAt(t.to).number, this.lineAuthors = n.state.facet(Ud), this.selectedLine = n.state.facet(fm));
  }
  authorAvatar() {
    const {
      avatar: t
    } = this.lineAuthors.get(this.lineNumber);
    let n = document.createElement("img");
    return n.classList.add("author-avatar"), n.src = t, n;
  }
  toDOM() {
    return this.selectedLine && this.selectedLine == this.lineNumber ? this.authorAvatar() : document.createElement("div");
  }
}
const Eit = B2({
  lineMarker: (e, t) => new n6(t, e),
  lineMarkerChange: (e) => e.startState.field(fm) != e.state.field(fm),
  initialSpacer: () => new n6(null, null)
}), Ait = (e) => [Ud.of(e), fm.init(null), Eit, Tit], Pit = AH.filter((e, t) => t != 3), Dit = PH.filter((e, t) => t != 1), Lit = (e) => {
  const {
    from: t
  } = e.state.selection.main, n = e.state.doc.lineAt(t);
  return {
    line: n.number - 1,
    ch: t - n.from
  };
}, Mit = (e, t) => {
  const {
    line: n,
    ch: r
  } = t, i = e.state.doc.line(n + 1).from + r;
  e.dispatch({
    selection: {
      anchor: i,
      head: i
    },
    scrollIntoView: !0
  });
};
class qa {
  constructor(t = []) {
    this.important = [De.lineSeparator.of(`
`)], this.base = t, this.extensions = qa.defaultPlugins();
  }
  static minimalSetup() {
    return new qa(Dit);
  }
  static basicSetup() {
    return new qa(Pit);
  }
  static defaultPlugins() {
    return [Pt.lineWrapping, Mrt(), EP(), Ko.of([XX, {
      key: "Mod-Z",
      run: Qg
    }])];
  }
  disable(t) {
    return this.base.push(Ts.highest(Ko.of(t.map((n) => ({
      key: n,
      run: () => !0
    }))))), this;
  }
  addUpdateListener(t) {
    return this.extensions.push(Pt.updateListener.of(t)), this;
  }
  useSpellcheck(t) {
    return this.extensions.push(zrt(t)), this;
  }
  useHighlighter(t) {
    return this.extensions.push(h3(t)), this;
  }
  useCompartment(t, n) {
    return this.extensions.push(t.of(n)), this;
  }
  useComments({
    enabled: t,
    ycomments: n
  }) {
    return t ? (this.important.push(Sit(n)), this) : this;
  }
  useRemoveSelectionOnBlur(t, n) {
    return this.base.push(Pt.domEventHandlers({
      blur(r, i) {
        const s = i.state.selection.main.head;
        n.awareness.setLocalStateField("cursor", {
          anchor: Bd(t, s),
          head: Bd(t, s)
        }), setTimeout(() => {
          i.dispatch({
            selection: mt.create([mt.range(s, s)])
          });
        }, 0);
      }
    })), this;
  }
  showCommentLineAuthors(t) {
    return this.important.push(Ait(t)), this;
  }
  readonly() {
    return this.extensions.push(Pt.editable.of(!1), De.readOnly.of(!0)), this;
  }
  useDefaultHistory() {
    return this.base.push(_w()), this;
  }
  useCollaboration({
    enabled: t = !0,
    ytext: n,
    provider: r,
    undoManager: i,
    editorRef: s
  }) {
    return t ? (this.extensions.push(Btt(n, r.awareness, {
      undoManager: i
    })), i && (i.on("stack-item-added", (o) => {
      o.stackItem.meta.set("cursor-location", Lit(s.current));
    }), i.on("stack-item-popped", (o) => {
      Mit(s.current, o.stackItem.meta.get("cursor-location"));
    }), this.extensions.push(Ko.of([{
      key: "Mod-z",
      run: () => i.undo(),
      preventDefault: !0
    }, {
      key: "Mod-y",
      run: () => i.redo(),
      preventDefault: !0
    }, {
      key: "Mod-Z",
      run: () => i.redo(),
      preventDefault: !0
    }]))), this) : this;
  }
  create() {
    return [...this.important, ...this.base, ...this.extensions];
  }
}
const Rit = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAyIDIwIDEyIiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjM4NDk2IDUuMDkxNzRDNS45MDUwNyA1LjA5MTc0IDUuNTE0NjUgNS40ODIxNiA1LjUxNDY1IDUuOTYyMDVDNS41MTQ2NSA2LjE4OTc5IDUuNjA0MTIgNi40MTc1NCA1Ljc2Njc5IDYuNTgwMjFDNS45Mjk0NyA2Ljc0Mjg5IDYuMTQ5MDggNi44MzIzNiA2LjM4NDk2IDYuODMyMzZDNi42MjA4NCA2LjgzMjM2IDYuODQwNDUgNi43NDI4OSA3LjAwMzEzIDYuNTgwMjFDNy4xNjU4IDYuNDE3NTQgNy4yNTUyNyA2LjE5NzkzIDcuMjU1MjcgNS45NjIwNUM3LjI1NTI3IDUuNDgyMTYgNi44NjQ4NSA1LjA5MTc0IDYuMzg0OTYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljk5NjI5IDUuMDkxNzRDOC41MTY0IDUuMDkxNzQgOC4xMjU5OCA1LjQ4MjE2IDguMTI1OTggNS45NjIwNUM4LjEyNTk4IDYuMTg5NzkgOC4yMTU0NSA2LjQxNzU0IDguMzc4MTIgNi41ODAyMUM4LjU0MDggNi43NDI4OSA4Ljc2MDQxIDYuODMyMzYgOC45OTYyOSA2LjgzMjM2QzkuMjMyMTcgNi44MzIzNiA5LjQ1MTc4IDYuNzQyODkgOS42MTQ0NSA2LjU4MDIxQzkuNzc3MTMgNi40MTc1NCA5Ljg2NjYgNi4xOTc5MyA5Ljg2NjYgNS45NjIwNUM5Ljg2NjYgNS40ODIxNiA5LjQ3NjE4IDUuMDkxNzQgOC45OTYyOSA1LjA5MTc0WiIgZmlsbD0iIzMzMkQzNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjYwNjYgNS4wOTE3NEMxMS4xMjY3IDUuMDkxNzQgMTAuNzM2MyA1LjQ4MjE2IDEwLjczNjMgNS45NjIwNUMxMC43MzYzIDYuMTg5NzkgMTAuODI1OCA2LjQxNzU0IDEwLjk4ODUgNi41ODAyMUMxMS4xNTExIDYuNzQyODkgMTEuMzcwOCA2LjgzMjM2IDExLjYwNjYgNi44MzIzNkMxMS44NDI1IDYuODMyMzYgMTIuMDYyMSA2Ljc0Mjg5IDEyLjIyNDggNi41ODAyMUMxMi4zODc1IDYuNDE3NTQgMTIuNDc3IDYuMTk3OTMgMTIuNDc3IDUuOTYyMDVDMTIuNDc3IDUuNDgyMTYgMTIuMDg2NSA1LjA5MTc0IDExLjYwNjYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZD0iTTE3LjEyOTggMTEuMDM3NVYwLjg2MjE4M0gwLjg2MjMwNVYxMC44NzQ4TDUuMTE2MjYgMTAuOTE1NUw5LjA1MyAxNC44NTIyTDEyLjg4NCAxMS4wMjk0TDE3LjEyOTggMTEuMDM3NVoiIHN0cm9rZT0iIzMzMkQzNyIgc3Ryb2tlLXdpZHRoPSIxLjUiLz4KPC9zdmc+", $it = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjYiIHZpZXdCb3g9IjAgMCAyNiAyMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik03LjcxMzg3IDYuMTQyOTRWMTIuNTcxNSIgc3Ryb2tlPSIjRTc0NzNDIiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik0xMC4yODUyIDYuMTQyODhWMTIuNTcxNSIgc3Ryb2tlPSIjRTc0NzNDIiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik02LjQyODcxIDFIMTEuNTcxNiIgc3Ryb2tlPSIjRTc0NzNDIiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik0wIDIuMjg1NjRIMTgiIHN0cm9rZT0iI0U3NDczQyIgc3Ryb2tlLXdpZHRoPSIxLjc1Ii8+CiAgICA8cGF0aCBkPSJNMS45Mjg3MSAyLjI4NTY0TDMuODU3MjggMTguMzU3MUgxNC4xNDNMMTYuMDcxNiAyLjI4NTY0IiBzdHJva2U9IiNFNzQ3M0MiIHN0cm9rZS13aWR0aD0iMS43NSIvPgo8L3N2Zz4K", Iit = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAyNSAyMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0xNC40NzI3IDcuMTE3MTlMOC43MTUxOCAxMi44NzQ3TDUuNTE3NTggOS42NzcwNyIgc3Ryb2tlPSIjMzMyRDM3IiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik0xMCAxOUMxNC45NzA2IDE5IDE5IDE0Ljk3MDYgMTkgMTBDMTkgNS4wMjk0NCAxNC45NzA2IDEgMTAgMUM1LjAyOTQ0IDEgMSA1LjAyOTQ0IDEgMTBDMSAxNC45NzA2IDUuMDI5NDQgMTkgMTAgMTlaIiBzdHJva2U9IiMzMzJEMzciIHN0cm9rZS13aWR0aD0iMS43NSIvPgo8L3N2Zz4K", Nit = ue.div`
  position: absolute;
  top: ${(e) => e.top + 20}px;
  left: ${(e) => e.left + 19}px;

  z-index: 3;
  right: 0px;
  background-color: var(--gray-500);

  ${(e) => e.fade ? "opacity: 0.4;" : ""}

  .cm-editor {
    background-color: var(--gray-500);
  }

  .cm-ySelectionInfo {
    z-index: 1004;
  }

  .cm-yLineSelection {
    margin: 0 !important;
    padding: 0 2px 0 6px;
  }

  .cm-gutters {
    border-width: 0;
  }

  .cm-content {
    padding: 0px;
  }
  .cm-line {
    line-height: 1.5em;
  }

  .cm-scroller {
    overflow-x: unset;
  }

  .cm-comment-author-colored {
    &::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: var(--bg);
      z-index: -3;
    }
  }

  .author-avatar {
    border-radius: 50%;
    height: 24px;
    width: 24px;
    box-shadow: rgba(0, 0, 0, 0.3) 0px 0px 4px;
    position: absolute;
    transform: translateX(-30px);
  }
`, Bit = ({
  ycomments: e,
  commentId: t,
  collaboration: n
}) => {
  let r = us(null);
  const i = Dn(() => e.lineAuthors(t), [t]), s = Yk((l) => l.heightChanged && l.view.requestMeasure({
    read: (h) => e.updateHeight(t, h.dom.clientHeight)
  }), [t]), o = e.parentLineHeight(t) + 3.8;
  lr(() => {
    if (!r.current)
      return;
    const l = e.getTextForComment(t), h = new Pt({
      state: De.create({
        doc: l.toString(),
        extensions: qa.minimalSetup().disable(["Mod-z", "Mod-y", "Mod-Z"]).useCollaboration({
          ytext: l,
          provider: e.provider
        }).useDefaultHistory().addUpdateListener(s).showCommentLineAuthors(i).useRemoveSelectionOnBlur(l, e.provider).create()
      }),
      parent: r.current
    });
    return e.syncSuggestions(t), l.observe((u, f) => {
      !f.local || e.syncSuggestions(t);
    }), e.newLocalComment && (h.focus(), e.newLocalComment = !1), () => {
      h.destroy();
    };
  }, [r]);
  const a = us(null);
  return lr(() => {
    !a.current || (a.current.onmouseup = () => {
      e.display().switchVisibility(t), e.updateMainCodeMirror();
    }, a.current.ondragstart = () => {
      e.draggedComment = t, e.display().update();
    }, a.current.ondragend = () => {
      e.draggedComment = null, e.display().update();
    });
  }, [a.current, e.commentWithPopup]), Kt` <${Nit}
    left=${e.marginLeft()}
    top=${e.display().offset(t)}
    fade=${e.draggedComment == t}
  >
    <div class="comment-wrapper" style="position:relative">
      ${e.commentWithPopup == t && Kt`
        <${Fit}
          left=${e.marginLeft()}
          shift=${o}
          onMouseLeave=${() => {
    e.commentWithPopup = null, e.updateMainCodeMirror();
  }}
        >
          <img class="comment-icon" ref=${a} src=${Rit} />

          <svg width="3" height="22" viewBox="0 10 2 19" fill="none">
            <path d="M1 1V25" stroke="#DDDDDD" stroke-width="0.75" stroke-linecap="round" />
          </svg>

          <${r6} icon=${$it} bgOnHover=${"#e7473c15"} text="DELETE" onClick=${() => e.deleteComment(t)} />
          ${n.resolvingCommentsEnabled && Kt`<${r6} icon=${Iit} bgOnHover=${"#AAE17320"} text="RESOLVE" onClick=${() => e.resolveComment(t)} />`}
        <//>
      `}

      <div style="display: ${e.display().isShown(t) ? "block" : "none"}" ref=${r}></div>
    </div>
  <//>`;
}, Fit = ue.div`
  width: fit-content;
  height: 25px;
  border-radius: 2px;
  position: absolute;
  background-color: white;
  border: 1px solid var(--icon-border);
  z-index: 30000000;
  left: ${(e) => -e.left - 13}px;
  top: ${(e) => -e.shift}px;
  box-shadow: 0 0 3px #ccc;
  box-sizing: content-box;

  .comment-icon {
    height: 20px;
    padding: 3px;
    margin-left: 10px;
    margin-right: 10px;
  }

  .resolve-icon {
    height: 20px;
    padding: 3px;
  }

  svg {
    box-sizing: content-box;
  }
`, Qit = ue.div`
  display: inline-flex;
  cursor: pointer;
  padding-left: 5px;
  padding-right: 5px;

  &:hover {
    background-color: ${(e) => e.bgOnHover};
  }

  img {
    height: 20px;
  }

  .delete-btn,
  .resolve-btn {
    color: #e7473c;
    line-height: 25px;
    font-size: 10px;
    margin-left: 5px;
    margin-right: 5px;
    box-sizing: content-box;
  }

  .delete-icon,
  resolve-icon {
    width: 11px;
    margin-top: 2px;
    margin-left: 5px;
    box-sizing: content-box;
  }
`, r6 = ({
  icon: e,
  onClick: t,
  text: n,
  bgOnHover: r
}) => Kt`
    <${Qit} bgOnHover=${r} onClick=${t}>
      <img class="resolve-icon" src=${e} />
      <span class="resolve-btn"> ${n} </span>
    <//>
  `, Zit = ({
  ycomments: e,
  collaboration: t
}) => {
  let n = ({
    commentId: o
  }) => Kt`<${Bit} ...${{
    key: o,
    commentId: o,
    ycomments: e,
    collaboration: t
  }} />`, r = () => e.iterComments().map(n), [i, s] = mn(r());
  return e.display().onUpdate(() => s(r())), Kt` ${i} `;
}, Vit = `<svg xmlns="http://www.w3.org/2000/svg" width="15" height="20" viewBox="0 2 20 12" fill="none">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.38496 5.09174C5.90507 5.09174 5.51465 5.48216 5.51465 5.96205C5.51465 6.18979 5.60412 6.41754 5.76679 6.58021C5.92947 6.74289 6.14908 6.83236 6.38496 6.83236C6.62084 6.83236 6.84045 6.74289 7.00313 6.58021C7.1658 6.41754 7.25527 6.19793 7.25527 5.96205C7.25527 5.48216 6.86485 5.09174 6.38496 5.09174Z" fill="#332D37"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.99629 5.09174C8.5164 5.09174 8.12598 5.48216 8.12598 5.96205C8.12598 6.18979 8.21545 6.41754 8.37812 6.58021C8.5408 6.74289 8.76041 6.83236 8.99629 6.83236C9.23217 6.83236 9.45178 6.74289 9.61445 6.58021C9.77713 6.41754 9.8666 6.19793 9.8666 5.96205C9.8666 5.48216 9.47618 5.09174 8.99629 5.09174Z" fill="#332D37"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.6066 5.09174C11.1267 5.09174 10.7363 5.48216 10.7363 5.96205C10.7363 6.18979 10.8258 6.41754 10.9885 6.58021C11.1511 6.74289 11.3708 6.83236 11.6066 6.83236C11.8425 6.83236 12.0621 6.74289 12.2248 6.58021C12.3875 6.41754 12.477 6.19793 12.477 5.96205C12.477 5.48216 12.0865 5.09174 11.6066 5.09174Z" fill="#332D37"/>
<path d="M17.1298 11.0375V0.862183H0.862305V10.8748L5.11626 10.9155L9.053 14.8522L12.884 11.0294L17.1298 11.0375Z" stroke="#332D37" stroke-width="1.5"/>
</svg>`, IR = ue.div`
  border-radius: var(--border-radius);
  background: var(--gray-200);
  font-family: monospace;
  font-size: 0.94em;
  resize: none;
  border: 0;
  padding: 20px;
  min-height: 500px;
  color: black;
  position: relative;
  box-shadow: inset 0px 0px 4px rgba(0, 0, 0, 0.15);

  .cm-gutters {
    background-color: var(--gray-200);
  }

  .comment-gutter-icon {
    height: 17px;
    width: 17px;
    cursor: pointer;
  }

  .comment-image {
    position: absolute;
    display: inline;
    background-color: var(--gray-200);
    background-image: url("data:image/svg+xml;charset=UTF-8,${(e) => encodeURIComponent(Vit)}");
    background-repeat: no-repeat;
  }

  .comment-box {
    width: 95%;
    display: flex;
    margin: 0px;
    padding: 0px;
  }

  .comment-box-hidden {
    position: absolute;
    pointer-events: none;
    margin-top: -5px;
  }

  @media print {
    & {
      display: none;
    }
  }

  .cm-ySelectionInfo {
    opacity: 1 !important;
    font-size: 0.6rem;
    padding: 0.25rem 0.5rem !important;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    border-bottom-right-radius: 10px;
    font-family: "Lato" !important;
    font-weight: 600 !important;
  }

  .cm-widgetBuffer {
    margin-bottom: 0;
  }

  .cm-ySelectionCaretDot {
    display: none;
  }

  .cm-yLineSelection {
    margin: 0 2px 0 6px;
  }

  .cm-editor {
    outline: 0;
  }

  .cm-scroller {
    overflow: visible;
  }

  .cm-error {
    text-decoration: underline red;
  }

  .cm-link {
    color: var(--blue-500);

    .cm-error {
      text-decoration: unset;
    }

    .ͼ6.ͼ5 {
      color: unset;
    }
  }

  .cm-mono {
    color: #219;
  }

  [title="Fold line"] {
    user-select: none;
  }

  .cm-panels-bottom {
    z-index: 3;
  }

  .cm-suggestion {
    font-weight: 700;

    &.replaced {
      font-weight: initial;
      color: initial !important;
      text-decoration: line-through;
    }

    & * {
      color: inherit;
    }
  }

  .cm-replacement {
    font-weight: 700;
    display: inline-block;
    margin-left: 4px;
    cursor: pointer;
  }
`, Yit = ue.textarea`
  display: none;
`, zit = (e, t) => {
  e.dispatch({
    changes: {
      from: 0,
      to: e.state.doc.length,
      insert: t
    }
  });
}, qit = ({
  text: e,
  id: t,
  name: n,
  mode: r,
  spellcheckOpts: i,
  highlights: s,
  collaboration: o
}) => {
  const a = us(null), l = us(null);
  return lr(() => {
    var h;
    if (o.opts.enabled && o.error) {
      e.readyToRender(), (h = a.current) == null || h.destroy();
      const u = new Pt({
        state: De.create({
          doc: e.get(),
          extensions: qa.basicSetup().useHighlighter(s).useSpellcheck(i).readonly().create()
        }),
        parent: l.current
      });
      u.dom.style.opacity = "0.5";
    }
  }, [o.error]), lr(() => {
    var f, d, p;
    if (o.opts.enabled && !o.ready || a.current || o.error)
      return;
    ((f = o.ytext) == null ? void 0 : f.toString().length) === 0 && e.get().length > 0 && (console.warn("[Collaboration] Remote state is empty, overriding with local state"), o.ytext.insert(0, e.get())), o.opts.enabled && e.set(o.ytext.toString()), e.readyToRender();
    const h = De.create({
      doc: o.opts.enabled ? o.ytext.toString() : e.get(),
      extensions: qa.basicSetup().useHighlighter(s).useCompartment($R, h3([])).useSpellcheck(i).useCollaboration({
        enabled: o.opts.enabled || !1,
        ytext: o.ytext,
        undoManager: o.undoManager,
        provider: o.provider,
        editorRef: a
      }).useComments({
        enabled: o.opts.commentsEnabled,
        ycomments: o.ycomments
      }).addUpdateListener((g) => g.docChanged && e.set(u.state.doc.toString())).useRemoveSelectionOnBlur(o.ytext, o.provider).create()
    }), u = new Pt({
      state: h,
      parent: l.current
    });
    return a.current = u, window.myst_editor.main_editor = u, (d = o.ycomments) == null || d.registerCodeMirror(u), (p = o.provider) == null || p.watchCollabolators(o.setUsers), e.onSync((g) => zit(u, g)), () => {
      o.opts.enabled && (o.provider.disconnect(), o.ydoc.destroy()), u.destroy();
    };
  }, [o.ready]), Kt`
    <${IR} className="myst-main-editor" ref=${l} $mode=${r} id="${t}-editor">
      ${o.opts.commentsEnabled && !o.error && Kt`<${Zit} ycomments=${o.ycomments} collaboration=${o.opts} />`}
    <//>
    <${Yit} value=${e.get()} name=${n} id=${t}><//>
  `;
}, NR = ue.div`
  background-color: white;
  padding: 20px;
  min-height: 150px;
  border: 1px solid var(--gray-400);
  border-left: 1px solid var(--gray-600);
  box-shadow: inset 0px 0px 4px var(--gray-600);
  border-radius: var(--border-radius);
  vertical-align: top;
  color: var(--gray-900);
  word-break: unset;

  @media print {
    & {
      display: block !important;
      border: 0px !important;
      box-shadow: none !important;
      border-radius: 0px !important;
      word-break: unset !important;
    }
  }

  p {
    margin-top: 0px;
    line-height: 1.3em;
    display: block;

    a {
      display: inline;
    }

    @media print {
      break-inside: avoid !important;
      text-align: justify !important;
      text-justify: inter-word !important;
    }
  }

  a {
    color: var(--blue-500);
    word-break: break-word;

    @media print {
      &::after {
        content: "(" attr(href) ")" !important;
      }
    }
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-weight: bold;
    line-height: 1.5;
    margin: 1em 0;
  }
  h1 {
    font-size: 1.8em;
  }
  h2 {
    font-size: 1.5em;
  }
  h3 {
    font-size: 1.25em;
  }
  h4 {
    font-size: 1.15em;
  }
  h5 {
    font-size: 1.1em;
  }
  h6 {
    font-size: 1em;
  }

  hr {
    height: 1px;
    margin: 16px 0;
    background-color: var(--gray-500);
    border: 0 none;
  }

  code,
  pre {
    border-radius: var(--border-radius);
    background-color: var(--gray-200);
  }
  code {
    padding: 0.1em 0.4em;
    font-family: "Source Code Pro";
    font-size: 0.9em;
    color: var(--black);
    border: none;
  }
  pre {
    white-space: pre-wrap;
    padding: 16px;
    & > code {
      padding: 0px;
    }
  }
  details > summary {
    display: list-item;
    cursor: pointer;
  }
  aside {
    border-radius: var(--border-radius);

    &.admonition {
      border: var(--border-2) solid var(--green-500);
      margin-bottom: 1rem;

      .admonition {
        margin: 0rem 1.4rem 0.9rem 1.4rem;
      }

      & > header,
      p {
        padding: 10px;
      }
      & > p {
        margin-bottom: 0;
      }
      & > header {
        color: var(--white);
        font-weight: bold;
        background: var(--green-500);
      }
    }

    &[class="admonition"] {
      .admonition {
        margin-top: 0.9rem;
      }
    }

    &.note,
    &.important,
    &.tip,
    &.hint,
    &.directive-unhandled,
    &.warning {
      border: 3px solid var(--blue-200);

      & > header {
        background-color: var(--blue-200);
        display: flex;

        &::before {
          padding-right: 5px;
          display: flex;
          align-items: center;
        }
      }
    }

    &.warning {
      border: 3px solid var(--orange-500);

      & > header {
        background-color: var(--orange-500);

        &::before {
          content: url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-exclamation-triangle' viewBox='0 0 16 16'%3E%3Cpath d='M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z' fill='white'%3E%3C/path%3E%3Cpath d='M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z' fill='white'%3E%3C/path%3E%3C/svg%3E%0A");
        }
      }
    }

    &.tip,
    &.hint {
      & > header::before {
        content: url("data:image/svg+xml,%3Csvg style='color: white' width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 0V2H8V0H7Z' fill='white'%3E%3C/path%3E%3Cpath d='M3.35355 3.64645L1.85355 2.14645L1.14645 2.85355L2.64645 4.35355L3.35355 3.64645Z' fill='white'%3E%3C/path%3E%3Cpath d='M12.3536 4.35355L13.8536 2.85355L13.1464 2.14645L11.6464 3.64645L12.3536 4.35355Z' fill='white'%3E%3C/path%3E%3Cpath d='M7.49998 3C5.52977 3 3.85938 4.44872 3.58075 6.39913L3.5707 6.46949C3.41148 7.58398 3.73042 8.64543 4.36009 9.45895C4.74345 9.95426 5 10.427 5 10.9013V12.5C5 12.7761 5.22386 13 5.5 13H9.5C9.77614 13 10 12.7761 10 12.5V10.9013C10 10.427 10.2565 9.95423 10.6399 9.45893C11.2696 8.64541 11.5885 7.58397 11.4293 6.4695L11.4192 6.39914C11.1406 4.44873 9.4702 3 7.49998 3Z' fill='white'%3E%3C/path%3E%3Cpath d='M0 8H2V7H0V8Z' fill='white'%3E%3C/path%3E%3Cpath d='M13 8H15V7H13V8Z' fill='white'%3E%3C/path%3E%3Cpath d='M6 15H9V14H6V15Z' fill='white'%3E%3C/path%3E%3C/svg%3E");
      }
    }

    &.note > header::before {
      content: url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-pencil' viewBox='0 0 16 16'%3E%3Cpath d='M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z' fill='white'%3E%3C/path%3E%3C/svg%3E");
    }

    &.important > header::before {
      content: url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24'%3E%3Cpath d='M18 16v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-5 0h-2v-2h2v2zm0-4h-2V8h2v4zm-1 10c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2z' fill='white'%3E%3C/path%3E%3C/svg%3E");
    }

    &.directive-unhandled,
    &.directive-error {
      margin-bottom: 1em;

      & > header {
        padding: 10px;
        color: var(--white);

        mark {
          background: transparent;
          font-weight: bold;
          color: inherit;
        }

        code {
          background: transparent;
          font-family: "Lato", sans-serif;
          font-weight: bold;
          padding: 0;
          margin-left: 0.3em;
        }
      }

      pre {
        background-color: var(--white);
        margin: 0;
        font-family: "Lato", sans-serif;
      }
    }

    &.directive-unhandled {
      border: 3px solid var(--gray-700);
      & > header {
        background-color: var(--gray-700);
      }
    }

    &.directive-error {
      border: 3px solid var(--red-500);
      & > header {
        background-color: var(--red-500);
      }
    }
  }

  sup,
  sub,
  numref {
    line-height: 0;
  }

  abbr {
    letter-spacing: 0.1em;
    font-weight: bold;
  }

  img {
    max-width: 100%;
    height: auto;
    display: block;
    margin-left: auto;
    margin-right: auto;
  }

  li {
    margin-bottom: 0.5em;
    line-height: 1.3em;
    p {
      padding: 0px;
    }
  }
  ul,
  ol {
    list-style: revert;
    padding-left: 40px;
    padding-top: 0.5em;
  }
  /* Add some padding to the outermost ul */
  &[class^="Preview"] > ul {
    padding-top: 0.5em;
    padding-bottom: 0.5em;
  }

  blockquote {
    border-left: 5px solid var(--green-500);
    margin-left: 0;
    margin-top: 0;
    padding-left: 0.75rem;
  }

  table {
    border-spacing: 0;
    margin: 20px 0 20px 0;
  }
  th,
  td {
    padding: 20px;
    text-align: left;
    border-right: 1px solid var(--gray-500);
    border-bottom: 1px solid var(--gray-500);
  }
  th {
    background: var(--gray-900);
    border-top: 1px solid var(--gray-500);
    color: var(--white);

    &:first-of-type {
      border-top-left-radius: var(--border-radius);
      border-left: 1px solid var(--gray-500);
    }

    &:last-of-type {
      border-top-right-radius: var(--border-radius);
    }
  }
  td {
    &:first-of-type {
      border-left: 1px solid var(--gray-500);
    }

    p:last-of-type {
      margin-bottom: 0;
    }
  }
  tr {
    &:nth-child(2n + 2) {
      background: var(--gray-100);
    }

    &:last-of-type {
      td {
        &:first-of-type {
          border-bottom-left-radius: var(--border-radius);
        }

        &:last-of-type {
          border-bottom-right-radius: var(--border-radius);
        }
      }
    }
  }
`;
NR.defaultProps = {
  className: "myst-preview"
};
class En {
  constructor(t, n, r, i) {
    this.fromA = t, this.toA = n, this.fromB = r, this.toB = i;
  }
  offset(t, n) {
    return new En(this.fromA + t, this.toA + t, this.fromB + n, this.toB + n);
  }
}
function cc(e, t, n, r, i, s) {
  if (e == r)
    return [];
  let o = p3(e, t, n, r, i, s), a = g3(e, t + o, n, r, i + o, s);
  t += o, n -= a, i += o, s -= a;
  let l = n - t, h = s - i;
  if (!l || !h)
    return [new En(t, n, i, s)];
  if (l > h) {
    let f = e.slice(t, n).indexOf(r.slice(i, s));
    if (f > -1)
      return [
        new En(t, t + f, i, i),
        new En(t + f + h, n, s, s)
      ];
  } else if (h > l) {
    let f = r.slice(i, s).indexOf(e.slice(t, n));
    if (f > -1)
      return [
        new En(t, t, i, i + f),
        new En(n, n, i + f + l, s)
      ];
  }
  if (l == 1 || h == 1)
    return [new En(t, n, i, s)];
  let u = QR(e, t, n, r, i, s);
  if (u) {
    let [f, d, p] = u;
    return cc(e, t, f, r, i, d).concat(cc(e, f + p, n, r, d + p, s));
  }
  return Wit(e, t, n, r, i, s);
}
let Af = 1e9;
function Wit(e, t, n, r, i, s) {
  let o = n - t, a = s - i;
  if (Af < 1e9 && Math.min(o, a) > Af * 16)
    return Math.min(o, a) > Af * 64 ? [new En(t, n, i, s)] : i6(e, t, n, r, i, s);
  let l = Math.ceil((o + a) / 2);
  uO.reset(l), fO.reset(l);
  let h = (p, g) => e.charCodeAt(t + p) == r.charCodeAt(i + g), u = (p, g) => e.charCodeAt(n - p - 1) == r.charCodeAt(s - g - 1), f = (o - a) % 2 != 0 ? fO : null, d = f ? null : uO;
  for (let p = 0; p < l; p++) {
    if (p > Af)
      return i6(e, t, n, r, i, s);
    let g = uO.advance(p, o, a, l, f, !1, h) || fO.advance(p, o, a, l, d, !0, u);
    if (g)
      return Uit(e, t, n, t + g[0], r, i, s, i + g[1]);
  }
  return [new En(t, n, i, s)];
}
class BR {
  constructor() {
    this.vec = [];
  }
  reset(t) {
    this.len = t << 1;
    for (let n = 0; n < this.len; n++)
      this.vec[n] = -1;
    this.vec[t + 1] = 0, this.start = this.end = 0;
  }
  advance(t, n, r, i, s, o, a) {
    for (let l = -t + this.start; l <= t - this.end; l += 2) {
      let h = i + l, u = l == -t || l != t && this.vec[h - 1] < this.vec[h + 1] ? this.vec[h + 1] : this.vec[h - 1] + 1, f = u - l;
      for (; u < n && f < r && a(u, f); )
        u++, f++;
      if (this.vec[h] = u, u > n)
        this.end += 2;
      else if (f > r)
        this.start += 2;
      else if (s) {
        let d = i + (n - r) - l;
        if (d >= 0 && d < this.len && s.vec[d] != -1)
          if (o) {
            let p = s.vec[d];
            if (p >= n - u)
              return [p, i + p - d];
          } else {
            let p = n - s.vec[d];
            if (u >= p)
              return [u, f];
          }
      }
    }
    return null;
  }
}
const uO = /* @__PURE__ */ new BR(), fO = /* @__PURE__ */ new BR();
function Uit(e, t, n, r, i, s, o, a) {
  let l = !1;
  return !Jh(e, r) && ++r == n && (l = !0), !Jh(i, a) && ++a == o && (l = !0), l ? [new En(t, n, s, o)] : cc(e, t, r, i, s, a).concat(cc(e, r, n, i, a, o));
}
function FR(e, t) {
  let n = 1, r = Math.min(e, t);
  for (; n < r; )
    n = n << 1;
  return n;
}
function p3(e, t, n, r, i, s) {
  if (t == n || t == s || e.charCodeAt(t) != r.charCodeAt(i))
    return 0;
  let o = FR(n - t, s - i);
  for (let a = t, l = i; ; ) {
    let h = a + o, u = l + o;
    if (h > n || u > s || e.slice(a, h) != r.slice(l, u)) {
      if (o == 1)
        return a - t - (Jh(e, a) ? 0 : 1);
      o = o >> 1;
    } else {
      if (h == n || u == s)
        return h - t;
      a = h, l = u;
    }
  }
}
function g3(e, t, n, r, i, s) {
  if (t == n || i == s || e.charCodeAt(n - 1) != r.charCodeAt(s - 1))
    return 0;
  let o = FR(n - t, s - i);
  for (let a = n, l = s; ; ) {
    let h = a - o, u = l - o;
    if (h < t || u < i || e.slice(h, a) != r.slice(u, l)) {
      if (o == 1)
        return n - a - (Jh(e, a) ? 0 : 1);
      o = o >> 1;
    } else {
      if (h == t || u == i)
        return n - h;
      a = h, l = u;
    }
  }
}
function c_(e, t, n, r, i, s, o, a) {
  let l = r.slice(i, s), h = null;
  for (; ; ) {
    if (h || o < a)
      return h;
    for (let u = t + o; ; ) {
      Jh(e, u) || u++;
      let f = u + o;
      if (Jh(e, f) || (f += f == u + 1 ? 1 : -1), f >= n)
        break;
      let d = e.slice(u, f), p = -1;
      for (; (p = l.indexOf(d, p + 1)) != -1; ) {
        let g = p3(e, f, n, r, i + p + d.length, s), m = g3(e, t, u, r, i, i + p), y = d.length + g + m;
        (!h || h[2] < y) && (h = [u - m, i + p - m, y]);
      }
      u = f;
    }
    if (a < 0)
      return h;
    o = o >> 1;
  }
}
function QR(e, t, n, r, i, s) {
  let o = n - t, a = s - i;
  if (o < a) {
    let l = QR(r, i, s, e, t, n);
    return l && [l[1], l[0], l[2]];
  }
  return o < 4 || a * 2 < o ? null : c_(e, t, n, r, i, s, Math.floor(o / 4), -1);
}
function i6(e, t, n, r, i, s) {
  let o = n - t, a = s - i, l;
  if (o < a) {
    let d = c_(r, i, s, e, t, n, Math.floor(o / 6), 50);
    l = d && [d[1], d[0], d[2]];
  } else
    l = c_(e, t, n, r, i, s, Math.floor(a / 6), 50);
  if (!l)
    return [new En(t, n, i, s)];
  let [h, u, f] = l;
  return cc(e, t, h, r, i, u).concat(cc(e, h + f, n, r, u + f, s));
}
function ZR(e, t) {
  for (let n = 1; n < e.length; n++) {
    let r = e[n - 1], i = e[n];
    r.toA > i.fromA - t && r.toB > i.fromB - t && (e[n - 1] = new En(r.fromA, i.toA, r.fromB, i.toB), e.splice(n--, 1));
  }
}
function jit(e, t, n) {
  for (; ; ) {
    ZR(n, 1);
    let r = !1;
    for (let i = 0; i < n.length; i++) {
      let s = n[i], o, a;
      (o = p3(e, s.fromA, s.toA, t, s.fromB, s.toB)) && (s = n[i] = new En(s.fromA + o, s.toA, s.fromB + o, s.toB)), (a = g3(e, s.fromA, s.toA, t, s.fromB, s.toB)) && (s = n[i] = new En(s.fromA, s.toA - a, s.fromB, s.toB - a));
      let l = s.toA - s.fromA, h = s.toB - s.fromB;
      if (l && h)
        continue;
      let u = s.fromA - (i ? n[i - 1].toA : 0), f = (i < n.length - 1 ? n[i + 1].fromA : e.length) - s.toA;
      if (!u || !f)
        continue;
      let d = l ? e.slice(s.fromA, s.toA) : t.slice(s.fromB, s.toB);
      u <= d.length && e.slice(s.fromA - u, s.fromA) == d.slice(d.length - u) ? (n[i] = new En(s.fromA - u, s.toA - u, s.fromB - u, s.toB - u), r = !0) : f <= d.length && e.slice(s.toA, s.toA + f) == d.slice(0, f) && (n[i] = new En(s.fromA + f, s.toA + f, s.fromB + f, s.toB + f), r = !0);
    }
    if (!r)
      break;
  }
  return n;
}
function Xit(e, t, n) {
  for (let r = 0, i = 0; i < e.length; i++) {
    let s = e[i], o = s.toA - s.fromA, a = s.toB - s.fromB;
    if (o && a || o > 3 || a > 3) {
      let l = i == e.length - 1 ? t.length : e[i + 1].fromA, h = s.fromA - r, u = l - s.toA, f = o6(t, s.fromA, Math.min(h, 5)), d = s6(t, s.toA, Math.min(u, 5)), p = s.fromA - f, g = d - s.toA;
      if (!o || !a) {
        let m = Math.max(o, a), [y, O, x] = o ? [t, s.fromA, s.toA] : [n, s.fromB, s.toB], _, w;
        p && g ? (m > p && t.slice(f, s.fromA) == y.slice(x - p, x) ? (s = e[i] = new En(f, f + o, s.fromB - p, s.toB - p), f = s.fromA, d = s6(t, s.toA, Math.min(l - s.toA, 5))) : m > g && t.slice(s.toA, d) == y.slice(O, O + g) && (s = e[i] = new En(d - o, d, s.fromB + g, s.toB + g), d = s.toA, f = o6(t, s.fromA, Math.min(s.fromA - r, 5))), p = s.fromA - f, g = d - s.toA) : !p && !g && (w = s.fromA - (_ = Git(t, s.fromA, h))) && t.slice(_, s.fromA) == y.slice(x - w, x) && (s = e[i] = new En(_, _ + o, s.fromB - w, s.toB - w));
      }
      (p || g) && (s = e[i] = new En(s.fromA - p, s.toA + g, s.fromB - p, s.toB + g)), r = s.toA;
    }
  }
  return ZR(e, 3), e;
}
let Xl;
try {
  Xl = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}]", "u");
} catch {
}
function VR(e) {
  return e > 48 && e < 58 || e > 64 && e < 91 || e > 96 && e < 123;
}
function YR(e, t) {
  if (t == e.length)
    return 0;
  let n = e.charCodeAt(t);
  return n < 192 ? VR(n) ? 1 : 0 : Xl ? !qR(n) || t == e.length - 1 ? Xl.test(String.fromCharCode(n)) ? 1 : 0 : Xl.test(e.slice(t, t + 2)) ? 2 : 0 : 0;
}
function zR(e, t) {
  if (!t)
    return 0;
  let n = e.charCodeAt(t - 1);
  return n < 192 ? VR(n) ? 1 : 0 : Xl ? !WR(n) || t == 1 ? Xl.test(String.fromCharCode(n)) ? 1 : 0 : Xl.test(e.slice(t - 2, t)) ? 2 : 0 : 0;
}
function s6(e, t, n) {
  if (t == e.length || !zR(e, t))
    return t;
  for (let r = t, i = t + n; ; ) {
    let s = YR(e, r);
    if (!s)
      return r;
    if (r += s, r > i)
      return t;
  }
}
function o6(e, t, n) {
  if (!t || !YR(e, t))
    return t;
  for (let r = t, i = t - n; ; ) {
    let s = zR(e, r);
    if (!s)
      return r;
    if (r -= s, r < i)
      return t;
  }
}
function Git(e, t, n) {
  for (let r = t, i = t - n; ; ) {
    let s = r ? e.charCodeAt(r - 1) : 10;
    if (s == 10)
      return r;
    if (r--, r < i || s != 32 && s != 9)
      return t;
  }
}
const qR = (e) => e >= 55296 && e <= 56319, WR = (e) => e >= 56320 && e <= 57343;
function Jh(e, t) {
  return !t || t == e.length || !qR(e.charCodeAt(t - 1)) || !WR(e.charCodeAt(t));
}
function Hit(e, t, n) {
  var r;
  return Af = ((r = n == null ? void 0 : n.scanLimit) !== null && r !== void 0 ? r : 1e9) >> 1, jit(e, t, cc(e, 0, e.length, t, 0, t.length));
}
function UR(e, t, n) {
  return Xit(Hit(e, t, n), e, t);
}
const Ks = /* @__PURE__ */ Ft.define({
  combine: (e) => e[0]
}), h_ = /* @__PURE__ */ le.define(), tu = /* @__PURE__ */ bn.define({
  create(e) {
    return null;
  },
  update(e, t) {
    for (let n of t.effects)
      n.is(h_) && (e = n.value);
    return e;
  }
});
class vh {
  constructor(t, n, r, i, s) {
    this.changes = t, this.fromA = n, this.toA = r, this.fromB = i, this.toB = s;
  }
  offset(t, n) {
    return t || n ? new vh(this.changes, this.fromA + t, this.toA + t, this.fromB + n, this.toB + n) : this;
  }
  get endA() {
    return Math.max(this.fromA, this.toA - 1);
  }
  get endB() {
    return Math.max(this.fromB, this.toB - 1);
  }
  static build(t, n, r) {
    return jR(UR(t.toString(), n.toString(), r), t, n, 0, 0);
  }
  static updateA(t, n, r, i, s) {
    return u6(h6(t, i, !0, r.length), t, n, r, s);
  }
  static updateB(t, n, r, i, s) {
    return u6(h6(t, i, !1, n.length), t, n, r, s);
  }
}
function a6(e, t, n, r) {
  let i = n.lineAt(e), s = r.lineAt(t);
  return i.to == e && s.to == t && e < n.length && t < r.length ? [e + 1, t + 1] : [i.from, s.from];
}
function l6(e, t, n, r) {
  let i = n.lineAt(e), s = r.lineAt(t);
  return i.from == e && s.from == t ? [e, t] : [i.to + 1, s.to + 1];
}
function jR(e, t, n, r, i) {
  let s = [];
  for (let o = 0; o < e.length; o++) {
    let a = e[o], [l, h] = a6(a.fromA + r, a.fromB + i, t, n), [u, f] = l6(a.toA + r, a.toB + i, t, n), d = [a.offset(-l + r, -h + i)];
    for (; o < e.length - 1; ) {
      let p = e[o + 1], [g, m] = a6(p.fromA + r, p.fromB + i, t, n);
      if (g > u + 1 && m > f + 1)
        break;
      d.push(p.offset(-l + r, -h + i)), [u, f] = l6(p.toA + r, p.toB + i, t, n), o++;
    }
    s.push(new vh(d, l, Math.max(l, u), h, Math.max(h, f)));
  }
  return s;
}
const X0 = 1e3;
function c6(e, t, n, r) {
  let i = 0, s = e.length;
  for (; ; ) {
    if (i == s) {
      let u = 0, f = 0;
      i && ({ toA: u, toB: f } = e[i - 1]);
      let d = t - (n ? u : f);
      return [u + d, f + d];
    }
    let o = i + s >> 1, a = e[o], [l, h] = n ? [a.fromA, a.toA] : [a.fromB, a.toB];
    if (l > t)
      s = o;
    else if (h <= t)
      i = o + 1;
    else
      return r ? [a.fromA, a.fromB] : [a.toA, a.toB];
  }
}
function h6(e, t, n, r) {
  let i = [];
  return t.iterChangedRanges((s, o, a, l) => {
    let h = 0, u = n ? t.length : r, f = 0, d = n ? r : t.length;
    s > X0 && ([h, f] = c6(e, s - X0, n, !0)), o < t.length - X0 && ([u, d] = c6(e, o + X0, n, !1));
    let p = l - a - (o - s), g, [m, y] = n ? [p, 0] : [0, p];
    i.length && (g = i[i.length - 1]).toA >= h ? i[i.length - 1] = {
      fromA: g.fromA,
      fromB: g.fromB,
      toA: u,
      toB: d,
      diffA: g.diffA + m,
      diffB: g.diffB + y
    } : i.push({ fromA: h, toA: u, fromB: f, toB: d, diffA: m, diffB: y });
  }), i;
}
function u6(e, t, n, r, i) {
  if (!e.length)
    return t;
  let s = 0, o = 0, a = 0, l = [];
  for (let h of e) {
    let u = h.fromA + o, f = h.toA + o + h.diffA, d = h.fromB + a, p = h.toB + a + h.diffB;
    for (; s < t.length; ) {
      let g = t[s];
      if (g.toA + o <= u && g.toB + a <= d)
        l.push(g.offset(o, a));
      else if (g.fromA + o > f)
        break;
      s++;
    }
    for (let g of jR(UR(n.sliceString(u, f), r.sliceString(d, p), i), n, r, u, d))
      l.push(g);
    o += h.diffA, a += h.diffB;
  }
  for (; s < t.length; )
    l.push(t[s++].offset(o, a));
  return l;
}
const XR = /* @__PURE__ */ He.fromClass(class {
  constructor(e) {
    ({ deco: this.deco, gutter: this.gutter } = p6(e));
  }
  update(e) {
    (e.docChanged || e.viewportChanged || Kit(e.startState, e.state) || Jit(e.startState, e.state)) && ({ deco: this.deco, gutter: this.gutter } = p6(e.view));
  }
}, {
  decorations: (e) => e.deco
}), G0 = /* @__PURE__ */ Ts.low(/* @__PURE__ */ B2({
  class: "cm-changeGutter",
  markers: (e) => {
    var t;
    return ((t = e.plugin(XR)) === null || t === void 0 ? void 0 : t.gutter) || Ne.empty;
  }
}));
function Kit(e, t) {
  return e.field(tu, !1) != t.field(tu, !1);
}
function Jit(e, t) {
  return e.facet(Ks) != t.facet(Ks);
}
const f6 = /* @__PURE__ */ Bt.line({ class: "cm-changedLine" }), tst = /* @__PURE__ */ Bt.mark({ class: "cm-changedText" }), est = /* @__PURE__ */ Bt.mark({ tagName: "ins", class: "cm-insertedLine" }), nst = /* @__PURE__ */ Bt.mark({ tagName: "del", class: "cm-deletedLine" }), d6 = /* @__PURE__ */ new class extends Yi {
  constructor() {
    super(...arguments), this.elementClass = "cm-changedLineGutter";
  }
}();
function rst(e, t, n, r, i, s) {
  let o = n ? e.fromA : e.fromB, a = n ? e.toA : e.toB, l = 0;
  if (o != a) {
    i.add(o, o, f6), i.add(o, a, n ? nst : est), s && s.add(o, o, d6);
    for (let h = t.iterRange(o, a - 1), u = o; !h.next().done; ) {
      if (h.lineBreak) {
        u++, i.add(u, u, f6), s && s.add(u, u, d6);
        continue;
      }
      let f = u + h.value.length;
      if (r)
        for (; l < e.changes.length; ) {
          let d = e.changes[l], p = o + (n ? d.fromA : d.fromB), g = o + (n ? d.toA : d.toB), m = Math.max(u, p), y = Math.min(f, g);
          if (m < y && i.add(m, y, tst), g < f)
            l++;
          else
            break;
        }
      u = f;
    }
  }
}
function p6(e) {
  let t = e.state.field(tu), { side: n, highlightChanges: r, markGutter: i } = e.state.facet(Ks), s = n == "a", o = new cr(), a = i ? new cr() : null, { from: l, to: h } = e.viewport;
  for (let u of t) {
    if ((s ? u.fromA : u.fromB) >= h)
      break;
    (s ? u.toA : u.toB) > l && rst(u, e.state.doc, s, r, o, a);
  }
  return { deco: o.finish(), gutter: a && a.finish() };
}
class H0 extends si {
  constructor(t) {
    super(), this.height = t;
  }
  eq(t) {
    return this.height == t.height;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-mergeSpacer", t.style.height = this.height + "px", t;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
const dm = /* @__PURE__ */ le.define({
  map: (e, t) => e.map(t)
}), Pf = /* @__PURE__ */ bn.define({
  create: () => Bt.none,
  update: (e, t) => {
    for (let n of t.effects)
      if (n.is(dm))
        return n.value;
    return e.map(t.changes);
  },
  provide: (e) => Pt.decorations.from(e)
}), K0 = 0.01;
function ist(e, t, n) {
  let r = new cr(), i = new cr(), s = e.state.field(Pf).iter(), o = t.state.field(Pf).iter(), a = 0, l = 0, h = 0, u = 0;
  for (let g = 0; ; g++) {
    let m = g < n.length ? n[g] : null;
    if (a < (m ? m.fromA : e.state.doc.length)) {
      let y = e.lineBlockAt(a).top + h, O = t.lineBlockAt(l).top + u, x = y - O;
      x < -K0 ? (h -= x, r.add(a, a, Bt.widget({
        widget: new H0(-x),
        block: !0,
        side: -1
      }))) : x > K0 && (u += x, i.add(l, l, Bt.widget({
        widget: new H0(x),
        block: !0,
        side: -1
      })));
    }
    if (!m)
      break;
    for (a = m.toA, l = m.toB; s.value && s.from < a; )
      h -= s.value.spec.widget.height, s.next();
    for (; o.value && o.from < l; )
      u -= o.value.spec.widget.height, o.next();
  }
  for (; s.value; )
    h -= s.value.spec.widget.height, s.next();
  for (; o.value; )
    u -= o.value.spec.widget.height, o.next();
  let f = e.contentHeight + h - (t.contentHeight + u);
  f < K0 ? r.add(e.state.doc.length, e.state.doc.length, Bt.widget({
    widget: new H0(-f),
    block: !0,
    side: 1
  })) : f > K0 && i.add(t.state.doc.length, t.state.doc.length, Bt.widget({
    widget: new H0(f),
    block: !0,
    side: 1
  }));
  let d = r.finish(), p = i.finish();
  Ne.eq([d], [e.state.field(Pf)]) || e.dispatch({ effects: dm.of(d) }), Ne.eq([p], [t.state.field(Pf)]) || t.dispatch({ effects: dm.of(p) });
}
const u_ = /* @__PURE__ */ le.define({
  map: (e, t) => t.mapPos(e)
});
class sst extends si {
  constructor(t) {
    super(), this.lines = t;
  }
  eq(t) {
    return this.lines == t.lines;
  }
  toDOM(t) {
    let n = document.createElement("div");
    return n.className = "cm-collapsedLines", n.textContent = "\u299A " + t.state.phrase("$ unchanged lines", this.lines) + " \u299A", n.addEventListener("click", (r) => {
      let i = t.posAtDOM(r.target);
      t.dispatch({ effects: u_.of(i) });
      let { side: s, sibling: o } = t.state.facet(Ks);
      o && o().dispatch({ effects: u_.of(ost(i, t.state.field(tu), s == "a")) });
    }), n;
  }
  ignoreEvent(t) {
    return t instanceof MouseEvent;
  }
  get estimatedHeight() {
    return 27;
  }
}
function ost(e, t, n) {
  let r = 0, i = 0;
  for (let s = 0; ; s++) {
    let o = s < t.length ? t[s] : null;
    if (!o || (n ? o.fromA : o.fromB) >= e)
      return i + (e - r);
    [r, i] = n ? [o.toA, o.toB] : [o.toB, o.toA];
  }
}
const ast = /* @__PURE__ */ bn.define({
  create(e) {
    return Bt.none;
  },
  update(e, t) {
    e = e.map(t.changes);
    for (let n of t.effects)
      n.is(u_) && (e = e.update({ filter: (r) => r != n.value }));
    return e;
  },
  provide: (e) => Pt.decorations.from(e)
});
function g6({ margin: e = 3, minSize: t = 4 }) {
  return ast.init((n) => lst(n, e, t));
}
function lst(e, t, n) {
  let r = new cr(), i = e.facet(Ks).side == "a", s = e.field(tu), o = 1;
  for (let a = 0; ; a++) {
    let l = a < s.length ? s[a] : null, h = a ? o + t : 1, u = l ? e.doc.lineAt(i ? l.fromA : l.fromB).number - 1 - t : e.doc.lines, f = u - h + 1;
    if (f >= n && r.add(e.doc.line(h).from, e.doc.line(u).to, Bt.replace({
      widget: new sst(f),
      block: !0
    })), !l)
      break;
    o = e.doc.lineAt(Math.min(e.doc.length, i ? l.toA : l.toB)).number;
  }
  return r.finish();
}
const cst = /* @__PURE__ */ Pt.styleModule.of(/* @__PURE__ */ new sa({
  ".cm-mergeView": {
    overflowY: "auto"
  },
  ".cm-mergeViewEditors": {
    display: "flex",
    alignItems: "stretch"
  },
  ".cm-mergeViewEditor": {
    flexGrow: 1,
    flexBasis: 0,
    overflow: "hidden"
  },
  ".cm-merge-revert": {
    width: "1.6em",
    flexGrow: 0,
    flexShrink: 0,
    position: "relative"
  },
  ".cm-merge-revert button": {
    position: "absolute",
    display: "block",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "center",
    background: "none",
    border: "none",
    font: "inherit",
    cursor: "pointer"
  }
})), hst = /* @__PURE__ */ Pt.baseTheme({
  ".cm-mergeView & .cm-scroller, .cm-mergeView &": {
    height: "auto !important",
    overflowY: "visible !important"
  },
  "&.cm-merge-a .cm-changedLine, .cm-deletedChunk": {
    backgroundColor: "rgba(160, 128, 100, .08)"
  },
  "&.cm-merge-b .cm-changedLine": {
    backgroundColor: "rgba(100, 160, 128, .08)"
  },
  "&light.cm-merge-a .cm-changedText, &light .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ee443366, #ee443366) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-a .cm-changedText, &dark .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ffaa9966, #ffaa9966) bottom/100% 2px no-repeat"
  },
  "&light.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#22bb2266, #22bb2266) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#88ff8866, #88ff8866) bottom/100% 2px no-repeat"
  },
  ".cm-insertedLine, .cm-deletedLine": {
    textDecoration: "none"
  },
  ".cm-deletedChunk": {
    paddingLeft: "6px",
    "& .cm-chunkButtons": {
      position: "absolute",
      insetInlineEnd: "5px"
    },
    "& button": {
      border: "none",
      cursor: "pointer",
      color: "white",
      margin: "0 2px",
      borderRadius: "3px",
      "&[name=accept]": { background: "#2a2" },
      "&[name=reject]": { background: "#d43" }
    }
  },
  ".cm-collapsedLines": {
    padding: "5px 5px 5px 10px",
    cursor: "pointer"
  },
  "&light .cm-collapsedLines": {
    color: "#444",
    background: "linear-gradient(to bottom, transparent 0, #f3f3f3 30%, #f3f3f3 70%, transparent 100%)"
  },
  "&dark .cm-collapsedLines": {
    color: "#ddd",
    background: "linear-gradient(to bottom, transparent 0, #222 30%, #222 70%, transparent 100%)"
  },
  ".cm-changeGutter": { width: "3px", paddingLeft: "1px" },
  "&light.cm-merge-a .cm-changedLineGutter, &light .cm-deletedLineGutter": { background: "#e43" },
  "&dark.cm-merge-a .cm-changedLineGutter, &dark .cm-deletedLineGutter": { background: "#fa9" },
  "&light.cm-merge-b .cm-changedLineGutter": { background: "#2b2" },
  "&dark.cm-merge-b .cm-changedLineGutter": { background: "#8f8" }
}), m6 = /* @__PURE__ */ new Sc(), J0 = /* @__PURE__ */ new Sc();
class ust {
  constructor(t) {
    this.revertDOM = null, this.revertToA = !1, this.revertToLeft = !1, this.measuring = -1, this.diffConf = t.diffConfig;
    let n = [
      Ts.low(XR),
      hst,
      cst,
      Pf,
      Pt.updateListener.of((f) => {
        this.measuring < 0 && (f.heightChanged || f.viewportChanged) && !f.transactions.some((d) => d.effects.some((p) => p.is(dm))) && this.measure();
      })
    ], r = [Ks.of({
      side: "a",
      sibling: () => this.b,
      highlightChanges: t.highlightChanges !== !1,
      markGutter: t.gutter !== !1
    })];
    t.gutter !== !1 && r.push(G0);
    let i = De.create({
      doc: t.a.doc,
      selection: t.a.selection,
      extensions: [
        t.a.extensions || [],
        Pt.editorAttributes.of({ class: "cm-merge-a" }),
        J0.of(r),
        n
      ]
    }), s = [Ks.of({
      side: "b",
      sibling: () => this.a,
      highlightChanges: t.highlightChanges !== !1,
      markGutter: t.gutter !== !1
    })];
    t.gutter !== !1 && s.push(G0);
    let o = De.create({
      doc: t.b.doc,
      selection: t.b.selection,
      extensions: [
        t.b.extensions || [],
        Pt.editorAttributes.of({ class: "cm-merge-b" }),
        J0.of(s),
        n
      ]
    });
    this.chunks = vh.build(i.doc, o.doc, this.diffConf);
    let a = [
      tu.init(() => this.chunks),
      m6.of(t.collapseUnchanged ? g6(t.collapseUnchanged) : [])
    ];
    i = i.update({ effects: le.appendConfig.of(a) }).state, o = o.update({ effects: le.appendConfig.of(a) }).state, this.dom = document.createElement("div"), this.dom.className = "cm-mergeView", this.editorDOM = this.dom.appendChild(document.createElement("div")), this.editorDOM.className = "cm-mergeViewEditors";
    let l = t.orientation || "a-b", h = document.createElement("div");
    h.className = "cm-mergeViewEditor";
    let u = document.createElement("div");
    u.className = "cm-mergeViewEditor", this.editorDOM.appendChild(l == "a-b" ? h : u), this.editorDOM.appendChild(l == "a-b" ? u : h), this.a = new Pt({
      state: i,
      parent: h,
      root: t.root,
      dispatchTransactions: (f) => this.dispatch(f, this.a)
    }), this.b = new Pt({
      state: o,
      parent: u,
      root: t.root,
      dispatchTransactions: (f) => this.dispatch(f, this.b)
    }), this.setupRevertControls(!!t.revertControls, t.revertControls == "b-to-a", t.renderRevertControl), t.parent && t.parent.appendChild(this.dom), this.scheduleMeasure();
  }
  dispatch(t, n) {
    if (t.some((r) => r.docChanged)) {
      let r = t[t.length - 1], i = t.reduce((o, a) => o.compose(a.changes), $n.empty(t[0].startState.doc.length));
      this.chunks = n == this.a ? vh.updateA(this.chunks, r.newDoc, this.b.state.doc, i, this.diffConf) : vh.updateB(this.chunks, this.a.state.doc, r.newDoc, i, this.diffConf), n.update([...t, r.state.update({ effects: h_.of(this.chunks) })]);
      let s = n == this.a ? this.b : this.a;
      s.update([s.state.update({ effects: h_.of(this.chunks) })]), this.scheduleMeasure();
    } else
      n.update(t);
  }
  reconfigure(t) {
    if ("diffConfig" in t && (this.diffConf = t.diffConfig), "orientation" in t) {
      let s = t.orientation != "b-a";
      if (s != (this.editorDOM.firstChild == this.a.dom.parentNode)) {
        let o = this.a.dom.parentNode, a = this.b.dom.parentNode;
        o.remove(), a.remove(), this.editorDOM.insertBefore(s ? o : a, this.editorDOM.firstChild), this.editorDOM.appendChild(s ? a : o), this.revertToLeft = !this.revertToLeft, this.revertDOM && (this.revertDOM.textContent = "");
      }
    }
    if ("revertControls" in t || "renderRevertControl" in t) {
      let s = !!this.revertDOM, o = this.revertToA, a = this.renderRevert;
      "revertControls" in t && (s = !!t.revertControls, o = t.revertControls == "b-to-a"), "renderRevertControl" in t && (a = t.renderRevertControl), this.setupRevertControls(s, o, a);
    }
    let n = "highlightChanges" in t, r = "gutter" in t, i = "collapseUnchanged" in t;
    if (n || r || i) {
      let s = [], o = [];
      if (n || r) {
        let a = this.a.state.facet(Ks), l = r ? t.gutter !== !1 : a.markGutter, h = n ? t.highlightChanges !== !1 : a.highlightChanges;
        s.push(J0.reconfigure([
          Ks.of({ side: "a", sibling: () => this.b, highlightChanges: h, markGutter: l }),
          l ? G0 : []
        ])), o.push(J0.reconfigure([
          Ks.of({ side: "b", sibling: () => this.a, highlightChanges: h, markGutter: l }),
          l ? G0 : []
        ]));
      }
      if (i) {
        let a = m6.reconfigure(t.collapseUnchanged ? g6(t.collapseUnchanged) : []);
        s.push(a), o.push(a);
      }
      this.a.dispatch({ effects: s }), this.b.dispatch({ effects: o });
    }
    this.scheduleMeasure();
  }
  setupRevertControls(t, n, r) {
    this.revertToA = n, this.revertToLeft = this.revertToA == (this.editorDOM.firstChild == this.a.dom.parentNode), this.renderRevert = r, !t && this.revertDOM ? (this.revertDOM.remove(), this.revertDOM = null) : t && !this.revertDOM ? (this.revertDOM = this.editorDOM.insertBefore(document.createElement("div"), this.editorDOM.firstChild.nextSibling), this.revertDOM.addEventListener("mousedown", (i) => this.revertClicked(i)), this.revertDOM.className = "cm-merge-revert") : this.revertDOM && (this.revertDOM.textContent = "");
  }
  scheduleMeasure() {
    if (this.measuring < 0) {
      let t = this.dom.ownerDocument.defaultView || window;
      this.measuring = t.requestAnimationFrame(() => {
        this.measuring = -1, this.measure();
      });
    }
  }
  measure() {
    ist(this.a, this.b, this.chunks), this.revertDOM && this.updateRevertButtons();
  }
  updateRevertButtons() {
    let t = this.revertDOM, n = t.firstChild, r = this.a.viewport, i = this.b.viewport;
    for (let s = 0; s < this.chunks.length; s++) {
      let o = this.chunks[s];
      if (o.fromA > r.to || o.fromB > i.to)
        break;
      if (o.fromA < r.from || o.fromB < i.from)
        continue;
      let a = this.a.lineBlockAt(o.fromA).top + "px";
      for (; n && +n.dataset.chunk < s; )
        n = y6(n);
      n && n.dataset.chunk == String(s) ? (n.style.top != a && (n.style.top = a), n = n.nextSibling) : t.insertBefore(this.renderRevertButton(a, s), n);
    }
    for (; n; )
      n = y6(n);
  }
  renderRevertButton(t, n) {
    let r;
    if (this.renderRevert)
      r = this.renderRevert();
    else {
      r = document.createElement("button");
      let i = this.a.state.phrase("Revert this chunk");
      r.setAttribute("aria-label", i), r.setAttribute("title", i), r.textContent = this.revertToLeft ? "\u21DC" : "\u21DD";
    }
    return r.style.top = t, r.setAttribute("data-chunk", String(n)), r;
  }
  revertClicked(t) {
    let n = t.target, r;
    for (; n && n.parentNode != this.revertDOM; )
      n = n.parentNode;
    if (n && (r = this.chunks[n.dataset.chunk])) {
      let [i, s, o, a, l, h] = this.revertToA ? [this.b, this.a, r.fromB, r.toB, r.fromA, r.toA] : [this.a, this.b, r.fromA, r.toA, r.fromB, r.toB], u = i.state.sliceDoc(o, Math.max(o, a - 1));
      o != a && h <= s.state.doc.length && (u += i.state.lineBreak), s.dispatch({
        changes: { from: l, to: Math.min(s.state.doc.length, h), insert: u },
        userEvent: "revert"
      }), t.preventDefault();
    }
  }
  destroy() {
    this.a.destroy(), this.b.destroy(), this.measuring > -1 && (this.dom.ownerDocument.defaultView || window).cancelAnimationFrame(this.measuring), this.dom.remove();
  }
}
function y6(e) {
  let t = e.nextSibling;
  return e.remove(), t;
}
const b6 = ue(IR)`
  width: 50%;
  display: block;
`, fst = ({
  old: e,
  current: t
}) => {
  const n = qa.basicSetup().readonly().create();
  return new ust({
    a: {
      doc: e,
      extensions: n
    },
    b: {
      doc: t,
      extensions: n
    },
    orientation: "b-a"
  });
}, GR = ({
  oldText: e,
  text: t
}) => {
  let n = us(null), r = us(null), i = us(null);
  return lr(() => {
    if (i.current)
      return !1;
    i.current = fst({
      old: e,
      current: t.get()
    }), n.current.appendChild(i.current.b.dom), r.current.appendChild(i.current.a.dom);
  }, []), Kt` <div style="display:flex; width: 100%">
    <${b6} ref=${n} />
    <${b6} ref=${r} />
  </div>`;
};
GR.defaultProps = {
  className: "diff"
};
var HR = { exports: {} }, Ve = {}, m3 = { exports: {} };
const dst = "\xC1", pst = "\xE1", gst = "\u0102", mst = "\u0103", yst = "\u223E", bst = "\u223F", Ost = "\u223E\u0333", xst = "\xC2", vst = "\xE2", _st = "\xB4", kst = "\u0410", wst = "\u0430", Sst = "\xC6", Cst = "\xE6", Tst = "\u2061", Est = "\u{1D504}", Ast = "\u{1D51E}", Pst = "\xC0", Dst = "\xE0", Lst = "\u2135", Mst = "\u2135", Rst = "\u0391", $st = "\u03B1", Ist = "\u0100", Nst = "\u0101", Bst = "\u2A3F", Fst = "&", Qst = "&", Zst = "\u2A55", Vst = "\u2A53", Yst = "\u2227", zst = "\u2A5C", qst = "\u2A58", Wst = "\u2A5A", Ust = "\u2220", jst = "\u29A4", Xst = "\u2220", Gst = "\u29A8", Hst = "\u29A9", Kst = "\u29AA", Jst = "\u29AB", tot = "\u29AC", eot = "\u29AD", not = "\u29AE", rot = "\u29AF", iot = "\u2221", sot = "\u221F", oot = "\u22BE", aot = "\u299D", lot = "\u2222", cot = "\xC5", hot = "\u237C", uot = "\u0104", fot = "\u0105", dot = "\u{1D538}", pot = "\u{1D552}", got = "\u2A6F", mot = "\u2248", yot = "\u2A70", bot = "\u224A", Oot = "\u224B", xot = "'", vot = "\u2061", _ot = "\u2248", kot = "\u224A", wot = "\xC5", Sot = "\xE5", Cot = "\u{1D49C}", Tot = "\u{1D4B6}", Eot = "\u2254", Aot = "*", Pot = "\u2248", Dot = "\u224D", Lot = "\xC3", Mot = "\xE3", Rot = "\xC4", $ot = "\xE4", Iot = "\u2233", Not = "\u2A11", Bot = "\u224C", Fot = "\u03F6", Qot = "\u2035", Zot = "\u223D", Vot = "\u22CD", Yot = "\u2216", zot = "\u2AE7", qot = "\u22BD", Wot = "\u2305", Uot = "\u2306", jot = "\u2305", Xot = "\u23B5", Got = "\u23B6", Hot = "\u224C", Kot = "\u0411", Jot = "\u0431", tat = "\u201E", eat = "\u2235", nat = "\u2235", rat = "\u2235", iat = "\u29B0", sat = "\u03F6", oat = "\u212C", aat = "\u212C", lat = "\u0392", cat = "\u03B2", hat = "\u2136", uat = "\u226C", fat = "\u{1D505}", dat = "\u{1D51F}", pat = "\u22C2", gat = "\u25EF", mat = "\u22C3", yat = "\u2A00", bat = "\u2A01", Oat = "\u2A02", xat = "\u2A06", vat = "\u2605", _at = "\u25BD", kat = "\u25B3", wat = "\u2A04", Sat = "\u22C1", Cat = "\u22C0", Tat = "\u290D", Eat = "\u29EB", Aat = "\u25AA", Pat = "\u25B4", Dat = "\u25BE", Lat = "\u25C2", Mat = "\u25B8", Rat = "\u2423", $at = "\u2592", Iat = "\u2591", Nat = "\u2593", Bat = "\u2588", Fat = "=\u20E5", Qat = "\u2261\u20E5", Zat = "\u2AED", Vat = "\u2310", Yat = "\u{1D539}", zat = "\u{1D553}", qat = "\u22A5", Wat = "\u22A5", Uat = "\u22C8", jat = "\u29C9", Xat = "\u2510", Gat = "\u2555", Hat = "\u2556", Kat = "\u2557", Jat = "\u250C", tlt = "\u2552", elt = "\u2553", nlt = "\u2554", rlt = "\u2500", ilt = "\u2550", slt = "\u252C", olt = "\u2564", alt = "\u2565", llt = "\u2566", clt = "\u2534", hlt = "\u2567", ult = "\u2568", flt = "\u2569", dlt = "\u229F", plt = "\u229E", glt = "\u22A0", mlt = "\u2518", ylt = "\u255B", blt = "\u255C", Olt = "\u255D", xlt = "\u2514", vlt = "\u2558", _lt = "\u2559", klt = "\u255A", wlt = "\u2502", Slt = "\u2551", Clt = "\u253C", Tlt = "\u256A", Elt = "\u256B", Alt = "\u256C", Plt = "\u2524", Dlt = "\u2561", Llt = "\u2562", Mlt = "\u2563", Rlt = "\u251C", $lt = "\u255E", Ilt = "\u255F", Nlt = "\u2560", Blt = "\u2035", Flt = "\u02D8", Qlt = "\u02D8", Zlt = "\xA6", Vlt = "\u{1D4B7}", Ylt = "\u212C", zlt = "\u204F", qlt = "\u223D", Wlt = "\u22CD", Ult = "\u29C5", jlt = "\\", Xlt = "\u27C8", Glt = "\u2022", Hlt = "\u2022", Klt = "\u224E", Jlt = "\u2AAE", tct = "\u224F", ect = "\u224E", nct = "\u224F", rct = "\u0106", ict = "\u0107", sct = "\u2A44", oct = "\u2A49", act = "\u2A4B", lct = "\u2229", cct = "\u22D2", hct = "\u2A47", uct = "\u2A40", fct = "\u2145", dct = "\u2229\uFE00", pct = "\u2041", gct = "\u02C7", mct = "\u212D", yct = "\u2A4D", bct = "\u010C", Oct = "\u010D", xct = "\xC7", vct = "\xE7", _ct = "\u0108", kct = "\u0109", wct = "\u2230", Sct = "\u2A4C", Cct = "\u2A50", Tct = "\u010A", Ect = "\u010B", Act = "\xB8", Pct = "\xB8", Dct = "\u29B2", Lct = "\xA2", Mct = "\xB7", Rct = "\xB7", $ct = "\u{1D520}", Ict = "\u212D", Nct = "\u0427", Bct = "\u0447", Fct = "\u2713", Qct = "\u2713", Zct = "\u03A7", Vct = "\u03C7", Yct = "\u02C6", zct = "\u2257", qct = "\u21BA", Wct = "\u21BB", Uct = "\u229B", jct = "\u229A", Xct = "\u229D", Gct = "\u2299", Hct = "\xAE", Kct = "\u24C8", Jct = "\u2296", tht = "\u2295", eht = "\u2297", nht = "\u25CB", rht = "\u29C3", iht = "\u2257", sht = "\u2A10", oht = "\u2AEF", aht = "\u29C2", lht = "\u2232", cht = "\u201D", hht = "\u2019", uht = "\u2663", fht = "\u2663", dht = ":", pht = "\u2237", ght = "\u2A74", mht = "\u2254", yht = "\u2254", bht = ",", Oht = "@", xht = "\u2201", vht = "\u2218", _ht = "\u2201", kht = "\u2102", wht = "\u2245", Sht = "\u2A6D", Cht = "\u2261", Tht = "\u222E", Eht = "\u222F", Aht = "\u222E", Pht = "\u{1D554}", Dht = "\u2102", Lht = "\u2210", Mht = "\u2210", Rht = "\xA9", $ht = "\xA9", Iht = "\u2117", Nht = "\u2233", Bht = "\u21B5", Fht = "\u2717", Qht = "\u2A2F", Zht = "\u{1D49E}", Vht = "\u{1D4B8}", Yht = "\u2ACF", zht = "\u2AD1", qht = "\u2AD0", Wht = "\u2AD2", Uht = "\u22EF", jht = "\u2938", Xht = "\u2935", Ght = "\u22DE", Hht = "\u22DF", Kht = "\u21B6", Jht = "\u293D", tut = "\u2A48", eut = "\u2A46", nut = "\u224D", rut = "\u222A", iut = "\u22D3", sut = "\u2A4A", out = "\u228D", aut = "\u2A45", lut = "\u222A\uFE00", cut = "\u21B7", hut = "\u293C", uut = "\u22DE", fut = "\u22DF", dut = "\u22CE", put = "\u22CF", gut = "\xA4", mut = "\u21B6", yut = "\u21B7", but = "\u22CE", Out = "\u22CF", xut = "\u2232", vut = "\u2231", _ut = "\u232D", kut = "\u2020", wut = "\u2021", Sut = "\u2138", Cut = "\u2193", Tut = "\u21A1", Eut = "\u21D3", Aut = "\u2010", Put = "\u2AE4", Dut = "\u22A3", Lut = "\u290F", Mut = "\u02DD", Rut = "\u010E", $ut = "\u010F", Iut = "\u0414", Nut = "\u0434", But = "\u2021", Fut = "\u21CA", Qut = "\u2145", Zut = "\u2146", Vut = "\u2911", Yut = "\u2A77", zut = "\xB0", qut = "\u2207", Wut = "\u0394", Uut = "\u03B4", jut = "\u29B1", Xut = "\u297F", Gut = "\u{1D507}", Hut = "\u{1D521}", Kut = "\u2965", Jut = "\u21C3", tft = "\u21C2", eft = "\xB4", nft = "\u02D9", rft = "\u02DD", ift = "`", sft = "\u02DC", oft = "\u22C4", aft = "\u22C4", lft = "\u22C4", cft = "\u2666", hft = "\u2666", uft = "\xA8", fft = "\u2146", dft = "\u03DD", pft = "\u22F2", gft = "\xF7", mft = "\xF7", yft = "\u22C7", bft = "\u22C7", Oft = "\u0402", xft = "\u0452", vft = "\u231E", _ft = "\u230D", kft = "$", wft = "\u{1D53B}", Sft = "\u{1D555}", Cft = "\xA8", Tft = "\u02D9", Eft = "\u20DC", Aft = "\u2250", Pft = "\u2251", Dft = "\u2250", Lft = "\u2238", Mft = "\u2214", Rft = "\u22A1", $ft = "\u2306", Ift = "\u222F", Nft = "\xA8", Bft = "\u21D3", Fft = "\u21D0", Qft = "\u21D4", Zft = "\u2AE4", Vft = "\u27F8", Yft = "\u27FA", zft = "\u27F9", qft = "\u21D2", Wft = "\u22A8", Uft = "\u21D1", jft = "\u21D5", Xft = "\u2225", Gft = "\u2913", Hft = "\u2193", Kft = "\u2193", Jft = "\u21D3", tdt = "\u21F5", edt = "\u0311", ndt = "\u21CA", rdt = "\u21C3", idt = "\u21C2", sdt = "\u2950", odt = "\u295E", adt = "\u2956", ldt = "\u21BD", cdt = "\u295F", hdt = "\u2957", udt = "\u21C1", fdt = "\u21A7", ddt = "\u22A4", pdt = "\u2910", gdt = "\u231F", mdt = "\u230C", ydt = "\u{1D49F}", bdt = "\u{1D4B9}", Odt = "\u0405", xdt = "\u0455", vdt = "\u29F6", _dt = "\u0110", kdt = "\u0111", wdt = "\u22F1", Sdt = "\u25BF", Cdt = "\u25BE", Tdt = "\u21F5", Edt = "\u296F", Adt = "\u29A6", Pdt = "\u040F", Ddt = "\u045F", Ldt = "\u27FF", Mdt = "\xC9", Rdt = "\xE9", $dt = "\u2A6E", Idt = "\u011A", Ndt = "\u011B", Bdt = "\xCA", Fdt = "\xEA", Qdt = "\u2256", Zdt = "\u2255", Vdt = "\u042D", Ydt = "\u044D", zdt = "\u2A77", qdt = "\u0116", Wdt = "\u0117", Udt = "\u2251", jdt = "\u2147", Xdt = "\u2252", Gdt = "\u{1D508}", Hdt = "\u{1D522}", Kdt = "\u2A9A", Jdt = "\xC8", tpt = "\xE8", ept = "\u2A96", npt = "\u2A98", rpt = "\u2A99", ipt = "\u2208", spt = "\u23E7", opt = "\u2113", apt = "\u2A95", lpt = "\u2A97", cpt = "\u0112", hpt = "\u0113", upt = "\u2205", fpt = "\u2205", dpt = "\u25FB", ppt = "\u2205", gpt = "\u25AB", mpt = "\u2004", ypt = "\u2005", bpt = "\u2003", Opt = "\u014A", xpt = "\u014B", vpt = "\u2002", _pt = "\u0118", kpt = "\u0119", wpt = "\u{1D53C}", Spt = "\u{1D556}", Cpt = "\u22D5", Tpt = "\u29E3", Ept = "\u2A71", Apt = "\u03B5", Ppt = "\u0395", Dpt = "\u03B5", Lpt = "\u03F5", Mpt = "\u2256", Rpt = "\u2255", $pt = "\u2242", Ipt = "\u2A96", Npt = "\u2A95", Bpt = "\u2A75", Fpt = "=", Qpt = "\u2242", Zpt = "\u225F", Vpt = "\u21CC", Ypt = "\u2261", zpt = "\u2A78", qpt = "\u29E5", Wpt = "\u2971", Upt = "\u2253", jpt = "\u212F", Xpt = "\u2130", Gpt = "\u2250", Hpt = "\u2A73", Kpt = "\u2242", Jpt = "\u0397", t0t = "\u03B7", e0t = "\xD0", n0t = "\xF0", r0t = "\xCB", i0t = "\xEB", s0t = "\u20AC", o0t = "!", a0t = "\u2203", l0t = "\u2203", c0t = "\u2130", h0t = "\u2147", u0t = "\u2147", f0t = "\u2252", d0t = "\u0424", p0t = "\u0444", g0t = "\u2640", m0t = "\uFB03", y0t = "\uFB00", b0t = "\uFB04", O0t = "\u{1D509}", x0t = "\u{1D523}", v0t = "\uFB01", _0t = "\u25FC", k0t = "\u25AA", w0t = "fj", S0t = "\u266D", C0t = "\uFB02", T0t = "\u25B1", E0t = "\u0192", A0t = "\u{1D53D}", P0t = "\u{1D557}", D0t = "\u2200", L0t = "\u2200", M0t = "\u22D4", R0t = "\u2AD9", $0t = "\u2131", I0t = "\u2A0D", N0t = "\xBD", B0t = "\u2153", F0t = "\xBC", Q0t = "\u2155", Z0t = "\u2159", V0t = "\u215B", Y0t = "\u2154", z0t = "\u2156", q0t = "\xBE", W0t = "\u2157", U0t = "\u215C", j0t = "\u2158", X0t = "\u215A", G0t = "\u215D", H0t = "\u215E", K0t = "\u2044", J0t = "\u2322", t1t = "\u{1D4BB}", e1t = "\u2131", n1t = "\u01F5", r1t = "\u0393", i1t = "\u03B3", s1t = "\u03DC", o1t = "\u03DD", a1t = "\u2A86", l1t = "\u011E", c1t = "\u011F", h1t = "\u0122", u1t = "\u011C", f1t = "\u011D", d1t = "\u0413", p1t = "\u0433", g1t = "\u0120", m1t = "\u0121", y1t = "\u2265", b1t = "\u2267", O1t = "\u2A8C", x1t = "\u22DB", v1t = "\u2265", _1t = "\u2267", k1t = "\u2A7E", w1t = "\u2AA9", S1t = "\u2A7E", C1t = "\u2A80", T1t = "\u2A82", E1t = "\u2A84", A1t = "\u22DB\uFE00", P1t = "\u2A94", D1t = "\u{1D50A}", L1t = "\u{1D524}", M1t = "\u226B", R1t = "\u22D9", $1t = "\u22D9", I1t = "\u2137", N1t = "\u0403", B1t = "\u0453", F1t = "\u2AA5", Q1t = "\u2277", Z1t = "\u2A92", V1t = "\u2AA4", Y1t = "\u2A8A", z1t = "\u2A8A", q1t = "\u2A88", W1t = "\u2269", U1t = "\u2A88", j1t = "\u2269", X1t = "\u22E7", G1t = "\u{1D53E}", H1t = "\u{1D558}", K1t = "`", J1t = "\u2265", tgt = "\u22DB", egt = "\u2267", ngt = "\u2AA2", rgt = "\u2277", igt = "\u2A7E", sgt = "\u2273", ogt = "\u{1D4A2}", agt = "\u210A", lgt = "\u2273", cgt = "\u2A8E", hgt = "\u2A90", ugt = "\u2AA7", fgt = "\u2A7A", dgt = ">", pgt = ">", ggt = "\u226B", mgt = "\u22D7", ygt = "\u2995", bgt = "\u2A7C", Ogt = "\u2A86", xgt = "\u2978", vgt = "\u22D7", _gt = "\u22DB", kgt = "\u2A8C", wgt = "\u2277", Sgt = "\u2273", Cgt = "\u2269\uFE00", Tgt = "\u2269\uFE00", Egt = "\u02C7", Agt = "\u200A", Pgt = "\xBD", Dgt = "\u210B", Lgt = "\u042A", Mgt = "\u044A", Rgt = "\u2948", $gt = "\u2194", Igt = "\u21D4", Ngt = "\u21AD", Bgt = "^", Fgt = "\u210F", Qgt = "\u0124", Zgt = "\u0125", Vgt = "\u2665", Ygt = "\u2665", zgt = "\u2026", qgt = "\u22B9", Wgt = "\u{1D525}", Ugt = "\u210C", jgt = "\u210B", Xgt = "\u2925", Ggt = "\u2926", Hgt = "\u21FF", Kgt = "\u223B", Jgt = "\u21A9", tmt = "\u21AA", emt = "\u{1D559}", nmt = "\u210D", rmt = "\u2015", imt = "\u2500", smt = "\u{1D4BD}", omt = "\u210B", amt = "\u210F", lmt = "\u0126", cmt = "\u0127", hmt = "\u224E", umt = "\u224F", fmt = "\u2043", dmt = "\u2010", pmt = "\xCD", gmt = "\xED", mmt = "\u2063", ymt = "\xCE", bmt = "\xEE", Omt = "\u0418", xmt = "\u0438", vmt = "\u0130", _mt = "\u0415", kmt = "\u0435", wmt = "\xA1", Smt = "\u21D4", Cmt = "\u{1D526}", Tmt = "\u2111", Emt = "\xCC", Amt = "\xEC", Pmt = "\u2148", Dmt = "\u2A0C", Lmt = "\u222D", Mmt = "\u29DC", Rmt = "\u2129", $mt = "\u0132", Imt = "\u0133", Nmt = "\u012A", Bmt = "\u012B", Fmt = "\u2111", Qmt = "\u2148", Zmt = "\u2110", Vmt = "\u2111", Ymt = "\u0131", zmt = "\u2111", qmt = "\u22B7", Wmt = "\u01B5", Umt = "\u21D2", jmt = "\u2105", Xmt = "\u221E", Gmt = "\u29DD", Hmt = "\u0131", Kmt = "\u22BA", Jmt = "\u222B", t2t = "\u222C", e2t = "\u2124", n2t = "\u222B", r2t = "\u22BA", i2t = "\u22C2", s2t = "\u2A17", o2t = "\u2A3C", a2t = "\u2063", l2t = "\u2062", c2t = "\u0401", h2t = "\u0451", u2t = "\u012E", f2t = "\u012F", d2t = "\u{1D540}", p2t = "\u{1D55A}", g2t = "\u0399", m2t = "\u03B9", y2t = "\u2A3C", b2t = "\xBF", O2t = "\u{1D4BE}", x2t = "\u2110", v2t = "\u2208", _2t = "\u22F5", k2t = "\u22F9", w2t = "\u22F4", S2t = "\u22F3", C2t = "\u2208", T2t = "\u2062", E2t = "\u0128", A2t = "\u0129", P2t = "\u0406", D2t = "\u0456", L2t = "\xCF", M2t = "\xEF", R2t = "\u0134", $2t = "\u0135", I2t = "\u0419", N2t = "\u0439", B2t = "\u{1D50D}", F2t = "\u{1D527}", Q2t = "\u0237", Z2t = "\u{1D541}", V2t = "\u{1D55B}", Y2t = "\u{1D4A5}", z2t = "\u{1D4BF}", q2t = "\u0408", W2t = "\u0458", U2t = "\u0404", j2t = "\u0454", X2t = "\u039A", G2t = "\u03BA", H2t = "\u03F0", K2t = "\u0136", J2t = "\u0137", tyt = "\u041A", eyt = "\u043A", nyt = "\u{1D50E}", ryt = "\u{1D528}", iyt = "\u0138", syt = "\u0425", oyt = "\u0445", ayt = "\u040C", lyt = "\u045C", cyt = "\u{1D542}", hyt = "\u{1D55C}", uyt = "\u{1D4A6}", fyt = "\u{1D4C0}", dyt = "\u21DA", pyt = "\u0139", gyt = "\u013A", myt = "\u29B4", yyt = "\u2112", byt = "\u039B", Oyt = "\u03BB", xyt = "\u27E8", vyt = "\u27EA", _yt = "\u2991", kyt = "\u27E8", wyt = "\u2A85", Syt = "\u2112", Cyt = "\xAB", Tyt = "\u21E4", Eyt = "\u291F", Ayt = "\u2190", Pyt = "\u219E", Dyt = "\u21D0", Lyt = "\u291D", Myt = "\u21A9", Ryt = "\u21AB", $yt = "\u2939", Iyt = "\u2973", Nyt = "\u21A2", Byt = "\u2919", Fyt = "\u291B", Qyt = "\u2AAB", Zyt = "\u2AAD", Vyt = "\u2AAD\uFE00", Yyt = "\u290C", zyt = "\u290E", qyt = "\u2772", Wyt = "{", Uyt = "[", jyt = "\u298B", Xyt = "\u298F", Gyt = "\u298D", Hyt = "\u013D", Kyt = "\u013E", Jyt = "\u013B", tbt = "\u013C", ebt = "\u2308", nbt = "{", rbt = "\u041B", ibt = "\u043B", sbt = "\u2936", obt = "\u201C", abt = "\u201E", lbt = "\u2967", cbt = "\u294B", hbt = "\u21B2", ubt = "\u2264", fbt = "\u2266", dbt = "\u27E8", pbt = "\u21E4", gbt = "\u2190", mbt = "\u2190", ybt = "\u21D0", bbt = "\u21C6", Obt = "\u21A2", xbt = "\u2308", vbt = "\u27E6", _bt = "\u2961", kbt = "\u2959", wbt = "\u21C3", Sbt = "\u230A", Cbt = "\u21BD", Tbt = "\u21BC", Ebt = "\u21C7", Abt = "\u2194", Pbt = "\u2194", Dbt = "\u21D4", Lbt = "\u21C6", Mbt = "\u21CB", Rbt = "\u21AD", $bt = "\u294E", Ibt = "\u21A4", Nbt = "\u22A3", Bbt = "\u295A", Fbt = "\u22CB", Qbt = "\u29CF", Zbt = "\u22B2", Vbt = "\u22B4", Ybt = "\u2951", zbt = "\u2960", qbt = "\u2958", Wbt = "\u21BF", Ubt = "\u2952", jbt = "\u21BC", Xbt = "\u2A8B", Gbt = "\u22DA", Hbt = "\u2264", Kbt = "\u2266", Jbt = "\u2A7D", tOt = "\u2AA8", eOt = "\u2A7D", nOt = "\u2A7F", rOt = "\u2A81", iOt = "\u2A83", sOt = "\u22DA\uFE00", oOt = "\u2A93", aOt = "\u2A85", lOt = "\u22D6", cOt = "\u22DA", hOt = "\u2A8B", uOt = "\u22DA", fOt = "\u2266", dOt = "\u2276", pOt = "\u2276", gOt = "\u2AA1", mOt = "\u2272", yOt = "\u2A7D", bOt = "\u2272", OOt = "\u297C", xOt = "\u230A", vOt = "\u{1D50F}", _Ot = "\u{1D529}", kOt = "\u2276", wOt = "\u2A91", SOt = "\u2962", COt = "\u21BD", TOt = "\u21BC", EOt = "\u296A", AOt = "\u2584", POt = "\u0409", DOt = "\u0459", LOt = "\u21C7", MOt = "\u226A", ROt = "\u22D8", $Ot = "\u231E", IOt = "\u21DA", NOt = "\u296B", BOt = "\u25FA", FOt = "\u013F", QOt = "\u0140", ZOt = "\u23B0", VOt = "\u23B0", YOt = "\u2A89", zOt = "\u2A89", qOt = "\u2A87", WOt = "\u2268", UOt = "\u2A87", jOt = "\u2268", XOt = "\u22E6", GOt = "\u27EC", HOt = "\u21FD", KOt = "\u27E6", JOt = "\u27F5", txt = "\u27F5", ext = "\u27F8", nxt = "\u27F7", rxt = "\u27F7", ixt = "\u27FA", sxt = "\u27FC", oxt = "\u27F6", axt = "\u27F6", lxt = "\u27F9", cxt = "\u21AB", hxt = "\u21AC", uxt = "\u2985", fxt = "\u{1D543}", dxt = "\u{1D55D}", pxt = "\u2A2D", gxt = "\u2A34", mxt = "\u2217", yxt = "_", bxt = "\u2199", Oxt = "\u2198", xxt = "\u25CA", vxt = "\u25CA", _xt = "\u29EB", kxt = "(", wxt = "\u2993", Sxt = "\u21C6", Cxt = "\u231F", Txt = "\u21CB", Ext = "\u296D", Axt = "\u200E", Pxt = "\u22BF", Dxt = "\u2039", Lxt = "\u{1D4C1}", Mxt = "\u2112", Rxt = "\u21B0", $xt = "\u21B0", Ixt = "\u2272", Nxt = "\u2A8D", Bxt = "\u2A8F", Fxt = "[", Qxt = "\u2018", Zxt = "\u201A", Vxt = "\u0141", Yxt = "\u0142", zxt = "\u2AA6", qxt = "\u2A79", Wxt = "<", Uxt = "<", jxt = "\u226A", Xxt = "\u22D6", Gxt = "\u22CB", Hxt = "\u22C9", Kxt = "\u2976", Jxt = "\u2A7B", tvt = "\u25C3", evt = "\u22B4", nvt = "\u25C2", rvt = "\u2996", ivt = "\u294A", svt = "\u2966", ovt = "\u2268\uFE00", avt = "\u2268\uFE00", lvt = "\xAF", cvt = "\u2642", hvt = "\u2720", uvt = "\u2720", fvt = "\u21A6", dvt = "\u21A6", pvt = "\u21A7", gvt = "\u21A4", mvt = "\u21A5", yvt = "\u25AE", bvt = "\u2A29", Ovt = "\u041C", xvt = "\u043C", vvt = "\u2014", _vt = "\u223A", kvt = "\u2221", wvt = "\u205F", Svt = "\u2133", Cvt = "\u{1D510}", Tvt = "\u{1D52A}", Evt = "\u2127", Avt = "\xB5", Pvt = "*", Dvt = "\u2AF0", Lvt = "\u2223", Mvt = "\xB7", Rvt = "\u229F", $vt = "\u2212", Ivt = "\u2238", Nvt = "\u2A2A", Bvt = "\u2213", Fvt = "\u2ADB", Qvt = "\u2026", Zvt = "\u2213", Vvt = "\u22A7", Yvt = "\u{1D544}", zvt = "\u{1D55E}", qvt = "\u2213", Wvt = "\u{1D4C2}", Uvt = "\u2133", jvt = "\u223E", Xvt = "\u039C", Gvt = "\u03BC", Hvt = "\u22B8", Kvt = "\u22B8", Jvt = "\u2207", t_t = "\u0143", e_t = "\u0144", n_t = "\u2220\u20D2", r_t = "\u2249", i_t = "\u2A70\u0338", s_t = "\u224B\u0338", o_t = "\u0149", a_t = "\u2249", l_t = "\u266E", c_t = "\u2115", h_t = "\u266E", u_t = "\xA0", f_t = "\u224E\u0338", d_t = "\u224F\u0338", p_t = "\u2A43", g_t = "\u0147", m_t = "\u0148", y_t = "\u0145", b_t = "\u0146", O_t = "\u2247", x_t = "\u2A6D\u0338", v_t = "\u2A42", __t = "\u041D", k_t = "\u043D", w_t = "\u2013", S_t = "\u2924", C_t = "\u2197", T_t = "\u21D7", E_t = "\u2197", A_t = "\u2260", P_t = "\u2250\u0338", D_t = "\u200B", L_t = "\u200B", M_t = "\u200B", R_t = "\u200B", $_t = "\u2262", I_t = "\u2928", N_t = "\u2242\u0338", B_t = "\u226B", F_t = "\u226A", Q_t = `
`, Z_t = "\u2204", V_t = "\u2204", Y_t = "\u{1D511}", z_t = "\u{1D52B}", q_t = "\u2267\u0338", W_t = "\u2271", U_t = "\u2271", j_t = "\u2267\u0338", X_t = "\u2A7E\u0338", G_t = "\u2A7E\u0338", H_t = "\u22D9\u0338", K_t = "\u2275", J_t = "\u226B\u20D2", tkt = "\u226F", ekt = "\u226F", nkt = "\u226B\u0338", rkt = "\u21AE", ikt = "\u21CE", skt = "\u2AF2", okt = "\u220B", akt = "\u22FC", lkt = "\u22FA", ckt = "\u220B", hkt = "\u040A", ukt = "\u045A", fkt = "\u219A", dkt = "\u21CD", pkt = "\u2025", gkt = "\u2266\u0338", mkt = "\u2270", ykt = "\u219A", bkt = "\u21CD", Okt = "\u21AE", xkt = "\u21CE", vkt = "\u2270", _kt = "\u2266\u0338", kkt = "\u2A7D\u0338", wkt = "\u2A7D\u0338", Skt = "\u226E", Ckt = "\u22D8\u0338", Tkt = "\u2274", Ekt = "\u226A\u20D2", Akt = "\u226E", Pkt = "\u22EA", Dkt = "\u22EC", Lkt = "\u226A\u0338", Mkt = "\u2224", Rkt = "\u2060", $kt = "\xA0", Ikt = "\u{1D55F}", Nkt = "\u2115", Bkt = "\u2AEC", Fkt = "\xAC", Qkt = "\u2262", Zkt = "\u226D", Vkt = "\u2226", Ykt = "\u2209", zkt = "\u2260", qkt = "\u2242\u0338", Wkt = "\u2204", Ukt = "\u226F", jkt = "\u2271", Xkt = "\u2267\u0338", Gkt = "\u226B\u0338", Hkt = "\u2279", Kkt = "\u2A7E\u0338", Jkt = "\u2275", twt = "\u224E\u0338", ewt = "\u224F\u0338", nwt = "\u2209", rwt = "\u22F5\u0338", iwt = "\u22F9\u0338", swt = "\u2209", owt = "\u22F7", awt = "\u22F6", lwt = "\u29CF\u0338", cwt = "\u22EA", hwt = "\u22EC", uwt = "\u226E", fwt = "\u2270", dwt = "\u2278", pwt = "\u226A\u0338", gwt = "\u2A7D\u0338", mwt = "\u2274", ywt = "\u2AA2\u0338", bwt = "\u2AA1\u0338", Owt = "\u220C", xwt = "\u220C", vwt = "\u22FE", _wt = "\u22FD", kwt = "\u2280", wwt = "\u2AAF\u0338", Swt = "\u22E0", Cwt = "\u220C", Twt = "\u29D0\u0338", Ewt = "\u22EB", Awt = "\u22ED", Pwt = "\u228F\u0338", Dwt = "\u22E2", Lwt = "\u2290\u0338", Mwt = "\u22E3", Rwt = "\u2282\u20D2", $wt = "\u2288", Iwt = "\u2281", Nwt = "\u2AB0\u0338", Bwt = "\u22E1", Fwt = "\u227F\u0338", Qwt = "\u2283\u20D2", Zwt = "\u2289", Vwt = "\u2241", Ywt = "\u2244", zwt = "\u2247", qwt = "\u2249", Wwt = "\u2224", Uwt = "\u2226", jwt = "\u2226", Xwt = "\u2AFD\u20E5", Gwt = "\u2202\u0338", Hwt = "\u2A14", Kwt = "\u2280", Jwt = "\u22E0", t3t = "\u2280", e3t = "\u2AAF\u0338", n3t = "\u2AAF\u0338", r3t = "\u2933\u0338", i3t = "\u219B", s3t = "\u21CF", o3t = "\u219D\u0338", a3t = "\u219B", l3t = "\u21CF", c3t = "\u22EB", h3t = "\u22ED", u3t = "\u2281", f3t = "\u22E1", d3t = "\u2AB0\u0338", p3t = "\u{1D4A9}", g3t = "\u{1D4C3}", m3t = "\u2224", y3t = "\u2226", b3t = "\u2241", O3t = "\u2244", x3t = "\u2244", v3t = "\u2224", _3t = "\u2226", k3t = "\u22E2", w3t = "\u22E3", S3t = "\u2284", C3t = "\u2AC5\u0338", T3t = "\u2288", E3t = "\u2282\u20D2", A3t = "\u2288", P3t = "\u2AC5\u0338", D3t = "\u2281", L3t = "\u2AB0\u0338", M3t = "\u2285", R3t = "\u2AC6\u0338", $3t = "\u2289", I3t = "\u2283\u20D2", N3t = "\u2289", B3t = "\u2AC6\u0338", F3t = "\u2279", Q3t = "\xD1", Z3t = "\xF1", V3t = "\u2278", Y3t = "\u22EA", z3t = "\u22EC", q3t = "\u22EB", W3t = "\u22ED", U3t = "\u039D", j3t = "\u03BD", X3t = "#", G3t = "\u2116", H3t = "\u2007", K3t = "\u224D\u20D2", J3t = "\u22AC", t5t = "\u22AD", e5t = "\u22AE", n5t = "\u22AF", r5t = "\u2265\u20D2", i5t = ">\u20D2", s5t = "\u2904", o5t = "\u29DE", a5t = "\u2902", l5t = "\u2264\u20D2", c5t = "<\u20D2", h5t = "\u22B4\u20D2", u5t = "\u2903", f5t = "\u22B5\u20D2", d5t = "\u223C\u20D2", p5t = "\u2923", g5t = "\u2196", m5t = "\u21D6", y5t = "\u2196", b5t = "\u2927", O5t = "\xD3", x5t = "\xF3", v5t = "\u229B", _5t = "\xD4", k5t = "\xF4", w5t = "\u229A", S5t = "\u041E", C5t = "\u043E", T5t = "\u229D", E5t = "\u0150", A5t = "\u0151", P5t = "\u2A38", D5t = "\u2299", L5t = "\u29BC", M5t = "\u0152", R5t = "\u0153", $5t = "\u29BF", I5t = "\u{1D512}", N5t = "\u{1D52C}", B5t = "\u02DB", F5t = "\xD2", Q5t = "\xF2", Z5t = "\u29C1", V5t = "\u29B5", Y5t = "\u03A9", z5t = "\u222E", q5t = "\u21BA", W5t = "\u29BE", U5t = "\u29BB", j5t = "\u203E", X5t = "\u29C0", G5t = "\u014C", H5t = "\u014D", K5t = "\u03A9", J5t = "\u03C9", tSt = "\u039F", eSt = "\u03BF", nSt = "\u29B6", rSt = "\u2296", iSt = "\u{1D546}", sSt = "\u{1D560}", oSt = "\u29B7", aSt = "\u201C", lSt = "\u2018", cSt = "\u29B9", hSt = "\u2295", uSt = "\u21BB", fSt = "\u2A54", dSt = "\u2228", pSt = "\u2A5D", gSt = "\u2134", mSt = "\u2134", ySt = "\xAA", bSt = "\xBA", OSt = "\u22B6", xSt = "\u2A56", vSt = "\u2A57", _St = "\u2A5B", kSt = "\u24C8", wSt = "\u{1D4AA}", SSt = "\u2134", CSt = "\xD8", TSt = "\xF8", ESt = "\u2298", ASt = "\xD5", PSt = "\xF5", DSt = "\u2A36", LSt = "\u2A37", MSt = "\u2297", RSt = "\xD6", $St = "\xF6", ISt = "\u233D", NSt = "\u203E", BSt = "\u23DE", FSt = "\u23B4", QSt = "\u23DC", ZSt = "\xB6", VSt = "\u2225", YSt = "\u2225", zSt = "\u2AF3", qSt = "\u2AFD", WSt = "\u2202", USt = "\u2202", jSt = "\u041F", XSt = "\u043F", GSt = "%", HSt = ".", KSt = "\u2030", JSt = "\u22A5", t4t = "\u2031", e4t = "\u{1D513}", n4t = "\u{1D52D}", r4t = "\u03A6", i4t = "\u03C6", s4t = "\u03D5", o4t = "\u2133", a4t = "\u260E", l4t = "\u03A0", c4t = "\u03C0", h4t = "\u22D4", u4t = "\u03D6", f4t = "\u210F", d4t = "\u210E", p4t = "\u210F", g4t = "\u2A23", m4t = "\u229E", y4t = "\u2A22", b4t = "+", O4t = "\u2214", x4t = "\u2A25", v4t = "\u2A72", _4t = "\xB1", k4t = "\xB1", w4t = "\u2A26", S4t = "\u2A27", C4t = "\xB1", T4t = "\u210C", E4t = "\u2A15", A4t = "\u{1D561}", P4t = "\u2119", D4t = "\xA3", L4t = "\u2AB7", M4t = "\u2ABB", R4t = "\u227A", $4t = "\u227C", I4t = "\u2AB7", N4t = "\u227A", B4t = "\u227C", F4t = "\u227A", Q4t = "\u2AAF", Z4t = "\u227C", V4t = "\u227E", Y4t = "\u2AAF", z4t = "\u2AB9", q4t = "\u2AB5", W4t = "\u22E8", U4t = "\u2AAF", j4t = "\u2AB3", X4t = "\u227E", G4t = "\u2032", H4t = "\u2033", K4t = "\u2119", J4t = "\u2AB9", tCt = "\u2AB5", eCt = "\u22E8", nCt = "\u220F", rCt = "\u220F", iCt = "\u232E", sCt = "\u2312", oCt = "\u2313", aCt = "\u221D", lCt = "\u221D", cCt = "\u2237", hCt = "\u221D", uCt = "\u227E", fCt = "\u22B0", dCt = "\u{1D4AB}", pCt = "\u{1D4C5}", gCt = "\u03A8", mCt = "\u03C8", yCt = "\u2008", bCt = "\u{1D514}", OCt = "\u{1D52E}", xCt = "\u2A0C", vCt = "\u{1D562}", _Ct = "\u211A", kCt = "\u2057", wCt = "\u{1D4AC}", SCt = "\u{1D4C6}", CCt = "\u210D", TCt = "\u2A16", ECt = "?", ACt = "\u225F", PCt = '"', DCt = '"', LCt = "\u21DB", MCt = "\u223D\u0331", RCt = "\u0154", $Ct = "\u0155", ICt = "\u221A", NCt = "\u29B3", BCt = "\u27E9", FCt = "\u27EB", QCt = "\u2992", ZCt = "\u29A5", VCt = "\u27E9", YCt = "\xBB", zCt = "\u2975", qCt = "\u21E5", WCt = "\u2920", UCt = "\u2933", jCt = "\u2192", XCt = "\u21A0", GCt = "\u21D2", HCt = "\u291E", KCt = "\u21AA", JCt = "\u21AC", tTt = "\u2945", eTt = "\u2974", nTt = "\u2916", rTt = "\u21A3", iTt = "\u219D", sTt = "\u291A", oTt = "\u291C", aTt = "\u2236", lTt = "\u211A", cTt = "\u290D", hTt = "\u290F", uTt = "\u2910", fTt = "\u2773", dTt = "}", pTt = "]", gTt = "\u298C", mTt = "\u298E", yTt = "\u2990", bTt = "\u0158", OTt = "\u0159", xTt = "\u0156", vTt = "\u0157", _Tt = "\u2309", kTt = "}", wTt = "\u0420", STt = "\u0440", CTt = "\u2937", TTt = "\u2969", ETt = "\u201D", ATt = "\u201D", PTt = "\u21B3", DTt = "\u211C", LTt = "\u211B", MTt = "\u211C", RTt = "\u211D", $Tt = "\u211C", ITt = "\u25AD", NTt = "\xAE", BTt = "\xAE", FTt = "\u220B", QTt = "\u21CB", ZTt = "\u296F", VTt = "\u297D", YTt = "\u230B", zTt = "\u{1D52F}", qTt = "\u211C", WTt = "\u2964", UTt = "\u21C1", jTt = "\u21C0", XTt = "\u296C", GTt = "\u03A1", HTt = "\u03C1", KTt = "\u03F1", JTt = "\u27E9", t6t = "\u21E5", e6t = "\u2192", n6t = "\u2192", r6t = "\u21D2", i6t = "\u21C4", s6t = "\u21A3", o6t = "\u2309", a6t = "\u27E7", l6t = "\u295D", c6t = "\u2955", h6t = "\u21C2", u6t = "\u230B", f6t = "\u21C1", d6t = "\u21C0", p6t = "\u21C4", g6t = "\u21CC", m6t = "\u21C9", y6t = "\u219D", b6t = "\u21A6", O6t = "\u22A2", x6t = "\u295B", v6t = "\u22CC", _6t = "\u29D0", k6t = "\u22B3", w6t = "\u22B5", S6t = "\u294F", C6t = "\u295C", T6t = "\u2954", E6t = "\u21BE", A6t = "\u2953", P6t = "\u21C0", D6t = "\u02DA", L6t = "\u2253", M6t = "\u21C4", R6t = "\u21CC", $6t = "\u200F", I6t = "\u23B1", N6t = "\u23B1", B6t = "\u2AEE", F6t = "\u27ED", Q6t = "\u21FE", Z6t = "\u27E7", V6t = "\u2986", Y6t = "\u{1D563}", z6t = "\u211D", q6t = "\u2A2E", W6t = "\u2A35", U6t = "\u2970", j6t = ")", X6t = "\u2994", G6t = "\u2A12", H6t = "\u21C9", K6t = "\u21DB", J6t = "\u203A", tEt = "\u{1D4C7}", eEt = "\u211B", nEt = "\u21B1", rEt = "\u21B1", iEt = "]", sEt = "\u2019", oEt = "\u2019", aEt = "\u22CC", lEt = "\u22CA", cEt = "\u25B9", hEt = "\u22B5", uEt = "\u25B8", fEt = "\u29CE", dEt = "\u29F4", pEt = "\u2968", gEt = "\u211E", mEt = "\u015A", yEt = "\u015B", bEt = "\u201A", OEt = "\u2AB8", xEt = "\u0160", vEt = "\u0161", _Et = "\u2ABC", kEt = "\u227B", wEt = "\u227D", SEt = "\u2AB0", CEt = "\u2AB4", TEt = "\u015E", EEt = "\u015F", AEt = "\u015C", PEt = "\u015D", DEt = "\u2ABA", LEt = "\u2AB6", MEt = "\u22E9", REt = "\u2A13", $Et = "\u227F", IEt = "\u0421", NEt = "\u0441", BEt = "\u22A1", FEt = "\u22C5", QEt = "\u2A66", ZEt = "\u2925", VEt = "\u2198", YEt = "\u21D8", zEt = "\u2198", qEt = "\xA7", WEt = ";", UEt = "\u2929", jEt = "\u2216", XEt = "\u2216", GEt = "\u2736", HEt = "\u{1D516}", KEt = "\u{1D530}", JEt = "\u2322", tAt = "\u266F", eAt = "\u0429", nAt = "\u0449", rAt = "\u0428", iAt = "\u0448", sAt = "\u2193", oAt = "\u2190", aAt = "\u2223", lAt = "\u2225", cAt = "\u2192", hAt = "\u2191", uAt = "\xAD", fAt = "\u03A3", dAt = "\u03C3", pAt = "\u03C2", gAt = "\u03C2", mAt = "\u223C", yAt = "\u2A6A", bAt = "\u2243", OAt = "\u2243", xAt = "\u2A9E", vAt = "\u2AA0", _At = "\u2A9D", kAt = "\u2A9F", wAt = "\u2246", SAt = "\u2A24", CAt = "\u2972", TAt = "\u2190", EAt = "\u2218", AAt = "\u2216", PAt = "\u2A33", DAt = "\u29E4", LAt = "\u2223", MAt = "\u2323", RAt = "\u2AAA", $At = "\u2AAC", IAt = "\u2AAC\uFE00", NAt = "\u042C", BAt = "\u044C", FAt = "\u233F", QAt = "\u29C4", ZAt = "/", VAt = "\u{1D54A}", YAt = "\u{1D564}", zAt = "\u2660", qAt = "\u2660", WAt = "\u2225", UAt = "\u2293", jAt = "\u2293\uFE00", XAt = "\u2294", GAt = "\u2294\uFE00", HAt = "\u221A", KAt = "\u228F", JAt = "\u2291", t8t = "\u228F", e8t = "\u2291", n8t = "\u2290", r8t = "\u2292", i8t = "\u2290", s8t = "\u2292", o8t = "\u25A1", a8t = "\u25A1", l8t = "\u2293", c8t = "\u228F", h8t = "\u2291", u8t = "\u2290", f8t = "\u2292", d8t = "\u2294", p8t = "\u25AA", g8t = "\u25A1", m8t = "\u25AA", y8t = "\u2192", b8t = "\u{1D4AE}", O8t = "\u{1D4C8}", x8t = "\u2216", v8t = "\u2323", _8t = "\u22C6", k8t = "\u22C6", w8t = "\u2606", S8t = "\u2605", C8t = "\u03F5", T8t = "\u03D5", E8t = "\xAF", A8t = "\u2282", P8t = "\u22D0", D8t = "\u2ABD", L8t = "\u2AC5", M8t = "\u2286", R8t = "\u2AC3", $8t = "\u2AC1", I8t = "\u2ACB", N8t = "\u228A", B8t = "\u2ABF", F8t = "\u2979", Q8t = "\u2282", Z8t = "\u22D0", V8t = "\u2286", Y8t = "\u2AC5", z8t = "\u2286", q8t = "\u228A", W8t = "\u2ACB", U8t = "\u2AC7", j8t = "\u2AD5", X8t = "\u2AD3", G8t = "\u2AB8", H8t = "\u227B", K8t = "\u227D", J8t = "\u227B", t7t = "\u2AB0", e7t = "\u227D", n7t = "\u227F", r7t = "\u2AB0", i7t = "\u2ABA", s7t = "\u2AB6", o7t = "\u22E9", a7t = "\u227F", l7t = "\u220B", c7t = "\u2211", h7t = "\u2211", u7t = "\u266A", f7t = "\xB9", d7t = "\xB2", p7t = "\xB3", g7t = "\u2283", m7t = "\u22D1", y7t = "\u2ABE", b7t = "\u2AD8", O7t = "\u2AC6", x7t = "\u2287", v7t = "\u2AC4", _7t = "\u2283", k7t = "\u2287", w7t = "\u27C9", S7t = "\u2AD7", C7t = "\u297B", T7t = "\u2AC2", E7t = "\u2ACC", A7t = "\u228B", P7t = "\u2AC0", D7t = "\u2283", L7t = "\u22D1", M7t = "\u2287", R7t = "\u2AC6", $7t = "\u228B", I7t = "\u2ACC", N7t = "\u2AC8", B7t = "\u2AD4", F7t = "\u2AD6", Q7t = "\u2926", Z7t = "\u2199", V7t = "\u21D9", Y7t = "\u2199", z7t = "\u292A", q7t = "\xDF", W7t = "	", U7t = "\u2316", j7t = "\u03A4", X7t = "\u03C4", G7t = "\u23B4", H7t = "\u0164", K7t = "\u0165", J7t = "\u0162", t9t = "\u0163", e9t = "\u0422", n9t = "\u0442", r9t = "\u20DB", i9t = "\u2315", s9t = "\u{1D517}", o9t = "\u{1D531}", a9t = "\u2234", l9t = "\u2234", c9t = "\u2234", h9t = "\u0398", u9t = "\u03B8", f9t = "\u03D1", d9t = "\u03D1", p9t = "\u2248", g9t = "\u223C", m9t = "\u205F\u200A", y9t = "\u2009", b9t = "\u2009", O9t = "\u2248", x9t = "\u223C", v9t = "\xDE", _9t = "\xFE", k9t = "\u02DC", w9t = "\u223C", S9t = "\u2243", C9t = "\u2245", T9t = "\u2248", E9t = "\u2A31", A9t = "\u22A0", P9t = "\xD7", D9t = "\u2A30", L9t = "\u222D", M9t = "\u2928", R9t = "\u2336", $9t = "\u2AF1", I9t = "\u22A4", N9t = "\u{1D54B}", B9t = "\u{1D565}", F9t = "\u2ADA", Q9t = "\u2929", Z9t = "\u2034", V9t = "\u2122", Y9t = "\u2122", z9t = "\u25B5", q9t = "\u25BF", W9t = "\u25C3", U9t = "\u22B4", j9t = "\u225C", X9t = "\u25B9", G9t = "\u22B5", H9t = "\u25EC", K9t = "\u225C", J9t = "\u2A3A", tPt = "\u20DB", ePt = "\u2A39", nPt = "\u29CD", rPt = "\u2A3B", iPt = "\u23E2", sPt = "\u{1D4AF}", oPt = "\u{1D4C9}", aPt = "\u0426", lPt = "\u0446", cPt = "\u040B", hPt = "\u045B", uPt = "\u0166", fPt = "\u0167", dPt = "\u226C", pPt = "\u219E", gPt = "\u21A0", mPt = "\xDA", yPt = "\xFA", bPt = "\u2191", OPt = "\u219F", xPt = "\u21D1", vPt = "\u2949", _Pt = "\u040E", kPt = "\u045E", wPt = "\u016C", SPt = "\u016D", CPt = "\xDB", TPt = "\xFB", EPt = "\u0423", APt = "\u0443", PPt = "\u21C5", DPt = "\u0170", LPt = "\u0171", MPt = "\u296E", RPt = "\u297E", $Pt = "\u{1D518}", IPt = "\u{1D532}", NPt = "\xD9", BPt = "\xF9", FPt = "\u2963", QPt = "\u21BF", ZPt = "\u21BE", VPt = "\u2580", YPt = "\u231C", zPt = "\u231C", qPt = "\u230F", WPt = "\u25F8", UPt = "\u016A", jPt = "\u016B", XPt = "\xA8", GPt = "_", HPt = "\u23DF", KPt = "\u23B5", JPt = "\u23DD", tDt = "\u22C3", eDt = "\u228E", nDt = "\u0172", rDt = "\u0173", iDt = "\u{1D54C}", sDt = "\u{1D566}", oDt = "\u2912", aDt = "\u2191", lDt = "\u2191", cDt = "\u21D1", hDt = "\u21C5", uDt = "\u2195", fDt = "\u2195", dDt = "\u21D5", pDt = "\u296E", gDt = "\u21BF", mDt = "\u21BE", yDt = "\u228E", bDt = "\u2196", ODt = "\u2197", xDt = "\u03C5", vDt = "\u03D2", _Dt = "\u03D2", kDt = "\u03A5", wDt = "\u03C5", SDt = "\u21A5", CDt = "\u22A5", TDt = "\u21C8", EDt = "\u231D", ADt = "\u231D", PDt = "\u230E", DDt = "\u016E", LDt = "\u016F", MDt = "\u25F9", RDt = "\u{1D4B0}", $Dt = "\u{1D4CA}", IDt = "\u22F0", NDt = "\u0168", BDt = "\u0169", FDt = "\u25B5", QDt = "\u25B4", ZDt = "\u21C8", VDt = "\xDC", YDt = "\xFC", zDt = "\u29A7", qDt = "\u299C", WDt = "\u03F5", UDt = "\u03F0", jDt = "\u2205", XDt = "\u03D5", GDt = "\u03D6", HDt = "\u221D", KDt = "\u2195", JDt = "\u21D5", tLt = "\u03F1", eLt = "\u03C2", nLt = "\u228A\uFE00", rLt = "\u2ACB\uFE00", iLt = "\u228B\uFE00", sLt = "\u2ACC\uFE00", oLt = "\u03D1", aLt = "\u22B2", lLt = "\u22B3", cLt = "\u2AE8", hLt = "\u2AEB", uLt = "\u2AE9", fLt = "\u0412", dLt = "\u0432", pLt = "\u22A2", gLt = "\u22A8", mLt = "\u22A9", yLt = "\u22AB", bLt = "\u2AE6", OLt = "\u22BB", xLt = "\u2228", vLt = "\u22C1", _Lt = "\u225A", kLt = "\u22EE", wLt = "|", SLt = "\u2016", CLt = "|", TLt = "\u2016", ELt = "\u2223", ALt = "|", PLt = "\u2758", DLt = "\u2240", LLt = "\u200A", MLt = "\u{1D519}", RLt = "\u{1D533}", $Lt = "\u22B2", ILt = "\u2282\u20D2", NLt = "\u2283\u20D2", BLt = "\u{1D54D}", FLt = "\u{1D567}", QLt = "\u221D", ZLt = "\u22B3", VLt = "\u{1D4B1}", YLt = "\u{1D4CB}", zLt = "\u2ACB\uFE00", qLt = "\u228A\uFE00", WLt = "\u2ACC\uFE00", ULt = "\u228B\uFE00", jLt = "\u22AA", XLt = "\u299A", GLt = "\u0174", HLt = "\u0175", KLt = "\u2A5F", JLt = "\u2227", tMt = "\u22C0", eMt = "\u2259", nMt = "\u2118", rMt = "\u{1D51A}", iMt = "\u{1D534}", sMt = "\u{1D54E}", oMt = "\u{1D568}", aMt = "\u2118", lMt = "\u2240", cMt = "\u2240", hMt = "\u{1D4B2}", uMt = "\u{1D4CC}", fMt = "\u22C2", dMt = "\u25EF", pMt = "\u22C3", gMt = "\u25BD", mMt = "\u{1D51B}", yMt = "\u{1D535}", bMt = "\u27F7", OMt = "\u27FA", xMt = "\u039E", vMt = "\u03BE", _Mt = "\u27F5", kMt = "\u27F8", wMt = "\u27FC", SMt = "\u22FB", CMt = "\u2A00", TMt = "\u{1D54F}", EMt = "\u{1D569}", AMt = "\u2A01", PMt = "\u2A02", DMt = "\u27F6", LMt = "\u27F9", MMt = "\u{1D4B3}", RMt = "\u{1D4CD}", $Mt = "\u2A06", IMt = "\u2A04", NMt = "\u25B3", BMt = "\u22C1", FMt = "\u22C0", QMt = "\xDD", ZMt = "\xFD", VMt = "\u042F", YMt = "\u044F", zMt = "\u0176", qMt = "\u0177", WMt = "\u042B", UMt = "\u044B", jMt = "\xA5", XMt = "\u{1D51C}", GMt = "\u{1D536}", HMt = "\u0407", KMt = "\u0457", JMt = "\u{1D550}", tRt = "\u{1D56A}", eRt = "\u{1D4B4}", nRt = "\u{1D4CE}", rRt = "\u042E", iRt = "\u044E", sRt = "\xFF", oRt = "\u0178", aRt = "\u0179", lRt = "\u017A", cRt = "\u017D", hRt = "\u017E", uRt = "\u0417", fRt = "\u0437", dRt = "\u017B", pRt = "\u017C", gRt = "\u2128", mRt = "\u200B", yRt = "\u0396", bRt = "\u03B6", ORt = "\u{1D537}", xRt = "\u2128", vRt = "\u0416", _Rt = "\u0436", kRt = "\u21DD", wRt = "\u{1D56B}", SRt = "\u2124", CRt = "\u{1D4B5}", TRt = "\u{1D4CF}", ERt = "\u200D", ARt = "\u200C", PRt = {
  Aacute: dst,
  aacute: pst,
  Abreve: gst,
  abreve: mst,
  ac: yst,
  acd: bst,
  acE: Ost,
  Acirc: xst,
  acirc: vst,
  acute: _st,
  Acy: kst,
  acy: wst,
  AElig: Sst,
  aelig: Cst,
  af: Tst,
  Afr: Est,
  afr: Ast,
  Agrave: Pst,
  agrave: Dst,
  alefsym: Lst,
  aleph: Mst,
  Alpha: Rst,
  alpha: $st,
  Amacr: Ist,
  amacr: Nst,
  amalg: Bst,
  amp: Fst,
  AMP: Qst,
  andand: Zst,
  And: Vst,
  and: Yst,
  andd: zst,
  andslope: qst,
  andv: Wst,
  ang: Ust,
  ange: jst,
  angle: Xst,
  angmsdaa: Gst,
  angmsdab: Hst,
  angmsdac: Kst,
  angmsdad: Jst,
  angmsdae: tot,
  angmsdaf: eot,
  angmsdag: not,
  angmsdah: rot,
  angmsd: iot,
  angrt: sot,
  angrtvb: oot,
  angrtvbd: aot,
  angsph: lot,
  angst: cot,
  angzarr: hot,
  Aogon: uot,
  aogon: fot,
  Aopf: dot,
  aopf: pot,
  apacir: got,
  ap: mot,
  apE: yot,
  ape: bot,
  apid: Oot,
  apos: xot,
  ApplyFunction: vot,
  approx: _ot,
  approxeq: kot,
  Aring: wot,
  aring: Sot,
  Ascr: Cot,
  ascr: Tot,
  Assign: Eot,
  ast: Aot,
  asymp: Pot,
  asympeq: Dot,
  Atilde: Lot,
  atilde: Mot,
  Auml: Rot,
  auml: $ot,
  awconint: Iot,
  awint: Not,
  backcong: Bot,
  backepsilon: Fot,
  backprime: Qot,
  backsim: Zot,
  backsimeq: Vot,
  Backslash: Yot,
  Barv: zot,
  barvee: qot,
  barwed: Wot,
  Barwed: Uot,
  barwedge: jot,
  bbrk: Xot,
  bbrktbrk: Got,
  bcong: Hot,
  Bcy: Kot,
  bcy: Jot,
  bdquo: tat,
  becaus: eat,
  because: nat,
  Because: rat,
  bemptyv: iat,
  bepsi: sat,
  bernou: oat,
  Bernoullis: aat,
  Beta: lat,
  beta: cat,
  beth: hat,
  between: uat,
  Bfr: fat,
  bfr: dat,
  bigcap: pat,
  bigcirc: gat,
  bigcup: mat,
  bigodot: yat,
  bigoplus: bat,
  bigotimes: Oat,
  bigsqcup: xat,
  bigstar: vat,
  bigtriangledown: _at,
  bigtriangleup: kat,
  biguplus: wat,
  bigvee: Sat,
  bigwedge: Cat,
  bkarow: Tat,
  blacklozenge: Eat,
  blacksquare: Aat,
  blacktriangle: Pat,
  blacktriangledown: Dat,
  blacktriangleleft: Lat,
  blacktriangleright: Mat,
  blank: Rat,
  blk12: $at,
  blk14: Iat,
  blk34: Nat,
  block: Bat,
  bne: Fat,
  bnequiv: Qat,
  bNot: Zat,
  bnot: Vat,
  Bopf: Yat,
  bopf: zat,
  bot: qat,
  bottom: Wat,
  bowtie: Uat,
  boxbox: jat,
  boxdl: Xat,
  boxdL: Gat,
  boxDl: Hat,
  boxDL: Kat,
  boxdr: Jat,
  boxdR: tlt,
  boxDr: elt,
  boxDR: nlt,
  boxh: rlt,
  boxH: ilt,
  boxhd: slt,
  boxHd: olt,
  boxhD: alt,
  boxHD: llt,
  boxhu: clt,
  boxHu: hlt,
  boxhU: ult,
  boxHU: flt,
  boxminus: dlt,
  boxplus: plt,
  boxtimes: glt,
  boxul: mlt,
  boxuL: ylt,
  boxUl: blt,
  boxUL: Olt,
  boxur: xlt,
  boxuR: vlt,
  boxUr: _lt,
  boxUR: klt,
  boxv: wlt,
  boxV: Slt,
  boxvh: Clt,
  boxvH: Tlt,
  boxVh: Elt,
  boxVH: Alt,
  boxvl: Plt,
  boxvL: Dlt,
  boxVl: Llt,
  boxVL: Mlt,
  boxvr: Rlt,
  boxvR: $lt,
  boxVr: Ilt,
  boxVR: Nlt,
  bprime: Blt,
  breve: Flt,
  Breve: Qlt,
  brvbar: Zlt,
  bscr: Vlt,
  Bscr: Ylt,
  bsemi: zlt,
  bsim: qlt,
  bsime: Wlt,
  bsolb: Ult,
  bsol: jlt,
  bsolhsub: Xlt,
  bull: Glt,
  bullet: Hlt,
  bump: Klt,
  bumpE: Jlt,
  bumpe: tct,
  Bumpeq: ect,
  bumpeq: nct,
  Cacute: rct,
  cacute: ict,
  capand: sct,
  capbrcup: oct,
  capcap: act,
  cap: lct,
  Cap: cct,
  capcup: hct,
  capdot: uct,
  CapitalDifferentialD: fct,
  caps: dct,
  caret: pct,
  caron: gct,
  Cayleys: mct,
  ccaps: yct,
  Ccaron: bct,
  ccaron: Oct,
  Ccedil: xct,
  ccedil: vct,
  Ccirc: _ct,
  ccirc: kct,
  Cconint: wct,
  ccups: Sct,
  ccupssm: Cct,
  Cdot: Tct,
  cdot: Ect,
  cedil: Act,
  Cedilla: Pct,
  cemptyv: Dct,
  cent: Lct,
  centerdot: Mct,
  CenterDot: Rct,
  cfr: $ct,
  Cfr: Ict,
  CHcy: Nct,
  chcy: Bct,
  check: Fct,
  checkmark: Qct,
  Chi: Zct,
  chi: Vct,
  circ: Yct,
  circeq: zct,
  circlearrowleft: qct,
  circlearrowright: Wct,
  circledast: Uct,
  circledcirc: jct,
  circleddash: Xct,
  CircleDot: Gct,
  circledR: Hct,
  circledS: Kct,
  CircleMinus: Jct,
  CirclePlus: tht,
  CircleTimes: eht,
  cir: nht,
  cirE: rht,
  cire: iht,
  cirfnint: sht,
  cirmid: oht,
  cirscir: aht,
  ClockwiseContourIntegral: lht,
  CloseCurlyDoubleQuote: cht,
  CloseCurlyQuote: hht,
  clubs: uht,
  clubsuit: fht,
  colon: dht,
  Colon: pht,
  Colone: ght,
  colone: mht,
  coloneq: yht,
  comma: bht,
  commat: Oht,
  comp: xht,
  compfn: vht,
  complement: _ht,
  complexes: kht,
  cong: wht,
  congdot: Sht,
  Congruent: Cht,
  conint: Tht,
  Conint: Eht,
  ContourIntegral: Aht,
  copf: Pht,
  Copf: Dht,
  coprod: Lht,
  Coproduct: Mht,
  copy: Rht,
  COPY: $ht,
  copysr: Iht,
  CounterClockwiseContourIntegral: Nht,
  crarr: Bht,
  cross: Fht,
  Cross: Qht,
  Cscr: Zht,
  cscr: Vht,
  csub: Yht,
  csube: zht,
  csup: qht,
  csupe: Wht,
  ctdot: Uht,
  cudarrl: jht,
  cudarrr: Xht,
  cuepr: Ght,
  cuesc: Hht,
  cularr: Kht,
  cularrp: Jht,
  cupbrcap: tut,
  cupcap: eut,
  CupCap: nut,
  cup: rut,
  Cup: iut,
  cupcup: sut,
  cupdot: out,
  cupor: aut,
  cups: lut,
  curarr: cut,
  curarrm: hut,
  curlyeqprec: uut,
  curlyeqsucc: fut,
  curlyvee: dut,
  curlywedge: put,
  curren: gut,
  curvearrowleft: mut,
  curvearrowright: yut,
  cuvee: but,
  cuwed: Out,
  cwconint: xut,
  cwint: vut,
  cylcty: _ut,
  dagger: kut,
  Dagger: wut,
  daleth: Sut,
  darr: Cut,
  Darr: Tut,
  dArr: Eut,
  dash: Aut,
  Dashv: Put,
  dashv: Dut,
  dbkarow: Lut,
  dblac: Mut,
  Dcaron: Rut,
  dcaron: $ut,
  Dcy: Iut,
  dcy: Nut,
  ddagger: But,
  ddarr: Fut,
  DD: Qut,
  dd: Zut,
  DDotrahd: Vut,
  ddotseq: Yut,
  deg: zut,
  Del: qut,
  Delta: Wut,
  delta: Uut,
  demptyv: jut,
  dfisht: Xut,
  Dfr: Gut,
  dfr: Hut,
  dHar: Kut,
  dharl: Jut,
  dharr: tft,
  DiacriticalAcute: eft,
  DiacriticalDot: nft,
  DiacriticalDoubleAcute: rft,
  DiacriticalGrave: ift,
  DiacriticalTilde: sft,
  diam: oft,
  diamond: aft,
  Diamond: lft,
  diamondsuit: cft,
  diams: hft,
  die: uft,
  DifferentialD: fft,
  digamma: dft,
  disin: pft,
  div: gft,
  divide: mft,
  divideontimes: yft,
  divonx: bft,
  DJcy: Oft,
  djcy: xft,
  dlcorn: vft,
  dlcrop: _ft,
  dollar: kft,
  Dopf: wft,
  dopf: Sft,
  Dot: Cft,
  dot: Tft,
  DotDot: Eft,
  doteq: Aft,
  doteqdot: Pft,
  DotEqual: Dft,
  dotminus: Lft,
  dotplus: Mft,
  dotsquare: Rft,
  doublebarwedge: $ft,
  DoubleContourIntegral: Ift,
  DoubleDot: Nft,
  DoubleDownArrow: Bft,
  DoubleLeftArrow: Fft,
  DoubleLeftRightArrow: Qft,
  DoubleLeftTee: Zft,
  DoubleLongLeftArrow: Vft,
  DoubleLongLeftRightArrow: Yft,
  DoubleLongRightArrow: zft,
  DoubleRightArrow: qft,
  DoubleRightTee: Wft,
  DoubleUpArrow: Uft,
  DoubleUpDownArrow: jft,
  DoubleVerticalBar: Xft,
  DownArrowBar: Gft,
  downarrow: Hft,
  DownArrow: Kft,
  Downarrow: Jft,
  DownArrowUpArrow: tdt,
  DownBreve: edt,
  downdownarrows: ndt,
  downharpoonleft: rdt,
  downharpoonright: idt,
  DownLeftRightVector: sdt,
  DownLeftTeeVector: odt,
  DownLeftVectorBar: adt,
  DownLeftVector: ldt,
  DownRightTeeVector: cdt,
  DownRightVectorBar: hdt,
  DownRightVector: udt,
  DownTeeArrow: fdt,
  DownTee: ddt,
  drbkarow: pdt,
  drcorn: gdt,
  drcrop: mdt,
  Dscr: ydt,
  dscr: bdt,
  DScy: Odt,
  dscy: xdt,
  dsol: vdt,
  Dstrok: _dt,
  dstrok: kdt,
  dtdot: wdt,
  dtri: Sdt,
  dtrif: Cdt,
  duarr: Tdt,
  duhar: Edt,
  dwangle: Adt,
  DZcy: Pdt,
  dzcy: Ddt,
  dzigrarr: Ldt,
  Eacute: Mdt,
  eacute: Rdt,
  easter: $dt,
  Ecaron: Idt,
  ecaron: Ndt,
  Ecirc: Bdt,
  ecirc: Fdt,
  ecir: Qdt,
  ecolon: Zdt,
  Ecy: Vdt,
  ecy: Ydt,
  eDDot: zdt,
  Edot: qdt,
  edot: Wdt,
  eDot: Udt,
  ee: jdt,
  efDot: Xdt,
  Efr: Gdt,
  efr: Hdt,
  eg: Kdt,
  Egrave: Jdt,
  egrave: tpt,
  egs: ept,
  egsdot: npt,
  el: rpt,
  Element: ipt,
  elinters: spt,
  ell: opt,
  els: apt,
  elsdot: lpt,
  Emacr: cpt,
  emacr: hpt,
  empty: upt,
  emptyset: fpt,
  EmptySmallSquare: dpt,
  emptyv: ppt,
  EmptyVerySmallSquare: gpt,
  emsp13: mpt,
  emsp14: ypt,
  emsp: bpt,
  ENG: Opt,
  eng: xpt,
  ensp: vpt,
  Eogon: _pt,
  eogon: kpt,
  Eopf: wpt,
  eopf: Spt,
  epar: Cpt,
  eparsl: Tpt,
  eplus: Ept,
  epsi: Apt,
  Epsilon: Ppt,
  epsilon: Dpt,
  epsiv: Lpt,
  eqcirc: Mpt,
  eqcolon: Rpt,
  eqsim: $pt,
  eqslantgtr: Ipt,
  eqslantless: Npt,
  Equal: Bpt,
  equals: Fpt,
  EqualTilde: Qpt,
  equest: Zpt,
  Equilibrium: Vpt,
  equiv: Ypt,
  equivDD: zpt,
  eqvparsl: qpt,
  erarr: Wpt,
  erDot: Upt,
  escr: jpt,
  Escr: Xpt,
  esdot: Gpt,
  Esim: Hpt,
  esim: Kpt,
  Eta: Jpt,
  eta: t0t,
  ETH: e0t,
  eth: n0t,
  Euml: r0t,
  euml: i0t,
  euro: s0t,
  excl: o0t,
  exist: a0t,
  Exists: l0t,
  expectation: c0t,
  exponentiale: h0t,
  ExponentialE: u0t,
  fallingdotseq: f0t,
  Fcy: d0t,
  fcy: p0t,
  female: g0t,
  ffilig: m0t,
  fflig: y0t,
  ffllig: b0t,
  Ffr: O0t,
  ffr: x0t,
  filig: v0t,
  FilledSmallSquare: _0t,
  FilledVerySmallSquare: k0t,
  fjlig: w0t,
  flat: S0t,
  fllig: C0t,
  fltns: T0t,
  fnof: E0t,
  Fopf: A0t,
  fopf: P0t,
  forall: D0t,
  ForAll: L0t,
  fork: M0t,
  forkv: R0t,
  Fouriertrf: $0t,
  fpartint: I0t,
  frac12: N0t,
  frac13: B0t,
  frac14: F0t,
  frac15: Q0t,
  frac16: Z0t,
  frac18: V0t,
  frac23: Y0t,
  frac25: z0t,
  frac34: q0t,
  frac35: W0t,
  frac38: U0t,
  frac45: j0t,
  frac56: X0t,
  frac58: G0t,
  frac78: H0t,
  frasl: K0t,
  frown: J0t,
  fscr: t1t,
  Fscr: e1t,
  gacute: n1t,
  Gamma: r1t,
  gamma: i1t,
  Gammad: s1t,
  gammad: o1t,
  gap: a1t,
  Gbreve: l1t,
  gbreve: c1t,
  Gcedil: h1t,
  Gcirc: u1t,
  gcirc: f1t,
  Gcy: d1t,
  gcy: p1t,
  Gdot: g1t,
  gdot: m1t,
  ge: y1t,
  gE: b1t,
  gEl: O1t,
  gel: x1t,
  geq: v1t,
  geqq: _1t,
  geqslant: k1t,
  gescc: w1t,
  ges: S1t,
  gesdot: C1t,
  gesdoto: T1t,
  gesdotol: E1t,
  gesl: A1t,
  gesles: P1t,
  Gfr: D1t,
  gfr: L1t,
  gg: M1t,
  Gg: R1t,
  ggg: $1t,
  gimel: I1t,
  GJcy: N1t,
  gjcy: B1t,
  gla: F1t,
  gl: Q1t,
  glE: Z1t,
  glj: V1t,
  gnap: Y1t,
  gnapprox: z1t,
  gne: q1t,
  gnE: W1t,
  gneq: U1t,
  gneqq: j1t,
  gnsim: X1t,
  Gopf: G1t,
  gopf: H1t,
  grave: K1t,
  GreaterEqual: J1t,
  GreaterEqualLess: tgt,
  GreaterFullEqual: egt,
  GreaterGreater: ngt,
  GreaterLess: rgt,
  GreaterSlantEqual: igt,
  GreaterTilde: sgt,
  Gscr: ogt,
  gscr: agt,
  gsim: lgt,
  gsime: cgt,
  gsiml: hgt,
  gtcc: ugt,
  gtcir: fgt,
  gt: dgt,
  GT: pgt,
  Gt: ggt,
  gtdot: mgt,
  gtlPar: ygt,
  gtquest: bgt,
  gtrapprox: Ogt,
  gtrarr: xgt,
  gtrdot: vgt,
  gtreqless: _gt,
  gtreqqless: kgt,
  gtrless: wgt,
  gtrsim: Sgt,
  gvertneqq: Cgt,
  gvnE: Tgt,
  Hacek: Egt,
  hairsp: Agt,
  half: Pgt,
  hamilt: Dgt,
  HARDcy: Lgt,
  hardcy: Mgt,
  harrcir: Rgt,
  harr: $gt,
  hArr: Igt,
  harrw: Ngt,
  Hat: Bgt,
  hbar: Fgt,
  Hcirc: Qgt,
  hcirc: Zgt,
  hearts: Vgt,
  heartsuit: Ygt,
  hellip: zgt,
  hercon: qgt,
  hfr: Wgt,
  Hfr: Ugt,
  HilbertSpace: jgt,
  hksearow: Xgt,
  hkswarow: Ggt,
  hoarr: Hgt,
  homtht: Kgt,
  hookleftarrow: Jgt,
  hookrightarrow: tmt,
  hopf: emt,
  Hopf: nmt,
  horbar: rmt,
  HorizontalLine: imt,
  hscr: smt,
  Hscr: omt,
  hslash: amt,
  Hstrok: lmt,
  hstrok: cmt,
  HumpDownHump: hmt,
  HumpEqual: umt,
  hybull: fmt,
  hyphen: dmt,
  Iacute: pmt,
  iacute: gmt,
  ic: mmt,
  Icirc: ymt,
  icirc: bmt,
  Icy: Omt,
  icy: xmt,
  Idot: vmt,
  IEcy: _mt,
  iecy: kmt,
  iexcl: wmt,
  iff: Smt,
  ifr: Cmt,
  Ifr: Tmt,
  Igrave: Emt,
  igrave: Amt,
  ii: Pmt,
  iiiint: Dmt,
  iiint: Lmt,
  iinfin: Mmt,
  iiota: Rmt,
  IJlig: $mt,
  ijlig: Imt,
  Imacr: Nmt,
  imacr: Bmt,
  image: Fmt,
  ImaginaryI: Qmt,
  imagline: Zmt,
  imagpart: Vmt,
  imath: Ymt,
  Im: zmt,
  imof: qmt,
  imped: Wmt,
  Implies: Umt,
  incare: jmt,
  in: "\u2208",
  infin: Xmt,
  infintie: Gmt,
  inodot: Hmt,
  intcal: Kmt,
  int: Jmt,
  Int: t2t,
  integers: e2t,
  Integral: n2t,
  intercal: r2t,
  Intersection: i2t,
  intlarhk: s2t,
  intprod: o2t,
  InvisibleComma: a2t,
  InvisibleTimes: l2t,
  IOcy: c2t,
  iocy: h2t,
  Iogon: u2t,
  iogon: f2t,
  Iopf: d2t,
  iopf: p2t,
  Iota: g2t,
  iota: m2t,
  iprod: y2t,
  iquest: b2t,
  iscr: O2t,
  Iscr: x2t,
  isin: v2t,
  isindot: _2t,
  isinE: k2t,
  isins: w2t,
  isinsv: S2t,
  isinv: C2t,
  it: T2t,
  Itilde: E2t,
  itilde: A2t,
  Iukcy: P2t,
  iukcy: D2t,
  Iuml: L2t,
  iuml: M2t,
  Jcirc: R2t,
  jcirc: $2t,
  Jcy: I2t,
  jcy: N2t,
  Jfr: B2t,
  jfr: F2t,
  jmath: Q2t,
  Jopf: Z2t,
  jopf: V2t,
  Jscr: Y2t,
  jscr: z2t,
  Jsercy: q2t,
  jsercy: W2t,
  Jukcy: U2t,
  jukcy: j2t,
  Kappa: X2t,
  kappa: G2t,
  kappav: H2t,
  Kcedil: K2t,
  kcedil: J2t,
  Kcy: tyt,
  kcy: eyt,
  Kfr: nyt,
  kfr: ryt,
  kgreen: iyt,
  KHcy: syt,
  khcy: oyt,
  KJcy: ayt,
  kjcy: lyt,
  Kopf: cyt,
  kopf: hyt,
  Kscr: uyt,
  kscr: fyt,
  lAarr: dyt,
  Lacute: pyt,
  lacute: gyt,
  laemptyv: myt,
  lagran: yyt,
  Lambda: byt,
  lambda: Oyt,
  lang: xyt,
  Lang: vyt,
  langd: _yt,
  langle: kyt,
  lap: wyt,
  Laplacetrf: Syt,
  laquo: Cyt,
  larrb: Tyt,
  larrbfs: Eyt,
  larr: Ayt,
  Larr: Pyt,
  lArr: Dyt,
  larrfs: Lyt,
  larrhk: Myt,
  larrlp: Ryt,
  larrpl: $yt,
  larrsim: Iyt,
  larrtl: Nyt,
  latail: Byt,
  lAtail: Fyt,
  lat: Qyt,
  late: Zyt,
  lates: Vyt,
  lbarr: Yyt,
  lBarr: zyt,
  lbbrk: qyt,
  lbrace: Wyt,
  lbrack: Uyt,
  lbrke: jyt,
  lbrksld: Xyt,
  lbrkslu: Gyt,
  Lcaron: Hyt,
  lcaron: Kyt,
  Lcedil: Jyt,
  lcedil: tbt,
  lceil: ebt,
  lcub: nbt,
  Lcy: rbt,
  lcy: ibt,
  ldca: sbt,
  ldquo: obt,
  ldquor: abt,
  ldrdhar: lbt,
  ldrushar: cbt,
  ldsh: hbt,
  le: ubt,
  lE: fbt,
  LeftAngleBracket: dbt,
  LeftArrowBar: pbt,
  leftarrow: gbt,
  LeftArrow: mbt,
  Leftarrow: ybt,
  LeftArrowRightArrow: bbt,
  leftarrowtail: Obt,
  LeftCeiling: xbt,
  LeftDoubleBracket: vbt,
  LeftDownTeeVector: _bt,
  LeftDownVectorBar: kbt,
  LeftDownVector: wbt,
  LeftFloor: Sbt,
  leftharpoondown: Cbt,
  leftharpoonup: Tbt,
  leftleftarrows: Ebt,
  leftrightarrow: Abt,
  LeftRightArrow: Pbt,
  Leftrightarrow: Dbt,
  leftrightarrows: Lbt,
  leftrightharpoons: Mbt,
  leftrightsquigarrow: Rbt,
  LeftRightVector: $bt,
  LeftTeeArrow: Ibt,
  LeftTee: Nbt,
  LeftTeeVector: Bbt,
  leftthreetimes: Fbt,
  LeftTriangleBar: Qbt,
  LeftTriangle: Zbt,
  LeftTriangleEqual: Vbt,
  LeftUpDownVector: Ybt,
  LeftUpTeeVector: zbt,
  LeftUpVectorBar: qbt,
  LeftUpVector: Wbt,
  LeftVectorBar: Ubt,
  LeftVector: jbt,
  lEg: Xbt,
  leg: Gbt,
  leq: Hbt,
  leqq: Kbt,
  leqslant: Jbt,
  lescc: tOt,
  les: eOt,
  lesdot: nOt,
  lesdoto: rOt,
  lesdotor: iOt,
  lesg: sOt,
  lesges: oOt,
  lessapprox: aOt,
  lessdot: lOt,
  lesseqgtr: cOt,
  lesseqqgtr: hOt,
  LessEqualGreater: uOt,
  LessFullEqual: fOt,
  LessGreater: dOt,
  lessgtr: pOt,
  LessLess: gOt,
  lesssim: mOt,
  LessSlantEqual: yOt,
  LessTilde: bOt,
  lfisht: OOt,
  lfloor: xOt,
  Lfr: vOt,
  lfr: _Ot,
  lg: kOt,
  lgE: wOt,
  lHar: SOt,
  lhard: COt,
  lharu: TOt,
  lharul: EOt,
  lhblk: AOt,
  LJcy: POt,
  ljcy: DOt,
  llarr: LOt,
  ll: MOt,
  Ll: ROt,
  llcorner: $Ot,
  Lleftarrow: IOt,
  llhard: NOt,
  lltri: BOt,
  Lmidot: FOt,
  lmidot: QOt,
  lmoustache: ZOt,
  lmoust: VOt,
  lnap: YOt,
  lnapprox: zOt,
  lne: qOt,
  lnE: WOt,
  lneq: UOt,
  lneqq: jOt,
  lnsim: XOt,
  loang: GOt,
  loarr: HOt,
  lobrk: KOt,
  longleftarrow: JOt,
  LongLeftArrow: txt,
  Longleftarrow: ext,
  longleftrightarrow: nxt,
  LongLeftRightArrow: rxt,
  Longleftrightarrow: ixt,
  longmapsto: sxt,
  longrightarrow: oxt,
  LongRightArrow: axt,
  Longrightarrow: lxt,
  looparrowleft: cxt,
  looparrowright: hxt,
  lopar: uxt,
  Lopf: fxt,
  lopf: dxt,
  loplus: pxt,
  lotimes: gxt,
  lowast: mxt,
  lowbar: yxt,
  LowerLeftArrow: bxt,
  LowerRightArrow: Oxt,
  loz: xxt,
  lozenge: vxt,
  lozf: _xt,
  lpar: kxt,
  lparlt: wxt,
  lrarr: Sxt,
  lrcorner: Cxt,
  lrhar: Txt,
  lrhard: Ext,
  lrm: Axt,
  lrtri: Pxt,
  lsaquo: Dxt,
  lscr: Lxt,
  Lscr: Mxt,
  lsh: Rxt,
  Lsh: $xt,
  lsim: Ixt,
  lsime: Nxt,
  lsimg: Bxt,
  lsqb: Fxt,
  lsquo: Qxt,
  lsquor: Zxt,
  Lstrok: Vxt,
  lstrok: Yxt,
  ltcc: zxt,
  ltcir: qxt,
  lt: Wxt,
  LT: Uxt,
  Lt: jxt,
  ltdot: Xxt,
  lthree: Gxt,
  ltimes: Hxt,
  ltlarr: Kxt,
  ltquest: Jxt,
  ltri: tvt,
  ltrie: evt,
  ltrif: nvt,
  ltrPar: rvt,
  lurdshar: ivt,
  luruhar: svt,
  lvertneqq: ovt,
  lvnE: avt,
  macr: lvt,
  male: cvt,
  malt: hvt,
  maltese: uvt,
  Map: "\u2905",
  map: fvt,
  mapsto: dvt,
  mapstodown: pvt,
  mapstoleft: gvt,
  mapstoup: mvt,
  marker: yvt,
  mcomma: bvt,
  Mcy: Ovt,
  mcy: xvt,
  mdash: vvt,
  mDDot: _vt,
  measuredangle: kvt,
  MediumSpace: wvt,
  Mellintrf: Svt,
  Mfr: Cvt,
  mfr: Tvt,
  mho: Evt,
  micro: Avt,
  midast: Pvt,
  midcir: Dvt,
  mid: Lvt,
  middot: Mvt,
  minusb: Rvt,
  minus: $vt,
  minusd: Ivt,
  minusdu: Nvt,
  MinusPlus: Bvt,
  mlcp: Fvt,
  mldr: Qvt,
  mnplus: Zvt,
  models: Vvt,
  Mopf: Yvt,
  mopf: zvt,
  mp: qvt,
  mscr: Wvt,
  Mscr: Uvt,
  mstpos: jvt,
  Mu: Xvt,
  mu: Gvt,
  multimap: Hvt,
  mumap: Kvt,
  nabla: Jvt,
  Nacute: t_t,
  nacute: e_t,
  nang: n_t,
  nap: r_t,
  napE: i_t,
  napid: s_t,
  napos: o_t,
  napprox: a_t,
  natural: l_t,
  naturals: c_t,
  natur: h_t,
  nbsp: u_t,
  nbump: f_t,
  nbumpe: d_t,
  ncap: p_t,
  Ncaron: g_t,
  ncaron: m_t,
  Ncedil: y_t,
  ncedil: b_t,
  ncong: O_t,
  ncongdot: x_t,
  ncup: v_t,
  Ncy: __t,
  ncy: k_t,
  ndash: w_t,
  nearhk: S_t,
  nearr: C_t,
  neArr: T_t,
  nearrow: E_t,
  ne: A_t,
  nedot: P_t,
  NegativeMediumSpace: D_t,
  NegativeThickSpace: L_t,
  NegativeThinSpace: M_t,
  NegativeVeryThinSpace: R_t,
  nequiv: $_t,
  nesear: I_t,
  nesim: N_t,
  NestedGreaterGreater: B_t,
  NestedLessLess: F_t,
  NewLine: Q_t,
  nexist: Z_t,
  nexists: V_t,
  Nfr: Y_t,
  nfr: z_t,
  ngE: q_t,
  nge: W_t,
  ngeq: U_t,
  ngeqq: j_t,
  ngeqslant: X_t,
  nges: G_t,
  nGg: H_t,
  ngsim: K_t,
  nGt: J_t,
  ngt: tkt,
  ngtr: ekt,
  nGtv: nkt,
  nharr: rkt,
  nhArr: ikt,
  nhpar: skt,
  ni: okt,
  nis: akt,
  nisd: lkt,
  niv: ckt,
  NJcy: hkt,
  njcy: ukt,
  nlarr: fkt,
  nlArr: dkt,
  nldr: pkt,
  nlE: gkt,
  nle: mkt,
  nleftarrow: ykt,
  nLeftarrow: bkt,
  nleftrightarrow: Okt,
  nLeftrightarrow: xkt,
  nleq: vkt,
  nleqq: _kt,
  nleqslant: kkt,
  nles: wkt,
  nless: Skt,
  nLl: Ckt,
  nlsim: Tkt,
  nLt: Ekt,
  nlt: Akt,
  nltri: Pkt,
  nltrie: Dkt,
  nLtv: Lkt,
  nmid: Mkt,
  NoBreak: Rkt,
  NonBreakingSpace: $kt,
  nopf: Ikt,
  Nopf: Nkt,
  Not: Bkt,
  not: Fkt,
  NotCongruent: Qkt,
  NotCupCap: Zkt,
  NotDoubleVerticalBar: Vkt,
  NotElement: Ykt,
  NotEqual: zkt,
  NotEqualTilde: qkt,
  NotExists: Wkt,
  NotGreater: Ukt,
  NotGreaterEqual: jkt,
  NotGreaterFullEqual: Xkt,
  NotGreaterGreater: Gkt,
  NotGreaterLess: Hkt,
  NotGreaterSlantEqual: Kkt,
  NotGreaterTilde: Jkt,
  NotHumpDownHump: twt,
  NotHumpEqual: ewt,
  notin: nwt,
  notindot: rwt,
  notinE: iwt,
  notinva: swt,
  notinvb: owt,
  notinvc: awt,
  NotLeftTriangleBar: lwt,
  NotLeftTriangle: cwt,
  NotLeftTriangleEqual: hwt,
  NotLess: uwt,
  NotLessEqual: fwt,
  NotLessGreater: dwt,
  NotLessLess: pwt,
  NotLessSlantEqual: gwt,
  NotLessTilde: mwt,
  NotNestedGreaterGreater: ywt,
  NotNestedLessLess: bwt,
  notni: Owt,
  notniva: xwt,
  notnivb: vwt,
  notnivc: _wt,
  NotPrecedes: kwt,
  NotPrecedesEqual: wwt,
  NotPrecedesSlantEqual: Swt,
  NotReverseElement: Cwt,
  NotRightTriangleBar: Twt,
  NotRightTriangle: Ewt,
  NotRightTriangleEqual: Awt,
  NotSquareSubset: Pwt,
  NotSquareSubsetEqual: Dwt,
  NotSquareSuperset: Lwt,
  NotSquareSupersetEqual: Mwt,
  NotSubset: Rwt,
  NotSubsetEqual: $wt,
  NotSucceeds: Iwt,
  NotSucceedsEqual: Nwt,
  NotSucceedsSlantEqual: Bwt,
  NotSucceedsTilde: Fwt,
  NotSuperset: Qwt,
  NotSupersetEqual: Zwt,
  NotTilde: Vwt,
  NotTildeEqual: Ywt,
  NotTildeFullEqual: zwt,
  NotTildeTilde: qwt,
  NotVerticalBar: Wwt,
  nparallel: Uwt,
  npar: jwt,
  nparsl: Xwt,
  npart: Gwt,
  npolint: Hwt,
  npr: Kwt,
  nprcue: Jwt,
  nprec: t3t,
  npreceq: e3t,
  npre: n3t,
  nrarrc: r3t,
  nrarr: i3t,
  nrArr: s3t,
  nrarrw: o3t,
  nrightarrow: a3t,
  nRightarrow: l3t,
  nrtri: c3t,
  nrtrie: h3t,
  nsc: u3t,
  nsccue: f3t,
  nsce: d3t,
  Nscr: p3t,
  nscr: g3t,
  nshortmid: m3t,
  nshortparallel: y3t,
  nsim: b3t,
  nsime: O3t,
  nsimeq: x3t,
  nsmid: v3t,
  nspar: _3t,
  nsqsube: k3t,
  nsqsupe: w3t,
  nsub: S3t,
  nsubE: C3t,
  nsube: T3t,
  nsubset: E3t,
  nsubseteq: A3t,
  nsubseteqq: P3t,
  nsucc: D3t,
  nsucceq: L3t,
  nsup: M3t,
  nsupE: R3t,
  nsupe: $3t,
  nsupset: I3t,
  nsupseteq: N3t,
  nsupseteqq: B3t,
  ntgl: F3t,
  Ntilde: Q3t,
  ntilde: Z3t,
  ntlg: V3t,
  ntriangleleft: Y3t,
  ntrianglelefteq: z3t,
  ntriangleright: q3t,
  ntrianglerighteq: W3t,
  Nu: U3t,
  nu: j3t,
  num: X3t,
  numero: G3t,
  numsp: H3t,
  nvap: K3t,
  nvdash: J3t,
  nvDash: t5t,
  nVdash: e5t,
  nVDash: n5t,
  nvge: r5t,
  nvgt: i5t,
  nvHarr: s5t,
  nvinfin: o5t,
  nvlArr: a5t,
  nvle: l5t,
  nvlt: c5t,
  nvltrie: h5t,
  nvrArr: u5t,
  nvrtrie: f5t,
  nvsim: d5t,
  nwarhk: p5t,
  nwarr: g5t,
  nwArr: m5t,
  nwarrow: y5t,
  nwnear: b5t,
  Oacute: O5t,
  oacute: x5t,
  oast: v5t,
  Ocirc: _5t,
  ocirc: k5t,
  ocir: w5t,
  Ocy: S5t,
  ocy: C5t,
  odash: T5t,
  Odblac: E5t,
  odblac: A5t,
  odiv: P5t,
  odot: D5t,
  odsold: L5t,
  OElig: M5t,
  oelig: R5t,
  ofcir: $5t,
  Ofr: I5t,
  ofr: N5t,
  ogon: B5t,
  Ograve: F5t,
  ograve: Q5t,
  ogt: Z5t,
  ohbar: V5t,
  ohm: Y5t,
  oint: z5t,
  olarr: q5t,
  olcir: W5t,
  olcross: U5t,
  oline: j5t,
  olt: X5t,
  Omacr: G5t,
  omacr: H5t,
  Omega: K5t,
  omega: J5t,
  Omicron: tSt,
  omicron: eSt,
  omid: nSt,
  ominus: rSt,
  Oopf: iSt,
  oopf: sSt,
  opar: oSt,
  OpenCurlyDoubleQuote: aSt,
  OpenCurlyQuote: lSt,
  operp: cSt,
  oplus: hSt,
  orarr: uSt,
  Or: fSt,
  or: dSt,
  ord: pSt,
  order: gSt,
  orderof: mSt,
  ordf: ySt,
  ordm: bSt,
  origof: OSt,
  oror: xSt,
  orslope: vSt,
  orv: _St,
  oS: kSt,
  Oscr: wSt,
  oscr: SSt,
  Oslash: CSt,
  oslash: TSt,
  osol: ESt,
  Otilde: ASt,
  otilde: PSt,
  otimesas: DSt,
  Otimes: LSt,
  otimes: MSt,
  Ouml: RSt,
  ouml: $St,
  ovbar: ISt,
  OverBar: NSt,
  OverBrace: BSt,
  OverBracket: FSt,
  OverParenthesis: QSt,
  para: ZSt,
  parallel: VSt,
  par: YSt,
  parsim: zSt,
  parsl: qSt,
  part: WSt,
  PartialD: USt,
  Pcy: jSt,
  pcy: XSt,
  percnt: GSt,
  period: HSt,
  permil: KSt,
  perp: JSt,
  pertenk: t4t,
  Pfr: e4t,
  pfr: n4t,
  Phi: r4t,
  phi: i4t,
  phiv: s4t,
  phmmat: o4t,
  phone: a4t,
  Pi: l4t,
  pi: c4t,
  pitchfork: h4t,
  piv: u4t,
  planck: f4t,
  planckh: d4t,
  plankv: p4t,
  plusacir: g4t,
  plusb: m4t,
  pluscir: y4t,
  plus: b4t,
  plusdo: O4t,
  plusdu: x4t,
  pluse: v4t,
  PlusMinus: _4t,
  plusmn: k4t,
  plussim: w4t,
  plustwo: S4t,
  pm: C4t,
  Poincareplane: T4t,
  pointint: E4t,
  popf: A4t,
  Popf: P4t,
  pound: D4t,
  prap: L4t,
  Pr: M4t,
  pr: R4t,
  prcue: $4t,
  precapprox: I4t,
  prec: N4t,
  preccurlyeq: B4t,
  Precedes: F4t,
  PrecedesEqual: Q4t,
  PrecedesSlantEqual: Z4t,
  PrecedesTilde: V4t,
  preceq: Y4t,
  precnapprox: z4t,
  precneqq: q4t,
  precnsim: W4t,
  pre: U4t,
  prE: j4t,
  precsim: X4t,
  prime: G4t,
  Prime: H4t,
  primes: K4t,
  prnap: J4t,
  prnE: tCt,
  prnsim: eCt,
  prod: nCt,
  Product: rCt,
  profalar: iCt,
  profline: sCt,
  profsurf: oCt,
  prop: aCt,
  Proportional: lCt,
  Proportion: cCt,
  propto: hCt,
  prsim: uCt,
  prurel: fCt,
  Pscr: dCt,
  pscr: pCt,
  Psi: gCt,
  psi: mCt,
  puncsp: yCt,
  Qfr: bCt,
  qfr: OCt,
  qint: xCt,
  qopf: vCt,
  Qopf: _Ct,
  qprime: kCt,
  Qscr: wCt,
  qscr: SCt,
  quaternions: CCt,
  quatint: TCt,
  quest: ECt,
  questeq: ACt,
  quot: PCt,
  QUOT: DCt,
  rAarr: LCt,
  race: MCt,
  Racute: RCt,
  racute: $Ct,
  radic: ICt,
  raemptyv: NCt,
  rang: BCt,
  Rang: FCt,
  rangd: QCt,
  range: ZCt,
  rangle: VCt,
  raquo: YCt,
  rarrap: zCt,
  rarrb: qCt,
  rarrbfs: WCt,
  rarrc: UCt,
  rarr: jCt,
  Rarr: XCt,
  rArr: GCt,
  rarrfs: HCt,
  rarrhk: KCt,
  rarrlp: JCt,
  rarrpl: tTt,
  rarrsim: eTt,
  Rarrtl: nTt,
  rarrtl: rTt,
  rarrw: iTt,
  ratail: sTt,
  rAtail: oTt,
  ratio: aTt,
  rationals: lTt,
  rbarr: cTt,
  rBarr: hTt,
  RBarr: uTt,
  rbbrk: fTt,
  rbrace: dTt,
  rbrack: pTt,
  rbrke: gTt,
  rbrksld: mTt,
  rbrkslu: yTt,
  Rcaron: bTt,
  rcaron: OTt,
  Rcedil: xTt,
  rcedil: vTt,
  rceil: _Tt,
  rcub: kTt,
  Rcy: wTt,
  rcy: STt,
  rdca: CTt,
  rdldhar: TTt,
  rdquo: ETt,
  rdquor: ATt,
  rdsh: PTt,
  real: DTt,
  realine: LTt,
  realpart: MTt,
  reals: RTt,
  Re: $Tt,
  rect: ITt,
  reg: NTt,
  REG: BTt,
  ReverseElement: FTt,
  ReverseEquilibrium: QTt,
  ReverseUpEquilibrium: ZTt,
  rfisht: VTt,
  rfloor: YTt,
  rfr: zTt,
  Rfr: qTt,
  rHar: WTt,
  rhard: UTt,
  rharu: jTt,
  rharul: XTt,
  Rho: GTt,
  rho: HTt,
  rhov: KTt,
  RightAngleBracket: JTt,
  RightArrowBar: t6t,
  rightarrow: e6t,
  RightArrow: n6t,
  Rightarrow: r6t,
  RightArrowLeftArrow: i6t,
  rightarrowtail: s6t,
  RightCeiling: o6t,
  RightDoubleBracket: a6t,
  RightDownTeeVector: l6t,
  RightDownVectorBar: c6t,
  RightDownVector: h6t,
  RightFloor: u6t,
  rightharpoondown: f6t,
  rightharpoonup: d6t,
  rightleftarrows: p6t,
  rightleftharpoons: g6t,
  rightrightarrows: m6t,
  rightsquigarrow: y6t,
  RightTeeArrow: b6t,
  RightTee: O6t,
  RightTeeVector: x6t,
  rightthreetimes: v6t,
  RightTriangleBar: _6t,
  RightTriangle: k6t,
  RightTriangleEqual: w6t,
  RightUpDownVector: S6t,
  RightUpTeeVector: C6t,
  RightUpVectorBar: T6t,
  RightUpVector: E6t,
  RightVectorBar: A6t,
  RightVector: P6t,
  ring: D6t,
  risingdotseq: L6t,
  rlarr: M6t,
  rlhar: R6t,
  rlm: $6t,
  rmoustache: I6t,
  rmoust: N6t,
  rnmid: B6t,
  roang: F6t,
  roarr: Q6t,
  robrk: Z6t,
  ropar: V6t,
  ropf: Y6t,
  Ropf: z6t,
  roplus: q6t,
  rotimes: W6t,
  RoundImplies: U6t,
  rpar: j6t,
  rpargt: X6t,
  rppolint: G6t,
  rrarr: H6t,
  Rrightarrow: K6t,
  rsaquo: J6t,
  rscr: tEt,
  Rscr: eEt,
  rsh: nEt,
  Rsh: rEt,
  rsqb: iEt,
  rsquo: sEt,
  rsquor: oEt,
  rthree: aEt,
  rtimes: lEt,
  rtri: cEt,
  rtrie: hEt,
  rtrif: uEt,
  rtriltri: fEt,
  RuleDelayed: dEt,
  ruluhar: pEt,
  rx: gEt,
  Sacute: mEt,
  sacute: yEt,
  sbquo: bEt,
  scap: OEt,
  Scaron: xEt,
  scaron: vEt,
  Sc: _Et,
  sc: kEt,
  sccue: wEt,
  sce: SEt,
  scE: CEt,
  Scedil: TEt,
  scedil: EEt,
  Scirc: AEt,
  scirc: PEt,
  scnap: DEt,
  scnE: LEt,
  scnsim: MEt,
  scpolint: REt,
  scsim: $Et,
  Scy: IEt,
  scy: NEt,
  sdotb: BEt,
  sdot: FEt,
  sdote: QEt,
  searhk: ZEt,
  searr: VEt,
  seArr: YEt,
  searrow: zEt,
  sect: qEt,
  semi: WEt,
  seswar: UEt,
  setminus: jEt,
  setmn: XEt,
  sext: GEt,
  Sfr: HEt,
  sfr: KEt,
  sfrown: JEt,
  sharp: tAt,
  SHCHcy: eAt,
  shchcy: nAt,
  SHcy: rAt,
  shcy: iAt,
  ShortDownArrow: sAt,
  ShortLeftArrow: oAt,
  shortmid: aAt,
  shortparallel: lAt,
  ShortRightArrow: cAt,
  ShortUpArrow: hAt,
  shy: uAt,
  Sigma: fAt,
  sigma: dAt,
  sigmaf: pAt,
  sigmav: gAt,
  sim: mAt,
  simdot: yAt,
  sime: bAt,
  simeq: OAt,
  simg: xAt,
  simgE: vAt,
  siml: _At,
  simlE: kAt,
  simne: wAt,
  simplus: SAt,
  simrarr: CAt,
  slarr: TAt,
  SmallCircle: EAt,
  smallsetminus: AAt,
  smashp: PAt,
  smeparsl: DAt,
  smid: LAt,
  smile: MAt,
  smt: RAt,
  smte: $At,
  smtes: IAt,
  SOFTcy: NAt,
  softcy: BAt,
  solbar: FAt,
  solb: QAt,
  sol: ZAt,
  Sopf: VAt,
  sopf: YAt,
  spades: zAt,
  spadesuit: qAt,
  spar: WAt,
  sqcap: UAt,
  sqcaps: jAt,
  sqcup: XAt,
  sqcups: GAt,
  Sqrt: HAt,
  sqsub: KAt,
  sqsube: JAt,
  sqsubset: t8t,
  sqsubseteq: e8t,
  sqsup: n8t,
  sqsupe: r8t,
  sqsupset: i8t,
  sqsupseteq: s8t,
  square: o8t,
  Square: a8t,
  SquareIntersection: l8t,
  SquareSubset: c8t,
  SquareSubsetEqual: h8t,
  SquareSuperset: u8t,
  SquareSupersetEqual: f8t,
  SquareUnion: d8t,
  squarf: p8t,
  squ: g8t,
  squf: m8t,
  srarr: y8t,
  Sscr: b8t,
  sscr: O8t,
  ssetmn: x8t,
  ssmile: v8t,
  sstarf: _8t,
  Star: k8t,
  star: w8t,
  starf: S8t,
  straightepsilon: C8t,
  straightphi: T8t,
  strns: E8t,
  sub: A8t,
  Sub: P8t,
  subdot: D8t,
  subE: L8t,
  sube: M8t,
  subedot: R8t,
  submult: $8t,
  subnE: I8t,
  subne: N8t,
  subplus: B8t,
  subrarr: F8t,
  subset: Q8t,
  Subset: Z8t,
  subseteq: V8t,
  subseteqq: Y8t,
  SubsetEqual: z8t,
  subsetneq: q8t,
  subsetneqq: W8t,
  subsim: U8t,
  subsub: j8t,
  subsup: X8t,
  succapprox: G8t,
  succ: H8t,
  succcurlyeq: K8t,
  Succeeds: J8t,
  SucceedsEqual: t7t,
  SucceedsSlantEqual: e7t,
  SucceedsTilde: n7t,
  succeq: r7t,
  succnapprox: i7t,
  succneqq: s7t,
  succnsim: o7t,
  succsim: a7t,
  SuchThat: l7t,
  sum: c7t,
  Sum: h7t,
  sung: u7t,
  sup1: f7t,
  sup2: d7t,
  sup3: p7t,
  sup: g7t,
  Sup: m7t,
  supdot: y7t,
  supdsub: b7t,
  supE: O7t,
  supe: x7t,
  supedot: v7t,
  Superset: _7t,
  SupersetEqual: k7t,
  suphsol: w7t,
  suphsub: S7t,
  suplarr: C7t,
  supmult: T7t,
  supnE: E7t,
  supne: A7t,
  supplus: P7t,
  supset: D7t,
  Supset: L7t,
  supseteq: M7t,
  supseteqq: R7t,
  supsetneq: $7t,
  supsetneqq: I7t,
  supsim: N7t,
  supsub: B7t,
  supsup: F7t,
  swarhk: Q7t,
  swarr: Z7t,
  swArr: V7t,
  swarrow: Y7t,
  swnwar: z7t,
  szlig: q7t,
  Tab: W7t,
  target: U7t,
  Tau: j7t,
  tau: X7t,
  tbrk: G7t,
  Tcaron: H7t,
  tcaron: K7t,
  Tcedil: J7t,
  tcedil: t9t,
  Tcy: e9t,
  tcy: n9t,
  tdot: r9t,
  telrec: i9t,
  Tfr: s9t,
  tfr: o9t,
  there4: a9t,
  therefore: l9t,
  Therefore: c9t,
  Theta: h9t,
  theta: u9t,
  thetasym: f9t,
  thetav: d9t,
  thickapprox: p9t,
  thicksim: g9t,
  ThickSpace: m9t,
  ThinSpace: y9t,
  thinsp: b9t,
  thkap: O9t,
  thksim: x9t,
  THORN: v9t,
  thorn: _9t,
  tilde: k9t,
  Tilde: w9t,
  TildeEqual: S9t,
  TildeFullEqual: C9t,
  TildeTilde: T9t,
  timesbar: E9t,
  timesb: A9t,
  times: P9t,
  timesd: D9t,
  tint: L9t,
  toea: M9t,
  topbot: R9t,
  topcir: $9t,
  top: I9t,
  Topf: N9t,
  topf: B9t,
  topfork: F9t,
  tosa: Q9t,
  tprime: Z9t,
  trade: V9t,
  TRADE: Y9t,
  triangle: z9t,
  triangledown: q9t,
  triangleleft: W9t,
  trianglelefteq: U9t,
  triangleq: j9t,
  triangleright: X9t,
  trianglerighteq: G9t,
  tridot: H9t,
  trie: K9t,
  triminus: J9t,
  TripleDot: tPt,
  triplus: ePt,
  trisb: nPt,
  tritime: rPt,
  trpezium: iPt,
  Tscr: sPt,
  tscr: oPt,
  TScy: aPt,
  tscy: lPt,
  TSHcy: cPt,
  tshcy: hPt,
  Tstrok: uPt,
  tstrok: fPt,
  twixt: dPt,
  twoheadleftarrow: pPt,
  twoheadrightarrow: gPt,
  Uacute: mPt,
  uacute: yPt,
  uarr: bPt,
  Uarr: OPt,
  uArr: xPt,
  Uarrocir: vPt,
  Ubrcy: _Pt,
  ubrcy: kPt,
  Ubreve: wPt,
  ubreve: SPt,
  Ucirc: CPt,
  ucirc: TPt,
  Ucy: EPt,
  ucy: APt,
  udarr: PPt,
  Udblac: DPt,
  udblac: LPt,
  udhar: MPt,
  ufisht: RPt,
  Ufr: $Pt,
  ufr: IPt,
  Ugrave: NPt,
  ugrave: BPt,
  uHar: FPt,
  uharl: QPt,
  uharr: ZPt,
  uhblk: VPt,
  ulcorn: YPt,
  ulcorner: zPt,
  ulcrop: qPt,
  ultri: WPt,
  Umacr: UPt,
  umacr: jPt,
  uml: XPt,
  UnderBar: GPt,
  UnderBrace: HPt,
  UnderBracket: KPt,
  UnderParenthesis: JPt,
  Union: tDt,
  UnionPlus: eDt,
  Uogon: nDt,
  uogon: rDt,
  Uopf: iDt,
  uopf: sDt,
  UpArrowBar: oDt,
  uparrow: aDt,
  UpArrow: lDt,
  Uparrow: cDt,
  UpArrowDownArrow: hDt,
  updownarrow: uDt,
  UpDownArrow: fDt,
  Updownarrow: dDt,
  UpEquilibrium: pDt,
  upharpoonleft: gDt,
  upharpoonright: mDt,
  uplus: yDt,
  UpperLeftArrow: bDt,
  UpperRightArrow: ODt,
  upsi: xDt,
  Upsi: vDt,
  upsih: _Dt,
  Upsilon: kDt,
  upsilon: wDt,
  UpTeeArrow: SDt,
  UpTee: CDt,
  upuparrows: TDt,
  urcorn: EDt,
  urcorner: ADt,
  urcrop: PDt,
  Uring: DDt,
  uring: LDt,
  urtri: MDt,
  Uscr: RDt,
  uscr: $Dt,
  utdot: IDt,
  Utilde: NDt,
  utilde: BDt,
  utri: FDt,
  utrif: QDt,
  uuarr: ZDt,
  Uuml: VDt,
  uuml: YDt,
  uwangle: zDt,
  vangrt: qDt,
  varepsilon: WDt,
  varkappa: UDt,
  varnothing: jDt,
  varphi: XDt,
  varpi: GDt,
  varpropto: HDt,
  varr: KDt,
  vArr: JDt,
  varrho: tLt,
  varsigma: eLt,
  varsubsetneq: nLt,
  varsubsetneqq: rLt,
  varsupsetneq: iLt,
  varsupsetneqq: sLt,
  vartheta: oLt,
  vartriangleleft: aLt,
  vartriangleright: lLt,
  vBar: cLt,
  Vbar: hLt,
  vBarv: uLt,
  Vcy: fLt,
  vcy: dLt,
  vdash: pLt,
  vDash: gLt,
  Vdash: mLt,
  VDash: yLt,
  Vdashl: bLt,
  veebar: OLt,
  vee: xLt,
  Vee: vLt,
  veeeq: _Lt,
  vellip: kLt,
  verbar: wLt,
  Verbar: SLt,
  vert: CLt,
  Vert: TLt,
  VerticalBar: ELt,
  VerticalLine: ALt,
  VerticalSeparator: PLt,
  VerticalTilde: DLt,
  VeryThinSpace: LLt,
  Vfr: MLt,
  vfr: RLt,
  vltri: $Lt,
  vnsub: ILt,
  vnsup: NLt,
  Vopf: BLt,
  vopf: FLt,
  vprop: QLt,
  vrtri: ZLt,
  Vscr: VLt,
  vscr: YLt,
  vsubnE: zLt,
  vsubne: qLt,
  vsupnE: WLt,
  vsupne: ULt,
  Vvdash: jLt,
  vzigzag: XLt,
  Wcirc: GLt,
  wcirc: HLt,
  wedbar: KLt,
  wedge: JLt,
  Wedge: tMt,
  wedgeq: eMt,
  weierp: nMt,
  Wfr: rMt,
  wfr: iMt,
  Wopf: sMt,
  wopf: oMt,
  wp: aMt,
  wr: lMt,
  wreath: cMt,
  Wscr: hMt,
  wscr: uMt,
  xcap: fMt,
  xcirc: dMt,
  xcup: pMt,
  xdtri: gMt,
  Xfr: mMt,
  xfr: yMt,
  xharr: bMt,
  xhArr: OMt,
  Xi: xMt,
  xi: vMt,
  xlarr: _Mt,
  xlArr: kMt,
  xmap: wMt,
  xnis: SMt,
  xodot: CMt,
  Xopf: TMt,
  xopf: EMt,
  xoplus: AMt,
  xotime: PMt,
  xrarr: DMt,
  xrArr: LMt,
  Xscr: MMt,
  xscr: RMt,
  xsqcup: $Mt,
  xuplus: IMt,
  xutri: NMt,
  xvee: BMt,
  xwedge: FMt,
  Yacute: QMt,
  yacute: ZMt,
  YAcy: VMt,
  yacy: YMt,
  Ycirc: zMt,
  ycirc: qMt,
  Ycy: WMt,
  ycy: UMt,
  yen: jMt,
  Yfr: XMt,
  yfr: GMt,
  YIcy: HMt,
  yicy: KMt,
  Yopf: JMt,
  yopf: tRt,
  Yscr: eRt,
  yscr: nRt,
  YUcy: rRt,
  yucy: iRt,
  yuml: sRt,
  Yuml: oRt,
  Zacute: aRt,
  zacute: lRt,
  Zcaron: cRt,
  zcaron: hRt,
  Zcy: uRt,
  zcy: fRt,
  Zdot: dRt,
  zdot: pRt,
  zeetrf: gRt,
  ZeroWidthSpace: mRt,
  Zeta: yRt,
  zeta: bRt,
  zfr: ORt,
  Zfr: xRt,
  ZHcy: vRt,
  zhcy: _Rt,
  zigrarr: kRt,
  zopf: wRt,
  Zopf: SRt,
  Zscr: CRt,
  zscr: TRt,
  zwj: ERt,
  zwnj: ARt
};
(function(e) {
  e.exports = PRt;
})(m3);
var y3 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, Iu = {}, O6 = {};
function DRt(e) {
  var t, n, r = O6[e];
  if (r)
    return r;
  for (r = O6[e] = [], t = 0; t < 128; t++)
    n = String.fromCharCode(t), /^[0-9a-z]$/i.test(n) ? r.push(n) : r.push("%" + ("0" + t.toString(16).toUpperCase()).slice(-2));
  for (t = 0; t < e.length; t++)
    r[e.charCodeAt(t)] = e[t];
  return r;
}
function ay(e, t, n) {
  var r, i, s, o, a, l = "";
  for (typeof t != "string" && (n = t, t = ay.defaultChars), typeof n > "u" && (n = !0), a = DRt(t), r = 0, i = e.length; r < i; r++) {
    if (s = e.charCodeAt(r), n && s === 37 && r + 2 < i && /^[0-9a-f]{2}$/i.test(e.slice(r + 1, r + 3))) {
      l += e.slice(r, r + 3), r += 2;
      continue;
    }
    if (s < 128) {
      l += a[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && r + 1 < i && (o = e.charCodeAt(r + 1), o >= 56320 && o <= 57343)) {
        l += encodeURIComponent(e[r] + e[r + 1]), r++;
        continue;
      }
      l += "%EF%BF%BD";
      continue;
    }
    l += encodeURIComponent(e[r]);
  }
  return l;
}
ay.defaultChars = ";/?:@&=+$,-_.!~*'()#";
ay.componentChars = "-_.!~*'()";
var LRt = ay, x6 = {};
function MRt(e) {
  var t, n, r = x6[e];
  if (r)
    return r;
  for (r = x6[e] = [], t = 0; t < 128; t++)
    n = String.fromCharCode(t), r.push(n);
  for (t = 0; t < e.length; t++)
    n = e.charCodeAt(t), r[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2);
  return r;
}
function ly(e, t) {
  var n;
  return typeof t != "string" && (t = ly.defaultChars), n = MRt(t), e.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var i, s, o, a, l, h, u, f = "";
    for (i = 0, s = r.length; i < s; i += 3) {
      if (o = parseInt(r.slice(i + 1, i + 3), 16), o < 128) {
        f += n[o];
        continue;
      }
      if ((o & 224) === 192 && i + 3 < s && (a = parseInt(r.slice(i + 4, i + 6), 16), (a & 192) === 128)) {
        u = o << 6 & 1984 | a & 63, u < 128 ? f += "\uFFFD\uFFFD" : f += String.fromCharCode(u), i += 3;
        continue;
      }
      if ((o & 240) === 224 && i + 6 < s && (a = parseInt(r.slice(i + 4, i + 6), 16), l = parseInt(r.slice(i + 7, i + 9), 16), (a & 192) === 128 && (l & 192) === 128)) {
        u = o << 12 & 61440 | a << 6 & 4032 | l & 63, u < 2048 || u >= 55296 && u <= 57343 ? f += "\uFFFD\uFFFD\uFFFD" : f += String.fromCharCode(u), i += 6;
        continue;
      }
      if ((o & 248) === 240 && i + 9 < s && (a = parseInt(r.slice(i + 4, i + 6), 16), l = parseInt(r.slice(i + 7, i + 9), 16), h = parseInt(r.slice(i + 10, i + 12), 16), (a & 192) === 128 && (l & 192) === 128 && (h & 192) === 128)) {
        u = o << 18 & 1835008 | a << 12 & 258048 | l << 6 & 4032 | h & 63, u < 65536 || u > 1114111 ? f += "\uFFFD\uFFFD\uFFFD\uFFFD" : (u -= 65536, f += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), i += 9;
        continue;
      }
      f += "\uFFFD";
    }
    return f;
  });
}
ly.defaultChars = ";/?:@&=+$,#";
ly.componentChars = "";
var RRt = ly, $Rt = function(t) {
  var n = "";
  return n += t.protocol || "", n += t.slashes ? "//" : "", n += t.auth ? t.auth + "@" : "", t.hostname && t.hostname.indexOf(":") !== -1 ? n += "[" + t.hostname + "]" : n += t.hostname || "", n += t.port ? ":" + t.port : "", n += t.pathname || "", n += t.search || "", n += t.hash || "", n;
};
function pm() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var IRt = /^([a-z0-9.+-]+:)/i, NRt = /:[0-9]*$/, BRt = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, FRt = ["<", ">", '"', "`", " ", "\r", `
`, "	"], QRt = ["{", "}", "|", "\\", "^", "`"].concat(FRt), ZRt = ["'"].concat(QRt), v6 = ["%", "/", "?", ";", "#"].concat(ZRt), _6 = ["/", "?", "#"], VRt = 255, k6 = /^[+a-z0-9A-Z_-]{0,63}$/, YRt = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, w6 = {
  javascript: !0,
  "javascript:": !0
}, S6 = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function zRt(e, t) {
  if (e && e instanceof pm)
    return e;
  var n = new pm();
  return n.parse(e, t), n;
}
pm.prototype.parse = function(e, t) {
  var n, r, i, s, o, a = e;
  if (a = a.trim(), !t && e.split("#").length === 1) {
    var l = BRt.exec(a);
    if (l)
      return this.pathname = l[1], l[2] && (this.search = l[2]), this;
  }
  var h = IRt.exec(a);
  if (h && (h = h[0], i = h.toLowerCase(), this.protocol = h, a = a.substr(h.length)), (t || h || a.match(/^\/\/[^@\/]+@[^@\/]+/)) && (o = a.substr(0, 2) === "//", o && !(h && w6[h]) && (a = a.substr(2), this.slashes = !0)), !w6[h] && (o || h && !S6[h])) {
    var u = -1;
    for (n = 0; n < _6.length; n++)
      s = a.indexOf(_6[n]), s !== -1 && (u === -1 || s < u) && (u = s);
    var f, d;
    for (u === -1 ? d = a.lastIndexOf("@") : d = a.lastIndexOf("@", u), d !== -1 && (f = a.slice(0, d), a = a.slice(d + 1), this.auth = f), u = -1, n = 0; n < v6.length; n++)
      s = a.indexOf(v6[n]), s !== -1 && (u === -1 || s < u) && (u = s);
    u === -1 && (u = a.length), a[u - 1] === ":" && u--;
    var p = a.slice(0, u);
    a = a.slice(u), this.parseHost(p), this.hostname = this.hostname || "";
    var g = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!g) {
      var m = this.hostname.split(/\./);
      for (n = 0, r = m.length; n < r; n++) {
        var y = m[n];
        if (!!y && !y.match(k6)) {
          for (var O = "", x = 0, _ = y.length; x < _; x++)
            y.charCodeAt(x) > 127 ? O += "x" : O += y[x];
          if (!O.match(k6)) {
            var w = m.slice(0, n), E = m.slice(n + 1), T = y.match(YRt);
            T && (w.push(T[1]), E.unshift(T[2])), E.length && (a = E.join(".") + a), this.hostname = w.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > VRt && (this.hostname = ""), g && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var S = a.indexOf("#");
  S !== -1 && (this.hash = a.substr(S), a = a.slice(0, S));
  var R = a.indexOf("?");
  return R !== -1 && (this.search = a.substr(R), a = a.slice(0, R)), a && (this.pathname = a), S6[i] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
pm.prototype.parseHost = function(e) {
  var t = NRt.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
var qRt = zRt;
Iu.encode = LRt;
Iu.decode = RRt;
Iu.format = $Rt;
Iu.parse = qRt;
var _l = {}, dO, C6;
function KR() {
  return C6 || (C6 = 1, dO = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), dO;
}
var pO, T6;
function JR() {
  return T6 || (T6 = 1, pO = /[\0-\x1F\x7F-\x9F]/), pO;
}
var gO, E6;
function WRt() {
  return E6 || (E6 = 1, gO = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), gO;
}
var mO, A6;
function t$() {
  return A6 || (A6 = 1, mO = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), mO;
}
var P6;
function URt() {
  return P6 || (P6 = 1, _l.Any = KR(), _l.Cc = JR(), _l.Cf = WRt(), _l.P = y3, _l.Z = t$()), _l;
}
(function(e) {
  function t(b) {
    return Object.prototype.toString.call(b);
  }
  function n(b) {
    return t(b) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function i(b, M) {
    return r.call(b, M);
  }
  function s(b) {
    var M = Array.prototype.slice.call(arguments, 1);
    return M.forEach(function(v) {
      if (!!v) {
        if (typeof v != "object")
          throw new TypeError(v + "must be object");
        Object.keys(v).forEach(function(N) {
          b[N] = v[N];
        });
      }
    }), b;
  }
  function o(b, M, v) {
    return [].concat(b.slice(0, M), v, b.slice(M + 1));
  }
  function a(b) {
    return !(b >= 55296 && b <= 57343 || b >= 64976 && b <= 65007 || (b & 65535) === 65535 || (b & 65535) === 65534 || b >= 0 && b <= 8 || b === 11 || b >= 14 && b <= 31 || b >= 127 && b <= 159 || b > 1114111);
  }
  function l(b) {
    if (b > 65535) {
      b -= 65536;
      var M = 55296 + (b >> 10), v = 56320 + (b & 1023);
      return String.fromCharCode(M, v);
    }
    return String.fromCharCode(b);
  }
  var h = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, f = new RegExp(h.source + "|" + u.source, "gi"), d = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, p = m3.exports;
  function g(b, M) {
    var v = 0;
    return i(p, M) ? p[M] : M.charCodeAt(0) === 35 && d.test(M) && (v = M[1].toLowerCase() === "x" ? parseInt(M.slice(2), 16) : parseInt(M.slice(1), 10), a(v)) ? l(v) : b;
  }
  function m(b) {
    return b.indexOf("\\") < 0 ? b : b.replace(h, "$1");
  }
  function y(b) {
    return b.indexOf("\\") < 0 && b.indexOf("&") < 0 ? b : b.replace(f, function(M, v, N) {
      return v || g(M, N);
    });
  }
  var O = /[&<>"]/, x = /[&<>"]/g, _ = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function w(b) {
    return _[b];
  }
  function E(b) {
    return O.test(b) ? b.replace(x, w) : b;
  }
  var T = /[.?*+^$[\]\\(){}|-]/g;
  function S(b) {
    return b.replace(T, "\\$&");
  }
  function R(b) {
    switch (b) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function A(b) {
    if (b >= 8192 && b <= 8202)
      return !0;
    switch (b) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var P = y3;
  function C(b) {
    return P.test(b);
  }
  function k(b) {
    switch (b) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function D(b) {
    return b = b.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (b = b.replace(/ẞ/g, "\xDF")), b.toLowerCase().toUpperCase();
  }
  e.lib = {}, e.lib.mdurl = Iu, e.lib.ucmicro = URt(), e.assign = s, e.isString = n, e.has = i, e.unescapeMd = m, e.unescapeAll = y, e.isValidEntityCode = a, e.fromCodePoint = l, e.escapeHtml = E, e.arrayReplaceAt = o, e.isSpace = R, e.isWhiteSpace = A, e.isMdAsciiPunct = k, e.isPunctChar = C, e.escapeRE = S, e.normalizeReference = D;
})(Ve);
var cy = {}, jRt = function(t, n, r) {
  var i, s, o, a, l = -1, h = t.posMax, u = t.pos;
  for (t.pos = n + 1, i = 1; t.pos < h; ) {
    if (o = t.src.charCodeAt(t.pos), o === 93 && (i--, i === 0)) {
      s = !0;
      break;
    }
    if (a = t.pos, t.md.inline.skipToken(t), o === 91) {
      if (a === t.pos - 1)
        i++;
      else if (r)
        return t.pos = u, -1;
    }
  }
  return s && (l = t.pos), t.pos = u, l;
}, D6 = Ve.unescapeAll, XRt = function(t, n, r) {
  var i, s, o = 0, a = n, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (t.charCodeAt(n) === 60) {
    for (n++; n < r; ) {
      if (i = t.charCodeAt(n), i === 10 || i === 60)
        return l;
      if (i === 62)
        return l.pos = n + 1, l.str = D6(t.slice(a + 1, n)), l.ok = !0, l;
      if (i === 92 && n + 1 < r) {
        n += 2;
        continue;
      }
      n++;
    }
    return l;
  }
  for (s = 0; n < r && (i = t.charCodeAt(n), !(i === 32 || i < 32 || i === 127)); ) {
    if (i === 92 && n + 1 < r) {
      if (t.charCodeAt(n + 1) === 32)
        break;
      n += 2;
      continue;
    }
    if (i === 40 && (s++, s > 32))
      return l;
    if (i === 41) {
      if (s === 0)
        break;
      s--;
    }
    n++;
  }
  return a === n || s !== 0 || (l.str = D6(t.slice(a, n)), l.lines = o, l.pos = n, l.ok = !0), l;
}, GRt = Ve.unescapeAll, HRt = function(t, n, r) {
  var i, s, o = 0, a = n, l = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (n >= r || (s = t.charCodeAt(n), s !== 34 && s !== 39 && s !== 40))
    return l;
  for (n++, s === 40 && (s = 41); n < r; ) {
    if (i = t.charCodeAt(n), i === s)
      return l.pos = n + 1, l.lines = o, l.str = GRt(t.slice(a + 1, n)), l.ok = !0, l;
    if (i === 40 && s === 41)
      return l;
    i === 10 ? o++ : i === 92 && n + 1 < r && (n++, t.charCodeAt(n) === 10 && o++), n++;
  }
  return l;
};
cy.parseLinkLabel = jRt;
cy.parseLinkDestination = XRt;
cy.parseLinkTitle = HRt;
var KRt = Ve.assign, JRt = Ve.unescapeAll, hc = Ve.escapeHtml, ko = {};
ko.code_inline = function(e, t, n, r, i) {
  var s = e[t];
  return "<code" + i.renderAttrs(s) + ">" + hc(e[t].content) + "</code>";
};
ko.code_block = function(e, t, n, r, i) {
  var s = e[t];
  return "<pre" + i.renderAttrs(s) + "><code>" + hc(e[t].content) + `</code></pre>
`;
};
ko.fence = function(e, t, n, r, i) {
  var s = e[t], o = s.info ? JRt(s.info).trim() : "", a = "", l = "", h, u, f, d, p;
  return o && (f = o.split(/(\s+)/g), a = f[0], l = f.slice(2).join("")), n.highlight ? h = n.highlight(s.content, a, l) || hc(s.content) : h = hc(s.content), h.indexOf("<pre") === 0 ? h + `
` : o ? (u = s.attrIndex("class"), d = s.attrs ? s.attrs.slice() : [], u < 0 ? d.push(["class", n.langPrefix + a]) : (d[u] = d[u].slice(), d[u][1] += " " + n.langPrefix + a), p = {
    attrs: d
  }, "<pre><code" + i.renderAttrs(p) + ">" + h + `</code></pre>
`) : "<pre><code" + i.renderAttrs(s) + ">" + h + `</code></pre>
`;
};
ko.image = function(e, t, n, r, i) {
  var s = e[t];
  return s.attrs[s.attrIndex("alt")][1] = i.renderInlineAsText(s.children, n, r), i.renderToken(e, t, n);
};
ko.hardbreak = function(e, t, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
ko.softbreak = function(e, t, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ko.text = function(e, t) {
  return hc(e[t].content);
};
ko.html_block = function(e, t) {
  return e[t].content;
};
ko.html_inline = function(e, t) {
  return e[t].content;
};
function Nu() {
  this.rules = KRt({}, ko);
}
Nu.prototype.renderAttrs = function(t) {
  var n, r, i;
  if (!t.attrs)
    return "";
  for (i = "", n = 0, r = t.attrs.length; n < r; n++)
    i += " " + hc(t.attrs[n][0]) + '="' + hc(t.attrs[n][1]) + '"';
  return i;
};
Nu.prototype.renderToken = function(t, n, r) {
  var i, s = "", o = !1, a = t[n];
  return a.hidden ? "" : (a.block && a.nesting !== -1 && n && t[n - 1].hidden && (s += `
`), s += (a.nesting === -1 ? "</" : "<") + a.tag, s += this.renderAttrs(a), a.nesting === 0 && r.xhtmlOut && (s += " /"), a.block && (o = !0, a.nesting === 1 && n + 1 < t.length && (i = t[n + 1], (i.type === "inline" || i.hidden || i.nesting === -1 && i.tag === a.tag) && (o = !1))), s += o ? `>
` : ">", s);
};
Nu.prototype.renderInline = function(e, t, n) {
  for (var r, i = "", s = this.rules, o = 0, a = e.length; o < a; o++)
    r = e[o].type, typeof s[r] < "u" ? i += s[r](e, o, t, n, this) : i += this.renderToken(e, o, t);
  return i;
};
Nu.prototype.renderInlineAsText = function(e, t, n) {
  for (var r = "", i = 0, s = e.length; i < s; i++)
    e[i].type === "text" ? r += e[i].content : e[i].type === "image" ? r += this.renderInlineAsText(e[i].children, t, n) : e[i].type === "softbreak" && (r += `
`);
  return r;
};
Nu.prototype.render = function(e, t, n) {
  var r, i, s, o = "", a = this.rules;
  for (r = 0, i = e.length; r < i; r++)
    s = e[r].type, s === "inline" ? o += this.renderInline(e[r].children, t, n) : typeof a[s] < "u" ? o += a[e[r].type](e, r, t, n, this) : o += this.renderToken(e, r, t, n);
  return o;
};
var t$t = Nu;
function Ds() {
  this.__rules__ = [], this.__cache__ = null;
}
Ds.prototype.__find__ = function(e) {
  for (var t = 0; t < this.__rules__.length; t++)
    if (this.__rules__[t].name === e)
      return t;
  return -1;
};
Ds.prototype.__compile__ = function() {
  var e = this, t = [""];
  e.__rules__.forEach(function(n) {
    !n.enabled || n.alt.forEach(function(r) {
      t.indexOf(r) < 0 && t.push(r);
    });
  }), e.__cache__ = {}, t.forEach(function(n) {
    e.__cache__[n] = [], e.__rules__.forEach(function(r) {
      !r.enabled || n && r.alt.indexOf(n) < 0 || e.__cache__[n].push(r.fn);
    });
  });
};
Ds.prototype.at = function(e, t, n) {
  var r = this.__find__(e), i = n || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__[r].fn = t, this.__rules__[r].alt = i.alt || [], this.__cache__ = null;
};
Ds.prototype.before = function(e, t, n, r) {
  var i = this.__find__(e), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(i, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Ds.prototype.after = function(e, t, n, r) {
  var i = this.__find__(e), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(i + 1, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
Ds.prototype.push = function(e, t, n) {
  var r = n || {};
  this.__rules__.push({
    name: e,
    enabled: !0,
    fn: t,
    alt: r.alt || []
  }), this.__cache__ = null;
};
Ds.prototype.enable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  var n = [];
  return e.forEach(function(r) {
    var i = this.__find__(r);
    if (i < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !0, n.push(r);
  }, this), this.__cache__ = null, n;
};
Ds.prototype.enableOnly = function(e, t) {
  Array.isArray(e) || (e = [e]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(e, t);
};
Ds.prototype.disable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  var n = [];
  return e.forEach(function(r) {
    var i = this.__find__(r);
    if (i < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !1, n.push(r);
  }, this), this.__cache__ = null, n;
};
Ds.prototype.getRules = function(e) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[e] || [];
};
var b3 = Ds, e$t = /\r\n?|\n/g, n$t = /\0/g, r$t = function(t) {
  var n;
  n = t.src.replace(e$t, `
`), n = n.replace(n$t, "\uFFFD"), t.src = n;
}, i$t = function(t) {
  var n;
  t.inlineMode ? (n = new t.Token("inline", "", 0), n.content = t.src, n.map = [0, 1], n.children = [], t.tokens.push(n)) : t.md.block.parse(t.src, t.md, t.env, t.tokens);
}, s$t = function(t) {
  var n = t.tokens, r, i, s;
  for (i = 0, s = n.length; i < s; i++)
    r = n[i], r.type === "inline" && t.md.inline.parse(r.content, t.md, t.env, r.children);
}, o$t = Ve.arrayReplaceAt;
function a$t(e) {
  return /^<a[>\s]/i.test(e);
}
function l$t(e) {
  return /^<\/a\s*>/i.test(e);
}
var c$t = function(t) {
  var n, r, i, s, o, a, l, h, u, f, d, p, g, m, y, O, x = t.tokens, _;
  if (!!t.md.options.linkify) {
    for (r = 0, i = x.length; r < i; r++)
      if (!(x[r].type !== "inline" || !t.md.linkify.pretest(x[r].content)))
        for (s = x[r].children, g = 0, n = s.length - 1; n >= 0; n--) {
          if (a = s[n], a.type === "link_close") {
            for (n--; s[n].level !== a.level && s[n].type !== "link_open"; )
              n--;
            continue;
          }
          if (a.type === "html_inline" && (a$t(a.content) && g > 0 && g--, l$t(a.content) && g++), !(g > 0) && a.type === "text" && t.md.linkify.test(a.content)) {
            for (u = a.content, _ = t.md.linkify.match(u), l = [], p = a.level, d = 0, h = 0; h < _.length; h++)
              m = _[h].url, y = t.md.normalizeLink(m), t.md.validateLink(y) && (O = _[h].text, _[h].schema ? _[h].schema === "mailto:" && !/^mailto:/i.test(O) ? O = t.md.normalizeLinkText("mailto:" + O).replace(/^mailto:/, "") : O = t.md.normalizeLinkText(O) : O = t.md.normalizeLinkText("http://" + O).replace(/^http:\/\//, ""), f = _[h].index, f > d && (o = new t.Token("text", "", 0), o.content = u.slice(d, f), o.level = p, l.push(o)), o = new t.Token("link_open", "a", 1), o.attrs = [["href", y]], o.level = p++, o.markup = "linkify", o.info = "auto", l.push(o), o = new t.Token("text", "", 0), o.content = O, o.level = p, l.push(o), o = new t.Token("link_close", "a", -1), o.level = --p, o.markup = "linkify", o.info = "auto", l.push(o), d = _[h].lastIndex);
            d < u.length && (o = new t.Token("text", "", 0), o.content = u.slice(d), o.level = p, l.push(o)), x[r].children = s = o$t(s, n, l);
          }
        }
  }
}, e$ = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, h$t = /\((c|tm|r|p)\)/i, u$t = /\((c|tm|r|p)\)/ig, f$t = {
  c: "\xA9",
  r: "\xAE",
  p: "\xA7",
  tm: "\u2122"
};
function d$t(e, t) {
  return f$t[t.toLowerCase()];
}
function p$t(e) {
  var t, n, r = 0;
  for (t = e.length - 1; t >= 0; t--)
    n = e[t], n.type === "text" && !r && (n.content = n.content.replace(u$t, d$t)), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++;
}
function g$t(e) {
  var t, n, r = 0;
  for (t = e.length - 1; t >= 0; t--)
    n = e[t], n.type === "text" && !r && e$.test(n.content) && (n.content = n.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++;
}
var m$t = function(t) {
  var n;
  if (!!t.md.options.typographer)
    for (n = t.tokens.length - 1; n >= 0; n--)
      t.tokens[n].type === "inline" && (h$t.test(t.tokens[n].content) && p$t(t.tokens[n].children), e$.test(t.tokens[n].content) && g$t(t.tokens[n].children));
}, L6 = Ve.isWhiteSpace, M6 = Ve.isPunctChar, R6 = Ve.isMdAsciiPunct, y$t = /['"]/, $6 = /['"]/g, I6 = "\u2019";
function t1(e, t, n) {
  return e.substr(0, t) + n + e.substr(t + 1);
}
function b$t(e, t) {
  var n, r, i, s, o, a, l, h, u, f, d, p, g, m, y, O, x, _, w, E, T;
  for (w = [], n = 0; n < e.length; n++) {
    for (r = e[n], l = e[n].level, x = w.length - 1; x >= 0 && !(w[x].level <= l); x--)
      ;
    if (w.length = x + 1, r.type !== "text")
      continue;
    i = r.content, o = 0, a = i.length;
    t:
      for (; o < a && ($6.lastIndex = o, s = $6.exec(i), !!s); ) {
        if (y = O = !0, o = s.index + 1, _ = s[0] === "'", u = 32, s.index - 1 >= 0)
          u = i.charCodeAt(s.index - 1);
        else
          for (x = n - 1; x >= 0 && !(e[x].type === "softbreak" || e[x].type === "hardbreak"); x--)
            if (!!e[x].content) {
              u = e[x].content.charCodeAt(e[x].content.length - 1);
              break;
            }
        if (f = 32, o < a)
          f = i.charCodeAt(o);
        else
          for (x = n + 1; x < e.length && !(e[x].type === "softbreak" || e[x].type === "hardbreak"); x++)
            if (!!e[x].content) {
              f = e[x].content.charCodeAt(0);
              break;
            }
        if (d = R6(u) || M6(String.fromCharCode(u)), p = R6(f) || M6(String.fromCharCode(f)), g = L6(u), m = L6(f), m ? y = !1 : p && (g || d || (y = !1)), g ? O = !1 : d && (m || p || (O = !1)), f === 34 && s[0] === '"' && u >= 48 && u <= 57 && (O = y = !1), y && O && (y = d, O = p), !y && !O) {
          _ && (r.content = t1(r.content, s.index, I6));
          continue;
        }
        if (O) {
          for (x = w.length - 1; x >= 0 && (h = w[x], !(w[x].level < l)); x--)
            if (h.single === _ && w[x].level === l) {
              h = w[x], _ ? (E = t.md.options.quotes[2], T = t.md.options.quotes[3]) : (E = t.md.options.quotes[0], T = t.md.options.quotes[1]), r.content = t1(r.content, s.index, T), e[h.token].content = t1(
                e[h.token].content,
                h.pos,
                E
              ), o += T.length - 1, h.token === n && (o += E.length - 1), i = r.content, a = i.length, w.length = x;
              continue t;
            }
        }
        y ? w.push({
          token: n,
          pos: s.index,
          single: _,
          level: l
        }) : O && _ && (r.content = t1(r.content, s.index, I6));
      }
  }
}
var O$t = function(t) {
  var n;
  if (!!t.md.options.typographer)
    for (n = t.tokens.length - 1; n >= 0; n--)
      t.tokens[n].type !== "inline" || !y$t.test(t.tokens[n].content) || b$t(t.tokens[n].children, t);
};
function Bu(e, t, n) {
  this.type = e, this.tag = t, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Bu.prototype.attrIndex = function(t) {
  var n, r, i;
  if (!this.attrs)
    return -1;
  for (n = this.attrs, r = 0, i = n.length; r < i; r++)
    if (n[r][0] === t)
      return r;
  return -1;
};
Bu.prototype.attrPush = function(t) {
  this.attrs ? this.attrs.push(t) : this.attrs = [t];
};
Bu.prototype.attrSet = function(t, n) {
  var r = this.attrIndex(t), i = [t, n];
  r < 0 ? this.attrPush(i) : this.attrs[r] = i;
};
Bu.prototype.attrGet = function(t) {
  var n = this.attrIndex(t), r = null;
  return n >= 0 && (r = this.attrs[n][1]), r;
};
Bu.prototype.attrJoin = function(t, n) {
  var r = this.attrIndex(t);
  r < 0 ? this.attrPush([t, n]) : this.attrs[r][1] = this.attrs[r][1] + " " + n;
};
var O3 = Bu, x$t = O3;
function n$(e, t, n) {
  this.src = e, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = t;
}
n$.prototype.Token = x$t;
var v$t = n$, _$t = b3, yO = [
  ["normalize", r$t],
  ["block", i$t],
  ["inline", s$t],
  ["linkify", c$t],
  ["replacements", m$t],
  ["smartquotes", O$t]
];
function x3() {
  this.ruler = new _$t();
  for (var e = 0; e < yO.length; e++)
    this.ruler.push(yO[e][0], yO[e][1]);
}
x3.prototype.process = function(e) {
  var t, n, r;
  for (r = this.ruler.getRules(""), t = 0, n = r.length; t < n; t++)
    r[t](e);
};
x3.prototype.State = v$t;
var k$t = x3, bO = Ve.isSpace;
function OO(e, t) {
  var n = e.bMarks[t] + e.tShift[t], r = e.eMarks[t];
  return e.src.substr(n, r - n);
}
function N6(e) {
  var t = [], n = 0, r = e.length, i, s = !1, o = 0, a = "";
  for (i = e.charCodeAt(n); n < r; )
    i === 124 && (s ? (a += e.substring(o, n - 1), o = n) : (t.push(a + e.substring(o, n)), a = "", o = n + 1)), s = i === 92, n++, i = e.charCodeAt(n);
  return t.push(a + e.substring(o)), t;
}
var w$t = function(t, n, r, i) {
  var s, o, a, l, h, u, f, d, p, g, m, y, O, x, _, w, E, T;
  if (n + 2 > r || (u = n + 1, t.sCount[u] < t.blkIndent) || t.sCount[u] - t.blkIndent >= 4 || (a = t.bMarks[u] + t.tShift[u], a >= t.eMarks[u]) || (E = t.src.charCodeAt(a++), E !== 124 && E !== 45 && E !== 58) || a >= t.eMarks[u] || (T = t.src.charCodeAt(a++), T !== 124 && T !== 45 && T !== 58 && !bO(T)) || E === 45 && bO(T))
    return !1;
  for (; a < t.eMarks[u]; ) {
    if (s = t.src.charCodeAt(a), s !== 124 && s !== 45 && s !== 58 && !bO(s))
      return !1;
    a++;
  }
  for (o = OO(t, n + 1), f = o.split("|"), g = [], l = 0; l < f.length; l++) {
    if (m = f[l].trim(), !m) {
      if (l === 0 || l === f.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(m))
      return !1;
    m.charCodeAt(m.length - 1) === 58 ? g.push(m.charCodeAt(0) === 58 ? "center" : "right") : m.charCodeAt(0) === 58 ? g.push("left") : g.push("");
  }
  if (o = OO(t, n).trim(), o.indexOf("|") === -1 || t.sCount[n] - t.blkIndent >= 4 || (f = N6(o), f.length && f[0] === "" && f.shift(), f.length && f[f.length - 1] === "" && f.pop(), d = f.length, d === 0 || d !== g.length))
    return !1;
  if (i)
    return !0;
  for (x = t.parentType, t.parentType = "table", w = t.md.block.ruler.getRules("blockquote"), p = t.push("table_open", "table", 1), p.map = y = [n, 0], p = t.push("thead_open", "thead", 1), p.map = [n, n + 1], p = t.push("tr_open", "tr", 1), p.map = [n, n + 1], l = 0; l < f.length; l++)
    p = t.push("th_open", "th", 1), g[l] && (p.attrs = [["style", "text-align:" + g[l]]]), p = t.push("inline", "", 0), p.content = f[l].trim(), p.children = [], p = t.push("th_close", "th", -1);
  for (p = t.push("tr_close", "tr", -1), p = t.push("thead_close", "thead", -1), u = n + 2; u < r && !(t.sCount[u] < t.blkIndent); u++) {
    for (_ = !1, l = 0, h = w.length; l < h; l++)
      if (w[l](t, u, r, !0)) {
        _ = !0;
        break;
      }
    if (_ || (o = OO(t, u).trim(), !o) || t.sCount[u] - t.blkIndent >= 4)
      break;
    for (f = N6(o), f.length && f[0] === "" && f.shift(), f.length && f[f.length - 1] === "" && f.pop(), u === n + 2 && (p = t.push("tbody_open", "tbody", 1), p.map = O = [n + 2, 0]), p = t.push("tr_open", "tr", 1), p.map = [u, u + 1], l = 0; l < d; l++)
      p = t.push("td_open", "td", 1), g[l] && (p.attrs = [["style", "text-align:" + g[l]]]), p = t.push("inline", "", 0), p.content = f[l] ? f[l].trim() : "", p.children = [], p = t.push("td_close", "td", -1);
    p = t.push("tr_close", "tr", -1);
  }
  return O && (p = t.push("tbody_close", "tbody", -1), O[1] = u), p = t.push("table_close", "table", -1), y[1] = u, t.parentType = x, t.line = u, !0;
}, S$t = function(t, n, r) {
  var i, s, o;
  if (t.sCount[n] - t.blkIndent < 4)
    return !1;
  for (s = i = n + 1; i < r; ) {
    if (t.isEmpty(i)) {
      i++;
      continue;
    }
    if (t.sCount[i] - t.blkIndent >= 4) {
      i++, s = i;
      continue;
    }
    break;
  }
  return t.line = s, o = t.push("code_block", "code", 0), o.content = t.getLines(n, s, 4 + t.blkIndent, !1) + `
`, o.map = [n, t.line], !0;
}, C$t = function(t, n, r, i) {
  var s, o, a, l, h, u, f, d = !1, p = t.bMarks[n] + t.tShift[n], g = t.eMarks[n];
  if (t.sCount[n] - t.blkIndent >= 4 || p + 3 > g || (s = t.src.charCodeAt(p), s !== 126 && s !== 96) || (h = p, p = t.skipChars(p, s), o = p - h, o < 3) || (f = t.src.slice(h, p), a = t.src.slice(p, g), s === 96 && a.indexOf(String.fromCharCode(s)) >= 0))
    return !1;
  if (i)
    return !0;
  for (l = n; l++, !(l >= r || (p = h = t.bMarks[l] + t.tShift[l], g = t.eMarks[l], p < g && t.sCount[l] < t.blkIndent)); )
    if (t.src.charCodeAt(p) === s && !(t.sCount[l] - t.blkIndent >= 4) && (p = t.skipChars(p, s), !(p - h < o) && (p = t.skipSpaces(p), !(p < g)))) {
      d = !0;
      break;
    }
  return o = t.sCount[n], t.line = l + (d ? 1 : 0), u = t.push("fence", "code", 0), u.info = a, u.content = t.getLines(n + 1, l, o, !0), u.markup = f, u.map = [n, t.line], !0;
}, B6 = Ve.isSpace, T$t = function(t, n, r, i) {
  var s, o, a, l, h, u, f, d, p, g, m, y, O, x, _, w, E, T, S, R, A = t.lineMax, P = t.bMarks[n] + t.tShift[n], C = t.eMarks[n];
  if (t.sCount[n] - t.blkIndent >= 4 || t.src.charCodeAt(P++) !== 62)
    return !1;
  if (i)
    return !0;
  for (l = p = t.sCount[n] + 1, t.src.charCodeAt(P) === 32 ? (P++, l++, p++, s = !1, w = !0) : t.src.charCodeAt(P) === 9 ? (w = !0, (t.bsCount[n] + p) % 4 === 3 ? (P++, l++, p++, s = !1) : s = !0) : w = !1, g = [t.bMarks[n]], t.bMarks[n] = P; P < C && (o = t.src.charCodeAt(P), B6(o)); ) {
    o === 9 ? p += 4 - (p + t.bsCount[n] + (s ? 1 : 0)) % 4 : p++;
    P++;
  }
  for (m = [t.bsCount[n]], t.bsCount[n] = t.sCount[n] + 1 + (w ? 1 : 0), u = P >= C, x = [t.sCount[n]], t.sCount[n] = p - l, _ = [t.tShift[n]], t.tShift[n] = P - t.bMarks[n], T = t.md.block.ruler.getRules("blockquote"), O = t.parentType, t.parentType = "blockquote", d = n + 1; d < r && (R = t.sCount[d] < t.blkIndent, P = t.bMarks[d] + t.tShift[d], C = t.eMarks[d], !(P >= C)); d++) {
    if (t.src.charCodeAt(P++) === 62 && !R) {
      for (l = p = t.sCount[d] + 1, t.src.charCodeAt(P) === 32 ? (P++, l++, p++, s = !1, w = !0) : t.src.charCodeAt(P) === 9 ? (w = !0, (t.bsCount[d] + p) % 4 === 3 ? (P++, l++, p++, s = !1) : s = !0) : w = !1, g.push(t.bMarks[d]), t.bMarks[d] = P; P < C && (o = t.src.charCodeAt(P), B6(o)); ) {
        o === 9 ? p += 4 - (p + t.bsCount[d] + (s ? 1 : 0)) % 4 : p++;
        P++;
      }
      u = P >= C, m.push(t.bsCount[d]), t.bsCount[d] = t.sCount[d] + 1 + (w ? 1 : 0), x.push(t.sCount[d]), t.sCount[d] = p - l, _.push(t.tShift[d]), t.tShift[d] = P - t.bMarks[d];
      continue;
    }
    if (u)
      break;
    for (E = !1, a = 0, h = T.length; a < h; a++)
      if (T[a](t, d, r, !0)) {
        E = !0;
        break;
      }
    if (E) {
      t.lineMax = d, t.blkIndent !== 0 && (g.push(t.bMarks[d]), m.push(t.bsCount[d]), _.push(t.tShift[d]), x.push(t.sCount[d]), t.sCount[d] -= t.blkIndent);
      break;
    }
    g.push(t.bMarks[d]), m.push(t.bsCount[d]), _.push(t.tShift[d]), x.push(t.sCount[d]), t.sCount[d] = -1;
  }
  for (y = t.blkIndent, t.blkIndent = 0, S = t.push("blockquote_open", "blockquote", 1), S.markup = ">", S.map = f = [n, 0], t.md.block.tokenize(t, n, d), S = t.push("blockquote_close", "blockquote", -1), S.markup = ">", t.lineMax = A, t.parentType = O, f[1] = t.line, a = 0; a < _.length; a++)
    t.bMarks[a + n] = g[a], t.tShift[a + n] = _[a], t.sCount[a + n] = x[a], t.bsCount[a + n] = m[a];
  return t.blkIndent = y, !0;
}, E$t = Ve.isSpace, A$t = function(t, n, r, i) {
  var s, o, a, l, h = t.bMarks[n] + t.tShift[n], u = t.eMarks[n];
  if (t.sCount[n] - t.blkIndent >= 4 || (s = t.src.charCodeAt(h++), s !== 42 && s !== 45 && s !== 95))
    return !1;
  for (o = 1; h < u; ) {
    if (a = t.src.charCodeAt(h++), a !== s && !E$t(a))
      return !1;
    a === s && o++;
  }
  return o < 3 ? !1 : (i || (t.line = n + 1, l = t.push("hr", "hr", 0), l.map = [n, t.line], l.markup = Array(o + 1).join(String.fromCharCode(s))), !0);
}, r$ = Ve.isSpace;
function F6(e, t) {
  var n, r, i, s;
  return r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t], n = e.src.charCodeAt(r++), n !== 42 && n !== 45 && n !== 43 || r < i && (s = e.src.charCodeAt(r), !r$(s)) ? -1 : r;
}
function Q6(e, t) {
  var n, r = e.bMarks[t] + e.tShift[t], i = r, s = e.eMarks[t];
  if (i + 1 >= s || (n = e.src.charCodeAt(i++), n < 48 || n > 57))
    return -1;
  for (; ; ) {
    if (i >= s)
      return -1;
    if (n = e.src.charCodeAt(i++), n >= 48 && n <= 57) {
      if (i - r >= 10)
        return -1;
      continue;
    }
    if (n === 41 || n === 46)
      break;
    return -1;
  }
  return i < s && (n = e.src.charCodeAt(i), !r$(n)) ? -1 : i;
}
function P$t(e, t) {
  var n, r, i = e.level + 2;
  for (n = t + 2, r = e.tokens.length - 2; n < r; n++)
    e.tokens[n].level === i && e.tokens[n].type === "paragraph_open" && (e.tokens[n + 2].hidden = !0, e.tokens[n].hidden = !0, n += 2);
}
var D$t = function(t, n, r, i) {
  var s, o, a, l, h, u, f, d, p, g, m, y, O, x, _, w, E, T, S, R, A, P, C, k, D, b, M, v, N = !1, tt = !0;
  if (t.sCount[n] - t.blkIndent >= 4 || t.listIndent >= 0 && t.sCount[n] - t.listIndent >= 4 && t.sCount[n] < t.blkIndent)
    return !1;
  if (i && t.parentType === "paragraph" && t.sCount[n] >= t.blkIndent && (N = !0), (C = Q6(t, n)) >= 0) {
    if (f = !0, D = t.bMarks[n] + t.tShift[n], O = Number(t.src.slice(D, C - 1)), N && O !== 1)
      return !1;
  } else if ((C = F6(t, n)) >= 0)
    f = !1;
  else
    return !1;
  if (N && t.skipSpaces(C) >= t.eMarks[n])
    return !1;
  if (y = t.src.charCodeAt(C - 1), i)
    return !0;
  for (m = t.tokens.length, f ? (v = t.push("ordered_list_open", "ol", 1), O !== 1 && (v.attrs = [["start", O]])) : v = t.push("bullet_list_open", "ul", 1), v.map = g = [n, 0], v.markup = String.fromCharCode(y), _ = n, k = !1, M = t.md.block.ruler.getRules("list"), T = t.parentType, t.parentType = "list"; _ < r; ) {
    for (P = C, x = t.eMarks[_], u = w = t.sCount[_] + C - (t.bMarks[n] + t.tShift[n]); P < x; ) {
      if (s = t.src.charCodeAt(P), s === 9)
        w += 4 - (w + t.bsCount[_]) % 4;
      else if (s === 32)
        w++;
      else
        break;
      P++;
    }
    if (o = P, o >= x ? h = 1 : h = w - u, h > 4 && (h = 1), l = u + h, v = t.push("list_item_open", "li", 1), v.markup = String.fromCharCode(y), v.map = d = [n, 0], f && (v.info = t.src.slice(D, C - 1)), A = t.tight, R = t.tShift[n], S = t.sCount[n], E = t.listIndent, t.listIndent = t.blkIndent, t.blkIndent = l, t.tight = !0, t.tShift[n] = o - t.bMarks[n], t.sCount[n] = w, o >= x && t.isEmpty(n + 1) ? t.line = Math.min(t.line + 2, r) : t.md.block.tokenize(t, n, r, !0), (!t.tight || k) && (tt = !1), k = t.line - n > 1 && t.isEmpty(t.line - 1), t.blkIndent = t.listIndent, t.listIndent = E, t.tShift[n] = R, t.sCount[n] = S, t.tight = A, v = t.push("list_item_close", "li", -1), v.markup = String.fromCharCode(y), _ = n = t.line, d[1] = _, o = t.bMarks[n], _ >= r || t.sCount[_] < t.blkIndent || t.sCount[n] - t.blkIndent >= 4)
      break;
    for (b = !1, a = 0, p = M.length; a < p; a++)
      if (M[a](t, _, r, !0)) {
        b = !0;
        break;
      }
    if (b)
      break;
    if (f) {
      if (C = Q6(t, _), C < 0)
        break;
      D = t.bMarks[_] + t.tShift[_];
    } else if (C = F6(t, _), C < 0)
      break;
    if (y !== t.src.charCodeAt(C - 1))
      break;
  }
  return f ? v = t.push("ordered_list_close", "ol", -1) : v = t.push("bullet_list_close", "ul", -1), v.markup = String.fromCharCode(y), g[1] = _, t.line = _, t.parentType = T, tt && P$t(t, m), !0;
}, L$t = Ve.normalizeReference, e1 = Ve.isSpace, M$t = function(t, n, r, i) {
  var s, o, a, l, h, u, f, d, p, g, m, y, O, x, _, w, E = 0, T = t.bMarks[n] + t.tShift[n], S = t.eMarks[n], R = n + 1;
  if (t.sCount[n] - t.blkIndent >= 4 || t.src.charCodeAt(T) !== 91)
    return !1;
  for (; ++T < S; )
    if (t.src.charCodeAt(T) === 93 && t.src.charCodeAt(T - 1) !== 92) {
      if (T + 1 === S || t.src.charCodeAt(T + 1) !== 58)
        return !1;
      break;
    }
  for (l = t.lineMax, _ = t.md.block.ruler.getRules("reference"), g = t.parentType, t.parentType = "reference"; R < l && !t.isEmpty(R); R++)
    if (!(t.sCount[R] - t.blkIndent > 3) && !(t.sCount[R] < 0)) {
      for (x = !1, u = 0, f = _.length; u < f; u++)
        if (_[u](t, R, l, !0)) {
          x = !0;
          break;
        }
      if (x)
        break;
    }
  for (O = t.getLines(n, R, t.blkIndent, !1).trim(), S = O.length, T = 1; T < S; T++) {
    if (s = O.charCodeAt(T), s === 91)
      return !1;
    if (s === 93) {
      p = T;
      break;
    } else
      s === 10 ? E++ : s === 92 && (T++, T < S && O.charCodeAt(T) === 10 && E++);
  }
  if (p < 0 || O.charCodeAt(p + 1) !== 58)
    return !1;
  for (T = p + 2; T < S; T++)
    if (s = O.charCodeAt(T), s === 10)
      E++;
    else if (!e1(s))
      break;
  if (m = t.md.helpers.parseLinkDestination(O, T, S), !m.ok || (h = t.md.normalizeLink(m.str), !t.md.validateLink(h)))
    return !1;
  for (T = m.pos, E += m.lines, o = T, a = E, y = T; T < S; T++)
    if (s = O.charCodeAt(T), s === 10)
      E++;
    else if (!e1(s))
      break;
  for (m = t.md.helpers.parseLinkTitle(O, T, S), T < S && y !== T && m.ok ? (w = m.str, T = m.pos, E += m.lines) : (w = "", T = o, E = a); T < S && (s = O.charCodeAt(T), !!e1(s)); )
    T++;
  if (T < S && O.charCodeAt(T) !== 10 && w)
    for (w = "", T = o, E = a; T < S && (s = O.charCodeAt(T), !!e1(s)); )
      T++;
  return T < S && O.charCodeAt(T) !== 10 || (d = L$t(O.slice(1, p)), !d) ? !1 : (i || (typeof t.env.references > "u" && (t.env.references = {}), typeof t.env.references[d] > "u" && (t.env.references[d] = { title: w, href: h }), t.parentType = g, t.line = n + E + 1), !0);
}, R$t = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], hy = {}, $$t = "[a-zA-Z_:][a-zA-Z0-9:._-]*", I$t = "[^\"'=<>`\\x00-\\x20]+", N$t = "'[^']*'", B$t = '"[^"]*"', F$t = "(?:" + I$t + "|" + N$t + "|" + B$t + ")", Q$t = "(?:\\s+" + $$t + "(?:\\s*=\\s*" + F$t + ")?)", i$ = "<[A-Za-z][A-Za-z0-9\\-]*" + Q$t + "*\\s*\\/?>", s$ = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", Z$t = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", V$t = "<[?][\\s\\S]*?[?]>", Y$t = "<![A-Z]+\\s+[^>]*>", z$t = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", q$t = new RegExp("^(?:" + i$ + "|" + s$ + "|" + Z$t + "|" + V$t + "|" + Y$t + "|" + z$t + ")"), W$t = new RegExp("^(?:" + i$ + "|" + s$ + ")");
hy.HTML_TAG_RE = q$t;
hy.HTML_OPEN_CLOSE_TAG_RE = W$t;
var U$t = R$t, j$t = hy.HTML_OPEN_CLOSE_TAG_RE, Qc = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + U$t.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(j$t.source + "\\s*$"), /^$/, !1]
], X$t = function(t, n, r, i) {
  var s, o, a, l, h = t.bMarks[n] + t.tShift[n], u = t.eMarks[n];
  if (t.sCount[n] - t.blkIndent >= 4 || !t.md.options.html || t.src.charCodeAt(h) !== 60)
    return !1;
  for (l = t.src.slice(h, u), s = 0; s < Qc.length && !Qc[s][0].test(l); s++)
    ;
  if (s === Qc.length)
    return !1;
  if (i)
    return Qc[s][2];
  if (o = n + 1, !Qc[s][1].test(l)) {
    for (; o < r && !(t.sCount[o] < t.blkIndent); o++)
      if (h = t.bMarks[o] + t.tShift[o], u = t.eMarks[o], l = t.src.slice(h, u), Qc[s][1].test(l)) {
        l.length !== 0 && o++;
        break;
      }
  }
  return t.line = o, a = t.push("html_block", "", 0), a.map = [n, o], a.content = t.getLines(n, o, t.blkIndent, !0), !0;
}, Z6 = Ve.isSpace, G$t = function(t, n, r, i) {
  var s, o, a, l, h = t.bMarks[n] + t.tShift[n], u = t.eMarks[n];
  if (t.sCount[n] - t.blkIndent >= 4 || (s = t.src.charCodeAt(h), s !== 35 || h >= u))
    return !1;
  for (o = 1, s = t.src.charCodeAt(++h); s === 35 && h < u && o <= 6; )
    o++, s = t.src.charCodeAt(++h);
  return o > 6 || h < u && !Z6(s) ? !1 : (i || (u = t.skipSpacesBack(u, h), a = t.skipCharsBack(u, 35, h), a > h && Z6(t.src.charCodeAt(a - 1)) && (u = a), t.line = n + 1, l = t.push("heading_open", "h" + String(o), 1), l.markup = "########".slice(0, o), l.map = [n, t.line], l = t.push("inline", "", 0), l.content = t.src.slice(h, u).trim(), l.map = [n, t.line], l.children = [], l = t.push("heading_close", "h" + String(o), -1), l.markup = "########".slice(0, o)), !0);
}, H$t = function(t, n, r) {
  var i, s, o, a, l, h, u, f, d, p = n + 1, g, m = t.md.block.ruler.getRules("paragraph");
  if (t.sCount[n] - t.blkIndent >= 4)
    return !1;
  for (g = t.parentType, t.parentType = "paragraph"; p < r && !t.isEmpty(p); p++)
    if (!(t.sCount[p] - t.blkIndent > 3)) {
      if (t.sCount[p] >= t.blkIndent && (h = t.bMarks[p] + t.tShift[p], u = t.eMarks[p], h < u && (d = t.src.charCodeAt(h), (d === 45 || d === 61) && (h = t.skipChars(h, d), h = t.skipSpaces(h), h >= u)))) {
        f = d === 61 ? 1 : 2;
        break;
      }
      if (!(t.sCount[p] < 0)) {
        for (s = !1, o = 0, a = m.length; o < a; o++)
          if (m[o](t, p, r, !0)) {
            s = !0;
            break;
          }
        if (s)
          break;
      }
    }
  return f ? (i = t.getLines(n, p, t.blkIndent, !1).trim(), t.line = p + 1, l = t.push("heading_open", "h" + String(f), 1), l.markup = String.fromCharCode(d), l.map = [n, t.line], l = t.push("inline", "", 0), l.content = i, l.map = [n, t.line - 1], l.children = [], l = t.push("heading_close", "h" + String(f), -1), l.markup = String.fromCharCode(d), t.parentType = g, !0) : !1;
}, K$t = function(t, n) {
  var r, i, s, o, a, l, h = n + 1, u = t.md.block.ruler.getRules("paragraph"), f = t.lineMax;
  for (l = t.parentType, t.parentType = "paragraph"; h < f && !t.isEmpty(h); h++)
    if (!(t.sCount[h] - t.blkIndent > 3) && !(t.sCount[h] < 0)) {
      for (i = !1, s = 0, o = u.length; s < o; s++)
        if (u[s](t, h, f, !0)) {
          i = !0;
          break;
        }
      if (i)
        break;
    }
  return r = t.getLines(n, h, t.blkIndent, !1).trim(), t.line = h, a = t.push("paragraph_open", "p", 1), a.map = [n, t.line], a = t.push("inline", "", 0), a.content = r, a.map = [n, t.line], a.children = [], a = t.push("paragraph_close", "p", -1), t.parentType = l, !0;
}, o$ = O3, uy = Ve.isSpace;
function wo(e, t, n, r) {
  var i, s, o, a, l, h, u, f;
  for (this.src = e, this.md = t, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, f = !1, o = a = h = u = 0, l = s.length; a < l; a++) {
    if (i = s.charCodeAt(a), !f)
      if (uy(i)) {
        h++, i === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        f = !0;
    (i === 10 || a === l - 1) && (i !== 10 && a++, this.bMarks.push(o), this.eMarks.push(a), this.tShift.push(h), this.sCount.push(u), this.bsCount.push(0), f = !1, h = 0, u = 0, o = a + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
wo.prototype.push = function(e, t, n) {
  var r = new o$(e, t, n);
  return r.block = !0, n < 0 && this.level--, r.level = this.level, n > 0 && this.level++, this.tokens.push(r), r;
};
wo.prototype.isEmpty = function(t) {
  return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
};
wo.prototype.skipEmptyLines = function(t) {
  for (var n = this.lineMax; t < n && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
    ;
  return t;
};
wo.prototype.skipSpaces = function(t) {
  for (var n, r = this.src.length; t < r && (n = this.src.charCodeAt(t), !!uy(n)); t++)
    ;
  return t;
};
wo.prototype.skipSpacesBack = function(t, n) {
  if (t <= n)
    return t;
  for (; t > n; )
    if (!uy(this.src.charCodeAt(--t)))
      return t + 1;
  return t;
};
wo.prototype.skipChars = function(t, n) {
  for (var r = this.src.length; t < r && this.src.charCodeAt(t) === n; t++)
    ;
  return t;
};
wo.prototype.skipCharsBack = function(t, n, r) {
  if (t <= r)
    return t;
  for (; t > r; )
    if (n !== this.src.charCodeAt(--t))
      return t + 1;
  return t;
};
wo.prototype.getLines = function(t, n, r, i) {
  var s, o, a, l, h, u, f, d = t;
  if (t >= n)
    return "";
  for (u = new Array(n - t), s = 0; d < n; d++, s++) {
    for (o = 0, f = l = this.bMarks[d], d + 1 < n || i ? h = this.eMarks[d] + 1 : h = this.eMarks[d]; l < h && o < r; ) {
      if (a = this.src.charCodeAt(l), uy(a))
        a === 9 ? o += 4 - (o + this.bsCount[d]) % 4 : o++;
      else if (l - f < this.tShift[d])
        o++;
      else
        break;
      l++;
    }
    o > r ? u[s] = new Array(o - r + 1).join(" ") + this.src.slice(l, h) : u[s] = this.src.slice(l, h);
  }
  return u.join("");
};
wo.prototype.Token = o$;
var J$t = wo, tIt = b3, n1 = [
  ["table", w$t, ["paragraph", "reference"]],
  ["code", S$t],
  ["fence", C$t, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", T$t, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", A$t, ["paragraph", "reference", "blockquote", "list"]],
  ["list", D$t, ["paragraph", "reference", "blockquote"]],
  ["reference", M$t],
  ["html_block", X$t, ["paragraph", "reference", "blockquote"]],
  ["heading", G$t, ["paragraph", "reference", "blockquote"]],
  ["lheading", H$t],
  ["paragraph", K$t]
];
function fy() {
  this.ruler = new tIt();
  for (var e = 0; e < n1.length; e++)
    this.ruler.push(n1[e][0], n1[e][1], { alt: (n1[e][2] || []).slice() });
}
fy.prototype.tokenize = function(e, t, n) {
  for (var r, i, s = this.ruler.getRules(""), o = s.length, a = t, l = !1, h = e.md.options.maxNesting; a < n && (e.line = a = e.skipEmptyLines(a), !(a >= n || e.sCount[a] < e.blkIndent)); ) {
    if (e.level >= h) {
      e.line = n;
      break;
    }
    for (i = 0; i < o && (r = s[i](e, a, n, !1), !r); i++)
      ;
    e.tight = !l, e.isEmpty(e.line - 1) && (l = !0), a = e.line, a < n && e.isEmpty(a) && (l = !0, a++, e.line = a);
  }
};
fy.prototype.parse = function(e, t, n, r) {
  var i;
  !e || (i = new this.State(e, t, n, r), this.tokenize(i, i.line, i.lineMax));
};
fy.prototype.State = J$t;
var eIt = fy;
function nIt(e) {
  switch (e) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var rIt = function(t, n) {
  for (var r = t.pos; r < t.posMax && !nIt(t.src.charCodeAt(r)); )
    r++;
  return r === t.pos ? !1 : (n || (t.pending += t.src.slice(t.pos, r)), t.pos = r, !0);
}, iIt = Ve.isSpace, sIt = function(t, n) {
  var r, i, s, o = t.pos;
  if (t.src.charCodeAt(o) !== 10)
    return !1;
  if (r = t.pending.length - 1, i = t.posMax, !n)
    if (r >= 0 && t.pending.charCodeAt(r) === 32)
      if (r >= 1 && t.pending.charCodeAt(r - 1) === 32) {
        for (s = r - 1; s >= 1 && t.pending.charCodeAt(s - 1) === 32; )
          s--;
        t.pending = t.pending.slice(0, s), t.push("hardbreak", "br", 0);
      } else
        t.pending = t.pending.slice(0, -1), t.push("softbreak", "br", 0);
    else
      t.push("softbreak", "br", 0);
  for (o++; o < i && iIt(t.src.charCodeAt(o)); )
    o++;
  return t.pos = o, !0;
}, oIt = Ve.isSpace, v3 = [];
for (var V6 = 0; V6 < 256; V6++)
  v3.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e) {
  v3[e.charCodeAt(0)] = 1;
});
var aIt = function(t, n) {
  var r, i = t.pos, s = t.posMax;
  if (t.src.charCodeAt(i) !== 92)
    return !1;
  if (i++, i < s) {
    if (r = t.src.charCodeAt(i), r < 256 && v3[r] !== 0)
      return n || (t.pending += t.src[i]), t.pos += 2, !0;
    if (r === 10) {
      for (n || t.push("hardbreak", "br", 0), i++; i < s && (r = t.src.charCodeAt(i), !!oIt(r)); )
        i++;
      return t.pos = i, !0;
    }
  }
  return n || (t.pending += "\\"), t.pos++, !0;
}, lIt = function(t, n) {
  var r, i, s, o, a, l, h, u, f = t.pos, d = t.src.charCodeAt(f);
  if (d !== 96)
    return !1;
  for (r = f, f++, i = t.posMax; f < i && t.src.charCodeAt(f) === 96; )
    f++;
  if (s = t.src.slice(r, f), h = s.length, t.backticksScanned && (t.backticks[h] || 0) <= r)
    return n || (t.pending += s), t.pos += h, !0;
  for (a = l = f; (a = t.src.indexOf("`", l)) !== -1; ) {
    for (l = a + 1; l < i && t.src.charCodeAt(l) === 96; )
      l++;
    if (u = l - a, u === h)
      return n || (o = t.push("code_inline", "code", 0), o.markup = s, o.content = t.src.slice(f, a).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), t.pos = l, !0;
    t.backticks[u] = a;
  }
  return t.backticksScanned = !0, n || (t.pending += s), t.pos += h, !0;
}, dy = {};
dy.tokenize = function(t, n) {
  var r, i, s, o, a, l = t.pos, h = t.src.charCodeAt(l);
  if (n || h !== 126 || (i = t.scanDelims(t.pos, !0), o = i.length, a = String.fromCharCode(h), o < 2))
    return !1;
  for (o % 2 && (s = t.push("text", "", 0), s.content = a, o--), r = 0; r < o; r += 2)
    s = t.push("text", "", 0), s.content = a + a, t.delimiters.push({
      marker: h,
      length: 0,
      token: t.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return t.pos += i.length, !0;
};
function Y6(e, t) {
  var n, r, i, s, o, a = [], l = t.length;
  for (n = 0; n < l; n++)
    i = t[n], i.marker === 126 && i.end !== -1 && (s = t[i.end], o = e.tokens[i.token], o.type = "s_open", o.tag = "s", o.nesting = 1, o.markup = "~~", o.content = "", o = e.tokens[s.token], o.type = "s_close", o.tag = "s", o.nesting = -1, o.markup = "~~", o.content = "", e.tokens[s.token - 1].type === "text" && e.tokens[s.token - 1].content === "~" && a.push(s.token - 1));
  for (; a.length; ) {
    for (n = a.pop(), r = n + 1; r < e.tokens.length && e.tokens[r].type === "s_close"; )
      r++;
    r--, n !== r && (o = e.tokens[r], e.tokens[r] = e.tokens[n], e.tokens[n] = o);
  }
}
dy.postProcess = function(t) {
  var n, r = t.tokens_meta, i = t.tokens_meta.length;
  for (Y6(t, t.delimiters), n = 0; n < i; n++)
    r[n] && r[n].delimiters && Y6(t, r[n].delimiters);
};
var py = {};
py.tokenize = function(t, n) {
  var r, i, s, o = t.pos, a = t.src.charCodeAt(o);
  if (n || a !== 95 && a !== 42)
    return !1;
  for (i = t.scanDelims(t.pos, a === 42), r = 0; r < i.length; r++)
    s = t.push("text", "", 0), s.content = String.fromCharCode(a), t.delimiters.push({
      marker: a,
      length: i.length,
      token: t.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return t.pos += i.length, !0;
};
function z6(e, t) {
  var n, r, i, s, o, a, l = t.length;
  for (n = l - 1; n >= 0; n--)
    r = t[n], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (i = t[r.end], a = n > 0 && t[n - 1].end === r.end + 1 && t[n - 1].marker === r.marker && t[n - 1].token === r.token - 1 && t[r.end + 1].token === i.token + 1, o = String.fromCharCode(r.marker), s = e.tokens[r.token], s.type = a ? "strong_open" : "em_open", s.tag = a ? "strong" : "em", s.nesting = 1, s.markup = a ? o + o : o, s.content = "", s = e.tokens[i.token], s.type = a ? "strong_close" : "em_close", s.tag = a ? "strong" : "em", s.nesting = -1, s.markup = a ? o + o : o, s.content = "", a && (e.tokens[t[n - 1].token].content = "", e.tokens[t[r.end + 1].token].content = "", n--));
}
py.postProcess = function(t) {
  var n, r = t.tokens_meta, i = t.tokens_meta.length;
  for (z6(t, t.delimiters), n = 0; n < i; n++)
    r[n] && r[n].delimiters && z6(t, r[n].delimiters);
};
var cIt = Ve.normalizeReference, xO = Ve.isSpace, hIt = function(t, n) {
  var r, i, s, o, a, l, h, u, f, d = "", p = "", g = t.pos, m = t.posMax, y = t.pos, O = !0;
  if (t.src.charCodeAt(t.pos) !== 91 || (a = t.pos + 1, o = t.md.helpers.parseLinkLabel(t, t.pos, !0), o < 0))
    return !1;
  if (l = o + 1, l < m && t.src.charCodeAt(l) === 40) {
    for (O = !1, l++; l < m && (i = t.src.charCodeAt(l), !(!xO(i) && i !== 10)); l++)
      ;
    if (l >= m)
      return !1;
    if (y = l, h = t.md.helpers.parseLinkDestination(t.src, l, t.posMax), h.ok) {
      for (d = t.md.normalizeLink(h.str), t.md.validateLink(d) ? l = h.pos : d = "", y = l; l < m && (i = t.src.charCodeAt(l), !(!xO(i) && i !== 10)); l++)
        ;
      if (h = t.md.helpers.parseLinkTitle(t.src, l, t.posMax), l < m && y !== l && h.ok)
        for (p = h.str, l = h.pos; l < m && (i = t.src.charCodeAt(l), !(!xO(i) && i !== 10)); l++)
          ;
    }
    (l >= m || t.src.charCodeAt(l) !== 41) && (O = !0), l++;
  }
  if (O) {
    if (typeof t.env.references > "u")
      return !1;
    if (l < m && t.src.charCodeAt(l) === 91 ? (y = l + 1, l = t.md.helpers.parseLinkLabel(t, l), l >= 0 ? s = t.src.slice(y, l++) : l = o + 1) : l = o + 1, s || (s = t.src.slice(a, o)), u = t.env.references[cIt(s)], !u)
      return t.pos = g, !1;
    d = u.href, p = u.title;
  }
  return n || (t.pos = a, t.posMax = o, f = t.push("link_open", "a", 1), f.attrs = r = [["href", d]], p && r.push(["title", p]), t.md.inline.tokenize(t), f = t.push("link_close", "a", -1)), t.pos = l, t.posMax = m, !0;
}, uIt = Ve.normalizeReference, vO = Ve.isSpace, fIt = function(t, n) {
  var r, i, s, o, a, l, h, u, f, d, p, g, m, y = "", O = t.pos, x = t.posMax;
  if (t.src.charCodeAt(t.pos) !== 33 || t.src.charCodeAt(t.pos + 1) !== 91 || (l = t.pos + 2, a = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1), a < 0))
    return !1;
  if (h = a + 1, h < x && t.src.charCodeAt(h) === 40) {
    for (h++; h < x && (i = t.src.charCodeAt(h), !(!vO(i) && i !== 10)); h++)
      ;
    if (h >= x)
      return !1;
    for (m = h, f = t.md.helpers.parseLinkDestination(t.src, h, t.posMax), f.ok && (y = t.md.normalizeLink(f.str), t.md.validateLink(y) ? h = f.pos : y = ""), m = h; h < x && (i = t.src.charCodeAt(h), !(!vO(i) && i !== 10)); h++)
      ;
    if (f = t.md.helpers.parseLinkTitle(t.src, h, t.posMax), h < x && m !== h && f.ok)
      for (d = f.str, h = f.pos; h < x && (i = t.src.charCodeAt(h), !(!vO(i) && i !== 10)); h++)
        ;
    else
      d = "";
    if (h >= x || t.src.charCodeAt(h) !== 41)
      return t.pos = O, !1;
    h++;
  } else {
    if (typeof t.env.references > "u")
      return !1;
    if (h < x && t.src.charCodeAt(h) === 91 ? (m = h + 1, h = t.md.helpers.parseLinkLabel(t, h), h >= 0 ? o = t.src.slice(m, h++) : h = a + 1) : h = a + 1, o || (o = t.src.slice(l, a)), u = t.env.references[uIt(o)], !u)
      return t.pos = O, !1;
    y = u.href, d = u.title;
  }
  return n || (s = t.src.slice(l, a), t.md.inline.parse(
    s,
    t.md,
    t.env,
    g = []
  ), p = t.push("image", "img", 0), p.attrs = r = [["src", y], ["alt", ""]], p.children = g, p.content = s, d && r.push(["title", d])), t.pos = h, t.posMax = x, !0;
}, dIt = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, pIt = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, gIt = function(t, n) {
  var r, i, s, o, a, l, h = t.pos;
  if (t.src.charCodeAt(h) !== 60)
    return !1;
  for (a = t.pos, l = t.posMax; ; ) {
    if (++h >= l || (o = t.src.charCodeAt(h), o === 60))
      return !1;
    if (o === 62)
      break;
  }
  return r = t.src.slice(a + 1, h), pIt.test(r) ? (i = t.md.normalizeLink(r), t.md.validateLink(i) ? (n || (s = t.push("link_open", "a", 1), s.attrs = [["href", i]], s.markup = "autolink", s.info = "auto", s = t.push("text", "", 0), s.content = t.md.normalizeLinkText(r), s = t.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), t.pos += r.length + 2, !0) : !1) : dIt.test(r) ? (i = t.md.normalizeLink("mailto:" + r), t.md.validateLink(i) ? (n || (s = t.push("link_open", "a", 1), s.attrs = [["href", i]], s.markup = "autolink", s.info = "auto", s = t.push("text", "", 0), s.content = t.md.normalizeLinkText(r), s = t.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), t.pos += r.length + 2, !0) : !1) : !1;
}, mIt = hy.HTML_TAG_RE;
function yIt(e) {
  var t = e | 32;
  return t >= 97 && t <= 122;
}
var bIt = function(t, n) {
  var r, i, s, o, a = t.pos;
  return !t.md.options.html || (s = t.posMax, t.src.charCodeAt(a) !== 60 || a + 2 >= s) || (r = t.src.charCodeAt(a + 1), r !== 33 && r !== 63 && r !== 47 && !yIt(r)) || (i = t.src.slice(a).match(mIt), !i) ? !1 : (n || (o = t.push("html_inline", "", 0), o.content = t.src.slice(a, a + i[0].length)), t.pos += i[0].length, !0);
}, q6 = m3.exports, OIt = Ve.has, xIt = Ve.isValidEntityCode, W6 = Ve.fromCodePoint, vIt = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, _It = /^&([a-z][a-z0-9]{1,31});/i, kIt = function(t, n) {
  var r, i, s, o = t.pos, a = t.posMax;
  if (t.src.charCodeAt(o) !== 38)
    return !1;
  if (o + 1 < a) {
    if (r = t.src.charCodeAt(o + 1), r === 35) {
      if (s = t.src.slice(o).match(vIt), s)
        return n || (i = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), t.pending += xIt(i) ? W6(i) : W6(65533)), t.pos += s[0].length, !0;
    } else if (s = t.src.slice(o).match(_It), s && OIt(q6, s[1]))
      return n || (t.pending += q6[s[1]]), t.pos += s[0].length, !0;
  }
  return n || (t.pending += "&"), t.pos++, !0;
};
function U6(e, t) {
  var n, r, i, s, o, a, l, h, u = {}, f = t.length;
  if (!!f) {
    var d = 0, p = -2, g = [];
    for (n = 0; n < f; n++)
      if (i = t[n], g.push(0), (t[d].marker !== i.marker || p !== i.token - 1) && (d = n), p = i.token, i.length = i.length || 0, !!i.close) {
        for (u.hasOwnProperty(i.marker) || (u[i.marker] = [-1, -1, -1, -1, -1, -1]), o = u[i.marker][(i.open ? 3 : 0) + i.length % 3], r = d - g[d] - 1, a = r; r > o; r -= g[r] + 1)
          if (s = t[r], s.marker === i.marker && s.open && s.end < 0 && (l = !1, (s.close || i.open) && (s.length + i.length) % 3 === 0 && (s.length % 3 !== 0 || i.length % 3 !== 0) && (l = !0), !l)) {
            h = r > 0 && !t[r - 1].open ? g[r - 1] + 1 : 0, g[n] = n - r + h, g[r] = h, i.open = !1, s.end = n, s.close = !1, a = -1, p = -2;
            break;
          }
        a !== -1 && (u[i.marker][(i.open ? 3 : 0) + (i.length || 0) % 3] = a);
      }
  }
}
var wIt = function(t) {
  var n, r = t.tokens_meta, i = t.tokens_meta.length;
  for (U6(t, t.delimiters), n = 0; n < i; n++)
    r[n] && r[n].delimiters && U6(t, r[n].delimiters);
}, SIt = function(t) {
  var n, r, i = 0, s = t.tokens, o = t.tokens.length;
  for (n = r = 0; n < o; n++)
    s[n].nesting < 0 && i--, s[n].level = i, s[n].nesting > 0 && i++, s[n].type === "text" && n + 1 < o && s[n + 1].type === "text" ? s[n + 1].content = s[n].content + s[n + 1].content : (n !== r && (s[r] = s[n]), r++);
  n !== r && (s.length = r);
}, _3 = O3, j6 = Ve.isWhiteSpace, X6 = Ve.isPunctChar, G6 = Ve.isMdAsciiPunct;
function Xp(e, t, n, r) {
  this.src = e, this.env = n, this.md = t, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1;
}
Xp.prototype.pushPending = function() {
  var e = new _3("text", "", 0);
  return e.content = this.pending, e.level = this.pendingLevel, this.tokens.push(e), this.pending = "", e;
};
Xp.prototype.push = function(e, t, n) {
  this.pending && this.pushPending();
  var r = new _3(e, t, n), i = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(i), r;
};
Xp.prototype.scanDelims = function(e, t) {
  var n = e, r, i, s, o, a, l, h, u, f, d = !0, p = !0, g = this.posMax, m = this.src.charCodeAt(e);
  for (r = e > 0 ? this.src.charCodeAt(e - 1) : 32; n < g && this.src.charCodeAt(n) === m; )
    n++;
  return s = n - e, i = n < g ? this.src.charCodeAt(n) : 32, h = G6(r) || X6(String.fromCharCode(r)), f = G6(i) || X6(String.fromCharCode(i)), l = j6(r), u = j6(i), u ? d = !1 : f && (l || h || (d = !1)), l ? p = !1 : h && (u || f || (p = !1)), t ? (o = d, a = p) : (o = d && (!p || h), a = p && (!d || f)), {
    can_open: o,
    can_close: a,
    length: s
  };
};
Xp.prototype.Token = _3;
var CIt = Xp, H6 = b3, _O = [
  ["text", rIt],
  ["newline", sIt],
  ["escape", aIt],
  ["backticks", lIt],
  ["strikethrough", dy.tokenize],
  ["emphasis", py.tokenize],
  ["link", hIt],
  ["image", fIt],
  ["autolink", gIt],
  ["html_inline", bIt],
  ["entity", kIt]
], kO = [
  ["balance_pairs", wIt],
  ["strikethrough", dy.postProcess],
  ["emphasis", py.postProcess],
  ["text_collapse", SIt]
];
function Gp() {
  var e;
  for (this.ruler = new H6(), e = 0; e < _O.length; e++)
    this.ruler.push(_O[e][0], _O[e][1]);
  for (this.ruler2 = new H6(), e = 0; e < kO.length; e++)
    this.ruler2.push(kO[e][0], kO[e][1]);
}
Gp.prototype.skipToken = function(e) {
  var t, n, r = e.pos, i = this.ruler.getRules(""), s = i.length, o = e.md.options.maxNesting, a = e.cache;
  if (typeof a[r] < "u") {
    e.pos = a[r];
    return;
  }
  if (e.level < o)
    for (n = 0; n < s && (e.level++, t = i[n](e, !0), e.level--, !t); n++)
      ;
  else
    e.pos = e.posMax;
  t || e.pos++, a[r] = e.pos;
};
Gp.prototype.tokenize = function(e) {
  for (var t, n, r = this.ruler.getRules(""), i = r.length, s = e.posMax, o = e.md.options.maxNesting; e.pos < s; ) {
    if (e.level < o)
      for (n = 0; n < i && (t = r[n](e, !1), !t); n++)
        ;
    if (t) {
      if (e.pos >= s)
        break;
      continue;
    }
    e.pending += e.src[e.pos++];
  }
  e.pending && e.pushPending();
};
Gp.prototype.parse = function(e, t, n, r) {
  var i, s, o, a = new this.State(e, t, n, r);
  for (this.tokenize(a), s = this.ruler2.getRules(""), o = s.length, i = 0; i < o; i++)
    s[i](a);
};
Gp.prototype.State = CIt;
var TIt = Gp, wO, K6;
function EIt() {
  return K6 || (K6 = 1, wO = function(e) {
    var t = {};
    t.src_Any = KR().source, t.src_Cc = JR().source, t.src_Z = t$().source, t.src_P = y3.source, t.src_ZPCc = [t.src_Z, t.src_P, t.src_Cc].join("|"), t.src_ZCc = [t.src_Z, t.src_Cc].join("|");
    var n = "[><\uFF5C]";
    return t.src_pseudo_letter = "(?:(?!" + n + "|" + t.src_ZPCc + ")" + t.src_Any + ")", t.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", t.src_auth = "(?:(?:(?!" + t.src_ZCc + "|[@/\\[\\]()]).)+@)?", t.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", t.src_host_terminator = "(?=$|" + n + "|" + t.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + t.src_ZPCc + "))", t.src_path = "(?:[/?#](?:(?!" + t.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + t.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + t.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + t.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + t.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + t.src_ZCc + "|[']).)+\\'|\\'(?=" + t.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + t.src_ZCc + "|[.]).|" + (e && e["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + t.src_ZCc + ").|;(?!" + t.src_ZCc + ").|\\!+(?!" + t.src_ZCc + "|[!]).|\\?(?!" + t.src_ZCc + "|[?]).)+|\\/)?", t.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', t.src_xn = "xn--[a-z0-9\\-]{1,59}", t.src_domain_root = "(?:" + t.src_xn + "|" + t.src_pseudo_letter + "{1,63})", t.src_domain = "(?:" + t.src_xn + "|(?:" + t.src_pseudo_letter + ")|(?:" + t.src_pseudo_letter + "(?:-|" + t.src_pseudo_letter + "){0,61}" + t.src_pseudo_letter + "))", t.src_host = "(?:(?:(?:(?:" + t.src_domain + ")\\.)*" + t.src_domain + "))", t.tpl_host_fuzzy = "(?:" + t.src_ip4 + "|(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%)))", t.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%))", t.src_host_strict = t.src_host + t.src_host_terminator, t.tpl_host_fuzzy_strict = t.tpl_host_fuzzy + t.src_host_terminator, t.src_host_port_strict = t.src_host + t.src_port + t.src_host_terminator, t.tpl_host_port_fuzzy_strict = t.tpl_host_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_port_no_ip_fuzzy_strict = t.tpl_host_no_ip_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + t.src_ZPCc + "|>|$))", t.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + t.src_ZCc + ")(" + t.src_email_name + "@" + t.tpl_host_fuzzy_strict + ")", t.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + t.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + t.tpl_host_port_fuzzy_strict + t.src_path + ")", t.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + t.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + t.tpl_host_port_no_ip_fuzzy_strict + t.src_path + ")", t;
  }), wO;
}
function f_(e) {
  var t = Array.prototype.slice.call(arguments, 1);
  return t.forEach(function(n) {
    !n || Object.keys(n).forEach(function(r) {
      e[r] = n[r];
    });
  }), e;
}
function gy(e) {
  return Object.prototype.toString.call(e);
}
function AIt(e) {
  return gy(e) === "[object String]";
}
function PIt(e) {
  return gy(e) === "[object Object]";
}
function DIt(e) {
  return gy(e) === "[object RegExp]";
}
function J6(e) {
  return gy(e) === "[object Function]";
}
function LIt(e) {
  return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var a$ = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function MIt(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t || a$.hasOwnProperty(n);
  }, !1);
}
var RIt = {
  "http:": {
    validate: function(e, t, n) {
      var r = e.slice(t);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(r) ? r.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(e, t, n) {
      var r = e.slice(t);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(r) ? t >= 3 && e[t - 3] === ":" || t >= 3 && e[t - 3] === "/" ? 0 : r.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(e, t, n) {
      var r = e.slice(t);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0;
    }
  }
}, $It = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", IIt = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function NIt(e) {
  e.__index__ = -1, e.__text_cache__ = "";
}
function BIt(e) {
  return function(t, n) {
    var r = t.slice(n);
    return e.test(r) ? r.match(e)[0].length : 0;
  };
}
function tE() {
  return function(e, t) {
    t.normalize(e);
  };
}
function gm(e) {
  var t = e.re = EIt()(e.__opts__), n = e.__tlds__.slice();
  e.onCompile(), e.__tlds_replaced__ || n.push($It), n.push(t.src_xn), t.src_tlds = n.join("|");
  function r(a) {
    return a.replace("%TLDS%", t.src_tlds);
  }
  t.email_fuzzy = RegExp(r(t.tpl_email_fuzzy), "i"), t.link_fuzzy = RegExp(r(t.tpl_link_fuzzy), "i"), t.link_no_ip_fuzzy = RegExp(r(t.tpl_link_no_ip_fuzzy), "i"), t.host_fuzzy_test = RegExp(r(t.tpl_host_fuzzy_test), "i");
  var i = [];
  e.__compiled__ = {};
  function s(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(e.__schemas__).forEach(function(a) {
    var l = e.__schemas__[a];
    if (l !== null) {
      var h = { validate: null, link: null };
      if (e.__compiled__[a] = h, PIt(l)) {
        DIt(l.validate) ? h.validate = BIt(l.validate) : J6(l.validate) ? h.validate = l.validate : s(a, l), J6(l.normalize) ? h.normalize = l.normalize : l.normalize ? s(a, l) : h.normalize = tE();
        return;
      }
      if (AIt(l)) {
        i.push(a);
        return;
      }
      s(a, l);
    }
  }), i.forEach(function(a) {
    !e.__compiled__[e.__schemas__[a]] || (e.__compiled__[a].validate = e.__compiled__[e.__schemas__[a]].validate, e.__compiled__[a].normalize = e.__compiled__[e.__schemas__[a]].normalize);
  }), e.__compiled__[""] = { validate: null, normalize: tE() };
  var o = Object.keys(e.__compiled__).filter(function(a) {
    return a.length > 0 && e.__compiled__[a];
  }).map(LIt).join("|");
  e.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + t.src_ZPCc + "))(" + o + ")", "i"), e.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + t.src_ZPCc + "))(" + o + ")", "ig"), e.re.pretest = RegExp(
    "(" + e.re.schema_test.source + ")|(" + e.re.host_fuzzy_test.source + ")|@",
    "i"
  ), NIt(e);
}
function FIt(e, t) {
  var n = e.__index__, r = e.__last_index__, i = e.__text_cache__.slice(n, r);
  this.schema = e.__schema__.toLowerCase(), this.index = n + t, this.lastIndex = r + t, this.raw = i, this.text = i, this.url = i;
}
function eE(e, t) {
  var n = new FIt(e, t);
  return e.__compiled__[n.schema].normalize(n, e), n;
}
function zi(e, t) {
  if (!(this instanceof zi))
    return new zi(e, t);
  t || MIt(e) && (t = e, e = {}), this.__opts__ = f_({}, a$, t), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = f_({}, RIt, e), this.__compiled__ = {}, this.__tlds__ = IIt, this.__tlds_replaced__ = !1, this.re = {}, gm(this);
}
zi.prototype.add = function(t, n) {
  return this.__schemas__[t] = n, gm(this), this;
};
zi.prototype.set = function(t) {
  return this.__opts__ = f_(this.__opts__, t), this;
};
zi.prototype.test = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length)
    return !1;
  var n, r, i, s, o, a, l, h, u;
  if (this.re.schema_test.test(t)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (n = l.exec(t)) !== null; )
      if (s = this.testSchemaAt(t, n[2], l.lastIndex), s) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (h = t.search(this.re.host_fuzzy_test), h >= 0 && (this.__index__ < 0 || h < this.__index__) && (r = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = r.index + r[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = t.indexOf("@"), u >= 0 && (i = t.match(this.re.email_fuzzy)) !== null && (o = i.index + i[1].length, a = i.index + i[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && a > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = a))), this.__index__ >= 0;
};
zi.prototype.pretest = function(t) {
  return this.re.pretest.test(t);
};
zi.prototype.testSchemaAt = function(t, n, r) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(t, r, this) : 0;
};
zi.prototype.match = function(t) {
  var n = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === t && (r.push(eE(this, n)), n = this.__last_index__);
  for (var i = n ? t.slice(n) : t; this.test(i); )
    r.push(eE(this, n)), i = i.slice(this.__last_index__), n += this.__last_index__;
  return r.length ? r : null;
};
zi.prototype.tlds = function(t, n) {
  return t = Array.isArray(t) ? t : [t], n ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(r, i, s) {
    return r !== s[i - 1];
  }).reverse(), gm(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, gm(this), this);
};
zi.prototype.normalize = function(t) {
  t.schema || (t.url = "http://" + t.url), t.schema === "mailto:" && !/^mailto:/i.test(t.url) && (t.url = "mailto:" + t.url);
};
zi.prototype.onCompile = function() {
};
var QIt = zi;
const _h = 2147483647, no = 36, k3 = 1, jd = 26, ZIt = 38, VIt = 700, l$ = 72, c$ = 128, h$ = "-", YIt = /^xn--/, zIt = /[^\0-\x7F]/, qIt = /[\x2E\u3002\uFF0E\uFF61]/g, WIt = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, SO = no - k3, ro = Math.floor, CO = String.fromCharCode;
function Aa(e) {
  throw new RangeError(WIt[e]);
}
function UIt(e, t) {
  const n = [];
  let r = e.length;
  for (; r--; )
    n[r] = t(e[r]);
  return n;
}
function u$(e, t) {
  const n = e.split("@");
  let r = "";
  n.length > 1 && (r = n[0] + "@", e = n[1]), e = e.replace(qIt, ".");
  const i = e.split("."), s = UIt(i, t).join(".");
  return r + s;
}
function w3(e) {
  const t = [];
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const i = e.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const s = e.charCodeAt(n++);
      (s & 64512) == 56320 ? t.push(((i & 1023) << 10) + (s & 1023) + 65536) : (t.push(i), n--);
    } else
      t.push(i);
  }
  return t;
}
const f$ = (e) => String.fromCodePoint(...e), jIt = function(e) {
  return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : no;
}, nE = function(e, t) {
  return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
}, d$ = function(e, t, n) {
  let r = 0;
  for (e = n ? ro(e / VIt) : e >> 1, e += ro(e / t); e > SO * jd >> 1; r += no)
    e = ro(e / SO);
  return ro(r + (SO + 1) * e / (e + ZIt));
}, S3 = function(e) {
  const t = [], n = e.length;
  let r = 0, i = c$, s = l$, o = e.lastIndexOf(h$);
  o < 0 && (o = 0);
  for (let a = 0; a < o; ++a)
    e.charCodeAt(a) >= 128 && Aa("not-basic"), t.push(e.charCodeAt(a));
  for (let a = o > 0 ? o + 1 : 0; a < n; ) {
    const l = r;
    for (let u = 1, f = no; ; f += no) {
      a >= n && Aa("invalid-input");
      const d = jIt(e.charCodeAt(a++));
      d >= no && Aa("invalid-input"), d > ro((_h - r) / u) && Aa("overflow"), r += d * u;
      const p = f <= s ? k3 : f >= s + jd ? jd : f - s;
      if (d < p)
        break;
      const g = no - p;
      u > ro(_h / g) && Aa("overflow"), u *= g;
    }
    const h = t.length + 1;
    s = d$(r - l, h, l == 0), ro(r / h) > _h - i && Aa("overflow"), i += ro(r / h), r %= h, t.splice(r++, 0, i);
  }
  return String.fromCodePoint(...t);
}, C3 = function(e) {
  const t = [];
  e = w3(e);
  const n = e.length;
  let r = c$, i = 0, s = l$;
  for (const l of e)
    l < 128 && t.push(CO(l));
  const o = t.length;
  let a = o;
  for (o && t.push(h$); a < n; ) {
    let l = _h;
    for (const u of e)
      u >= r && u < l && (l = u);
    const h = a + 1;
    l - r > ro((_h - i) / h) && Aa("overflow"), i += (l - r) * h, r = l;
    for (const u of e)
      if (u < r && ++i > _h && Aa("overflow"), u === r) {
        let f = i;
        for (let d = no; ; d += no) {
          const p = d <= s ? k3 : d >= s + jd ? jd : d - s;
          if (f < p)
            break;
          const g = f - p, m = no - p;
          t.push(
            CO(nE(p + g % m, 0))
          ), f = ro(g / m);
        }
        t.push(CO(nE(f, 0))), s = d$(i, h, a === o), i = 0, ++a;
      }
    ++i, ++r;
  }
  return t.join("");
}, p$ = function(e) {
  return u$(e, function(t) {
    return YIt.test(t) ? S3(t.slice(4).toLowerCase()) : t;
  });
}, g$ = function(e) {
  return u$(e, function(t) {
    return zIt.test(t) ? "xn--" + C3(t) : t;
  });
}, XIt = {
  version: "2.3.1",
  ucs2: {
    decode: w3,
    encode: f$
  },
  decode: S3,
  encode: C3,
  toASCII: g$,
  toUnicode: p$
}, GIt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ucs2decode: w3,
  ucs2encode: f$,
  decode: S3,
  encode: C3,
  toASCII: g$,
  toUnicode: p$,
  default: XIt
}, Symbol.toStringTag, { value: "Module" })), HIt = /* @__PURE__ */ F7(GIt);
var KIt = {
  options: {
    html: !1,
    xhtmlOut: !1,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, JIt = {
  options: {
    html: !1,
    xhtmlOut: !1,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
}, tNt = {
  options: {
    html: !0,
    xhtmlOut: !0,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
}, Hf = Ve, eNt = cy, nNt = t$t, rNt = k$t, iNt = eIt, sNt = TIt, oNt = QIt, Yl = Iu, m$ = HIt, aNt = {
  default: KIt,
  zero: JIt,
  commonmark: tNt
}, lNt = /^(vbscript|javascript|file|data):/, cNt = /^data:image\/(gif|png|jpeg|webp);/;
function hNt(e) {
  var t = e.trim().toLowerCase();
  return lNt.test(t) ? !!cNt.test(t) : !0;
}
var y$ = ["http:", "https:", "mailto:"];
function uNt(e) {
  var t = Yl.parse(e, !0);
  if (t.hostname && (!t.protocol || y$.indexOf(t.protocol) >= 0))
    try {
      t.hostname = m$.toASCII(t.hostname);
    } catch {
    }
  return Yl.encode(Yl.format(t));
}
function fNt(e) {
  var t = Yl.parse(e, !0);
  if (t.hostname && (!t.protocol || y$.indexOf(t.protocol) >= 0))
    try {
      t.hostname = m$.toUnicode(t.hostname);
    } catch {
    }
  return Yl.decode(Yl.format(t), Yl.decode.defaultChars + "%");
}
function qi(e, t) {
  if (!(this instanceof qi))
    return new qi(e, t);
  t || Hf.isString(e) || (t = e || {}, e = "default"), this.inline = new sNt(), this.block = new iNt(), this.core = new rNt(), this.renderer = new nNt(), this.linkify = new oNt(), this.validateLink = hNt, this.normalizeLink = uNt, this.normalizeLinkText = fNt, this.utils = Hf, this.helpers = Hf.assign({}, eNt), this.options = {}, this.configure(e), t && this.set(t);
}
qi.prototype.set = function(e) {
  return Hf.assign(this.options, e), this;
};
qi.prototype.configure = function(e) {
  var t = this, n;
  if (Hf.isString(e) && (n = e, e = aNt[n], !e))
    throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  if (!e)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return e.options && t.set(e.options), e.components && Object.keys(e.components).forEach(function(r) {
    e.components[r].rules && t[r].ruler.enableOnly(e.components[r].rules), e.components[r].rules2 && t[r].ruler2.enableOnly(e.components[r].rules2);
  }), this;
};
qi.prototype.enable = function(e, t) {
  var n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.enable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(e, !0));
  var r = e.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !t)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
qi.prototype.disable = function(e, t) {
  var n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.disable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(e, !0));
  var r = e.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !t)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
qi.prototype.use = function(e) {
  var t = [this].concat(Array.prototype.slice.call(arguments, 1));
  return e.apply(e, t), this;
};
qi.prototype.parse = function(e, t) {
  if (typeof e != "string")
    throw new Error("Input data should be a String");
  var n = new this.core.State(e, this, t);
  return this.core.process(n), n.tokens;
};
qi.prototype.render = function(e, t) {
  return t = t || {}, this.renderer.render(this.parse(e, t), this.options, t);
};
qi.prototype.parseInline = function(e, t) {
  var n = new this.core.State(e, this, t);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
qi.prototype.renderInline = function(e, t) {
  return t = t || {}, this.renderer.render(this.parseInline(e, t), this.options, t);
};
var dNt = qi;
(function(e) {
  e.exports = dNt;
})(HR);
const pNt = /* @__PURE__ */ ZY(HR.exports);
class ba {
  constructor(t) {
    this.state = t;
  }
  run(t) {
    return [];
  }
}
class gNt extends ba {
  run(t) {
    const n = new this.state.Token("code_inline", "code", 0);
    return n.content = t.content, [n];
  }
}
const mNt = {
  raw: gNt
}, d_ = "math_inline";
class yNt extends ba {
  run(t) {
    const n = new this.state.Token(d_, "span", 0);
    return n.attrSet("class", "math inline"), n.markup = "$", n.content = t.content, [n];
  }
}
function bNt(e, t) {
  var n;
  !(!((n = t == null ? void 0 : t.roles) === null || n === void 0) && n.math) || e.renderer.rules[d_] || (e.renderer.rules[d_] = (r, i) => {
    var s, o, a;
    const l = (a = (o = (s = t == null ? void 0 : t.opts) === null || s === void 0 ? void 0 : s.math) === null || o === void 0 ? void 0 : o.renderer) !== null && a !== void 0 ? a : (d) => e.utils.escapeHtml(d), h = r[i], u = h.content.trim(), f = l(u, { displayMode: !1 });
    return `<span class="${h.attrGet("class")}">${f}</span>`;
  });
}
const ONt = {
  math: yNt
};
function b$(e, t) {
  t.parseRoles && e.inline.ruler.before("backticks", "parse_roles", xNt), e.core.ruler.after(t.rolesAfter || "inline", "run_roles", _Nt(t.roles || {})), e.renderer.rules.role = (n, r) => {
    const i = n[r];
    return `<span class="role-unhandled"><mark>${i.meta.name}</mark><code>${i.content}</code></span>`;
  }, bNt(e, t);
}
function xNt(e, t) {
  if (e.src.charCodeAt(e.pos - 1) === 92)
    return !1;
  const n = vNt.exec(e.src.slice(e.pos));
  if (n == null)
    return !1;
  const [r, i, , s] = n;
  if (e.pos += r.length, !t) {
    const o = e.push("role", "", 0);
    o.meta = { name: i }, o.content = s;
  }
  return !0;
}
let p_;
try {
  p_ = new RegExp("^\\{([a-zA-Z_\\-+:]{1,36})\\}(`+)(?!`)(.+?)(?<!`)\\2(?!`)");
} catch {
  p_ = /^\{([a-zA-Z_\-+:]{1,36})\}(`+)(?!`)(.+?)\2(?!`)/;
}
const vNt = p_;
function _Nt(e) {
  function t(n) {
    var r;
    for (const i of n.tokens)
      if (i.type === "inline" && i.children) {
        const s = [];
        for (const o of i.children)
          if (o.type === "role" && ((r = o.meta) === null || r === void 0 ? void 0 : r.name) in e)
            try {
              const a = new e[o.meta.name](n), l = new n.Token("parsed_role_open", "", 1);
              l.content = o.content, l.hidden = !0, l.meta = { name: o.meta.name }, l.block = !1;
              const h = [l];
              h.push(...a.run({
                parentMap: i.map,
                content: o.content
              }));
              const u = new n.Token("parsed_role_close", "", -1);
              u.block = !1, u.hidden = !0, h.push(u), s.push(...h);
            } catch (a) {
              const l = new n.Token("role_error", "", 0);
              l.content = o.content, l.info = o.info, l.meta = o.meta, l.map = o.map, l.meta.error_message = a.message, l.meta.error_name = a.name, s.push(l);
            }
          else
            s.push(o);
        i.children = s;
      }
    return !0;
  }
  return t;
}
class rE extends ba {
  run(t) {
    const n = new this.state.Token("sub_open", "sub", 1);
    n.markup = "~";
    const r = new this.state.Token("text", "", 0);
    r.content = t.content;
    const i = new this.state.Token("sub_close", "sub", -1);
    return i.markup = "~", [n, r, i];
  }
}
class iE extends ba {
  run(t) {
    const n = new this.state.Token("sup_open", "sup", 1);
    n.markup = "~";
    const r = new this.state.Token("text", "", 0);
    r.content = t.content;
    const i = new this.state.Token("sup_close", "sup", -1);
    return i.markup = "~", [n, r, i];
  }
}
const kNt = /^(.+?)\(([^()]+)\)$/;
class sE extends ba {
  run(t) {
    var n, r, i, s;
    const o = kNt.exec(t.content), a = (r = (n = o == null ? void 0 : o[1]) === null || n === void 0 ? void 0 : n.trim()) !== null && r !== void 0 ? r : t.content.trim(), l = (s = (i = o == null ? void 0 : o[2]) === null || i === void 0 ? void 0 : i.trim()) !== null && s !== void 0 ? s : null, h = new this.state.Token("abbr_open", "abbr", 1);
    l && h.attrSet("title", l);
    const u = new this.state.Token("text", "", 0);
    u.content = a;
    const f = new this.state.Token("abbr_close", "abbr", -1);
    return [h, u, f];
  }
}
const wNt = {
  subscript: rE,
  sub: rE,
  superscript: iE,
  sup: iE,
  abbreviation: sE,
  abbr: sE
};
var Xd;
(function(e) {
  e.equation = "eq", e.figure = "fig", e.table = "table", e.code = "code", e.section = "sec";
})(Xd || (Xd = {}));
function my(e) {
  var t, n;
  const r = (n = (t = e.env) === null || t === void 0 ? void 0 : t.docutils) !== null && n !== void 0 ? n : {};
  return r.targets || (r.targets = {}), r.references || (r.references = []), r.numbering || (r.numbering = {}), e.env.docutils || (e.env.docutils = r), r;
}
function SNt(e) {
  var t, n;
  const r = (n = (t = e.meta) === null || t === void 0 ? void 0 : t.docutils) !== null && n !== void 0 ? n : {};
  return e.meta || (e.meta = {}), e.meta.docutils || (e.meta.docutils = r), r;
}
function CNt(e, t) {
  const n = my(e);
  return n.numbering[t] == null ? n.numbering[t] = 1 : n.numbering[t] += 1, n.numbering[t];
}
function O$(e, t, n, r, i, s = !1) {
  const o = my(e), a = CNt(e, n), l = {
    label: r,
    kind: n,
    number: a,
    title: i
  };
  if (!s) {
    const h = SNt(t);
    h.target = l, t.attrSet("id", r), o.targets[r] = l;
  }
  return l;
}
function T3(e, t, n, r) {
  var i;
  t.open.meta = (i = t.open.meta) !== null && i !== void 0 ? i : {}, t.open.meta.kind = n.kind, t.open.meta.label = n.label, t.open.meta.value = n.value, my(e).references.push(Object.assign({ label: n.label, tokens: t }, r));
}
const x$ = /^(.+?)<([^<>]+)>$/;
class TNt extends ba {
  run(t) {
    const n = new this.state.Token("ref_open", "a", 1), r = new this.state.Token("text", "", 0), i = new this.state.Token("ref_close", "a", -1);
    return T3(this.state, { open: n, content: r, close: i }, { kind: "eq", label: t.content }, {
      kind: Xd.equation,
      contentFromTarget: (s) => `(${s.number})`
    }), [n, r, i];
  }
}
class ENt extends ba {
  run(t) {
    const n = x$.exec(t.content), [, r, i] = n != null ? n : [], s = r == null ? void 0 : r.trim(), o = new this.state.Token("ref_open", "a", 1), a = new this.state.Token("text", "", 0), l = new this.state.Token("ref_close", "a", -1);
    return T3(this.state, { open: o, content: a, close: l }, { kind: "numref", label: i || t.content, value: s }, {
      contentFromTarget: (h) => n ? s.replace(/%s/g, String(h.number)).replace(/\{number\}/g, String(h.number)) : h.title.trim()
    }), [o, a, l];
  }
}
class ANt extends ba {
  run(t) {
    const n = x$.exec(t.content), [, r, i] = n != null ? n : [], s = r == null ? void 0 : r.trim(), o = new this.state.Token("ref_open", "a", 1), a = new this.state.Token("text", "", 0), l = new this.state.Token("ref_close", "a", -1);
    return T3(this.state, { open: o, content: a, close: l }, { kind: "ref", label: i || t.content, value: s }, {
      contentFromTarget: (h) => s || h.title
    }), [o, a, l];
  }
}
const PNt = {
  eq: TNt,
  ref: ANt,
  numref: ENt
}, DNt = Object.assign(Object.assign(Object.assign(Object.assign({}, mNt), wNt), ONt), PNt);
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function v$(e) {
  return typeof e > "u" || e === null;
}
function LNt(e) {
  return typeof e == "object" && e !== null;
}
function MNt(e) {
  return Array.isArray(e) ? e : v$(e) ? [] : [e];
}
function RNt(e, t) {
  var n, r, i, s;
  if (t)
    for (s = Object.keys(t), n = 0, r = s.length; n < r; n += 1)
      i = s[n], e[i] = t[i];
  return e;
}
function $Nt(e, t) {
  var n = "", r;
  for (r = 0; r < t; r += 1)
    n += e;
  return n;
}
function INt(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
var NNt = v$, BNt = LNt, FNt = MNt, QNt = $Nt, ZNt = INt, VNt = RNt, Hn = {
  isNothing: NNt,
  isObject: BNt,
  toArray: FNt,
  repeat: QNt,
  isNegativeZero: ZNt,
  extend: VNt
};
function _$(e, t) {
  var n = "", r = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (n += 'in "' + e.mark.name + '" '), n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (n += `

` + e.mark.snippet), r + " " + n) : r;
}
function Gd(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = _$(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Gd.prototype = Object.create(Error.prototype);
Gd.prototype.constructor = Gd;
Gd.prototype.toString = function(t) {
  return this.name + ": " + _$(this, t);
};
var Ir = Gd;
function TO(e, t, n, r, i) {
  var s = "", o = "", a = Math.floor(i / 2) - 1;
  return r - t > a && (s = " ... ", t = r - a + s.length), n - r > a && (o = " ...", n = r + a - o.length), {
    str: s + e.slice(t, n).replace(/\t/g, "\u2192") + o,
    pos: r - t + s.length
  };
}
function EO(e, t) {
  return Hn.repeat(" ", t - e.length) + e;
}
function YNt(e, t) {
  if (t = Object.create(t || null), !e.buffer)
    return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], s, o = -1; s = n.exec(e.buffer); )
    i.push(s.index), r.push(s.index + s[0].length), e.position <= s.index && o < 0 && (o = r.length - 2);
  o < 0 && (o = r.length - 1);
  var a = "", l, h, u = Math.min(e.line + t.linesAfter, i.length).toString().length, f = t.maxLength - (t.indent + u + 3);
  for (l = 1; l <= t.linesBefore && !(o - l < 0); l++)
    h = TO(
      e.buffer,
      r[o - l],
      i[o - l],
      e.position - (r[o] - r[o - l]),
      f
    ), a = Hn.repeat(" ", t.indent) + EO((e.line - l + 1).toString(), u) + " | " + h.str + `
` + a;
  for (h = TO(e.buffer, r[o], i[o], e.position, f), a += Hn.repeat(" ", t.indent) + EO((e.line + 1).toString(), u) + " | " + h.str + `
`, a += Hn.repeat("-", t.indent + u + 3 + h.pos) + `^
`, l = 1; l <= t.linesAfter && !(o + l >= i.length); l++)
    h = TO(
      e.buffer,
      r[o + l],
      i[o + l],
      e.position - (r[o] - r[o + l]),
      f
    ), a += Hn.repeat(" ", t.indent) + EO((e.line + l + 1).toString(), u) + " | " + h.str + `
`;
  return a.replace(/\n$/, "");
}
var zNt = YNt, qNt = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], WNt = [
  "scalar",
  "sequence",
  "mapping"
];
function UNt(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(n) {
    e[n].forEach(function(r) {
      t[String(r)] = n;
    });
  }), t;
}
function jNt(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(n) {
    if (qNt.indexOf(n) === -1)
      throw new Ir('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(n) {
    return n;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = UNt(t.styleAliases || null), WNt.indexOf(this.kind) === -1)
    throw new Ir('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var br = jNt;
function oE(e, t) {
  var n = [];
  return e[t].forEach(function(r) {
    var i = n.length;
    n.forEach(function(s, o) {
      s.tag === r.tag && s.kind === r.kind && s.multi === r.multi && (i = o);
    }), n[i] = r;
  }), n;
}
function XNt() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, n;
  function r(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (t = 0, n = arguments.length; t < n; t += 1)
    arguments[t].forEach(r);
  return e;
}
function g_(e) {
  return this.extend(e);
}
g_.prototype.extend = function(t) {
  var n = [], r = [];
  if (t instanceof br)
    r.push(t);
  else if (Array.isArray(t))
    r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)), t.explicit && (r = r.concat(t.explicit));
  else
    throw new Ir("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(s) {
    if (!(s instanceof br))
      throw new Ir("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Ir("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Ir("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(s) {
    if (!(s instanceof br))
      throw new Ir("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(g_.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = oE(i, "implicit"), i.compiledExplicit = oE(i, "explicit"), i.compiledTypeMap = XNt(i.compiledImplicit, i.compiledExplicit), i;
};
var k$ = g_, w$ = new br("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), S$ = new br("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), C$ = new br("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), T$ = new k$({
  explicit: [
    w$,
    S$,
    C$
  ]
});
function GNt(e) {
  if (e === null)
    return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function HNt() {
  return null;
}
function KNt(e) {
  return e === null;
}
var E$ = new br("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: GNt,
  construct: HNt,
  predicate: KNt,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function JNt(e) {
  if (e === null)
    return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function tBt(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function eBt(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var A$ = new br("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: JNt,
  construct: tBt,
  predicate: eBt,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function nBt(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function rBt(e) {
  return 48 <= e && e <= 55;
}
function iBt(e) {
  return 48 <= e && e <= 57;
}
function sBt(e) {
  if (e === null)
    return !1;
  var t = e.length, n = 0, r = !1, i;
  if (!t)
    return !1;
  if (i = e[n], (i === "-" || i === "+") && (i = e[++n]), i === "0") {
    if (n + 1 === t)
      return !0;
    if (i = e[++n], i === "b") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!nBt(e.charCodeAt(n)))
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!rBt(e.charCodeAt(n)))
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_")
    return !1;
  for (; n < t; n++)
    if (i = e[n], i !== "_") {
      if (!iBt(e.charCodeAt(n)))
        return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function oBt(e) {
  var t = e, n = 1, r;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), r = t[0], (r === "-" || r === "+") && (r === "-" && (n = -1), t = t.slice(1), r = t[0]), t === "0")
    return 0;
  if (r === "0") {
    if (t[1] === "b")
      return n * parseInt(t.slice(2), 2);
    if (t[1] === "x")
      return n * parseInt(t.slice(2), 16);
    if (t[1] === "o")
      return n * parseInt(t.slice(2), 8);
  }
  return n * parseInt(t, 10);
}
function aBt(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !Hn.isNegativeZero(e);
}
var P$ = new br("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: sBt,
  construct: oBt,
  predicate: aBt,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), lBt = new RegExp(
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function cBt(e) {
  return !(e === null || !lBt.test(e) || e[e.length - 1] === "_");
}
function hBt(e) {
  var t, n;
  return t = e.replace(/_/g, "").toLowerCase(), n = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : n * parseFloat(t, 10);
}
var uBt = /^[-+]?[0-9]+e/;
function fBt(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Hn.isNegativeZero(e))
    return "-0.0";
  return n = e.toString(10), uBt.test(n) ? n.replace("e", ".e") : n;
}
function dBt(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Hn.isNegativeZero(e));
}
var D$ = new br("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: cBt,
  construct: hBt,
  predicate: dBt,
  represent: fBt,
  defaultStyle: "lowercase"
}), L$ = T$.extend({
  implicit: [
    E$,
    A$,
    P$,
    D$
  ]
}), M$ = L$, R$ = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), $$ = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function pBt(e) {
  return e === null ? !1 : R$.exec(e) !== null || $$.exec(e) !== null;
}
function gBt(e) {
  var t, n, r, i, s, o, a, l = 0, h = null, u, f, d;
  if (t = R$.exec(e), t === null && (t = $$.exec(e)), t === null)
    throw new Error("Date resolve error");
  if (n = +t[1], r = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(n, r, i));
  if (s = +t[4], o = +t[5], a = +t[6], t[7]) {
    for (l = t[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return t[9] && (u = +t[10], f = +(t[11] || 0), h = (u * 60 + f) * 6e4, t[9] === "-" && (h = -h)), d = new Date(Date.UTC(n, r, i, s, o, a, l)), h && d.setTime(d.getTime() - h), d;
}
function mBt(e) {
  return e.toISOString();
}
var I$ = new br("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: pBt,
  construct: gBt,
  instanceOf: Date,
  represent: mBt
});
function yBt(e) {
  return e === "<<" || e === null;
}
var N$ = new br("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: yBt
}), E3 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function bBt(e) {
  if (e === null)
    return !1;
  var t, n, r = 0, i = e.length, s = E3;
  for (n = 0; n < i; n++)
    if (t = s.indexOf(e.charAt(n)), !(t > 64)) {
      if (t < 0)
        return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function OBt(e) {
  var t, n, r = e.replace(/[\r\n=]/g, ""), i = r.length, s = E3, o = 0, a = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)), o = o << 6 | s.indexOf(r.charAt(t));
  return n = i % 4 * 6, n === 0 ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)) : n === 18 ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : n === 12 && a.push(o >> 4 & 255), new Uint8Array(a);
}
function xBt(e) {
  var t = "", n = 0, r, i, s = e.length, o = E3;
  for (r = 0; r < s; r++)
    r % 3 === 0 && r && (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]), n = (n << 8) + e[r];
  return i = s % 3, i === 0 ? (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]) : i === 2 ? (t += o[n >> 10 & 63], t += o[n >> 4 & 63], t += o[n << 2 & 63], t += o[64]) : i === 1 && (t += o[n >> 2 & 63], t += o[n << 4 & 63], t += o[64], t += o[64]), t;
}
function vBt(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var B$ = new br("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: bBt,
  construct: OBt,
  predicate: vBt,
  represent: xBt
}), _Bt = Object.prototype.hasOwnProperty, kBt = Object.prototype.toString;
function wBt(e) {
  if (e === null)
    return !0;
  var t = [], n, r, i, s, o, a = e;
  for (n = 0, r = a.length; n < r; n += 1) {
    if (i = a[n], o = !1, kBt.call(i) !== "[object Object]")
      return !1;
    for (s in i)
      if (_Bt.call(i, s))
        if (!o)
          o = !0;
        else
          return !1;
    if (!o)
      return !1;
    if (t.indexOf(s) === -1)
      t.push(s);
    else
      return !1;
  }
  return !0;
}
function SBt(e) {
  return e !== null ? e : [];
}
var F$ = new br("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: wBt,
  construct: SBt
}), CBt = Object.prototype.toString;
function TBt(e) {
  if (e === null)
    return !0;
  var t, n, r, i, s, o = e;
  for (s = new Array(o.length), t = 0, n = o.length; t < n; t += 1) {
    if (r = o[t], CBt.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1))
      return !1;
    s[t] = [i[0], r[i[0]]];
  }
  return !0;
}
function EBt(e) {
  if (e === null)
    return [];
  var t, n, r, i, s, o = e;
  for (s = new Array(o.length), t = 0, n = o.length; t < n; t += 1)
    r = o[t], i = Object.keys(r), s[t] = [i[0], r[i[0]]];
  return s;
}
var Q$ = new br("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: TBt,
  construct: EBt
}), ABt = Object.prototype.hasOwnProperty;
function PBt(e) {
  if (e === null)
    return !0;
  var t, n = e;
  for (t in n)
    if (ABt.call(n, t) && n[t] !== null)
      return !1;
  return !0;
}
function DBt(e) {
  return e !== null ? e : {};
}
var Z$ = new br("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: PBt,
  construct: DBt
}), A3 = M$.extend({
  implicit: [
    I$,
    N$
  ],
  explicit: [
    B$,
    F$,
    Q$,
    Z$
  ]
}), ol = Object.prototype.hasOwnProperty, mm = 1, V$ = 2, Y$ = 3, ym = 4, AO = 1, LBt = 2, aE = 3, MBt = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, RBt = /[\x85\u2028\u2029]/, $Bt = /[,\[\]\{\}]/, z$ = /^(?:!|!!|![a-z\-]+!)$/i, q$ = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function lE(e) {
  return Object.prototype.toString.call(e);
}
function co(e) {
  return e === 10 || e === 13;
}
function Gl(e) {
  return e === 9 || e === 32;
}
function ni(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function th(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function IBt(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function NBt(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function BBt(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function cE(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "\x85" : e === 95 ? "\xA0" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function FBt(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var W$ = new Array(256), U$ = new Array(256);
for (var Zc = 0; Zc < 256; Zc++)
  W$[Zc] = cE(Zc) ? 1 : 0, U$[Zc] = cE(Zc);
function QBt(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || A3, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function j$(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return n.snippet = zNt(n), new Ir(t, n);
}
function Jt(e, t) {
  throw j$(e, t);
}
function bm(e, t) {
  e.onWarning && e.onWarning.call(null, j$(e, t));
}
var hE = {
  YAML: function(t, n, r) {
    var i, s, o;
    t.version !== null && Jt(t, "duplication of %YAML directive"), r.length !== 1 && Jt(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && Jt(t, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), o = parseInt(i[2], 10), s !== 1 && Jt(t, "unacceptable YAML version of the document"), t.version = r[0], t.checkLineBreaks = o < 2, o !== 1 && o !== 2 && bm(t, "unsupported YAML version of the document");
  },
  TAG: function(t, n, r) {
    var i, s;
    r.length !== 2 && Jt(t, "TAG directive accepts exactly two arguments"), i = r[0], s = r[1], z$.test(i) || Jt(t, "ill-formed tag handle (first argument) of the TAG directive"), ol.call(t.tagMap, i) && Jt(t, 'there is a previously declared suffix for "' + i + '" tag handle'), q$.test(s) || Jt(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      Jt(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[i] = s;
  }
};
function Wa(e, t, n, r) {
  var i, s, o, a;
  if (t < n) {
    if (a = e.input.slice(t, n), r)
      for (i = 0, s = a.length; i < s; i += 1)
        o = a.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || Jt(e, "expected valid JSON character");
    else
      MBt.test(a) && Jt(e, "the stream contains non-printable characters");
    e.result += a;
  }
}
function uE(e, t, n, r) {
  var i, s, o, a;
  for (Hn.isObject(n) || Jt(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), o = 0, a = i.length; o < a; o += 1)
    s = i[o], ol.call(t, s) || (t[s] = n[s], r[s] = !0);
}
function eh(e, t, n, r, i, s, o, a, l) {
  var h, u;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), h = 0, u = i.length; h < u; h += 1)
      Array.isArray(i[h]) && Jt(e, "nested arrays are not supported inside keys"), typeof i == "object" && lE(i[h]) === "[object Object]" && (i[h] = "[object Object]");
  if (typeof i == "object" && lE(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), r === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (h = 0, u = s.length; h < u; h += 1)
        uE(e, t, s[h], n);
    else
      uE(e, t, s, n);
  else
    !e.json && !ol.call(n, i) && ol.call(t, i) && (e.line = o || e.line, e.lineStart = a || e.lineStart, e.position = l || e.position, Jt(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[i] = s, delete n[i];
  return t;
}
function P3(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : Jt(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function Fn(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Gl(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (co(i))
      for (P3(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return n !== -1 && r !== 0 && e.lineIndent < n && bm(e, "deficient indentation"), r;
}
function yy(e) {
  var t = e.position, n;
  return n = e.input.charCodeAt(t), !!((n === 45 || n === 46) && n === e.input.charCodeAt(t + 1) && n === e.input.charCodeAt(t + 2) && (t += 3, n = e.input.charCodeAt(t), n === 0 || ni(n)));
}
function D3(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Hn.repeat(`
`, t - 1));
}
function ZBt(e, t, n) {
  var r, i, s, o, a, l, h, u, f = e.kind, d = e.result, p;
  if (p = e.input.charCodeAt(e.position), ni(p) || th(p) || p === 35 || p === 38 || p === 42 || p === 33 || p === 124 || p === 62 || p === 39 || p === 34 || p === 37 || p === 64 || p === 96 || (p === 63 || p === 45) && (i = e.input.charCodeAt(e.position + 1), ni(i) || n && th(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = o = e.position, a = !1; p !== 0; ) {
    if (p === 58) {
      if (i = e.input.charCodeAt(e.position + 1), ni(i) || n && th(i))
        break;
    } else if (p === 35) {
      if (r = e.input.charCodeAt(e.position - 1), ni(r))
        break;
    } else {
      if (e.position === e.lineStart && yy(e) || n && th(p))
        break;
      if (co(p))
        if (l = e.line, h = e.lineStart, u = e.lineIndent, Fn(e, !1, -1), e.lineIndent >= t) {
          a = !0, p = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = l, e.lineStart = h, e.lineIndent = u;
          break;
        }
    }
    a && (Wa(e, s, o, !1), D3(e, e.line - l), s = o = e.position, a = !1), Gl(p) || (o = e.position + 1), p = e.input.charCodeAt(++e.position);
  }
  return Wa(e, s, o, !1), e.result ? !0 : (e.kind = f, e.result = d, !1);
}
function VBt(e, t) {
  var n, r, i;
  if (n = e.input.charCodeAt(e.position), n !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
    if (n === 39)
      if (Wa(e, r, e.position, !0), n = e.input.charCodeAt(++e.position), n === 39)
        r = e.position, e.position++, i = e.position;
      else
        return !0;
    else
      co(n) ? (Wa(e, r, i, !0), D3(e, Fn(e, !1, t)), r = i = e.position) : e.position === e.lineStart && yy(e) ? Jt(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  Jt(e, "unexpected end of the stream within a single quoted scalar");
}
function YBt(e, t) {
  var n, r, i, s, o, a;
  if (a = e.input.charCodeAt(e.position), a !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; (a = e.input.charCodeAt(e.position)) !== 0; ) {
    if (a === 34)
      return Wa(e, n, e.position, !0), e.position++, !0;
    if (a === 92) {
      if (Wa(e, n, e.position, !0), a = e.input.charCodeAt(++e.position), co(a))
        Fn(e, !1, t);
      else if (a < 256 && W$[a])
        e.result += U$[a], e.position++;
      else if ((o = NBt(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          a = e.input.charCodeAt(++e.position), (o = IBt(a)) >= 0 ? s = (s << 4) + o : Jt(e, "expected hexadecimal character");
        e.result += FBt(s), e.position++;
      } else
        Jt(e, "unknown escape sequence");
      n = r = e.position;
    } else
      co(a) ? (Wa(e, n, r, !0), D3(e, Fn(e, !1, t)), n = r = e.position) : e.position === e.lineStart && yy(e) ? Jt(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
  }
  Jt(e, "unexpected end of the stream within a double quoted scalar");
}
function zBt(e, t) {
  var n = !0, r, i, s, o = e.tag, a, l = e.anchor, h, u, f, d, p, g = /* @__PURE__ */ Object.create(null), m, y, O, x;
  if (x = e.input.charCodeAt(e.position), x === 91)
    u = 93, p = !1, a = [];
  else if (x === 123)
    u = 125, p = !0, a = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), x = e.input.charCodeAt(++e.position); x !== 0; ) {
    if (Fn(e, !0, t), x = e.input.charCodeAt(e.position), x === u)
      return e.position++, e.tag = o, e.anchor = l, e.kind = p ? "mapping" : "sequence", e.result = a, !0;
    n ? x === 44 && Jt(e, "expected the node content, but found ','") : Jt(e, "missed comma between flow collection entries"), y = m = O = null, f = d = !1, x === 63 && (h = e.input.charCodeAt(e.position + 1), ni(h) && (f = d = !0, e.position++, Fn(e, !0, t))), r = e.line, i = e.lineStart, s = e.position, eu(e, t, mm, !1, !0), y = e.tag, m = e.result, Fn(e, !0, t), x = e.input.charCodeAt(e.position), (d || e.line === r) && x === 58 && (f = !0, x = e.input.charCodeAt(++e.position), Fn(e, !0, t), eu(e, t, mm, !1, !0), O = e.result), p ? eh(e, a, g, y, m, O, r, i, s) : f ? a.push(eh(e, null, g, y, m, O, r, i, s)) : a.push(m), Fn(e, !0, t), x = e.input.charCodeAt(e.position), x === 44 ? (n = !0, x = e.input.charCodeAt(++e.position)) : n = !1;
  }
  Jt(e, "unexpected end of the stream within a flow collection");
}
function qBt(e, t) {
  var n, r, i = AO, s = !1, o = !1, a = t, l = 0, h = !1, u, f;
  if (f = e.input.charCodeAt(e.position), f === 124)
    r = !1;
  else if (f === 62)
    r = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; f !== 0; )
    if (f = e.input.charCodeAt(++e.position), f === 43 || f === 45)
      AO === i ? i = f === 43 ? aE : LBt : Jt(e, "repeat of a chomping mode identifier");
    else if ((u = BBt(f)) >= 0)
      u === 0 ? Jt(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? Jt(e, "repeat of an indentation width identifier") : (a = t + u - 1, o = !0);
    else
      break;
  if (Gl(f)) {
    do
      f = e.input.charCodeAt(++e.position);
    while (Gl(f));
    if (f === 35)
      do
        f = e.input.charCodeAt(++e.position);
      while (!co(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (P3(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position); (!o || e.lineIndent < a) && f === 32; )
      e.lineIndent++, f = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > a && (a = e.lineIndent), co(f)) {
      l++;
      continue;
    }
    if (e.lineIndent < a) {
      i === aE ? e.result += Hn.repeat(`
`, s ? 1 + l : l) : i === AO && s && (e.result += `
`);
      break;
    }
    for (r ? Gl(f) ? (h = !0, e.result += Hn.repeat(`
`, s ? 1 + l : l)) : h ? (h = !1, e.result += Hn.repeat(`
`, l + 1)) : l === 0 ? s && (e.result += " ") : e.result += Hn.repeat(`
`, l) : e.result += Hn.repeat(`
`, s ? 1 + l : l), s = !0, o = !0, l = 0, n = e.position; !co(f) && f !== 0; )
      f = e.input.charCodeAt(++e.position);
    Wa(e, n, e.position, !1);
  }
  return !0;
}
function fE(e, t) {
  var n, r = e.tag, i = e.anchor, s = [], o, a = !1, l;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), l = e.input.charCodeAt(e.position); l !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Jt(e, "tab characters must not be used in indentation")), !(l !== 45 || (o = e.input.charCodeAt(e.position + 1), !ni(o)))); ) {
    if (a = !0, e.position++, Fn(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), l = e.input.charCodeAt(e.position);
      continue;
    }
    if (n = e.line, eu(e, t, Y$, !1, !0), s.push(e.result), Fn(e, !0, -1), l = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && l !== 0)
      Jt(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return a ? (e.tag = r, e.anchor = i, e.kind = "sequence", e.result = s, !0) : !1;
}
function WBt(e, t, n) {
  var r, i, s, o, a, l, h = e.tag, u = e.anchor, f = {}, d = /* @__PURE__ */ Object.create(null), p = null, g = null, m = null, y = !1, O = !1, x;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = f), x = e.input.charCodeAt(e.position); x !== 0; ) {
    if (!y && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Jt(e, "tab characters must not be used in indentation")), r = e.input.charCodeAt(e.position + 1), s = e.line, (x === 63 || x === 58) && ni(r))
      x === 63 ? (y && (eh(e, f, d, p, g, null, o, a, l), p = g = m = null), O = !0, y = !0, i = !0) : y ? (y = !1, i = !0) : Jt(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, x = r;
    else {
      if (o = e.line, a = e.lineStart, l = e.position, !eu(e, n, V$, !1, !0))
        break;
      if (e.line === s) {
        for (x = e.input.charCodeAt(e.position); Gl(x); )
          x = e.input.charCodeAt(++e.position);
        if (x === 58)
          x = e.input.charCodeAt(++e.position), ni(x) || Jt(e, "a whitespace character is expected after the key-value separator within a block mapping"), y && (eh(e, f, d, p, g, null, o, a, l), p = g = m = null), O = !0, y = !1, i = !1, p = e.tag, g = e.result;
        else if (O)
          Jt(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = h, e.anchor = u, !0;
      } else if (O)
        Jt(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = h, e.anchor = u, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (y && (o = e.line, a = e.lineStart, l = e.position), eu(e, t, ym, !0, i) && (y ? g = e.result : m = e.result), y || (eh(e, f, d, p, g, m, o, a, l), p = g = m = null), Fn(e, !0, -1), x = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && x !== 0)
      Jt(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return y && eh(e, f, d, p, g, null, o, a, l), O && (e.tag = h, e.anchor = u, e.kind = "mapping", e.result = f), O;
}
function UBt(e) {
  var t, n = !1, r = !1, i, s, o;
  if (o = e.input.charCodeAt(e.position), o !== 33)
    return !1;
  if (e.tag !== null && Jt(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (n = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (r = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, n) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), o = e.input.charCodeAt(++e.position)) : Jt(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !ni(o); )
      o === 33 && (r ? Jt(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), z$.test(i) || Jt(e, "named tag handle cannot contain such characters"), r = !0, t = e.position + 1)), o = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), $Bt.test(s) && Jt(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !q$.test(s) && Jt(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    Jt(e, "tag name is malformed: " + s);
  }
  return n ? e.tag = s : ol.call(e.tagMap, i) ? e.tag = e.tagMap[i] + s : i === "!" ? e.tag = "!" + s : i === "!!" ? e.tag = "tag:yaml.org,2002:" + s : Jt(e, 'undeclared tag handle "' + i + '"'), !0;
}
function jBt(e) {
  var t, n;
  if (n = e.input.charCodeAt(e.position), n !== 38)
    return !1;
  for (e.anchor !== null && Jt(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !ni(n) && !th(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && Jt(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function XBt(e) {
  var t, n, r;
  if (r = e.input.charCodeAt(e.position), r !== 42)
    return !1;
  for (r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !ni(r) && !th(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && Jt(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), ol.call(e.anchorMap, n) || Jt(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], Fn(e, !0, -1), !0;
}
function eu(e, t, n, r, i) {
  var s, o, a, l = 1, h = !1, u = !1, f, d, p, g, m, y;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = o = a = ym === n || Y$ === n, r && Fn(e, !0, -1) && (h = !0, e.lineIndent > t ? l = 1 : e.lineIndent === t ? l = 0 : e.lineIndent < t && (l = -1)), l === 1)
    for (; UBt(e) || jBt(e); )
      Fn(e, !0, -1) ? (h = !0, a = s, e.lineIndent > t ? l = 1 : e.lineIndent === t ? l = 0 : e.lineIndent < t && (l = -1)) : a = !1;
  if (a && (a = h || i), (l === 1 || ym === n) && (mm === n || V$ === n ? m = t : m = t + 1, y = e.position - e.lineStart, l === 1 ? a && (fE(e, y) || WBt(e, y, m)) || zBt(e, m) ? u = !0 : (o && qBt(e, m) || VBt(e, m) || YBt(e, m) ? u = !0 : XBt(e) ? (u = !0, (e.tag !== null || e.anchor !== null) && Jt(e, "alias node should not have any properties")) : ZBt(e, m, mm === n) && (u = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : l === 0 && (u = a && fE(e, y))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && Jt(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), f = 0, d = e.implicitTypes.length; f < d; f += 1)
      if (g = e.implicitTypes[f], g.resolve(e.result)) {
        e.result = g.construct(e.result), e.tag = g.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (ol.call(e.typeMap[e.kind || "fallback"], e.tag))
      g = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (g = null, p = e.typeMap.multi[e.kind || "fallback"], f = 0, d = p.length; f < d; f += 1)
        if (e.tag.slice(0, p[f].tag.length) === p[f].tag) {
          g = p[f];
          break;
        }
    g || Jt(e, "unknown tag !<" + e.tag + ">"), e.result !== null && g.kind !== e.kind && Jt(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + g.kind + '", not "' + e.kind + '"'), g.resolve(e.result, e.tag) ? (e.result = g.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : Jt(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || u;
}
function GBt(e) {
  var t = e.position, n, r, i, s = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (o = e.input.charCodeAt(e.position)) !== 0 && (Fn(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = e.input.charCodeAt(++e.position), n = e.position; o !== 0 && !ni(o); )
      o = e.input.charCodeAt(++e.position);
    for (r = e.input.slice(n, e.position), i = [], r.length < 1 && Jt(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; Gl(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !co(o));
        break;
      }
      if (co(o))
        break;
      for (n = e.position; o !== 0 && !ni(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    o !== 0 && P3(e), ol.call(hE, r) ? hE[r](e, r, i) : bm(e, 'unknown document directive "' + r + '"');
  }
  if (Fn(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, Fn(e, !0, -1)) : s && Jt(e, "directives end mark is expected"), eu(e, e.lineIndent - 1, ym, !1, !0), Fn(e, !0, -1), e.checkLineBreaks && RBt.test(e.input.slice(t, e.position)) && bm(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && yy(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, Fn(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    Jt(e, "end of the stream or a document separator is expected");
  else
    return;
}
function X$(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new QBt(e, t), r = e.indexOf("\0");
  for (r !== -1 && (n.position = r, Jt(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    GBt(n);
  return n.documents;
}
function HBt(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && (n = t, t = null);
  var r = X$(e, n);
  if (typeof t != "function")
    return r;
  for (var i = 0, s = r.length; i < s; i += 1)
    t(r[i]);
}
function KBt(e, t) {
  var n = X$(e, t);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new Ir("expected a single document in the stream, but found more");
  }
}
var JBt = HBt, tFt = KBt, G$ = {
  loadAll: JBt,
  load: tFt
}, H$ = Object.prototype.toString, K$ = Object.prototype.hasOwnProperty, L3 = 65279, eFt = 9, Hd = 10, nFt = 13, rFt = 32, iFt = 33, sFt = 34, m_ = 35, oFt = 37, aFt = 38, lFt = 39, cFt = 42, J$ = 44, hFt = 45, Om = 58, uFt = 61, fFt = 62, dFt = 63, pFt = 64, tI = 91, eI = 93, gFt = 96, nI = 123, mFt = 124, rI = 125, Lr = {};
Lr[0] = "\\0";
Lr[7] = "\\a";
Lr[8] = "\\b";
Lr[9] = "\\t";
Lr[10] = "\\n";
Lr[11] = "\\v";
Lr[12] = "\\f";
Lr[13] = "\\r";
Lr[27] = "\\e";
Lr[34] = '\\"';
Lr[92] = "\\\\";
Lr[133] = "\\N";
Lr[160] = "\\_";
Lr[8232] = "\\L";
Lr[8233] = "\\P";
var yFt = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], bFt = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function OFt(e, t) {
  var n, r, i, s, o, a, l;
  if (t === null)
    return {};
  for (n = {}, r = Object.keys(t), i = 0, s = r.length; i < s; i += 1)
    o = r[i], a = String(t[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), l = e.compiledTypeMap.fallback[o], l && K$.call(l.styleAliases, a) && (a = l.styleAliases[a]), n[o] = a;
  return n;
}
function xFt(e) {
  var t, n, r;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    n = "x", r = 2;
  else if (e <= 65535)
    n = "u", r = 4;
  else if (e <= 4294967295)
    n = "U", r = 8;
  else
    throw new Ir("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + Hn.repeat("0", r - t.length) + t;
}
var vFt = 1, Kd = 2;
function _Ft(e) {
  this.schema = e.schema || A3, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = Hn.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = OFt(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Kd : vFt, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function dE(e, t) {
  for (var n = Hn.repeat(" ", t), r = 0, i = -1, s = "", o, a = e.length; r < a; )
    i = e.indexOf(`
`, r), i === -1 ? (o = e.slice(r), r = a) : (o = e.slice(r, i + 1), r = i + 1), o.length && o !== `
` && (s += n), s += o;
  return s;
}
function y_(e, t) {
  return `
` + Hn.repeat(" ", e.indent * t);
}
function kFt(e, t) {
  var n, r, i;
  for (n = 0, r = e.implicitTypes.length; n < r; n += 1)
    if (i = e.implicitTypes[n], i.resolve(t))
      return !0;
  return !1;
}
function xm(e) {
  return e === rFt || e === eFt;
}
function Jd(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== L3 || 65536 <= e && e <= 1114111;
}
function pE(e) {
  return Jd(e) && e !== L3 && e !== nFt && e !== Hd;
}
function gE(e, t, n) {
  var r = pE(e), i = r && !xm(e);
  return (n ? r : r && e !== J$ && e !== tI && e !== eI && e !== nI && e !== rI) && e !== m_ && !(t === Om && !i) || pE(t) && !xm(t) && e === m_ || t === Om && i;
}
function wFt(e) {
  return Jd(e) && e !== L3 && !xm(e) && e !== hFt && e !== dFt && e !== Om && e !== J$ && e !== tI && e !== eI && e !== nI && e !== rI && e !== m_ && e !== aFt && e !== cFt && e !== iFt && e !== mFt && e !== uFt && e !== fFt && e !== lFt && e !== sFt && e !== oFt && e !== pFt && e !== gFt;
}
function SFt(e) {
  return !xm(e) && e !== Om;
}
function Df(e, t) {
  var n = e.charCodeAt(t), r;
  return n >= 55296 && n <= 56319 && t + 1 < e.length && (r = e.charCodeAt(t + 1), r >= 56320 && r <= 57343) ? (n - 55296) * 1024 + r - 56320 + 65536 : n;
}
function iI(e) {
  var t = /^\n* /;
  return t.test(e);
}
var sI = 1, b_ = 2, oI = 3, aI = 4, jc = 5;
function CFt(e, t, n, r, i, s, o, a) {
  var l, h = 0, u = null, f = !1, d = !1, p = r !== -1, g = -1, m = wFt(Df(e, 0)) && SFt(Df(e, e.length - 1));
  if (t || o)
    for (l = 0; l < e.length; h >= 65536 ? l += 2 : l++) {
      if (h = Df(e, l), !Jd(h))
        return jc;
      m = m && gE(h, u, a), u = h;
    }
  else {
    for (l = 0; l < e.length; h >= 65536 ? l += 2 : l++) {
      if (h = Df(e, l), h === Hd)
        f = !0, p && (d = d || l - g - 1 > r && e[g + 1] !== " ", g = l);
      else if (!Jd(h))
        return jc;
      m = m && gE(h, u, a), u = h;
    }
    d = d || p && l - g - 1 > r && e[g + 1] !== " ";
  }
  return !f && !d ? m && !o && !i(e) ? sI : s === Kd ? jc : b_ : n > 9 && iI(e) ? jc : o ? s === Kd ? jc : b_ : d ? aI : oI;
}
function TFt(e, t, n, r, i) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Kd ? '""' : "''";
    if (!e.noCompatMode && (yFt.indexOf(t) !== -1 || bFt.test(t)))
      return e.quotingType === Kd ? '"' + t + '"' : "'" + t + "'";
    var s = e.indent * Math.max(1, n), o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s), a = r || e.flowLevel > -1 && n >= e.flowLevel;
    function l(h) {
      return kFt(e, h);
    }
    switch (CFt(
      t,
      a,
      e.indent,
      o,
      l,
      e.quotingType,
      e.forceQuotes && !r,
      i
    )) {
      case sI:
        return t;
      case b_:
        return "'" + t.replace(/'/g, "''") + "'";
      case oI:
        return "|" + mE(t, e.indent) + yE(dE(t, s));
      case aI:
        return ">" + mE(t, e.indent) + yE(dE(EFt(t, o), s));
      case jc:
        return '"' + AFt(t) + '"';
      default:
        throw new Ir("impossible error: invalid scalar style");
    }
  }();
}
function mE(e, t) {
  var n = iI(e) ? String(t) : "", r = e[e.length - 1] === `
`, i = r && (e[e.length - 2] === `
` || e === `
`), s = i ? "+" : r ? "" : "-";
  return n + s + `
`;
}
function yE(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function EFt(e, t) {
  for (var n = /(\n+)([^\n]*)/g, r = function() {
    var h = e.indexOf(`
`);
    return h = h !== -1 ? h : e.length, n.lastIndex = h, bE(e.slice(0, h), t);
  }(), i = e[0] === `
` || e[0] === " ", s, o; o = n.exec(e); ) {
    var a = o[1], l = o[2];
    s = l[0] === " ", r += a + (!i && !s && l !== "" ? `
` : "") + bE(l, t), i = s;
  }
  return r;
}
function bE(e, t) {
  if (e === "" || e[0] === " ")
    return e;
  for (var n = / [^ ]/g, r, i = 0, s, o = 0, a = 0, l = ""; r = n.exec(e); )
    a = r.index, a - i > t && (s = o > i ? o : a, l += `
` + e.slice(i, s), i = s + 1), o = a;
  return l += `
`, e.length - i > t && o > i ? l += e.slice(i, o) + `
` + e.slice(o + 1) : l += e.slice(i), l.slice(1);
}
function AFt(e) {
  for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? i += 2 : i++)
    n = Df(e, i), r = Lr[n], !r && Jd(n) ? (t += e[i], n >= 65536 && (t += e[i + 1])) : t += r || xFt(n);
  return t;
}
function PFt(e, t, n) {
  var r = "", i = e.tag, s, o, a;
  for (s = 0, o = n.length; s < o; s += 1)
    a = n[s], e.replacer && (a = e.replacer.call(n, String(s), a)), (ha(e, t, a, !1, !1) || typeof a > "u" && ha(e, t, null, !1, !1)) && (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")), r += e.dump);
  e.tag = i, e.dump = "[" + r + "]";
}
function OE(e, t, n, r) {
  var i = "", s = e.tag, o, a, l;
  for (o = 0, a = n.length; o < a; o += 1)
    l = n[o], e.replacer && (l = e.replacer.call(n, String(o), l)), (ha(e, t + 1, l, !0, !0, !1, !0) || typeof l > "u" && ha(e, t + 1, null, !0, !0, !1, !0)) && ((!r || i !== "") && (i += y_(e, t)), e.dump && Hd === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = s, e.dump = i || "[]";
}
function DFt(e, t, n) {
  var r = "", i = e.tag, s = Object.keys(n), o, a, l, h, u;
  for (o = 0, a = s.length; o < a; o += 1)
    u = "", r !== "" && (u += ", "), e.condenseFlow && (u += '"'), l = s[o], h = n[l], e.replacer && (h = e.replacer.call(n, l, h)), ha(e, t, l, !1, !1) && (e.dump.length > 1024 && (u += "? "), u += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), ha(e, t, h, !1, !1) && (u += e.dump, r += u));
  e.tag = i, e.dump = "{" + r + "}";
}
function LFt(e, t, n, r) {
  var i = "", s = e.tag, o = Object.keys(n), a, l, h, u, f, d;
  if (e.sortKeys === !0)
    o.sort();
  else if (typeof e.sortKeys == "function")
    o.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new Ir("sortKeys must be a boolean or a function");
  for (a = 0, l = o.length; a < l; a += 1)
    d = "", (!r || i !== "") && (d += y_(e, t)), h = o[a], u = n[h], e.replacer && (u = e.replacer.call(n, h, u)), ha(e, t + 1, h, !0, !0, !0) && (f = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, f && (e.dump && Hd === e.dump.charCodeAt(0) ? d += "?" : d += "? "), d += e.dump, f && (d += y_(e, t)), ha(e, t + 1, u, !0, f) && (e.dump && Hd === e.dump.charCodeAt(0) ? d += ":" : d += ": ", d += e.dump, i += d));
  e.tag = s, e.dump = i || "{}";
}
function xE(e, t, n) {
  var r, i, s, o, a, l;
  for (i = n ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (a = i[s], (a.instanceOf || a.predicate) && (!a.instanceOf || typeof t == "object" && t instanceof a.instanceOf) && (!a.predicate || a.predicate(t))) {
      if (n ? a.multi && a.representName ? e.tag = a.representName(t) : e.tag = a.tag : e.tag = "?", a.represent) {
        if (l = e.styleMap[a.tag] || a.defaultStyle, H$.call(a.represent) === "[object Function]")
          r = a.represent(t, l);
        else if (K$.call(a.represent, l))
          r = a.represent[l](t, l);
        else
          throw new Ir("!<" + a.tag + '> tag resolver accepts not "' + l + '" style');
        e.dump = r;
      }
      return !0;
    }
  return !1;
}
function ha(e, t, n, r, i, s, o) {
  e.tag = null, e.dump = n, xE(e, n, !1) || xE(e, n, !0);
  var a = H$.call(e.dump), l = r, h;
  r && (r = e.flowLevel < 0 || e.flowLevel > t);
  var u = a === "[object Object]" || a === "[object Array]", f, d;
  if (u && (f = e.duplicates.indexOf(n), d = f !== -1), (e.tag !== null && e.tag !== "?" || d || e.indent !== 2 && t > 0) && (i = !1), d && e.usedDuplicates[f])
    e.dump = "*ref_" + f;
  else {
    if (u && d && !e.usedDuplicates[f] && (e.usedDuplicates[f] = !0), a === "[object Object]")
      r && Object.keys(e.dump).length !== 0 ? (LFt(e, t, e.dump, i), d && (e.dump = "&ref_" + f + e.dump)) : (DFt(e, t, e.dump), d && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object Array]")
      r && e.dump.length !== 0 ? (e.noArrayIndent && !o && t > 0 ? OE(e, t - 1, e.dump, i) : OE(e, t, e.dump, i), d && (e.dump = "&ref_" + f + e.dump)) : (PFt(e, t, e.dump), d && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object String]")
      e.tag !== "?" && TFt(e, e.dump, t, s, l);
    else {
      if (a === "[object Undefined]")
        return !1;
      if (e.skipInvalid)
        return !1;
      throw new Ir("unacceptable kind of an object to dump " + a);
    }
    e.tag !== null && e.tag !== "?" && (h = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? h = "!" + h : h.slice(0, 18) === "tag:yaml.org,2002:" ? h = "!!" + h.slice(18) : h = "!<" + h + ">", e.dump = h + " " + e.dump);
  }
  return !0;
}
function MFt(e, t) {
  var n = [], r = [], i, s;
  for (O_(e, n, r), i = 0, s = r.length; i < s; i += 1)
    t.duplicates.push(n[r[i]]);
  t.usedDuplicates = new Array(s);
}
function O_(e, t, n) {
  var r, i, s;
  if (e !== null && typeof e == "object")
    if (i = t.indexOf(e), i !== -1)
      n.indexOf(i) === -1 && n.push(i);
    else if (t.push(e), Array.isArray(e))
      for (i = 0, s = e.length; i < s; i += 1)
        O_(e[i], t, n);
    else
      for (r = Object.keys(e), i = 0, s = r.length; i < s; i += 1)
        O_(e[r[i]], t, n);
}
function RFt(e, t) {
  t = t || {};
  var n = new _Ft(t);
  n.noRefs || MFt(e, n);
  var r = e;
  return n.replacer && (r = n.replacer.call({ "": r }, "", r)), ha(n, 0, r, !0, !0) ? n.dump + `
` : "";
}
var $Ft = RFt, IFt = {
  dump: $Ft
};
function M3(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
var NFt = br, BFt = k$, FFt = T$, QFt = L$, ZFt = M$, VFt = A3, YFt = G$.load, zFt = G$.loadAll, qFt = IFt.dump, WFt = Ir, UFt = {
  binary: B$,
  float: D$,
  map: C$,
  null: E$,
  pairs: Q$,
  set: Z$,
  timestamp: I$,
  bool: A$,
  int: P$,
  merge: N$,
  omap: F$,
  seq: S$,
  str: w$
}, jFt = M3("safeLoad", "load"), XFt = M3("safeLoadAll", "loadAll"), GFt = M3("safeDump", "dump"), HFt = {
  Type: NFt,
  Schema: BFt,
  FAILSAFE_SCHEMA: FFt,
  JSON_SCHEMA: QFt,
  CORE_SCHEMA: ZFt,
  DEFAULT_SCHEMA: VFt,
  load: YFt,
  loadAll: zFt,
  dump: qFt,
  YAMLException: WFt,
  types: UFt,
  safeLoad: jFt,
  safeLoadAll: XFt,
  safeDump: GFt
};
function KFt(e, t, n, r, i, s = !0) {
  const o = [];
  for (const l of [...e.core.ruler.__rules__].reverse()) {
    if (l.name === t) {
      s || o.push(l.name);
      break;
    }
    l.name && o.push(l.name);
  }
  e.core.ruler.disable(o);
  let a = [];
  try {
    a = e.parse(n, r);
  } finally {
    e.core.ruler.enable(o);
  }
  for (const l of a)
    l.map = l.map !== null ? [l.map[0] + i, l.map[1] + i] : l.map;
  return a;
}
class Tc {
  constructor(t) {
    this.required_arguments = 0, this.optional_arguments = 0, this.final_argument_whitespace = !1, this.has_content = !1, this.option_spec = {}, this.rawOptions = !1, this.state = t;
  }
  run(t) {
    return [];
  }
  assert(t, n) {
    if (!t)
      throw new Error(n);
  }
  assert_has_content(t) {
    if (!t.body)
      throw new Error("Content block expected, but none found.");
  }
  createToken(t, n, r, i) {
    const s = new this.state.Token(t, n, r);
    return (i == null ? void 0 : i.content) !== void 0 && (s.content = i.content), (i == null ? void 0 : i.level) !== void 0 && (s.level = i.level), (i == null ? void 0 : i.map) !== void 0 && (s.map = i.map), (i == null ? void 0 : i.block) !== void 0 && (s.block = i.block), (i == null ? void 0 : i.info) !== void 0 && (s.info = i.info), (i == null ? void 0 : i.meta) !== void 0 && (s.meta = i.meta), (i == null ? void 0 : i.children) !== void 0 && (s.children = i.children), s;
  }
  nestedParse(t, n) {
    return KFt(this.state.md, "run_directives", t, this.state.env, n, !0);
  }
}
class Fa extends Error {
  constructor() {
    super(...arguments), this.name = "DirectiveParsingError";
  }
}
function JFt(e, t) {
  const n = e.meta.arg || "", r = e.content;
  let i = r.trim() ? r.split(/\r?\n/) : [], s = 0, o = {};
  (Object.keys(t.option_spec || {}) || t.rawOptions) && ([i, o, s] = lI(i, t));
  let a = [];
  if (!t.required_arguments && !t.optional_arguments ? n && (s = 0, i = [n].concat(i)) : a = tQt(n, t), i.length && !i[0].trim() && (i.shift(), s++), i.length && !t.has_content)
    throw new Fa("Has content but content not allowed");
  return {
    map: e.map ? e.map : [0, 0],
    args: a,
    options: o,
    body: i.join(`
`),
    bodyMap: e.map ? [
      i.length > 0 ? e.map[0] + s : e.map[1],
      i.length > 0 ? e.map[1] - 1 : e.map[1]
    ] : [0, 0]
  };
}
function lI(e, t) {
  let n = 1, r = {}, i = null;
  if (e.length && e[0].startsWith("---")) {
    n++;
    const s = [];
    i = [];
    let o = !1;
    for (const a of e.slice(1)) {
      if (a.startsWith("---")) {
        n++, o = !0;
        continue;
      }
      o ? s.push(a) : (n++, i.push(a));
    }
    e = s;
  } else if (e.length && e[0].startsWith(":")) {
    const s = [];
    i = [];
    let o = !1;
    for (const a of e) {
      if (!o && !a.startsWith(":")) {
        o = !0, s.push(a);
        continue;
      }
      o ? s.push(a) : (n++, i.push(a.slice(1)));
    }
    e = s;
  }
  if (i !== null)
    try {
      const s = HFt.load(i.join(`
`));
      if (s !== null && typeof s == "object")
        r = s;
      else
        throw new Fa(`not dict: ${s}`);
    } catch (s) {
      throw new Fa(`Invalid options YAML: ${s}`);
    }
  if (t.rawOptions)
    return [e, r, n];
  for (const [s, o] of Object.entries(r)) {
    const a = t.option_spec ? t.option_spec[s] : null;
    if (!a)
      throw new Fa(`Unknown option: ${s}`);
    let l = o;
    (o === null || o === !1) && (l = "");
    try {
      l = a(`${l || ""}`);
    } catch (h) {
      throw new Fa(`Invalid option value: (option: '${s}'; value: ${o})
${h}`);
    }
    r[s] = l;
  }
  return [e, r, n];
}
function tQt(e, t) {
  var n;
  let r = e.trim() ? (n = e.trim()) === null || n === void 0 ? void 0 : n.split(/\s+/) : [];
  const i = (t.required_arguments || 0) + (t.optional_arguments || 0);
  if (r.length < (t.required_arguments || 0))
    throw new Fa(`${t.required_arguments} argument(s) required, ${r.length} supplied`);
  if (r.length > i)
    if (t.final_argument_whitespace) {
      const s = e.split(/\s+/);
      r = s.splice(0, i - 1), r.push(s.join(" "));
    } else
      throw new Fa(`maximum ${i} argument(s) allowed, ${r.length} supplied`);
  return r;
}
function eQt(e, t) {
  var n;
  let r = t.directivesAfter || "block";
  (!((n = t.replaceFences) !== null && n !== void 0) || n) && (e.core.ruler.after(r, "fence_to_directive", nQt), r = "fence_to_directive"), e.core.ruler.after(r, "run_directives", rQt(t.directives || {})), e.renderer.rules.directive = (i, s) => {
    const o = i[s];
    return `<aside class="directive-unhandled">
<header><mark>${o.info}</mark><code> ${o.meta.arg}</code></header>
<pre>${o.content}</pre></aside>
`;
  }, e.renderer.rules.directive_error = (i, s) => {
    const o = i[s];
    let a = "";
    return o.content && (a = `
---
${o.content}`), `<aside class="directive-error">
<header><mark>${o.info}</mark><code> ${o.meta.arg}</code></header>
<pre>${o.meta.error_name}:
${o.meta.error_message}
${a}</pre></aside>
`;
  };
}
function nQt(e) {
  for (const t of e.tokens)
    if (t.type === "fence" || t.type === "colon_fence") {
      const n = t.info.match(/^\{([^\s}]+)\}\s*(.*)$/);
      n && (t.type = "directive", t.info = n[1], t.meta = { arg: n[2] });
    }
  return !0;
}
function rQt(e) {
  function t(n) {
    const r = [];
    for (const i of n.tokens)
      if (i.type === "directive" && i.info in e)
        try {
          const s = new e[i.info](n), o = JFt(i, s), [a, l] = lI(i.content.trim() ? i.content.split(/\r?\n/) : [], s), h = new n.Token("parsed_directive_open", "", 1);
          h.info = i.info, h.hidden = !0, h.content = a.join(`
`).trim(), h.meta = {
            arg: i.meta.arg,
            opts: l
          };
          const u = [h];
          u.push(...s.run(o));
          const f = new n.Token("parsed_directive_close", "", -1);
          f.hidden = !0, u.push(f), u[1].meta = Object.assign(Object.assign({ directive: !0 }, o.options), u[1].meta), r.push(...u);
        } catch (s) {
          const o = new n.Token("directive_error", "", 0);
          o.content = i.content, o.info = i.info, o.meta = i.meta, o.map = i.map, o.meta.error_message = s.message, o.meta.error_name = s.name, r.push(o);
        }
      else
        r.push(i);
    return n.tokens = r, !0;
  }
  return t;
}
function iQt(e) {
  return e.toLowerCase().split(/\s+/).join("-").replace(/[^a-z0-9]+/, "-").replace(/^[-0-9]+|-+$/, "");
}
class uc extends Error {
  constructor() {
    super(...arguments), this.name = "OptionSpecError";
  }
}
const al = (e) => e, x_ = (e) => {
  if (!e)
    throw new uc("Argument required but none supplied");
  return e;
}, v_ = (e) => {
  if (e.trim())
    throw new uc(`No argument is allowed: "${e}" supplied`);
  return null;
}, Fu = (e) => `${e || ""}`.split(/\s+/).map((t) => iQt(t));
function cI(e) {
  if (!e)
    throw new uc("Value is not set");
  const t = Number.parseFloat(e);
  if (Number.isNaN(t) || !Number.isInteger(t))
    throw new uc(`Value "${e}" is not an integer`);
  return t;
}
function vm(e) {
  const t = cI(e);
  if (t < 0)
    throw new uc(`Value "${e}" must be positive or zero`);
  return t;
}
const hI = (e) => e ? vm(e) : null, sQt = (e) => (e = `${e || ""}`.replace(/\s+%$/, ""), vm(e));
function uI(e, t) {
  const r = new RegExp(`^(?<number>[0-9.]+)\\s*(?<units>${t.join("|")})$`).exec(e);
  if (!r || !r.groups)
    throw new uc(`not a positive measure of one of the following units: ${t.join("|")}`);
  return r.groups.number + r.groups.units;
}
const fI = ["em", "ex", "px", "in", "cm", "mm", "pt", "pc"], dI = (e) => uI(e, [...fI, ""]), R3 = (e, t = "") => {
  try {
    return uI(e, [...fI, "%"]);
  } catch {
    return dI(e) + t;
  }
}, oQt = (e, t = "") => e.toLowerCase() === "image" ? "image" : R3(e, t);
function $3(e) {
  return (t) => {
    if (t = t.toLowerCase().trim(), e.includes(t))
      return t;
    throw new uc(`must be in: ${e.join("|")}`);
  };
}
const aQt = (e) => e;
class Ls extends Tc {
  constructor() {
    super(...arguments), this.final_argument_whitespace = !0, this.has_content = !0, this.option_spec = {
      class: Fu,
      name: al
    }, this.title = "", this.kind = "";
  }
  run(t) {
    var n;
    const r = [], i = this.createToken("admonition_open", "aside", 1, {
      map: t.map,
      block: !0,
      meta: { kind: this.kind }
    });
    ((n = t.options.class) === null || n === void 0 ? void 0 : n.length) >= 1 ? (i.attrSet("class", t.options.class.join(" ")), i.attrJoin("class", "admonition")) : i.attrSet("class", "admonition"), this.kind && i.attrJoin("class", this.kind), r.push(i);
    const s = this.createToken("admonition_title_open", "header", 1);
    s.attrSet("class", "admonition-title"), r.push(s);
    const o = t.args[0] || this.title;
    r.push(this.createToken("inline", "", 0, {
      map: [t.map[0], t.map[0]],
      content: o,
      children: []
    })), r.push(this.createToken("admonition_title_close", "header", -1, { block: !0 }));
    const a = this.nestedParse(t.body, t.bodyMap[0]);
    return r.push(...a), r.push(this.createToken("admonition_close", "aside", -1, { block: !0 })), r;
  }
}
class lQt extends Ls {
  constructor() {
    super(...arguments), this.required_arguments = 1;
  }
}
class cQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Attention", this.kind = "attention";
  }
}
class hQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Caution", this.kind = "caution";
  }
}
class uQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Danger", this.kind = "danger";
  }
}
class fQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Error", this.kind = "error";
  }
}
class dQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Important", this.kind = "important";
  }
}
class pQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Hint", this.kind = "hint";
  }
}
class gQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Note", this.kind = "note";
  }
}
class mQt extends Ls {
  constructor() {
    super(...arguments), this.title = "See Also", this.kind = "seealso";
  }
}
class yQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Tip", this.kind = "tip";
  }
}
class bQt extends Ls {
  constructor() {
    super(...arguments), this.title = "Warning", this.kind = "warning";
  }
}
const OQt = {
  admonition: lQt,
  attention: cQt,
  caution: hQt,
  danger: uQt,
  error: fQt,
  important: dQt,
  hint: pQt,
  note: gQt,
  seealso: mQt,
  tip: yQt,
  warning: bQt
};
class xQt extends Tc {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      "number-lines": hI,
      force: v_,
      name: al,
      class: Fu
    };
  }
  run(t) {
    return this.assert_has_content(t), [this.createToken("fence", "code", 0, {
      info: t.args ? t.args[0] : "",
      content: t.body,
      map: t.bodyMap
    })];
  }
}
class vQt extends Tc {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      linenos: v_,
      "lineno-start": cI,
      dedent: hI,
      "emphasize-lines": x_,
      caption: x_,
      force: v_,
      name: al,
      class: Fu
    };
  }
  run(t) {
    return this.assert_has_content(t), [this.createToken("fence", "code", 0, {
      info: t.args ? t.args[0] : "",
      content: t.body,
      map: t.bodyMap
    })];
  }
}
class _Qt extends Tc {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.rawOptions = !0;
  }
  run(t) {
    return [this.createToken("fence", "code", 0, {
      info: t.args ? t.args[0] : "",
      content: t.body,
      map: t.bodyMap
    })];
  }
}
const kQt = {
  code: xQt,
  "code-block": vQt,
  "code-cell": _Qt
}, pI = {
  alt: al,
  height: dI,
  width: R3,
  scale: sQt,
  target: x_,
  class: Fu,
  name: al
};
class gI extends Tc {
  constructor() {
    super(...arguments), this.required_arguments = 1, this.optional_arguments = 0, this.final_argument_whitespace = !0, this.option_spec = Object.assign(Object.assign({}, pI), { align: $3(["left", "center", "right", "top", "middle", "bottom"]) });
  }
  create_image(t) {
    const n = aQt(t.args[0] || ""), r = this.createToken("image", "img", 0, { map: t.map, block: !0 });
    r.attrSet("src", n), r.attrSet("alt", t.options.alt || "");
    const i = [];
    return t.options.alt && this.state.md.inline.parse(t.options.alt, this.state.md, this.state.env, i), r.children = i, t.options.height && r.attrSet("height", t.options.height), t.options.width && r.attrSet("width", t.options.width), t.options.align && r.attrJoin("class", `align-${t.options.align}`), t.options.class && r.attrJoin("class", t.options.class.join(" ")), r;
  }
  run(t) {
    return [this.create_image(t)];
  }
}
class wQt extends gI {
  constructor() {
    super(...arguments), this.option_spec = Object.assign(Object.assign({}, pI), { align: $3(["left", "center", "right"]), figwidth: oQt, figclass: Fu }), this.has_content = !0;
  }
  run(t) {
    const n = this.createToken("figure_open", "figure", 1, {
      map: t.map,
      block: !0
    });
    t.options.figclass && n.attrJoin("class", t.options.figclass.join(" ")), t.options.align && n.attrJoin("class", `align-${t.options.align}`), t.options.figwidth && t.options.figwidth !== "image" && n.attrSet("width", t.options.figwidth);
    let r;
    t.options.name && (r = O$(
      this.state,
      n,
      Xd.figure,
      t.options.name,
      t.body.trim()
    ), n.attrJoin("class", "numbered"));
    const i = this.create_image(t);
    i.map = [t.map[0], t.map[0]];
    let s = [], o = [];
    if (t.body) {
      const [l, ...h] = t.body.split(`

`), u = h.join(`

`), f = t.bodyMap[0], d = this.createToken("figure_caption_open", "figcaption", 1, {
        block: !0
      });
      r && d.attrSet("number", `${r.number}`);
      const p = this.nestedParse(l, f), g = this.createToken("figure_caption_close", "figcaption", -1, {
        block: !0
      });
      if (s = [d, ...p, g], u) {
        const m = f + l.split(`
`).length + 1, y = this.createToken("figure_legend_open", "", 1, {
          block: !0
        }), O = this.nestedParse(u, m), x = this.createToken("figure_legend_close", "", -1, {
          block: !0
        });
        o = [y, ...O, x];
      }
    }
    const a = this.createToken("figure_close", "figure", -1, { block: !0 });
    return [n, i, ...s, ...o, a];
  }
}
const SQt = {
  image: gI,
  figure: wQt
};
class I3 {
  constructor(t, n = !0) {
    if (this.children = [], this.children = [], n) {
      this._set_children_from_tokens(t);
      return;
    }
    if (t.length === 0)
      throw new Error("Tree creation: Can only create root from empty token sequence.");
    if (t.length === 1) {
      const r = t[0];
      if (r.nesting)
        throw new Error("Unequal nesting level at the start and end of token stream.");
      this.token = r, r.children !== null && r.children.length > 0 && this._set_children_from_tokens(r.children);
    } else
      this.nester_tokens = { opening: t[0], closing: t[t.length - 1] }, this._set_children_from_tokens(t.slice(1, -1));
  }
  _set_children_from_tokens(t) {
    const n = [...t].reverse();
    let r;
    for (; n.length > 0 && (r = n.pop(), !!r); ) {
      if (!r.nesting) {
        this._add_child([r]);
        continue;
      }
      if (r.nesting !== 1)
        throw new Error("Invalid token nesting");
      const i = [r];
      let s = 1;
      for (; n.length > 0 && s !== 0; )
        r = n.pop(), r && (i.push(r), s += r.nesting);
      if (s)
        throw new Error(`unclosed tokens starting: ${i[0]}`);
      this._add_child(i);
    }
  }
  _add_child(t) {
    const n = new I3(t, !1);
    n.parent = this, this.children.push(n);
  }
  to_tokens() {
    function t(r, i) {
      if (r.type === "root")
        for (const s of r.children)
          t(s, i);
      else if (r.token)
        i.push(r.token);
      else {
        if (!r.nester_tokens)
          throw new Error("No nested token available");
        i.push(r.nester_tokens.opening);
        for (const s of r.children)
          t(s, i);
        i.push(r.nester_tokens.closing);
      }
    }
    const n = [];
    return t(this, n), n;
  }
  get is_root() {
    return !(this.token || this.nester_tokens);
  }
  get is_nested() {
    return !!this.nester_tokens;
  }
  get siblings() {
    return this.parent ? this.parent.children : [this];
  }
  *walk(t = !0) {
    t && (yield this);
    for (const n of this.children)
      yield* n.walk(!0);
  }
  get type() {
    var t, n, r;
    if (this.is_root)
      return "root";
    if (this.token)
      return this.token.type;
    if (!((t = this.nester_tokens) === null || t === void 0) && t.opening.type.endsWith("_open"))
      return (n = this.nester_tokens) === null || n === void 0 ? void 0 : n.opening.type.slice(0, -5);
    if (this.nester_tokens)
      return (r = this.nester_tokens) === null || r === void 0 ? void 0 : r.opening.type;
    throw new Error("no internal token");
  }
  attribute_token() {
    if (this.token)
      return this.token;
    if (this.nester_tokens)
      return this.nester_tokens.opening;
    throw new Error("Tree node does not have the accessed attribute");
  }
  get tag() {
    return this.attribute_token().tag;
  }
  get level() {
    return this.attribute_token().level;
  }
  get content() {
    return this.attribute_token().content;
  }
  get markup() {
    return this.attribute_token().markup;
  }
  get info() {
    return this.attribute_token().info;
  }
  get meta() {
    return this.attribute_token().meta;
  }
  get block() {
    return this.attribute_token().block;
  }
  get hidden() {
    return this.attribute_token().hidden;
  }
  get map() {
    return this.attribute_token().map;
  }
  get attrs() {
    return this.attribute_token().attrs;
  }
}
class CQt extends Tc {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !0, this.has_content = !0, this.option_spec = {
      "header-rows": vm,
      "stub-columns": vm,
      width: R3,
      widths: al,
      class: Fu,
      name: al,
      align: $3(["left", "center", "right"])
    };
  }
  run(t) {
    this.assert_has_content(t);
    const n = t.options["header-rows"] || 0, r = this.nestedParse(t.body, t.bodyMap[0]);
    if (r.length < 2 || r[0].type !== "bullet_list_open" || r[r.length - 1].type !== "bullet_list_close")
      throw new Fa("Content is not a single bullet list");
    const i = [], s = this.createToken("table_open", "table", 1, { map: t.bodyMap });
    t.options.align && s.attrJoin("class", `align-${t.options.align}`), t.options.class && s.attrJoin("class", t.options.class.join(" ")), i.push(s), t.args.length && t.args[0] && (i.push(this.createToken("table_caption_open", "caption", 1)), i.push(this.createToken("inline", "", 0, {
      map: [t.map[0], t.map[0]],
      content: t.args[0],
      children: []
    })), i.push(this.createToken("table_caption_close", "caption", -1)));
    let o = "th";
    n ? (i.push(this.createToken("thead_open", "thead", 1, { level: 1 })), o = "th") : (i.push(this.createToken("tbody_open", "tbody", 1, { level: 1 })), o = "td");
    let a, l = 0;
    for (const h of new I3(r.slice(1, -1)).children) {
      l += 1, this.assert(h.type === "list_item", `list item ${l} not of type 'list_item': ${h.type}`), this.assert(h.children.length === 1 && h.children[0].type === "bullet_list", `list item ${l} content not a nested bullet list`);
      const u = h.children[0].children;
      a === void 0 ? a = u.length : this.assert(u.length === a, `list item ${l} does not contain the same number of columns as previous items`), n && l === n + 1 && (i.push(this.createToken("thead_close", "thead", -1, { level: 1 })), i.push(this.createToken("tbody_open", "tbody", 1, { level: 1 })), o = "td"), i.push(this.createToken("tr_open", "tr", 1, { map: h.map, level: 2 }));
      for (const f of u)
        i.push(this.createToken(`${o}_open`, o, 1, { map: f.map, level: 3 })), i.push(...f.to_tokens().slice(1, -1)), i.push(this.createToken(`${o}_close`, o, -1, { level: 3 }));
      i.push(this.createToken("tr_close", "tr", -1, { level: 2 }));
    }
    if (n && l < n)
      throw new Error(`Insufficient rows (${l}) for required header rows (${n})`);
    return o === "td" ? i.push(this.createToken("tbody_close", "tbody", -1, { level: 1 })) : i.push(this.createToken("thead_close", "thead", -1, { level: 1 })), i.push(this.createToken("table_close", "table", -1)), i;
  }
}
const TQt = {
  "list-table": CQt
};
class EQt extends Tc {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 0, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      label: al
    };
  }
  run(t) {
    this.assert_has_content(t);
    const n = this.createToken("math_block", "div", 0, {
      content: t.body,
      map: t.bodyMap,
      block: !0
    });
    if (n.attrSet("class", "math block"), t.options.label) {
      n.attrSet("id", t.options.label);
      const r = O$(this.state, n, Xd.equation, t.options.label, "");
      n.attrSet("number", `${r.number}`), n.info = t.options.label, n.meta = { label: t.options.label, numbered: !0, number: r.number };
    }
    return [n];
  }
}
const AQt = {
  math: EQt
}, PQt = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, OQt), SQt), kQt), TQt), AQt);
function DQt(e) {
  return (t) => {
    const n = my(t);
    return n.references.forEach((r) => {
      const { label: i, tokens: s, contentFromTarget: o } = r, a = (h, u) => (s.open.attrJoin("class", "error"), s.open.tag = s.close.tag = "code", o && u ? s.content.content = o(u) : s.content.content = h, !0), l = n.targets[i];
      if (!l)
        return a(i, {
          kind: r.kind || "",
          label: i,
          title: i,
          number: `"${i}"`
        });
      if (r.kind && l.kind !== r.kind)
        return a(`Reference "${i}" does not match kind "${r.kind}"`);
      s.open.attrSet("href", `#${l.label}`), l.title && s.open.attrSet("title", l.title), o && (s.content.content = o(l).trim());
    }), !0;
  };
}
function LQt(e, t) {
  e.core.ruler.push("docutils_number", DQt());
}
const MQt = {
  parseRoles: !0,
  replaceFences: !0,
  rolesAfter: "inline",
  directivesAfter: "block",
  directives: PQt,
  roles: DNt
};
function RQt(e, t) {
  const n = Object.assign(Object.assign({}, MQt), t);
  e.use(b$, n), e.use(eQt, n), e.use(LQt, n);
}
const mI = "myst-editor/", $Qt = (e) => sessionStorage.getItem(mI + e), vE = (e, t) => sessionStorage.setItem(mI + e, t), yI = () => {
  for (var e in sessionStorage)
    e.startsWith("myst-editor") && sessionStorage.removeItem(e);
};
function IQt(e) {
  return new Promise((t) => {
    const n = new MutationObserver(() => {
      const r = document.getElementById(e);
      r && (n.disconnect(), t(r));
    });
    document.querySelectorAll("#myst-css-namespace").forEach((r) => n.observe(r, {
      childList: !0,
      subtree: !0
    }));
  });
}
const NQt = (e, t) => {
  const n = document.getElementById(e);
  n && (n.outerHTML = t);
}, BQt = (e) => {
  const t = document.getElementById(e);
  t && (t.outerHTML = t.innerHTML);
}, FQt = (e, t) => {
  const n = "placeholder-" + Math.random().toString().slice(2);
  return t.then(IQt(n)).then((r) => {
    vE(e, r), NQt(n, r);
  }).catch((r) => {
    console.error(r), BQt(n), vE(e, e);
  }), `<span id="${n}">${e}</span>`;
}, bI = ({
  transform: e,
  target: t
}) => ({
  target: t,
  transform: (n) => {
    const r = $Qt(n);
    if (r)
      return r;
    let i = e(n);
    return typeof i.then == "function" ? FQt(n, i) : i;
  }
}), QQt = (e, {
  transform: t,
  target: n
}) => e.replaceAll(n, t), ZQt = (e) => (t) => {
  const n = t.renderer.rules.text;
  t.renderer.rules.text = function(...r) {
    const i = n(...r);
    return e.map(bI).reduce(QQt, i);
  };
}, OI = "custom_role", VQt = ({
  target: e,
  transform: t
}) => ({
  name: e,
  role: class extends ba {
    run({
      content: r
    }) {
      const i = new this.state.Token(OI, "span", 1);
      return i.content = t(r), [i];
    }
  }
}), YQt = (e) => e.map(bI).map(VQt).reduce((t, {
  name: n,
  role: r
}) => (t[n] = r, t), {}), zQt = (e) => (t) => {
  const n = YQt(e);
  t.renderer.rules[OI] = (r, i) => r[i].content, t.use(b$, {
    roles: n
  });
};
/*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE */
function La(e) {
  return La = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, La(e);
}
function __(e, t) {
  return __ = Object.setPrototypeOf || function(r, i) {
    return r.__proto__ = i, r;
  }, __(e, t);
}
function qQt() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function X1(e, t, n) {
  return qQt() ? X1 = Reflect.construct : X1 = function(i, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(i, a), h = new l();
    return o && __(h, o.prototype), h;
  }, X1.apply(null, arguments);
}
function ns(e) {
  return WQt(e) || UQt(e) || jQt(e) || XQt();
}
function WQt(e) {
  if (Array.isArray(e))
    return k_(e);
}
function UQt(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function jQt(e, t) {
  if (!!e) {
    if (typeof e == "string")
      return k_(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return k_(e, t);
  }
}
function k_(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function XQt() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var GQt = Object.hasOwnProperty, _E = Object.setPrototypeOf, HQt = Object.isFrozen, KQt = Object.getPrototypeOf, JQt = Object.getOwnPropertyDescriptor, Yr = Object.freeze, ks = Object.seal, tZt = Object.create, xI = typeof Reflect < "u" && Reflect, _m = xI.apply, w_ = xI.construct;
_m || (_m = function(t, n, r) {
  return t.apply(n, r);
});
Yr || (Yr = function(t) {
  return t;
});
ks || (ks = function(t) {
  return t;
});
w_ || (w_ = function(t, n) {
  return X1(t, ns(n));
});
var eZt = Wi(Array.prototype.forEach), kE = Wi(Array.prototype.pop), lf = Wi(Array.prototype.push), G1 = Wi(String.prototype.toLowerCase), PO = Wi(String.prototype.toString), nZt = Wi(String.prototype.match), ts = Wi(String.prototype.replace), rZt = Wi(String.prototype.indexOf), iZt = Wi(String.prototype.trim), Rr = Wi(RegExp.prototype.test), DO = sZt(TypeError);
function Wi(e) {
  return function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      r[i - 1] = arguments[i];
    return _m(e, t, r);
  };
}
function sZt(e) {
  return function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return w_(e, n);
  };
}
function Ee(e, t, n) {
  var r;
  n = (r = n) !== null && r !== void 0 ? r : G1, _E && _E(e, null);
  for (var i = t.length; i--; ) {
    var s = t[i];
    if (typeof s == "string") {
      var o = n(s);
      o !== s && (HQt(t) || (t[i] = o), s = o);
    }
    e[s] = !0;
  }
  return e;
}
function kl(e) {
  var t = tZt(null), n;
  for (n in e)
    _m(GQt, e, [n]) === !0 && (t[n] = e[n]);
  return t;
}
function r1(e, t) {
  for (; e !== null; ) {
    var n = JQt(e, t);
    if (n) {
      if (n.get)
        return Wi(n.get);
      if (typeof n.value == "function")
        return Wi(n.value);
    }
    e = KQt(e);
  }
  function r(i) {
    return console.warn("fallback value for", i), null;
  }
  return r;
}
var wE = Yr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), LO = Yr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), MO = Yr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), oZt = Yr(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), RO = Yr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), aZt = Yr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), SE = Yr(["#text"]), CE = Yr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), $O = Yr(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), TE = Yr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), i1 = Yr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), lZt = ks(/\{\{[\w\W]*|[\w\W]*\}\}/gm), cZt = ks(/<%[\w\W]*|[\w\W]*%>/gm), hZt = ks(/\${[\w\W]*}/gm), uZt = ks(/^data-[\-\w.\u00B7-\uFFFF]/), fZt = ks(/^aria-[\-\w]+$/), dZt = ks(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), pZt = ks(/^(?:\w+script|data):/i), gZt = ks(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), mZt = ks(/^html$/i), yZt = function() {
  return typeof window > "u" ? null : window;
}, bZt = function(t, n) {
  if (La(t) !== "object" || typeof t.createPolicy != "function")
    return null;
  var r = null, i = "data-tt-policy-suffix";
  n.currentScript && n.currentScript.hasAttribute(i) && (r = n.currentScript.getAttribute(i));
  var s = "dompurify" + (r ? "#" + r : "");
  try {
    return t.createPolicy(s, {
      createHTML: function(a) {
        return a;
      },
      createScriptURL: function(a) {
        return a;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function vI() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : yZt(), t = function(Q) {
    return vI(Q);
  };
  if (t.version = "2.4.7", t.removed = [], !e || !e.document || e.document.nodeType !== 9)
    return t.isSupported = !1, t;
  var n = e.document, r = e.document, i = e.DocumentFragment, s = e.HTMLTemplateElement, o = e.Node, a = e.Element, l = e.NodeFilter, h = e.NamedNodeMap, u = h === void 0 ? e.NamedNodeMap || e.MozNamedAttrMap : h, f = e.HTMLFormElement, d = e.DOMParser, p = e.trustedTypes, g = a.prototype, m = r1(g, "cloneNode"), y = r1(g, "nextSibling"), O = r1(g, "childNodes"), x = r1(g, "parentNode");
  if (typeof s == "function") {
    var _ = r.createElement("template");
    _.content && _.content.ownerDocument && (r = _.content.ownerDocument);
  }
  var w = bZt(p, n), E = w ? w.createHTML("") : "", T = r, S = T.implementation, R = T.createNodeIterator, A = T.createDocumentFragment, P = T.getElementsByTagName, C = n.importNode, k = {};
  try {
    k = kl(r).documentMode ? r.documentMode : {};
  } catch {
  }
  var D = {};
  t.isSupported = typeof x == "function" && S && S.createHTMLDocument !== void 0 && k !== 9;
  var b = lZt, M = cZt, v = hZt, N = uZt, tt = fZt, Z = pZt, z = gZt, X = dZt, q = null, nt = Ee({}, [].concat(ns(wE), ns(LO), ns(MO), ns(RO), ns(SE))), st = null, ct = Ee({}, [].concat(ns(CE), ns($O), ns(TE), ns(i1))), Y = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Ct = null, H = null, et = !0, U = !0, W = !1, $ = !0, F = !1, G = !1, I = !1, ht = !1, L = !1, $t = !1, it = !1, At = !0, St = !1, bt = "user-content-", gt = !0, yt = !1, dt = {}, xt = null, Re = Ee({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), ye = null, zt = Ee({}, ["audio", "video", "img", "source", "image", "track"]), Yt = null, ce = Ee({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Ie = "http://www.w3.org/1998/Math/MathML", re = "http://www.w3.org/2000/svg", Qt = "http://www.w3.org/1999/xhtml", Lt = Qt, kt = !1, _t = null, Et = Ee({}, [Ie, re, Qt], PO), pt, Zt = ["application/xhtml+xml", "text/html"], lt = "text/html", Vt, ut = null, he = r.createElement("form"), pe = function(Q) {
    return Q instanceof RegExp || Q instanceof Function;
  }, be = function(Q) {
    ut && ut === Q || ((!Q || La(Q) !== "object") && (Q = {}), Q = kl(Q), pt = Zt.indexOf(Q.PARSER_MEDIA_TYPE) === -1 ? pt = lt : pt = Q.PARSER_MEDIA_TYPE, Vt = pt === "application/xhtml+xml" ? PO : G1, q = "ALLOWED_TAGS" in Q ? Ee({}, Q.ALLOWED_TAGS, Vt) : nt, st = "ALLOWED_ATTR" in Q ? Ee({}, Q.ALLOWED_ATTR, Vt) : ct, _t = "ALLOWED_NAMESPACES" in Q ? Ee({}, Q.ALLOWED_NAMESPACES, PO) : Et, Yt = "ADD_URI_SAFE_ATTR" in Q ? Ee(
      kl(ce),
      Q.ADD_URI_SAFE_ATTR,
      Vt
    ) : ce, ye = "ADD_DATA_URI_TAGS" in Q ? Ee(
      kl(zt),
      Q.ADD_DATA_URI_TAGS,
      Vt
    ) : zt, xt = "FORBID_CONTENTS" in Q ? Ee({}, Q.FORBID_CONTENTS, Vt) : Re, Ct = "FORBID_TAGS" in Q ? Ee({}, Q.FORBID_TAGS, Vt) : {}, H = "FORBID_ATTR" in Q ? Ee({}, Q.FORBID_ATTR, Vt) : {}, dt = "USE_PROFILES" in Q ? Q.USE_PROFILES : !1, et = Q.ALLOW_ARIA_ATTR !== !1, U = Q.ALLOW_DATA_ATTR !== !1, W = Q.ALLOW_UNKNOWN_PROTOCOLS || !1, $ = Q.ALLOW_SELF_CLOSE_IN_ATTR !== !1, F = Q.SAFE_FOR_TEMPLATES || !1, G = Q.WHOLE_DOCUMENT || !1, L = Q.RETURN_DOM || !1, $t = Q.RETURN_DOM_FRAGMENT || !1, it = Q.RETURN_TRUSTED_TYPE || !1, ht = Q.FORCE_BODY || !1, At = Q.SANITIZE_DOM !== !1, St = Q.SANITIZE_NAMED_PROPS || !1, gt = Q.KEEP_CONTENT !== !1, yt = Q.IN_PLACE || !1, X = Q.ALLOWED_URI_REGEXP || X, Lt = Q.NAMESPACE || Qt, Y = Q.CUSTOM_ELEMENT_HANDLING || {}, Q.CUSTOM_ELEMENT_HANDLING && pe(Q.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Y.tagNameCheck = Q.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Q.CUSTOM_ELEMENT_HANDLING && pe(Q.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Y.attributeNameCheck = Q.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Q.CUSTOM_ELEMENT_HANDLING && typeof Q.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Y.allowCustomizedBuiltInElements = Q.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), F && (U = !1), $t && (L = !0), dt && (q = Ee({}, ns(SE)), st = [], dt.html === !0 && (Ee(q, wE), Ee(st, CE)), dt.svg === !0 && (Ee(q, LO), Ee(st, $O), Ee(st, i1)), dt.svgFilters === !0 && (Ee(q, MO), Ee(st, $O), Ee(st, i1)), dt.mathMl === !0 && (Ee(q, RO), Ee(st, TE), Ee(st, i1))), Q.ADD_TAGS && (q === nt && (q = kl(q)), Ee(q, Q.ADD_TAGS, Vt)), Q.ADD_ATTR && (st === ct && (st = kl(st)), Ee(st, Q.ADD_ATTR, Vt)), Q.ADD_URI_SAFE_ATTR && Ee(Yt, Q.ADD_URI_SAFE_ATTR, Vt), Q.FORBID_CONTENTS && (xt === Re && (xt = kl(xt)), Ee(xt, Q.FORBID_CONTENTS, Vt)), gt && (q["#text"] = !0), G && Ee(q, ["html", "head", "body"]), q.table && (Ee(q, ["tbody"]), delete Ct.tbody), Yr && Yr(Q), ut = Q);
  }, Oe = Ee({}, ["mi", "mo", "mn", "ms", "mtext"]), ke = Ee({}, ["foreignobject", "desc", "title", "annotation-xml"]), qt = Ee({}, ["title", "style", "font", "a", "script"]), ne = Ee({}, LO);
  Ee(ne, MO), Ee(ne, oZt);
  var ge = Ee({}, RO);
  Ee(ge, aZt);
  var ie = function(Q) {
    var ot = x(Q);
    (!ot || !ot.tagName) && (ot = {
      namespaceURI: Lt,
      tagName: "template"
    });
    var vt = G1(Q.tagName), Gt = G1(ot.tagName);
    return _t[Q.namespaceURI] ? Q.namespaceURI === re ? ot.namespaceURI === Qt ? vt === "svg" : ot.namespaceURI === Ie ? vt === "svg" && (Gt === "annotation-xml" || Oe[Gt]) : Boolean(ne[vt]) : Q.namespaceURI === Ie ? ot.namespaceURI === Qt ? vt === "math" : ot.namespaceURI === re ? vt === "math" && ke[Gt] : Boolean(ge[vt]) : Q.namespaceURI === Qt ? ot.namespaceURI === re && !ke[Gt] || ot.namespaceURI === Ie && !Oe[Gt] ? !1 : !ge[vt] && (qt[vt] || !ne[vt]) : !!(pt === "application/xhtml+xml" && _t[Q.namespaceURI]) : !1;
  }, qn = function(Q) {
    lf(t.removed, {
      element: Q
    });
    try {
      Q.parentNode.removeChild(Q);
    } catch {
      try {
        Q.outerHTML = E;
      } catch {
        Q.remove();
      }
    }
  }, Ji = function(Q, ot) {
    try {
      lf(t.removed, {
        attribute: ot.getAttributeNode(Q),
        from: ot
      });
    } catch {
      lf(t.removed, {
        attribute: null,
        from: ot
      });
    }
    if (ot.removeAttribute(Q), Q === "is" && !st[Q])
      if (L || $t)
        try {
          qn(ot);
        } catch {
        }
      else
        try {
          ot.setAttribute(Q, "");
        } catch {
        }
  }, qe = function(Q) {
    var ot, vt;
    if (ht)
      Q = "<remove></remove>" + Q;
    else {
      var Gt = nZt(Q, /^[\r\n\t ]+/);
      vt = Gt && Gt[0];
    }
    pt === "application/xhtml+xml" && Lt === Qt && (Q = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Q + "</body></html>");
    var Ce = w ? w.createHTML(Q) : Q;
    if (Lt === Qt)
      try {
        ot = new d().parseFromString(Ce, pt);
      } catch {
      }
    if (!ot || !ot.documentElement) {
      ot = S.createDocument(Lt, "template", null);
      try {
        ot.documentElement.innerHTML = kt ? E : Ce;
      } catch {
      }
    }
    var Le = ot.body || ot.documentElement;
    return Q && vt && Le.insertBefore(r.createTextNode(vt), Le.childNodes[0] || null), Lt === Qt ? P.call(ot, G ? "html" : "body")[0] : G ? ot.documentElement : Le;
  }, ae = function(Q) {
    return R.call(
      Q.ownerDocument || Q,
      Q,
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT,
      null,
      !1
    );
  }, fn = function(Q) {
    return Q instanceof f && (typeof Q.nodeName != "string" || typeof Q.textContent != "string" || typeof Q.removeChild != "function" || !(Q.attributes instanceof u) || typeof Q.removeAttribute != "function" || typeof Q.setAttribute != "function" || typeof Q.namespaceURI != "string" || typeof Q.insertBefore != "function" || typeof Q.hasChildNodes != "function");
  }, On = function(Q) {
    return La(o) === "object" ? Q instanceof o : Q && La(Q) === "object" && typeof Q.nodeType == "number" && typeof Q.nodeName == "string";
  }, Qe = function(Q, ot, vt) {
    !D[Q] || eZt(D[Q], function(Gt) {
      Gt.call(t, ot, vt, ut);
    });
  }, xn = function(Q) {
    var ot;
    if (Qe("beforeSanitizeElements", Q, null), fn(Q) || Rr(/[\u0080-\uFFFF]/, Q.nodeName))
      return qn(Q), !0;
    var vt = Vt(Q.nodeName);
    if (Qe("uponSanitizeElement", Q, {
      tagName: vt,
      allowedTags: q
    }), Q.hasChildNodes() && !On(Q.firstElementChild) && (!On(Q.content) || !On(Q.content.firstElementChild)) && Rr(/<[/\w]/g, Q.innerHTML) && Rr(/<[/\w]/g, Q.textContent) || vt === "select" && Rr(/<template/i, Q.innerHTML))
      return qn(Q), !0;
    if (!q[vt] || Ct[vt]) {
      if (!Ct[vt] && Rn(vt) && (Y.tagNameCheck instanceof RegExp && Rr(Y.tagNameCheck, vt) || Y.tagNameCheck instanceof Function && Y.tagNameCheck(vt)))
        return !1;
      if (gt && !xt[vt]) {
        var Gt = x(Q) || Q.parentNode, Ce = O(Q) || Q.childNodes;
        if (Ce && Gt)
          for (var Le = Ce.length, $e = Le - 1; $e >= 0; --$e)
            Gt.insertBefore(m(Ce[$e], !0), y(Q));
      }
      return qn(Q), !0;
    }
    return Q instanceof a && !ie(Q) || (vt === "noscript" || vt === "noembed" || vt === "noframes") && Rr(/<\/no(script|embed|frames)/i, Q.innerHTML) ? (qn(Q), !0) : (F && Q.nodeType === 3 && (ot = Q.textContent, ot = ts(ot, b, " "), ot = ts(ot, M, " "), ot = ts(ot, v, " "), Q.textContent !== ot && (lf(t.removed, {
      element: Q.cloneNode()
    }), Q.textContent = ot)), Qe("afterSanitizeElements", Q, null), !1);
  }, We = function(Q, ot, vt) {
    if (At && (ot === "id" || ot === "name") && (vt in r || vt in he))
      return !1;
    if (!(U && !H[ot] && Rr(N, ot))) {
      if (!(et && Rr(tt, ot))) {
        if (!st[ot] || H[ot]) {
          if (!(Rn(Q) && (Y.tagNameCheck instanceof RegExp && Rr(Y.tagNameCheck, Q) || Y.tagNameCheck instanceof Function && Y.tagNameCheck(Q)) && (Y.attributeNameCheck instanceof RegExp && Rr(Y.attributeNameCheck, ot) || Y.attributeNameCheck instanceof Function && Y.attributeNameCheck(ot)) || ot === "is" && Y.allowCustomizedBuiltInElements && (Y.tagNameCheck instanceof RegExp && Rr(Y.tagNameCheck, vt) || Y.tagNameCheck instanceof Function && Y.tagNameCheck(vt))))
            return !1;
        } else if (!Yt[ot]) {
          if (!Rr(X, ts(vt, z, ""))) {
            if (!((ot === "src" || ot === "xlink:href" || ot === "href") && Q !== "script" && rZt(vt, "data:") === 0 && ye[Q])) {
              if (!(W && !Rr(Z, ts(vt, z, "")))) {
                if (vt)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Rn = function(Q) {
    return Q.indexOf("-") > 0;
  }, kn = function(Q) {
    var ot, vt, Gt, Ce;
    Qe("beforeSanitizeAttributes", Q, null);
    var Le = Q.attributes;
    if (!!Le) {
      var $e = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: st
      };
      for (Ce = Le.length; Ce--; ) {
        ot = Le[Ce];
        var Ue = ot, ln = Ue.name, Bs = Ue.namespaceURI;
        if (vt = ln === "value" ? ot.value : iZt(ot.value), Gt = Vt(ln), $e.attrName = Gt, $e.attrValue = vt, $e.keepAttr = !0, $e.forceKeepAttr = void 0, Qe("uponSanitizeAttribute", Q, $e), vt = $e.attrValue, !$e.forceKeepAttr && (Ji(ln, Q), !!$e.keepAttr)) {
          if (!$ && Rr(/\/>/i, vt)) {
            Ji(ln, Q);
            continue;
          }
          F && (vt = ts(vt, b, " "), vt = ts(vt, M, " "), vt = ts(vt, v, " "));
          var Ci = Vt(Q.nodeName);
          if (!!We(Ci, Gt, vt)) {
            if (St && (Gt === "id" || Gt === "name") && (Ji(ln, Q), vt = bt + vt), w && La(p) === "object" && typeof p.getAttributeType == "function" && !Bs)
              switch (p.getAttributeType(Ci, Gt)) {
                case "TrustedHTML": {
                  vt = w.createHTML(vt);
                  break;
                }
                case "TrustedScriptURL": {
                  vt = w.createScriptURL(vt);
                  break;
                }
              }
            try {
              Bs ? Q.setAttributeNS(Bs, ln, vt) : Q.setAttribute(ln, vt), kE(t.removed);
            } catch {
            }
          }
        }
      }
      Qe("afterSanitizeAttributes", Q, null);
    }
  }, It = function V(Q) {
    var ot, vt = ae(Q);
    for (Qe("beforeSanitizeShadowDOM", Q, null); ot = vt.nextNode(); )
      Qe("uponSanitizeShadowNode", ot, null), !xn(ot) && (ot.content instanceof i && V(ot.content), kn(ot));
    Qe("afterSanitizeShadowDOM", Q, null);
  };
  return t.sanitize = function(V) {
    var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ot, vt, Gt, Ce, Le;
    if (kt = !V, kt && (V = "<!-->"), typeof V != "string" && !On(V))
      if (typeof V.toString == "function") {
        if (V = V.toString(), typeof V != "string")
          throw DO("dirty is not a string, aborting");
      } else
        throw DO("toString is not a function");
    if (!t.isSupported) {
      if (La(e.toStaticHTML) === "object" || typeof e.toStaticHTML == "function") {
        if (typeof V == "string")
          return e.toStaticHTML(V);
        if (On(V))
          return e.toStaticHTML(V.outerHTML);
      }
      return V;
    }
    if (I || be(Q), t.removed = [], typeof V == "string" && (yt = !1), yt) {
      if (V.nodeName) {
        var $e = Vt(V.nodeName);
        if (!q[$e] || Ct[$e])
          throw DO("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (V instanceof o)
      ot = qe("<!---->"), vt = ot.ownerDocument.importNode(V, !0), vt.nodeType === 1 && vt.nodeName === "BODY" || vt.nodeName === "HTML" ? ot = vt : ot.appendChild(vt);
    else {
      if (!L && !F && !G && V.indexOf("<") === -1)
        return w && it ? w.createHTML(V) : V;
      if (ot = qe(V), !ot)
        return L ? null : it ? E : "";
    }
    ot && ht && qn(ot.firstChild);
    for (var Ue = ae(yt ? V : ot); Gt = Ue.nextNode(); )
      Gt.nodeType === 3 && Gt === Ce || xn(Gt) || (Gt.content instanceof i && It(Gt.content), kn(Gt), Ce = Gt);
    if (Ce = null, yt)
      return V;
    if (L) {
      if ($t)
        for (Le = A.call(ot.ownerDocument); ot.firstChild; )
          Le.appendChild(ot.firstChild);
      else
        Le = ot;
      return (st.shadowroot || st.shadowrootmod) && (Le = C.call(n, Le, !0)), Le;
    }
    var ln = G ? ot.outerHTML : ot.innerHTML;
    return G && q["!doctype"] && ot.ownerDocument && ot.ownerDocument.doctype && ot.ownerDocument.doctype.name && Rr(mZt, ot.ownerDocument.doctype.name) && (ln = "<!DOCTYPE " + ot.ownerDocument.doctype.name + `>
` + ln), F && (ln = ts(ln, b, " "), ln = ts(ln, M, " "), ln = ts(ln, v, " ")), w && it ? w.createHTML(ln) : ln;
  }, t.setConfig = function(V) {
    be(V), I = !0;
  }, t.clearConfig = function() {
    ut = null, I = !1;
  }, t.isValidAttribute = function(V, Q, ot) {
    ut || be({});
    var vt = Vt(V), Gt = Vt(Q);
    return We(vt, Gt, ot);
  }, t.addHook = function(V, Q) {
    typeof Q == "function" && (D[V] = D[V] || [], lf(D[V], Q));
  }, t.removeHook = function(V) {
    if (D[V])
      return kE(D[V]);
  }, t.removeHooks = function(V) {
    D[V] && (D[V] = []);
  }, t.removeAllHooks = function() {
    D = {};
  }, t;
}
var _I = vI(), kI = { exports: {} };
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
(function(e) {
  (function() {
    var t;
    function n(r, i) {
      var s = this instanceof n ? this : t;
      if (s.reset(i), typeof r == "string" && r.length > 0 && s.hash(r), s !== this)
        return s;
    }
    n.prototype.hash = function(r) {
      var i, s, o, a, l;
      switch (l = r.length, this.len += l, s = this.k1, o = 0, this.rem) {
        case 0:
          s ^= l > o ? r.charCodeAt(o++) & 65535 : 0;
        case 1:
          s ^= l > o ? (r.charCodeAt(o++) & 65535) << 8 : 0;
        case 2:
          s ^= l > o ? (r.charCodeAt(o++) & 65535) << 16 : 0;
        case 3:
          s ^= l > o ? (r.charCodeAt(o) & 255) << 24 : 0, s ^= l > o ? (r.charCodeAt(o++) & 65280) >> 8 : 0;
      }
      if (this.rem = l + this.rem & 3, l -= this.rem, l > 0) {
        for (i = this.h1; s = s * 11601 + (s & 65535) * 3432906752 & 4294967295, s = s << 15 | s >>> 17, s = s * 13715 + (s & 65535) * 461832192 & 4294967295, i ^= s, i = i << 13 | i >>> 19, i = i * 5 + 3864292196 & 4294967295, !(o >= l); )
          s = r.charCodeAt(o++) & 65535 ^ (r.charCodeAt(o++) & 65535) << 8 ^ (r.charCodeAt(o++) & 65535) << 16, a = r.charCodeAt(o++), s ^= (a & 255) << 24 ^ (a & 65280) >> 8;
        switch (s = 0, this.rem) {
          case 3:
            s ^= (r.charCodeAt(o + 2) & 65535) << 16;
          case 2:
            s ^= (r.charCodeAt(o + 1) & 65535) << 8;
          case 1:
            s ^= r.charCodeAt(o) & 65535;
        }
        this.h1 = i;
      }
      return this.k1 = s, this;
    }, n.prototype.result = function() {
      var r, i;
      return r = this.k1, i = this.h1, r > 0 && (r = r * 11601 + (r & 65535) * 3432906752 & 4294967295, r = r << 15 | r >>> 17, r = r * 13715 + (r & 65535) * 461832192 & 4294967295, i ^= r), i ^= this.len, i ^= i >>> 16, i = i * 51819 + (i & 65535) * 2246770688 & 4294967295, i ^= i >>> 13, i = i * 44597 + (i & 65535) * 3266445312 & 4294967295, i ^= i >>> 16, i >>> 0;
    }, n.prototype.reset = function(r) {
      return this.h1 = typeof r == "number" ? r : 0, this.rem = this.k1 = this.len = 0, this;
    }, t = new n(), e.exports = n;
  })();
})(kI);
const OZt = kI.exports;
function wI(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  var r = Array.from(typeof e == "string" ? [e] : e);
  r[r.length - 1] = r[r.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i = r.reduce(function(a, l) {
    var h = l.match(/\n([\t ]+|(?!\s).)/g);
    return h ? a.concat(h.map(function(u) {
      var f, d;
      return (d = (f = u.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && d !== void 0 ? d : 0;
    })) : a;
  }, []);
  if (i.length) {
    var s = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
    r = r.map(function(a) {
      return a.replace(s, `
`);
    });
  }
  r[0] = r[0].replace(/^\r?\n/, "");
  var o = r[0];
  return t.forEach(function(a, l) {
    var h = o.match(/(?:^|\n)( *)$/), u = h ? h[1] : "", f = a;
    typeof a == "string" && a.includes(`
`) && (f = String(a).split(`
`).map(function(d, p) {
      return p === 0 ? d : "" + u + d;
    }).join(`
`)), o += f + r[l + 1];
  }), o;
}
var SI = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(E2, function() {
    var n = 1e3, r = 6e4, i = 36e5, s = "millisecond", o = "second", a = "minute", l = "hour", h = "day", u = "week", f = "month", d = "quarter", p = "year", g = "date", m = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, O = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, x = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(b) {
      var M = ["th", "st", "nd", "rd"], v = b % 100;
      return "[" + b + (M[(v - 20) % 10] || M[v] || M[0]) + "]";
    } }, _ = function(b, M, v) {
      var N = String(b);
      return !N || N.length >= M ? b : "" + Array(M + 1 - N.length).join(v) + b;
    }, w = { s: _, z: function(b) {
      var M = -b.utcOffset(), v = Math.abs(M), N = Math.floor(v / 60), tt = v % 60;
      return (M <= 0 ? "+" : "-") + _(N, 2, "0") + ":" + _(tt, 2, "0");
    }, m: function b(M, v) {
      if (M.date() < v.date())
        return -b(v, M);
      var N = 12 * (v.year() - M.year()) + (v.month() - M.month()), tt = M.clone().add(N, f), Z = v - tt < 0, z = M.clone().add(N + (Z ? -1 : 1), f);
      return +(-(N + (v - tt) / (Z ? tt - z : z - tt)) || 0);
    }, a: function(b) {
      return b < 0 ? Math.ceil(b) || 0 : Math.floor(b);
    }, p: function(b) {
      return { M: f, y: p, w: u, d: h, D: g, h: l, m: a, s: o, ms: s, Q: d }[b] || String(b || "").toLowerCase().replace(/s$/, "");
    }, u: function(b) {
      return b === void 0;
    } }, E = "en", T = {};
    T[E] = x;
    var S = "$isDayjsObject", R = function(b) {
      return b instanceof k || !(!b || !b[S]);
    }, A = function b(M, v, N) {
      var tt;
      if (!M)
        return E;
      if (typeof M == "string") {
        var Z = M.toLowerCase();
        T[Z] && (tt = Z), v && (T[Z] = v, tt = Z);
        var z = M.split("-");
        if (!tt && z.length > 1)
          return b(z[0]);
      } else {
        var X = M.name;
        T[X] = M, tt = X;
      }
      return !N && tt && (E = tt), tt || !N && E;
    }, P = function(b, M) {
      if (R(b))
        return b.clone();
      var v = typeof M == "object" ? M : {};
      return v.date = b, v.args = arguments, new k(v);
    }, C = w;
    C.l = A, C.i = R, C.w = function(b, M) {
      return P(b, { locale: M.$L, utc: M.$u, x: M.$x, $offset: M.$offset });
    };
    var k = function() {
      function b(v) {
        this.$L = A(v.locale, null, !0), this.parse(v), this.$x = this.$x || v.x || {}, this[S] = !0;
      }
      var M = b.prototype;
      return M.parse = function(v) {
        this.$d = function(N) {
          var tt = N.date, Z = N.utc;
          if (tt === null)
            return new Date(NaN);
          if (C.u(tt))
            return new Date();
          if (tt instanceof Date)
            return new Date(tt);
          if (typeof tt == "string" && !/Z$/i.test(tt)) {
            var z = tt.match(y);
            if (z) {
              var X = z[2] - 1 || 0, q = (z[7] || "0").substring(0, 3);
              return Z ? new Date(Date.UTC(z[1], X, z[3] || 1, z[4] || 0, z[5] || 0, z[6] || 0, q)) : new Date(z[1], X, z[3] || 1, z[4] || 0, z[5] || 0, z[6] || 0, q);
            }
          }
          return new Date(tt);
        }(v), this.init();
      }, M.init = function() {
        var v = this.$d;
        this.$y = v.getFullYear(), this.$M = v.getMonth(), this.$D = v.getDate(), this.$W = v.getDay(), this.$H = v.getHours(), this.$m = v.getMinutes(), this.$s = v.getSeconds(), this.$ms = v.getMilliseconds();
      }, M.$utils = function() {
        return C;
      }, M.isValid = function() {
        return this.$d.toString() !== m;
      }, M.isSame = function(v, N) {
        var tt = P(v);
        return this.startOf(N) <= tt && tt <= this.endOf(N);
      }, M.isAfter = function(v, N) {
        return P(v) < this.startOf(N);
      }, M.isBefore = function(v, N) {
        return this.endOf(N) < P(v);
      }, M.$g = function(v, N, tt) {
        return C.u(v) ? this[N] : this.set(tt, v);
      }, M.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, M.valueOf = function() {
        return this.$d.getTime();
      }, M.startOf = function(v, N) {
        var tt = this, Z = !!C.u(N) || N, z = C.p(v), X = function(et, U) {
          var W = C.w(tt.$u ? Date.UTC(tt.$y, U, et) : new Date(tt.$y, U, et), tt);
          return Z ? W : W.endOf(h);
        }, q = function(et, U) {
          return C.w(tt.toDate()[et].apply(tt.toDate("s"), (Z ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(U)), tt);
        }, nt = this.$W, st = this.$M, ct = this.$D, Y = "set" + (this.$u ? "UTC" : "");
        switch (z) {
          case p:
            return Z ? X(1, 0) : X(31, 11);
          case f:
            return Z ? X(1, st) : X(0, st + 1);
          case u:
            var Ct = this.$locale().weekStart || 0, H = (nt < Ct ? nt + 7 : nt) - Ct;
            return X(Z ? ct - H : ct + (6 - H), st);
          case h:
          case g:
            return q(Y + "Hours", 0);
          case l:
            return q(Y + "Minutes", 1);
          case a:
            return q(Y + "Seconds", 2);
          case o:
            return q(Y + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, M.endOf = function(v) {
        return this.startOf(v, !1);
      }, M.$set = function(v, N) {
        var tt, Z = C.p(v), z = "set" + (this.$u ? "UTC" : ""), X = (tt = {}, tt[h] = z + "Date", tt[g] = z + "Date", tt[f] = z + "Month", tt[p] = z + "FullYear", tt[l] = z + "Hours", tt[a] = z + "Minutes", tt[o] = z + "Seconds", tt[s] = z + "Milliseconds", tt)[Z], q = Z === h ? this.$D + (N - this.$W) : N;
        if (Z === f || Z === p) {
          var nt = this.clone().set(g, 1);
          nt.$d[X](q), nt.init(), this.$d = nt.set(g, Math.min(this.$D, nt.daysInMonth())).$d;
        } else
          X && this.$d[X](q);
        return this.init(), this;
      }, M.set = function(v, N) {
        return this.clone().$set(v, N);
      }, M.get = function(v) {
        return this[C.p(v)]();
      }, M.add = function(v, N) {
        var tt, Z = this;
        v = Number(v);
        var z = C.p(N), X = function(st) {
          var ct = P(Z);
          return C.w(ct.date(ct.date() + Math.round(st * v)), Z);
        };
        if (z === f)
          return this.set(f, this.$M + v);
        if (z === p)
          return this.set(p, this.$y + v);
        if (z === h)
          return X(1);
        if (z === u)
          return X(7);
        var q = (tt = {}, tt[a] = r, tt[l] = i, tt[o] = n, tt)[z] || 1, nt = this.$d.getTime() + v * q;
        return C.w(nt, this);
      }, M.subtract = function(v, N) {
        return this.add(-1 * v, N);
      }, M.format = function(v) {
        var N = this, tt = this.$locale();
        if (!this.isValid())
          return tt.invalidDate || m;
        var Z = v || "YYYY-MM-DDTHH:mm:ssZ", z = C.z(this), X = this.$H, q = this.$m, nt = this.$M, st = tt.weekdays, ct = tt.months, Y = tt.meridiem, Ct = function(U, W, $, F) {
          return U && (U[W] || U(N, Z)) || $[W].slice(0, F);
        }, H = function(U) {
          return C.s(X % 12 || 12, U, "0");
        }, et = Y || function(U, W, $) {
          var F = U < 12 ? "AM" : "PM";
          return $ ? F.toLowerCase() : F;
        };
        return Z.replace(O, function(U, W) {
          return W || function($) {
            switch ($) {
              case "YY":
                return String(N.$y).slice(-2);
              case "YYYY":
                return C.s(N.$y, 4, "0");
              case "M":
                return nt + 1;
              case "MM":
                return C.s(nt + 1, 2, "0");
              case "MMM":
                return Ct(tt.monthsShort, nt, ct, 3);
              case "MMMM":
                return Ct(ct, nt);
              case "D":
                return N.$D;
              case "DD":
                return C.s(N.$D, 2, "0");
              case "d":
                return String(N.$W);
              case "dd":
                return Ct(tt.weekdaysMin, N.$W, st, 2);
              case "ddd":
                return Ct(tt.weekdaysShort, N.$W, st, 3);
              case "dddd":
                return st[N.$W];
              case "H":
                return String(X);
              case "HH":
                return C.s(X, 2, "0");
              case "h":
                return H(1);
              case "hh":
                return H(2);
              case "a":
                return et(X, q, !0);
              case "A":
                return et(X, q, !1);
              case "m":
                return String(q);
              case "mm":
                return C.s(q, 2, "0");
              case "s":
                return String(N.$s);
              case "ss":
                return C.s(N.$s, 2, "0");
              case "SSS":
                return C.s(N.$ms, 3, "0");
              case "Z":
                return z;
            }
            return null;
          }(U) || z.replace(":", "");
        });
      }, M.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, M.diff = function(v, N, tt) {
        var Z, z = this, X = C.p(N), q = P(v), nt = (q.utcOffset() - this.utcOffset()) * r, st = this - q, ct = function() {
          return C.m(z, q);
        };
        switch (X) {
          case p:
            Z = ct() / 12;
            break;
          case f:
            Z = ct();
            break;
          case d:
            Z = ct() / 3;
            break;
          case u:
            Z = (st - nt) / 6048e5;
            break;
          case h:
            Z = (st - nt) / 864e5;
            break;
          case l:
            Z = st / i;
            break;
          case a:
            Z = st / r;
            break;
          case o:
            Z = st / n;
            break;
          default:
            Z = st;
        }
        return tt ? Z : C.a(Z);
      }, M.daysInMonth = function() {
        return this.endOf(f).$D;
      }, M.$locale = function() {
        return T[this.$L];
      }, M.locale = function(v, N) {
        if (!v)
          return this.$L;
        var tt = this.clone(), Z = A(v, N, !0);
        return Z && (tt.$L = Z), tt;
      }, M.clone = function() {
        return C.w(this.$d, this);
      }, M.toDate = function() {
        return new Date(this.valueOf());
      }, M.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, M.toISOString = function() {
        return this.$d.toISOString();
      }, M.toString = function() {
        return this.$d.toUTCString();
      }, b;
    }(), D = k.prototype;
    return P.prototype = D, [["$ms", s], ["$s", o], ["$m", a], ["$H", l], ["$W", h], ["$M", f], ["$y", p], ["$D", g]].forEach(function(b) {
      D[b[1]] = function(M) {
        return this.$g(M, b[0], b[1]);
      };
    }), P.extend = function(b, M) {
      return b.$i || (b(M, k, P), b.$i = !0), P;
    }, P.locale = A, P.isDayjs = R, P.unix = function(b) {
      return P(1e3 * b);
    }, P.en = T[E], P.Ls = T, P.p = {}, P;
  });
})(SI);
const ri = SI.exports;
var Oa = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.sanitizeUrl = e.BLANK_URL = void 0;
  var t = /^([^\w]*)(javascript|data|vbscript)/im, n = /&#(\w+)(^\w|;)?/g, r = /&(newline|tab);/gi, i = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, s = /^.+(:|&colon;)/gim, o = [".", "/"];
  e.BLANK_URL = "about:blank";
  function a(u) {
    return o.indexOf(u[0]) > -1;
  }
  function l(u) {
    var f = u.replace(i, "");
    return f.replace(n, function(d, p) {
      return String.fromCharCode(p);
    });
  }
  function h(u) {
    if (!u)
      return e.BLANK_URL;
    var f = l(u).replace(r, "").replace(i, "").trim();
    if (!f)
      return e.BLANK_URL;
    if (a(f))
      return f;
    var d = f.match(s);
    if (!d)
      return f;
    var p = d[0];
    return t.test(p) ? e.BLANK_URL : f;
  }
  e.sanitizeUrl = h;
})(Oa);
function H1(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function xZt(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function N3(e) {
  let t, n, r;
  e.length !== 2 ? (t = H1, n = (a, l) => H1(e(a), l), r = (a, l) => e(a) - l) : (t = e === H1 || e === xZt ? e : vZt, n = e, r = e);
  function i(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0)
        return u;
      do {
        const f = h + u >>> 1;
        n(a[f], l) < 0 ? h = f + 1 : u = f;
      } while (h < u);
    }
    return h;
  }
  function s(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0)
        return u;
      do {
        const f = h + u >>> 1;
        n(a[f], l) <= 0 ? h = f + 1 : u = f;
      } while (h < u);
    }
    return h;
  }
  function o(a, l, h = 0, u = a.length) {
    const f = i(a, l, h, u - 1);
    return f > h && r(a[f - 1], l) > -r(a[f], l) ? f - 1 : f;
  }
  return { left: i, center: o, right: s };
}
function vZt() {
  return 0;
}
function _Zt(e) {
  return e === null ? NaN : +e;
}
const kZt = N3(H1), wZt = kZt.right;
N3(_Zt).center;
const SZt = wZt;
class EE extends Map {
  constructor(t, n = EZt) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, i] of t)
        this.set(r, i);
  }
  get(t) {
    return super.get(AE(this, t));
  }
  has(t) {
    return super.has(AE(this, t));
  }
  set(t, n) {
    return super.set(CZt(this, t), n);
  }
  delete(t) {
    return super.delete(TZt(this, t));
  }
}
function AE({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function CZt({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function TZt({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function EZt(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const AZt = Math.sqrt(50), PZt = Math.sqrt(10), DZt = Math.sqrt(2);
function km(e, t, n) {
  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), s = r / Math.pow(10, i), o = s >= AZt ? 10 : s >= PZt ? 5 : s >= DZt ? 2 : 1;
  let a, l, h;
  return i < 0 ? (h = Math.pow(10, -i) / o, a = Math.round(e * h), l = Math.round(t * h), a / h < e && ++a, l / h > t && --l, h = -h) : (h = Math.pow(10, i) * o, a = Math.round(e / h), l = Math.round(t / h), a * h < e && ++a, l * h > t && --l), l < a && 0.5 <= n && n < 2 ? km(e, t, n * 2) : [a, l, h];
}
function LZt(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0))
    return [];
  if (e === t)
    return [e];
  const r = t < e, [i, s, o] = r ? km(t, e, n) : km(e, t, n);
  if (!(s >= i))
    return [];
  const a = s - i + 1, l = new Array(a);
  if (r)
    if (o < 0)
      for (let h = 0; h < a; ++h)
        l[h] = (s - h) / -o;
    else
      for (let h = 0; h < a; ++h)
        l[h] = (s - h) * o;
  else if (o < 0)
    for (let h = 0; h < a; ++h)
      l[h] = (i + h) / -o;
  else
    for (let h = 0; h < a; ++h)
      l[h] = (i + h) * o;
  return l;
}
function S_(e, t, n) {
  return t = +t, e = +e, n = +n, km(e, t, n)[2];
}
function C_(e, t, n) {
  t = +t, e = +e, n = +n;
  const r = t < e, i = r ? S_(t, e, n) : S_(e, t, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function MZt(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function RZt(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function $Zt(e) {
  return e;
}
var K1 = 1, IO = 2, T_ = 3, s1 = 4, PE = 1e-6;
function IZt(e) {
  return "translate(" + e + ",0)";
}
function NZt(e) {
  return "translate(0," + e + ")";
}
function BZt(e) {
  return (t) => +e(t);
}
function FZt(e, t) {
  return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;
}
function QZt() {
  return !this.__axis;
}
function CI(e, t) {
  var n = [], r = null, i = null, s = 6, o = 6, a = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, h = e === K1 || e === s1 ? -1 : 1, u = e === s1 || e === IO ? "x" : "y", f = e === K1 || e === T_ ? IZt : NZt;
  function d(p) {
    var g = r == null ? t.ticks ? t.ticks.apply(t, n) : t.domain() : r, m = i == null ? t.tickFormat ? t.tickFormat.apply(t, n) : $Zt : i, y = Math.max(s, 0) + a, O = t.range(), x = +O[0] + l, _ = +O[O.length - 1] + l, w = (t.bandwidth ? FZt : BZt)(t.copy(), l), E = p.selection ? p.selection() : p, T = E.selectAll(".domain").data([null]), S = E.selectAll(".tick").data(g, t).order(), R = S.exit(), A = S.enter().append("g").attr("class", "tick"), P = S.select("line"), C = S.select("text");
    T = T.merge(T.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), S = S.merge(A), P = P.merge(A.append("line").attr("stroke", "currentColor").attr(u + "2", h * s)), C = C.merge(A.append("text").attr("fill", "currentColor").attr(u, h * y).attr("dy", e === K1 ? "0em" : e === T_ ? "0.71em" : "0.32em")), p !== E && (T = T.transition(p), S = S.transition(p), P = P.transition(p), C = C.transition(p), R = R.transition(p).attr("opacity", PE).attr("transform", function(k) {
      return isFinite(k = w(k)) ? f(k + l) : this.getAttribute("transform");
    }), A.attr("opacity", PE).attr("transform", function(k) {
      var D = this.parentNode.__axis;
      return f((D && isFinite(D = D(k)) ? D : w(k)) + l);
    })), R.remove(), T.attr("d", e === s1 || e === IO ? o ? "M" + h * o + "," + x + "H" + l + "V" + _ + "H" + h * o : "M" + l + "," + x + "V" + _ : o ? "M" + x + "," + h * o + "V" + l + "H" + _ + "V" + h * o : "M" + x + "," + l + "H" + _), S.attr("opacity", 1).attr("transform", function(k) {
      return f(w(k) + l);
    }), P.attr(u + "2", h * s), C.attr(u, h * y).text(m), E.filter(QZt).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === IO ? "start" : e === s1 ? "end" : "middle"), E.each(function() {
      this.__axis = w;
    });
  }
  return d.scale = function(p) {
    return arguments.length ? (t = p, d) : t;
  }, d.ticks = function() {
    return n = Array.from(arguments), d;
  }, d.tickArguments = function(p) {
    return arguments.length ? (n = p == null ? [] : Array.from(p), d) : n.slice();
  }, d.tickValues = function(p) {
    return arguments.length ? (r = p == null ? null : Array.from(p), d) : r && r.slice();
  }, d.tickFormat = function(p) {
    return arguments.length ? (i = p, d) : i;
  }, d.tickSize = function(p) {
    return arguments.length ? (s = o = +p, d) : s;
  }, d.tickSizeInner = function(p) {
    return arguments.length ? (s = +p, d) : s;
  }, d.tickSizeOuter = function(p) {
    return arguments.length ? (o = +p, d) : o;
  }, d.tickPadding = function(p) {
    return arguments.length ? (a = +p, d) : a;
  }, d.offset = function(p) {
    return arguments.length ? (l = +p, d) : l;
  }, d;
}
function ZZt(e) {
  return CI(K1, e);
}
function VZt(e) {
  return CI(T_, e);
}
var YZt = { value: () => {
} };
function TI() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new J1(n);
}
function J1(e) {
  this._ = e;
}
function zZt(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
J1.prototype = TI.prototype = {
  constructor: J1,
  on: function(e, t) {
    var n = this._, r = zZt(e + "", n), i, s = -1, o = r.length;
    if (arguments.length < 2) {
      for (; ++s < o; )
        if ((i = (e = r[s]).type) && (i = qZt(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < o; )
      if (i = (e = r[s]).type)
        n[i] = DE(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = DE(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new J1(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, s; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, i = s.length; r < i; ++r)
      s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, s = r.length; i < s; ++i)
      r[i].value.apply(t, n);
  }
};
function qZt(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function DE(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = YZt, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var E_ = "http://www.w3.org/1999/xhtml";
const LE = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: E_,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function by(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), LE.hasOwnProperty(t) ? { space: LE[t], local: e } : e;
}
function WZt(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === E_ && t.documentElement.namespaceURI === E_ ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function UZt(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function EI(e) {
  var t = by(e);
  return (t.local ? UZt : WZt)(t);
}
function jZt() {
}
function B3(e) {
  return e == null ? jZt : function() {
    return this.querySelector(e);
  };
}
function XZt(e) {
  typeof e != "function" && (e = B3(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], o = s.length, a = r[i] = new Array(o), l, h, u = 0; u < o; ++u)
      (l = s[u]) && (h = e.call(l, l.__data__, u, s)) && ("__data__" in l && (h.__data__ = l.__data__), a[u] = h);
  return new zr(r, this._parents);
}
function AI(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function GZt() {
  return [];
}
function PI(e) {
  return e == null ? GZt : function() {
    return this.querySelectorAll(e);
  };
}
function HZt(e) {
  return function() {
    return AI(e.apply(this, arguments));
  };
}
function KZt(e) {
  typeof e == "function" ? e = HZt(e) : e = PI(e);
  for (var t = this._groups, n = t.length, r = [], i = [], s = 0; s < n; ++s)
    for (var o = t[s], a = o.length, l, h = 0; h < a; ++h)
      (l = o[h]) && (r.push(e.call(l, l.__data__, h, o)), i.push(l));
  return new zr(r, i);
}
function DI(e) {
  return function() {
    return this.matches(e);
  };
}
function LI(e) {
  return function(t) {
    return t.matches(e);
  };
}
var JZt = Array.prototype.find;
function tVt(e) {
  return function() {
    return JZt.call(this.children, e);
  };
}
function eVt() {
  return this.firstElementChild;
}
function nVt(e) {
  return this.select(e == null ? eVt : tVt(typeof e == "function" ? e : LI(e)));
}
var rVt = Array.prototype.filter;
function iVt() {
  return Array.from(this.children);
}
function sVt(e) {
  return function() {
    return rVt.call(this.children, e);
  };
}
function oVt(e) {
  return this.selectAll(e == null ? iVt : sVt(typeof e == "function" ? e : LI(e)));
}
function aVt(e) {
  typeof e != "function" && (e = DI(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], o = s.length, a = r[i] = [], l, h = 0; h < o; ++h)
      (l = s[h]) && e.call(l, l.__data__, h, s) && a.push(l);
  return new zr(r, this._parents);
}
function MI(e) {
  return new Array(e.length);
}
function lVt() {
  return new zr(this._enter || this._groups.map(MI), this._parents);
}
function wm(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
wm.prototype = {
  constructor: wm,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function cVt(e) {
  return function() {
    return e;
  };
}
function hVt(e, t, n, r, i, s) {
  for (var o = 0, a, l = t.length, h = s.length; o < h; ++o)
    (a = t[o]) ? (a.__data__ = s[o], r[o] = a) : n[o] = new wm(e, s[o]);
  for (; o < l; ++o)
    (a = t[o]) && (i[o] = a);
}
function uVt(e, t, n, r, i, s, o) {
  var a, l, h = /* @__PURE__ */ new Map(), u = t.length, f = s.length, d = new Array(u), p;
  for (a = 0; a < u; ++a)
    (l = t[a]) && (d[a] = p = o.call(l, l.__data__, a, t) + "", h.has(p) ? i[a] = l : h.set(p, l));
  for (a = 0; a < f; ++a)
    p = o.call(e, s[a], a, s) + "", (l = h.get(p)) ? (r[a] = l, l.__data__ = s[a], h.delete(p)) : n[a] = new wm(e, s[a]);
  for (a = 0; a < u; ++a)
    (l = t[a]) && h.get(d[a]) === l && (i[a] = l);
}
function fVt(e) {
  return e.__data__;
}
function dVt(e, t) {
  if (!arguments.length)
    return Array.from(this, fVt);
  var n = t ? uVt : hVt, r = this._parents, i = this._groups;
  typeof e != "function" && (e = cVt(e));
  for (var s = i.length, o = new Array(s), a = new Array(s), l = new Array(s), h = 0; h < s; ++h) {
    var u = r[h], f = i[h], d = f.length, p = pVt(e.call(u, u && u.__data__, h, r)), g = p.length, m = a[h] = new Array(g), y = o[h] = new Array(g), O = l[h] = new Array(d);
    n(u, f, m, y, O, p, t);
    for (var x = 0, _ = 0, w, E; x < g; ++x)
      if (w = m[x]) {
        for (x >= _ && (_ = x + 1); !(E = y[_]) && ++_ < g; )
          ;
        w._next = E || null;
      }
  }
  return o = new zr(o, r), o._enter = a, o._exit = l, o;
}
function pVt(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function gVt() {
  return new zr(this._exit || this._groups.map(MI), this._parents);
}
function mVt(e, t, n) {
  var r = this.enter(), i = this, s = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? s.remove() : n(s), r && i ? r.merge(i).order() : i;
}
function yVt(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, s = r.length, o = Math.min(i, s), a = new Array(i), l = 0; l < o; ++l)
    for (var h = n[l], u = r[l], f = h.length, d = a[l] = new Array(f), p, g = 0; g < f; ++g)
      (p = h[g] || u[g]) && (d[g] = p);
  for (; l < i; ++l)
    a[l] = n[l];
  return new zr(a, this._parents);
}
function bVt() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, s = r[i], o; --i >= 0; )
      (o = r[i]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function OVt(e) {
  e || (e = xVt);
  function t(f, d) {
    return f && d ? e(f.__data__, d.__data__) : !f - !d;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), s = 0; s < r; ++s) {
    for (var o = n[s], a = o.length, l = i[s] = new Array(a), h, u = 0; u < a; ++u)
      (h = o[u]) && (l[u] = h);
    l.sort(t);
  }
  return new zr(i, this._parents).order();
}
function xVt(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function vVt() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function _Vt() {
  return Array.from(this);
}
function kVt() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length; i < s; ++i) {
      var o = r[i];
      if (o)
        return o;
    }
  return null;
}
function wVt() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function SVt() {
  return !this.node();
}
function CVt(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], s = 0, o = i.length, a; s < o; ++s)
      (a = i[s]) && e.call(a, a.__data__, s, i);
  return this;
}
function TVt(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function EVt(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function AVt(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function PVt(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function DVt(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function LVt(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function MVt(e, t) {
  var n = by(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? EVt : TVt : typeof t == "function" ? n.local ? LVt : DVt : n.local ? PVt : AVt)(n, t));
}
function RI(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function RVt(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function $Vt(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function IVt(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function NVt(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? RVt : typeof t == "function" ? IVt : $Vt)(e, t, n == null ? "" : n)) : nu(this.node(), e);
}
function nu(e, t) {
  return e.style.getPropertyValue(t) || RI(e).getComputedStyle(e, null).getPropertyValue(t);
}
function BVt(e) {
  return function() {
    delete this[e];
  };
}
function FVt(e, t) {
  return function() {
    this[e] = t;
  };
}
function QVt(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function ZVt(e, t) {
  return arguments.length > 1 ? this.each((t == null ? BVt : typeof t == "function" ? QVt : FVt)(e, t)) : this.node()[e];
}
function $I(e) {
  return e.trim().split(/^|\s+/);
}
function F3(e) {
  return e.classList || new II(e);
}
function II(e) {
  this._node = e, this._names = $I(e.getAttribute("class") || "");
}
II.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function NI(e, t) {
  for (var n = F3(e), r = -1, i = t.length; ++r < i; )
    n.add(t[r]);
}
function BI(e, t) {
  for (var n = F3(e), r = -1, i = t.length; ++r < i; )
    n.remove(t[r]);
}
function VVt(e) {
  return function() {
    NI(this, e);
  };
}
function YVt(e) {
  return function() {
    BI(this, e);
  };
}
function zVt(e, t) {
  return function() {
    (t.apply(this, arguments) ? NI : BI)(this, e);
  };
}
function qVt(e, t) {
  var n = $I(e + "");
  if (arguments.length < 2) {
    for (var r = F3(this.node()), i = -1, s = n.length; ++i < s; )
      if (!r.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? zVt : t ? VVt : YVt)(n, t));
}
function WVt() {
  this.textContent = "";
}
function UVt(e) {
  return function() {
    this.textContent = e;
  };
}
function jVt(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t == null ? "" : t;
  };
}
function XVt(e) {
  return arguments.length ? this.each(e == null ? WVt : (typeof e == "function" ? jVt : UVt)(e)) : this.node().textContent;
}
function GVt() {
  this.innerHTML = "";
}
function HVt(e) {
  return function() {
    this.innerHTML = e;
  };
}
function KVt(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t == null ? "" : t;
  };
}
function JVt(e) {
  return arguments.length ? this.each(e == null ? GVt : (typeof e == "function" ? KVt : HVt)(e)) : this.node().innerHTML;
}
function tYt() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function eYt() {
  return this.each(tYt);
}
function nYt() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function rYt() {
  return this.each(nYt);
}
function iYt(e) {
  var t = typeof e == "function" ? e : EI(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function sYt() {
  return null;
}
function oYt(e, t) {
  var n = typeof e == "function" ? e : EI(e), r = t == null ? sYt : typeof t == "function" ? t : B3(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function aYt() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function lYt() {
  return this.each(aYt);
}
function cYt() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function hYt() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function uYt(e) {
  return this.select(e ? hYt : cYt);
}
function fYt(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function dYt(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function pYt(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function gYt(e) {
  return function() {
    var t = this.__on;
    if (!!t) {
      for (var n = 0, r = -1, i = t.length, s; n < i; ++n)
        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function mYt(e, t, n) {
  return function() {
    var r = this.__on, i, s = dYt(t);
    if (r) {
      for (var o = 0, a = r.length; o < a; ++o)
        if ((i = r[o]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, n), i = { type: e.type, name: e.name, value: t, listener: s, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function yYt(e, t, n) {
  var r = pYt(e + ""), i, s = r.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, h = a.length, u; l < h; ++l)
        for (i = 0, u = a[l]; i < s; ++i)
          if ((o = r[i]).type === u.type && o.name === u.name)
            return u.value;
    }
    return;
  }
  for (a = t ? mYt : gYt, i = 0; i < s; ++i)
    this.each(a(r[i], t, n));
  return this;
}
function FI(e, t, n) {
  var r = RI(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function bYt(e, t) {
  return function() {
    return FI(this, e, t);
  };
}
function OYt(e, t) {
  return function() {
    return FI(this, e, t.apply(this, arguments));
  };
}
function xYt(e, t) {
  return this.each((typeof t == "function" ? OYt : bYt)(e, t));
}
function* vYt() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length, o; i < s; ++i)
      (o = r[i]) && (yield o);
}
var Q3 = [null];
function zr(e, t) {
  this._groups = e, this._parents = t;
}
function Hp() {
  return new zr([[document.documentElement]], Q3);
}
function _Yt() {
  return this;
}
zr.prototype = Hp.prototype = {
  constructor: zr,
  select: XZt,
  selectAll: KZt,
  selectChild: nVt,
  selectChildren: oVt,
  filter: aVt,
  data: dVt,
  enter: lVt,
  exit: gVt,
  join: mVt,
  merge: yVt,
  selection: _Yt,
  order: bVt,
  sort: OVt,
  call: vVt,
  nodes: _Vt,
  node: kVt,
  size: wVt,
  empty: SVt,
  each: CVt,
  attr: MVt,
  style: NVt,
  property: ZVt,
  classed: qVt,
  text: XVt,
  html: JVt,
  raise: eYt,
  lower: rYt,
  append: iYt,
  insert: oYt,
  remove: lYt,
  clone: uYt,
  datum: fYt,
  on: yYt,
  dispatch: xYt,
  [Symbol.iterator]: vYt
};
function wt(e) {
  return typeof e == "string" ? new zr([[document.querySelector(e)]], [document.documentElement]) : new zr([[e]], Q3);
}
function Z3(e) {
  return typeof e == "string" ? new zr([document.querySelectorAll(e)], [document.documentElement]) : new zr([AI(e)], Q3);
}
function Kp(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Oy(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t)
    n[r] = t[r];
  return n;
}
function Ec() {
}
var tp = 0.7, Sm = 1 / tp, kh = "\\s*([+-]?\\d+)\\s*", ep = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ho = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", kYt = /^#([0-9a-f]{3,8})$/, wYt = new RegExp(`^rgb\\(${kh},${kh},${kh}\\)$`), SYt = new RegExp(`^rgb\\(${ho},${ho},${ho}\\)$`), CYt = new RegExp(`^rgba\\(${kh},${kh},${kh},${ep}\\)$`), TYt = new RegExp(`^rgba\\(${ho},${ho},${ho},${ep}\\)$`), EYt = new RegExp(`^hsl\\(${ep},${ho},${ho}\\)$`), AYt = new RegExp(`^hsla\\(${ep},${ho},${ho},${ep}\\)$`), ME = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Kp(Ec, fc, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: RE,
  formatHex: RE,
  formatHex8: PYt,
  formatHsl: DYt,
  formatRgb: $E,
  toString: $E
});
function RE() {
  return this.rgb().formatHex();
}
function PYt() {
  return this.rgb().formatHex8();
}
function DYt() {
  return ZI(this).formatHsl();
}
function $E() {
  return this.rgb().formatRgb();
}
function fc(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = kYt.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? IE(t) : n === 3 ? new Er(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? o1(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? o1(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = wYt.exec(e)) ? new Er(t[1], t[2], t[3], 1) : (t = SYt.exec(e)) ? new Er(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = CYt.exec(e)) ? o1(t[1], t[2], t[3], t[4]) : (t = TYt.exec(e)) ? o1(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = EYt.exec(e)) ? FE(t[1], t[2] / 100, t[3] / 100, 1) : (t = AYt.exec(e)) ? FE(t[1], t[2] / 100, t[3] / 100, t[4]) : ME.hasOwnProperty(e) ? IE(ME[e]) : e === "transparent" ? new Er(NaN, NaN, NaN, 0) : null;
}
function IE(e) {
  return new Er(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function o1(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Er(e, t, n, r);
}
function QI(e) {
  return e instanceof Ec || (e = fc(e)), e ? (e = e.rgb(), new Er(e.r, e.g, e.b, e.opacity)) : new Er();
}
function A_(e, t, n, r) {
  return arguments.length === 1 ? QI(e) : new Er(e, t, n, r == null ? 1 : r);
}
function Er(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
Kp(Er, A_, Oy(Ec, {
  brighter(e) {
    return e = e == null ? Sm : Math.pow(Sm, e), new Er(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? tp : Math.pow(tp, e), new Er(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Er(Hl(this.r), Hl(this.g), Hl(this.b), Cm(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: NE,
  formatHex: NE,
  formatHex8: LYt,
  formatRgb: BE,
  toString: BE
}));
function NE() {
  return `#${zl(this.r)}${zl(this.g)}${zl(this.b)}`;
}
function LYt() {
  return `#${zl(this.r)}${zl(this.g)}${zl(this.b)}${zl((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function BE() {
  const e = Cm(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Hl(this.r)}, ${Hl(this.g)}, ${Hl(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Cm(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Hl(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function zl(e) {
  return e = Hl(e), (e < 16 ? "0" : "") + e.toString(16);
}
function FE(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new as(e, t, n, r);
}
function ZI(e) {
  if (e instanceof as)
    return new as(e.h, e.s, e.l, e.opacity);
  if (e instanceof Ec || (e = fc(e)), !e)
    return new as();
  if (e instanceof as)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), s = Math.max(t, n, r), o = NaN, a = s - i, l = (s + i) / 2;
  return a ? (t === s ? o = (n - r) / a + (n < r) * 6 : n === s ? o = (r - t) / a + 2 : o = (t - n) / a + 4, a /= l < 0.5 ? s + i : 2 - s - i, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new as(o, a, l, e.opacity);
}
function MYt(e, t, n, r) {
  return arguments.length === 1 ? ZI(e) : new as(e, t, n, r == null ? 1 : r);
}
function as(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
Kp(as, MYt, Oy(Ec, {
  brighter(e) {
    return e = e == null ? Sm : Math.pow(Sm, e), new as(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? tp : Math.pow(tp, e), new as(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new Er(
      NO(e >= 240 ? e - 240 : e + 120, i, r),
      NO(e, i, r),
      NO(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new as(QE(this.h), a1(this.s), a1(this.l), Cm(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Cm(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${QE(this.h)}, ${a1(this.s) * 100}%, ${a1(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function QE(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function a1(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function NO(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const RYt = Math.PI / 180, $Yt = 180 / Math.PI, Tm = 18, VI = 0.96422, YI = 1, zI = 0.82521, qI = 4 / 29, wh = 6 / 29, WI = 3 * wh * wh, IYt = wh * wh * wh;
function UI(e) {
  if (e instanceof uo)
    return new uo(e.l, e.a, e.b, e.opacity);
  if (e instanceof zo)
    return jI(e);
  e instanceof Er || (e = QI(e));
  var t = ZO(e.r), n = ZO(e.g), r = ZO(e.b), i = BO((0.2225045 * t + 0.7168786 * n + 0.0606169 * r) / YI), s, o;
  return t === n && n === r ? s = o = i : (s = BO((0.4360747 * t + 0.3850649 * n + 0.1430804 * r) / VI), o = BO((0.0139322 * t + 0.0971045 * n + 0.7141733 * r) / zI)), new uo(116 * i - 16, 500 * (s - i), 200 * (i - o), e.opacity);
}
function NYt(e, t, n, r) {
  return arguments.length === 1 ? UI(e) : new uo(e, t, n, r == null ? 1 : r);
}
function uo(e, t, n, r) {
  this.l = +e, this.a = +t, this.b = +n, this.opacity = +r;
}
Kp(uo, NYt, Oy(Ec, {
  brighter(e) {
    return new uo(this.l + Tm * (e == null ? 1 : e), this.a, this.b, this.opacity);
  },
  darker(e) {
    return new uo(this.l - Tm * (e == null ? 1 : e), this.a, this.b, this.opacity);
  },
  rgb() {
    var e = (this.l + 16) / 116, t = isNaN(this.a) ? e : e + this.a / 500, n = isNaN(this.b) ? e : e - this.b / 200;
    return t = VI * FO(t), e = YI * FO(e), n = zI * FO(n), new Er(
      QO(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
      QO(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
      QO(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
      this.opacity
    );
  }
}));
function BO(e) {
  return e > IYt ? Math.pow(e, 1 / 3) : e / WI + qI;
}
function FO(e) {
  return e > wh ? e * e * e : WI * (e - qI);
}
function QO(e) {
  return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
}
function ZO(e) {
  return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
}
function BYt(e) {
  if (e instanceof zo)
    return new zo(e.h, e.c, e.l, e.opacity);
  if (e instanceof uo || (e = UI(e)), e.a === 0 && e.b === 0)
    return new zo(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
  var t = Math.atan2(e.b, e.a) * $Yt;
  return new zo(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
}
function P_(e, t, n, r) {
  return arguments.length === 1 ? BYt(e) : new zo(e, t, n, r == null ? 1 : r);
}
function zo(e, t, n, r) {
  this.h = +e, this.c = +t, this.l = +n, this.opacity = +r;
}
function jI(e) {
  if (isNaN(e.h))
    return new uo(e.l, 0, 0, e.opacity);
  var t = e.h * RYt;
  return new uo(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
}
Kp(zo, P_, Oy(Ec, {
  brighter(e) {
    return new zo(this.h, this.c, this.l + Tm * (e == null ? 1 : e), this.opacity);
  },
  darker(e) {
    return new zo(this.h, this.c, this.l - Tm * (e == null ? 1 : e), this.opacity);
  },
  rgb() {
    return jI(this).rgb();
  }
}));
const xy = (e) => () => e;
function XI(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function FYt(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function QYt(e, t) {
  var n = t - e;
  return n ? XI(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : xy(isNaN(e) ? t : e);
}
function ZYt(e) {
  return (e = +e) == 1 ? Kf : function(t, n) {
    return n - t ? FYt(t, n, e) : xy(isNaN(t) ? n : t);
  };
}
function Kf(e, t) {
  var n = t - e;
  return n ? XI(e, n) : xy(isNaN(e) ? t : e);
}
const Em = function e(t) {
  var n = ZYt(t);
  function r(i, s) {
    var o = n((i = A_(i)).r, (s = A_(s)).r), a = n(i.g, s.g), l = n(i.b, s.b), h = Kf(i.opacity, s.opacity);
    return function(u) {
      return i.r = o(u), i.g = a(u), i.b = l(u), i.opacity = h(u), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function VYt(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(s) {
    for (i = 0; i < n; ++i)
      r[i] = e[i] * (1 - s) + t[i] * s;
    return r;
  };
}
function YYt(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function zYt(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), s = new Array(n), o;
  for (o = 0; o < r; ++o)
    i[o] = V3(e[o], t[o]);
  for (; o < n; ++o)
    s[o] = t[o];
  return function(a) {
    for (o = 0; o < r; ++o)
      s[o] = i[o](a);
    return s;
  };
}
function qYt(e, t) {
  var n = new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function os(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function WYt(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = V3(e[i], t[i]) : r[i] = t[i];
  return function(s) {
    for (i in n)
      r[i] = n[i](s);
    return r;
  };
}
var D_ = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, VO = new RegExp(D_.source, "g");
function UYt(e) {
  return function() {
    return e;
  };
}
function jYt(e) {
  return function(t) {
    return e(t) + "";
  };
}
function GI(e, t) {
  var n = D_.lastIndex = VO.lastIndex = 0, r, i, s, o = -1, a = [], l = [];
  for (e = e + "", t = t + ""; (r = D_.exec(e)) && (i = VO.exec(t)); )
    (s = i.index) > n && (s = t.slice(n, s), a[o] ? a[o] += s : a[++o] = s), (r = r[0]) === (i = i[0]) ? a[o] ? a[o] += i : a[++o] = i : (a[++o] = null, l.push({ i: o, x: os(r, i) })), n = VO.lastIndex;
  return n < t.length && (s = t.slice(n), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? jYt(l[0].x) : UYt(t) : (t = l.length, function(h) {
    for (var u = 0, f; u < t; ++u)
      a[(f = l[u]).i] = f.x(h);
    return a.join("");
  });
}
function V3(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? xy(t) : (n === "number" ? os : n === "string" ? (r = fc(t)) ? (t = r, Em) : GI : t instanceof fc ? Em : t instanceof Date ? qYt : YYt(t) ? VYt : Array.isArray(t) ? zYt : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? WYt : os)(e, t);
}
function XYt(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var ZE = 180 / Math.PI, L_ = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function HI(e, t, n, r, i, s) {
  var o, a, l;
  return (o = Math.sqrt(e * e + t * t)) && (e /= o, t /= o), (l = e * n + t * r) && (n -= e * l, r -= t * l), (a = Math.sqrt(n * n + r * r)) && (n /= a, r /= a, l /= a), e * r < t * n && (e = -e, t = -t, l = -l, o = -o), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(t, e) * ZE,
    skewX: Math.atan(l) * ZE,
    scaleX: o,
    scaleY: a
  };
}
var l1;
function GYt(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? L_ : HI(t.a, t.b, t.c, t.d, t.e, t.f);
}
function HYt(e) {
  return e == null || (l1 || (l1 = document.createElementNS("http://www.w3.org/2000/svg", "g")), l1.setAttribute("transform", e), !(e = l1.transform.baseVal.consolidate())) ? L_ : (e = e.matrix, HI(e.a, e.b, e.c, e.d, e.e, e.f));
}
function KI(e, t, n, r) {
  function i(h) {
    return h.length ? h.pop() + " " : "";
  }
  function s(h, u, f, d, p, g) {
    if (h !== f || u !== d) {
      var m = p.push("translate(", null, t, null, n);
      g.push({ i: m - 4, x: os(h, f) }, { i: m - 2, x: os(u, d) });
    } else
      (f || d) && p.push("translate(" + f + t + d + n);
  }
  function o(h, u, f, d) {
    h !== u ? (h - u > 180 ? u += 360 : u - h > 180 && (h += 360), d.push({ i: f.push(i(f) + "rotate(", null, r) - 2, x: os(h, u) })) : u && f.push(i(f) + "rotate(" + u + r);
  }
  function a(h, u, f, d) {
    h !== u ? d.push({ i: f.push(i(f) + "skewX(", null, r) - 2, x: os(h, u) }) : u && f.push(i(f) + "skewX(" + u + r);
  }
  function l(h, u, f, d, p, g) {
    if (h !== f || u !== d) {
      var m = p.push(i(p) + "scale(", null, ",", null, ")");
      g.push({ i: m - 4, x: os(h, f) }, { i: m - 2, x: os(u, d) });
    } else
      (f !== 1 || d !== 1) && p.push(i(p) + "scale(" + f + "," + d + ")");
  }
  return function(h, u) {
    var f = [], d = [];
    return h = e(h), u = e(u), s(h.translateX, h.translateY, u.translateX, u.translateY, f, d), o(h.rotate, u.rotate, f, d), a(h.skewX, u.skewX, f, d), l(h.scaleX, h.scaleY, u.scaleX, u.scaleY, f, d), h = u = null, function(p) {
      for (var g = -1, m = d.length, y; ++g < m; )
        f[(y = d[g]).i] = y.x(p);
      return f.join("");
    };
  };
}
var KYt = KI(GYt, "px, ", "px)", "deg)"), JYt = KI(HYt, ", ", ")", ")");
function tzt(e) {
  return function(t, n) {
    var r = e((t = P_(t)).h, (n = P_(n)).h), i = Kf(t.c, n.c), s = Kf(t.l, n.l), o = Kf(t.opacity, n.opacity);
    return function(a) {
      return t.h = r(a), t.c = i(a), t.l = s(a), t.opacity = o(a), t + "";
    };
  };
}
const ezt = tzt(QYt);
var ru = 0, Lf = 0, cf = 0, JI = 1e3, Am, Mf, Pm = 0, dc = 0, vy = 0, np = typeof performance == "object" && performance.now ? performance : Date, tN = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Y3() {
  return dc || (tN(nzt), dc = np.now() + vy);
}
function nzt() {
  dc = 0;
}
function Dm() {
  this._call = this._time = this._next = null;
}
Dm.prototype = eN.prototype = {
  constructor: Dm,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? Y3() : +n) + (t == null ? 0 : +t), !this._next && Mf !== this && (Mf ? Mf._next = this : Am = this, Mf = this), this._call = e, this._time = n, M_();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, M_());
  }
};
function eN(e, t, n) {
  var r = new Dm();
  return r.restart(e, t, n), r;
}
function rzt() {
  Y3(), ++ru;
  for (var e = Am, t; e; )
    (t = dc - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --ru;
}
function VE() {
  dc = (Pm = np.now()) + vy, ru = Lf = 0;
  try {
    rzt();
  } finally {
    ru = 0, szt(), dc = 0;
  }
}
function izt() {
  var e = np.now(), t = e - Pm;
  t > JI && (vy -= t, Pm = e);
}
function szt() {
  for (var e, t = Am, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Am = n);
  Mf = e, M_(r);
}
function M_(e) {
  if (!ru) {
    Lf && (Lf = clearTimeout(Lf));
    var t = e - dc;
    t > 24 ? (e < 1 / 0 && (Lf = setTimeout(VE, e - np.now() - vy)), cf && (cf = clearInterval(cf))) : (cf || (Pm = np.now(), cf = setInterval(izt, JI)), ru = 1, tN(VE));
  }
}
function YE(e, t, n) {
  var r = new Dm();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
var ozt = TI("start", "end", "cancel", "interrupt"), azt = [], nN = 0, zE = 1, R_ = 2, tg = 3, qE = 4, $_ = 5, eg = 6;
function _y(e, t, n, r, i, s) {
  var o = e.__transition;
  if (!o)
    e.__transition = {};
  else if (n in o)
    return;
  lzt(e, n, {
    name: t,
    index: r,
    group: i,
    on: ozt,
    tween: azt,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: nN
  });
}
function z3(e, t) {
  var n = Ms(e, t);
  if (n.state > nN)
    throw new Error("too late; already scheduled");
  return n;
}
function So(e, t) {
  var n = Ms(e, t);
  if (n.state > tg)
    throw new Error("too late; already running");
  return n;
}
function Ms(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function lzt(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = eN(s, 0, n.time);
  function s(h) {
    n.state = zE, n.timer.restart(o, n.delay, n.time), n.delay <= h && o(h - n.delay);
  }
  function o(h) {
    var u, f, d, p;
    if (n.state !== zE)
      return l();
    for (u in r)
      if (p = r[u], p.name === n.name) {
        if (p.state === tg)
          return YE(o);
        p.state === qE ? (p.state = eg, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete r[u]) : +u < t && (p.state = eg, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete r[u]);
      }
    if (YE(function() {
      n.state === tg && (n.state = qE, n.timer.restart(a, n.delay, n.time), a(h));
    }), n.state = R_, n.on.call("start", e, e.__data__, n.index, n.group), n.state === R_) {
      for (n.state = tg, i = new Array(d = n.tween.length), u = 0, f = -1; u < d; ++u)
        (p = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (i[++f] = p);
      i.length = f + 1;
    }
  }
  function a(h) {
    for (var u = h < n.duration ? n.ease.call(null, h / n.duration) : (n.timer.restart(l), n.state = $_, 1), f = -1, d = i.length; ++f < d; )
      i[f].call(e, u);
    n.state === $_ && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = eg, n.timer.stop(), delete r[t];
    for (var h in r)
      return;
    delete e.__transition;
  }
}
function czt(e, t) {
  var n = e.__transition, r, i, s = !0, o;
  if (!!n) {
    t = t == null ? null : t + "";
    for (o in n) {
      if ((r = n[o]).name !== t) {
        s = !1;
        continue;
      }
      i = r.state > R_ && r.state < $_, r.state = eg, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[o];
    }
    s && delete e.__transition;
  }
}
function hzt(e) {
  return this.each(function() {
    czt(this, e);
  });
}
function uzt(e, t) {
  var n, r;
  return function() {
    var i = So(this, e), s = i.tween;
    if (s !== n) {
      r = n = s;
      for (var o = 0, a = r.length; o < a; ++o)
        if (r[o].name === t) {
          r = r.slice(), r.splice(o, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function fzt(e, t, n) {
  var r, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var s = So(this, e), o = s.tween;
    if (o !== r) {
      i = (r = o).slice();
      for (var a = { name: t, value: n }, l = 0, h = i.length; l < h; ++l)
        if (i[l].name === t) {
          i[l] = a;
          break;
        }
      l === h && i.push(a);
    }
    s.tween = i;
  };
}
function dzt(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Ms(this.node(), n).tween, i = 0, s = r.length, o; i < s; ++i)
      if ((o = r[i]).name === e)
        return o.value;
    return null;
  }
  return this.each((t == null ? uzt : fzt)(n, e, t));
}
function q3(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = So(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Ms(i, r).value[t];
  };
}
function rN(e, t) {
  var n;
  return (typeof t == "number" ? os : t instanceof fc ? Em : (n = fc(t)) ? (t = n, Em) : GI)(e, t);
}
function pzt(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function gzt(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function mzt(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var o = this.getAttribute(e);
    return o === i ? null : o === r ? s : s = t(r = o, n);
  };
}
function yzt(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var o = this.getAttributeNS(e.space, e.local);
    return o === i ? null : o === r ? s : s = t(r = o, n);
  };
}
function bzt(e, t, n) {
  var r, i, s;
  return function() {
    var o, a = n(this), l;
    return a == null ? void this.removeAttribute(e) : (o = this.getAttribute(e), l = a + "", o === l ? null : o === r && l === i ? s : (i = l, s = t(r = o, a)));
  };
}
function Ozt(e, t, n) {
  var r, i, s;
  return function() {
    var o, a = n(this), l;
    return a == null ? void this.removeAttributeNS(e.space, e.local) : (o = this.getAttributeNS(e.space, e.local), l = a + "", o === l ? null : o === r && l === i ? s : (i = l, s = t(r = o, a)));
  };
}
function xzt(e, t) {
  var n = by(e), r = n === "transform" ? JYt : rN;
  return this.attrTween(e, typeof t == "function" ? (n.local ? Ozt : bzt)(n, r, q3(this, "attr." + e, t)) : t == null ? (n.local ? gzt : pzt)(n) : (n.local ? yzt : mzt)(n, r, t));
}
function vzt(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function _zt(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function kzt(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && _zt(e, s)), n;
  }
  return i._value = t, i;
}
function wzt(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && vzt(e, s)), n;
  }
  return i._value = t, i;
}
function Szt(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var r = by(e);
  return this.tween(n, (r.local ? kzt : wzt)(r, t));
}
function Czt(e, t) {
  return function() {
    z3(this, e).delay = +t.apply(this, arguments);
  };
}
function Tzt(e, t) {
  return t = +t, function() {
    z3(this, e).delay = t;
  };
}
function Ezt(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Czt : Tzt)(t, e)) : Ms(this.node(), t).delay;
}
function Azt(e, t) {
  return function() {
    So(this, e).duration = +t.apply(this, arguments);
  };
}
function Pzt(e, t) {
  return t = +t, function() {
    So(this, e).duration = t;
  };
}
function Dzt(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Azt : Pzt)(t, e)) : Ms(this.node(), t).duration;
}
function Lzt(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    So(this, e).ease = t;
  };
}
function Mzt(e) {
  var t = this._id;
  return arguments.length ? this.each(Lzt(t, e)) : Ms(this.node(), t).ease;
}
function Rzt(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    So(this, e).ease = n;
  };
}
function $zt(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(Rzt(this._id, e));
}
function Izt(e) {
  typeof e != "function" && (e = DI(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], o = s.length, a = r[i] = [], l, h = 0; h < o; ++h)
      (l = s[h]) && e.call(l, l.__data__, h, s) && a.push(l);
  return new ua(r, this._parents, this._name, this._id);
}
function Nzt(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, s = Math.min(r, i), o = new Array(r), a = 0; a < s; ++a)
    for (var l = t[a], h = n[a], u = l.length, f = o[a] = new Array(u), d, p = 0; p < u; ++p)
      (d = l[p] || h[p]) && (f[p] = d);
  for (; a < r; ++a)
    o[a] = t[a];
  return new ua(o, this._parents, this._name, this._id);
}
function Bzt(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function Fzt(e, t, n) {
  var r, i, s = Bzt(t) ? z3 : So;
  return function() {
    var o = s(this, e), a = o.on;
    a !== r && (i = (r = a).copy()).on(t, n), o.on = i;
  };
}
function Qzt(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Ms(this.node(), n).on.on(e) : this.each(Fzt(n, e, t));
}
function Zzt(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function Vzt() {
  return this.on("end.remove", Zzt(this._id));
}
function Yzt(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = B3(e));
  for (var r = this._groups, i = r.length, s = new Array(i), o = 0; o < i; ++o)
    for (var a = r[o], l = a.length, h = s[o] = new Array(l), u, f, d = 0; d < l; ++d)
      (u = a[d]) && (f = e.call(u, u.__data__, d, a)) && ("__data__" in u && (f.__data__ = u.__data__), h[d] = f, _y(h[d], t, n, d, h, Ms(u, n)));
  return new ua(s, this._parents, t, n);
}
function zzt(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = PI(e));
  for (var r = this._groups, i = r.length, s = [], o = [], a = 0; a < i; ++a)
    for (var l = r[a], h = l.length, u, f = 0; f < h; ++f)
      if (u = l[f]) {
        for (var d = e.call(u, u.__data__, f, l), p, g = Ms(u, n), m = 0, y = d.length; m < y; ++m)
          (p = d[m]) && _y(p, t, n, m, d, g);
        s.push(d), o.push(u);
      }
  return new ua(s, o, t, n);
}
var qzt = Hp.prototype.constructor;
function Wzt() {
  return new qzt(this._groups, this._parents);
}
function Uzt(e, t) {
  var n, r, i;
  return function() {
    var s = nu(this, e), o = (this.style.removeProperty(e), nu(this, e));
    return s === o ? null : s === n && o === r ? i : i = t(n = s, r = o);
  };
}
function iN(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function jzt(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var o = nu(this, e);
    return o === i ? null : o === r ? s : s = t(r = o, n);
  };
}
function Xzt(e, t, n) {
  var r, i, s;
  return function() {
    var o = nu(this, e), a = n(this), l = a + "";
    return a == null && (l = a = (this.style.removeProperty(e), nu(this, e))), o === l ? null : o === r && l === i ? s : (i = l, s = t(r = o, a));
  };
}
function Gzt(e, t) {
  var n, r, i, s = "style." + t, o = "end." + s, a;
  return function() {
    var l = So(this, e), h = l.on, u = l.value[s] == null ? a || (a = iN(t)) : void 0;
    (h !== n || i !== u) && (r = (n = h).copy()).on(o, i = u), l.on = r;
  };
}
function Hzt(e, t, n) {
  var r = (e += "") == "transform" ? KYt : rN;
  return t == null ? this.styleTween(e, Uzt(e, r)).on("end.style." + e, iN(e)) : typeof t == "function" ? this.styleTween(e, Xzt(e, r, q3(this, "style." + e, t))).each(Gzt(this._id, e)) : this.styleTween(e, jzt(e, r, t), n).on("end.style." + e, null);
}
function Kzt(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function Jzt(e, t, n) {
  var r, i;
  function s() {
    var o = t.apply(this, arguments);
    return o !== i && (r = (i = o) && Kzt(e, o, n)), r;
  }
  return s._value = t, s;
}
function tqt(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(r, Jzt(e, t, n == null ? "" : n));
}
function eqt(e) {
  return function() {
    this.textContent = e;
  };
}
function nqt(e) {
  return function() {
    var t = e(this);
    this.textContent = t == null ? "" : t;
  };
}
function rqt(e) {
  return this.tween("text", typeof e == "function" ? nqt(q3(this, "text", e)) : eqt(e == null ? "" : e + ""));
}
function iqt(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function sqt(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && iqt(i)), t;
  }
  return r._value = e, r;
}
function oqt(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, sqt(e));
}
function aqt() {
  for (var e = this._name, t = this._id, n = sN(), r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var o = r[s], a = o.length, l, h = 0; h < a; ++h)
      if (l = o[h]) {
        var u = Ms(l, t);
        _y(l, e, n, h, o, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease
        });
      }
  return new ua(r, this._parents, e, n);
}
function lqt() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(s, o) {
    var a = { value: o }, l = { value: function() {
      --i === 0 && s();
    } };
    n.each(function() {
      var h = So(this, r), u = h.on;
      u !== e && (t = (e = u).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(l)), h.on = t;
    }), i === 0 && s();
  });
}
var cqt = 0;
function ua(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function sN() {
  return ++cqt;
}
var Po = Hp.prototype;
ua.prototype = {
  constructor: ua,
  select: Yzt,
  selectAll: zzt,
  selectChild: Po.selectChild,
  selectChildren: Po.selectChildren,
  filter: Izt,
  merge: Nzt,
  selection: Wzt,
  transition: aqt,
  call: Po.call,
  nodes: Po.nodes,
  node: Po.node,
  size: Po.size,
  empty: Po.empty,
  each: Po.each,
  on: Qzt,
  attr: xzt,
  attrTween: Szt,
  style: Hzt,
  styleTween: tqt,
  text: rqt,
  textTween: oqt,
  remove: Vzt,
  tween: dzt,
  delay: Ezt,
  duration: Dzt,
  ease: Mzt,
  easeVarying: $zt,
  end: lqt,
  [Symbol.iterator]: Po[Symbol.iterator]
};
function hqt(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var uqt = {
  time: null,
  delay: 0,
  duration: 250,
  ease: hqt
};
function fqt(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function dqt(e) {
  var t, n;
  e instanceof ua ? (t = e._id, e = e._name) : (t = sN(), (n = uqt).time = Y3(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var o = r[s], a = o.length, l, h = 0; h < a; ++h)
      (l = o[h]) && _y(l, e, t, h, o, n || fqt(l, t));
  return new ua(r, this._parents, e, t);
}
Hp.prototype.interrupt = hzt;
Hp.prototype.transition = dqt;
const I_ = Math.PI, N_ = 2 * I_, El = 1e-6, pqt = N_ - El;
function oN(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function gqt(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return oN;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, s = r.length; i < s; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
class mqt {
  constructor(t) {
    this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = t == null ? oN : gqt(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, s, o) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, n, r, i, s) {
    if (t = +t, n = +n, r = +r, i = +i, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = r - t, h = i - n, u = o - t, f = a - n, d = u * u + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (d > El)
      if (!(Math.abs(f * l - h * u) > El) || !s)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let p = r - o, g = i - a, m = l * l + h * h, y = p * p + g * g, O = Math.sqrt(m), x = Math.sqrt(d), _ = s * Math.tan((I_ - Math.acos((m + d - y) / (2 * O * x))) / 2), w = _ / x, E = _ / O;
        Math.abs(w - 1) > El && this._append`L${t + w * u},${n + w * f}`, this._append`A${s},${s},0,0,${+(f * p > u * g)},${this._x1 = t + E * l},${this._y1 = n + E * h}`;
      }
  }
  arc(t, n, r, i, s, o) {
    if (t = +t, n = +n, r = +r, o = !!o, r < 0)
      throw new Error(`negative radius: ${r}`);
    let a = r * Math.cos(i), l = r * Math.sin(i), h = t + a, u = n + l, f = 1 ^ o, d = o ? i - s : s - i;
    this._x1 === null ? this._append`M${h},${u}` : (Math.abs(this._x1 - h) > El || Math.abs(this._y1 - u) > El) && this._append`L${h},${u}`, r && (d < 0 && (d = d % N_ + N_), d > pqt ? this._append`A${r},${r},0,1,${f},${t - a},${n - l}A${r},${r},0,1,${f},${this._x1 = h},${this._y1 = u}` : d > El && this._append`A${r},${r},0,${+(d >= I_)},${f},${this._x1 = t + r * Math.cos(s)},${this._y1 = n + r * Math.sin(s)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
}
function yqt(e) {
  if (!e.ok)
    throw new Error(e.status + " " + e.statusText);
  return e.text();
}
function bqt(e, t) {
  return fetch(e, t).then(yqt);
}
function Oqt(e) {
  return (t, n) => bqt(t, n).then((r) => new DOMParser().parseFromString(r, e));
}
var xqt = Oqt("image/svg+xml");
function vqt(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Lm(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var n, r = e.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(n + 1)
  ];
}
function iu(e) {
  return e = Lm(Math.abs(e)), e ? e[1] : NaN;
}
function _qt(e, t) {
  return function(n, r) {
    for (var i = n.length, s = [], o = 0, a = e[0], l = 0; i > 0 && a > 0 && (l + a + 1 > r && (a = Math.max(1, r - l)), s.push(n.substring(i -= a, i + a)), !((l += a + 1) > r)); )
      a = e[o = (o + 1) % e.length];
    return s.reverse().join(t);
  };
}
function kqt(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var wqt = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Mm(e) {
  if (!(t = wqt.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new W3({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Mm.prototype = W3.prototype;
function W3(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
W3.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Sqt(e) {
  t:
    for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
      switch (e[n]) {
        case ".":
          r = i = n;
          break;
        case "0":
          r === 0 && (r = n), i = n;
          break;
        default:
          if (!+e[n])
            break t;
          r > 0 && (r = 0);
          break;
      }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
}
var aN;
function Cqt(e, t) {
  var n = Lm(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1], s = i - (aN = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, o = r.length;
  return s === o ? r : s > o ? r + new Array(s - o + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + Lm(e, Math.max(0, t + s - 1))[0];
}
function WE(e, t) {
  var n = Lm(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const UE = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: vqt,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => WE(e * 100, t),
  r: WE,
  s: Cqt,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function jE(e) {
  return e;
}
var XE = Array.prototype.map, GE = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Tqt(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? jE : _qt(XE.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? jE : kqt(XE.call(e.numerals, String)), o = e.percent === void 0 ? "%" : e.percent + "", a = e.minus === void 0 ? "\u2212" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function h(f) {
    f = Mm(f);
    var d = f.fill, p = f.align, g = f.sign, m = f.symbol, y = f.zero, O = f.width, x = f.comma, _ = f.precision, w = f.trim, E = f.type;
    E === "n" ? (x = !0, E = "g") : UE[E] || (_ === void 0 && (_ = 12), w = !0, E = "g"), (y || d === "0" && p === "=") && (y = !0, d = "0", p = "=");
    var T = m === "$" ? n : m === "#" && /[boxX]/.test(E) ? "0" + E.toLowerCase() : "", S = m === "$" ? r : /[%p]/.test(E) ? o : "", R = UE[E], A = /[defgprs%]/.test(E);
    _ = _ === void 0 ? 6 : /[gprs]/.test(E) ? Math.max(1, Math.min(21, _)) : Math.max(0, Math.min(20, _));
    function P(C) {
      var k = T, D = S, b, M, v;
      if (E === "c")
        D = R(C) + D, C = "";
      else {
        C = +C;
        var N = C < 0 || 1 / C < 0;
        if (C = isNaN(C) ? l : R(Math.abs(C), _), w && (C = Sqt(C)), N && +C == 0 && g !== "+" && (N = !1), k = (N ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + k, D = (E === "s" ? GE[8 + aN / 3] : "") + D + (N && g === "(" ? ")" : ""), A) {
          for (b = -1, M = C.length; ++b < M; )
            if (v = C.charCodeAt(b), 48 > v || v > 57) {
              D = (v === 46 ? i + C.slice(b + 1) : C.slice(b)) + D, C = C.slice(0, b);
              break;
            }
        }
      }
      x && !y && (C = t(C, 1 / 0));
      var tt = k.length + C.length + D.length, Z = tt < O ? new Array(O - tt + 1).join(d) : "";
      switch (x && y && (C = t(Z + C, Z.length ? O - D.length : 1 / 0), Z = ""), p) {
        case "<":
          C = k + C + D + Z;
          break;
        case "=":
          C = k + Z + C + D;
          break;
        case "^":
          C = Z.slice(0, tt = Z.length >> 1) + k + C + D + Z.slice(tt);
          break;
        default:
          C = Z + k + C + D;
          break;
      }
      return s(C);
    }
    return P.toString = function() {
      return f + "";
    }, P;
  }
  function u(f, d) {
    var p = h((f = Mm(f), f.type = "f", f)), g = Math.max(-8, Math.min(8, Math.floor(iu(d) / 3))) * 3, m = Math.pow(10, -g), y = GE[8 + g / 3];
    return function(O) {
      return p(m * O) + y;
    };
  }
  return {
    format: h,
    formatPrefix: u
  };
}
var c1, lN, cN;
Eqt({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Eqt(e) {
  return c1 = Tqt(e), lN = c1.format, cN = c1.formatPrefix, c1;
}
function Aqt(e) {
  return Math.max(0, -iu(Math.abs(e)));
}
function Pqt(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(iu(t) / 3))) * 3 - iu(Math.abs(e)));
}
function Dqt(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, iu(t) - iu(e)) + 1;
}
function U3(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
const HE = Symbol("implicit");
function hN() {
  var e = new EE(), t = [], n = [], r = HE;
  function i(s) {
    let o = e.get(s);
    if (o === void 0) {
      if (r !== HE)
        return r;
      e.set(s, o = t.push(s) - 1);
    }
    return n[o % n.length];
  }
  return i.domain = function(s) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new EE();
    for (const o of s)
      e.has(o) || e.set(o, t.push(o) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (n = Array.from(s), i) : n.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (r = s, i) : r;
  }, i.copy = function() {
    return hN(t, n).unknown(r);
  }, U3.apply(i, arguments), i;
}
function Lqt(e) {
  return function() {
    return e;
  };
}
function Mqt(e) {
  return +e;
}
var KE = [0, 1];
function nh(e) {
  return e;
}
function B_(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : Lqt(isNaN(t) ? NaN : 0.5);
}
function Rqt(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function $qt(e, t, n) {
  var r = e[0], i = e[1], s = t[0], o = t[1];
  return i < r ? (r = B_(i, r), s = n(o, s)) : (r = B_(r, i), s = n(s, o)), function(a) {
    return s(r(a));
  };
}
function Iqt(e, t, n) {
  var r = Math.min(e.length, t.length) - 1, i = new Array(r), s = new Array(r), o = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++o < r; )
    i[o] = B_(e[o], e[o + 1]), s[o] = n(t[o], t[o + 1]);
  return function(a) {
    var l = SZt(e, a, 1, r) - 1;
    return s[l](i[l](a));
  };
}
function uN(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function Nqt() {
  var e = KE, t = KE, n = V3, r, i, s, o = nh, a, l, h;
  function u() {
    var d = Math.min(e.length, t.length);
    return o !== nh && (o = Rqt(e[0], e[d - 1])), a = d > 2 ? Iqt : $qt, l = h = null, f;
  }
  function f(d) {
    return d == null || isNaN(d = +d) ? s : (l || (l = a(e.map(r), t, n)))(r(o(d)));
  }
  return f.invert = function(d) {
    return o(i((h || (h = a(t, e.map(r), os)))(d)));
  }, f.domain = function(d) {
    return arguments.length ? (e = Array.from(d, Mqt), u()) : e.slice();
  }, f.range = function(d) {
    return arguments.length ? (t = Array.from(d), u()) : t.slice();
  }, f.rangeRound = function(d) {
    return t = Array.from(d), n = XYt, u();
  }, f.clamp = function(d) {
    return arguments.length ? (o = d ? !0 : nh, u()) : o !== nh;
  }, f.interpolate = function(d) {
    return arguments.length ? (n = d, u()) : n;
  }, f.unknown = function(d) {
    return arguments.length ? (s = d, f) : s;
  }, function(d, p) {
    return r = d, i = p, u();
  };
}
function fN() {
  return Nqt()(nh, nh);
}
function Bqt(e, t, n, r) {
  var i = C_(e, t, n), s;
  switch (r = Mm(r == null ? ",f" : r), r.type) {
    case "s": {
      var o = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(s = Pqt(i, o)) && (r.precision = s), cN(r, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(s = Dqt(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = s - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(s = Aqt(i)) && (r.precision = s - (r.type === "%") * 2);
      break;
    }
  }
  return lN(r);
}
function Fqt(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var r = t();
    return LZt(r[0], r[r.length - 1], n == null ? 10 : n);
  }, e.tickFormat = function(n, r) {
    var i = t();
    return Bqt(i[0], i[i.length - 1], n == null ? 10 : n, r);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, s = r.length - 1, o = r[i], a = r[s], l, h, u = 10;
    for (a < o && (h = o, o = a, a = h, h = i, i = s, s = h); u-- > 0; ) {
      if (h = S_(o, a, n), h === l)
        return r[i] = o, r[s] = a, t(r);
      if (h > 0)
        o = Math.floor(o / h) * h, a = Math.ceil(a / h) * h;
      else if (h < 0)
        o = Math.ceil(o * h) / h, a = Math.floor(a * h) / h;
      else
        break;
      l = h;
    }
    return e;
  }, e;
}
function dN() {
  var e = fN();
  return e.copy = function() {
    return uN(e, dN());
  }, U3.apply(e, arguments), Fqt(e);
}
function Qqt(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], s = e[r], o;
  return s < i && (o = n, n = r, r = o, o = i, i = s, s = o), e[n] = t.floor(i), e[r] = t.ceil(s), e;
}
const YO = new Date(), zO = new Date();
function er(e, t, n, r) {
  function i(s) {
    return e(s = arguments.length === 0 ? new Date() : new Date(+s)), s;
  }
  return i.floor = (s) => (e(s = new Date(+s)), s), i.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), i.round = (s) => {
    const o = i(s), a = i.ceil(s);
    return s - o < a - s ? o : a;
  }, i.offset = (s, o) => (t(s = new Date(+s), o == null ? 1 : Math.floor(o)), s), i.range = (s, o, a) => {
    const l = [];
    if (s = i.ceil(s), a = a == null ? 1 : Math.floor(a), !(s < o) || !(a > 0))
      return l;
    let h;
    do
      l.push(h = new Date(+s)), t(s, a), e(s);
    while (h < s && s < o);
    return l;
  }, i.filter = (s) => er((o) => {
    if (o >= o)
      for (; e(o), !s(o); )
        o.setTime(o - 1);
  }, (o, a) => {
    if (o >= o)
      if (a < 0)
        for (; ++a <= 0; )
          for (; t(o, -1), !s(o); )
            ;
      else
        for (; --a >= 0; )
          for (; t(o, 1), !s(o); )
            ;
  }), n && (i.count = (s, o) => (YO.setTime(+s), zO.setTime(+o), e(YO), e(zO), Math.floor(n(YO, zO))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(r ? (o) => r(o) % s === 0 : (o) => i.count(0, o) % s === 0) : i)), i;
}
const Rm = er(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Rm.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? er((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Rm);
Rm.range;
const qo = 1e3, Fi = qo * 60, Wo = Fi * 60, fa = Wo * 24, j3 = fa * 7, JE = fa * 30, qO = fa * 365, rh = er((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * qo);
}, (e, t) => (t - e) / qo, (e) => e.getUTCSeconds());
rh.range;
const rp = er((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * qo);
}, (e, t) => {
  e.setTime(+e + t * Fi);
}, (e, t) => (t - e) / Fi, (e) => e.getMinutes());
rp.range;
const pN = er((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Fi);
}, (e, t) => (t - e) / Fi, (e) => e.getUTCMinutes());
pN.range;
const ip = er((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * qo - e.getMinutes() * Fi);
}, (e, t) => {
  e.setTime(+e + t * Wo);
}, (e, t) => (t - e) / Wo, (e) => e.getHours());
ip.range;
const gN = er((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * Wo);
}, (e, t) => (t - e) / Wo, (e) => e.getUTCHours());
gN.range;
const pc = er(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Fi) / fa,
  (e) => e.getDate() - 1
);
pc.range;
const X3 = er((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / fa, (e) => e.getUTCDate() - 1);
X3.range;
const mN = er((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / fa, (e) => Math.floor(e / fa));
mN.range;
function Ac(e) {
  return er((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Fi) / j3);
}
const su = Ac(0), $m = Ac(1), Zqt = Ac(2), Vqt = Ac(3), ou = Ac(4), Yqt = Ac(5), zqt = Ac(6);
su.range;
$m.range;
Zqt.range;
Vqt.range;
ou.range;
Yqt.range;
zqt.range;
function Pc(e) {
  return er((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / j3);
}
const G3 = Pc(0), Im = Pc(1), qqt = Pc(2), Wqt = Pc(3), au = Pc(4), Uqt = Pc(5), jqt = Pc(6);
G3.range;
Im.range;
qqt.range;
Wqt.range;
au.range;
Uqt.range;
jqt.range;
const sp = er((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
sp.range;
const yN = er((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
yN.range;
const da = er((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
da.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : er((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
da.range;
const ll = er((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
ll.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : er((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
ll.range;
function bN(e, t, n, r, i, s) {
  const o = [
    [rh, 1, qo],
    [rh, 5, 5 * qo],
    [rh, 15, 15 * qo],
    [rh, 30, 30 * qo],
    [s, 1, Fi],
    [s, 5, 5 * Fi],
    [s, 15, 15 * Fi],
    [s, 30, 30 * Fi],
    [i, 1, Wo],
    [i, 3, 3 * Wo],
    [i, 6, 6 * Wo],
    [i, 12, 12 * Wo],
    [r, 1, fa],
    [r, 2, 2 * fa],
    [n, 1, j3],
    [t, 1, JE],
    [t, 3, 3 * JE],
    [e, 1, qO]
  ];
  function a(h, u, f) {
    const d = u < h;
    d && ([h, u] = [u, h]);
    const p = f && typeof f.range == "function" ? f : l(h, u, f), g = p ? p.range(h, +u + 1) : [];
    return d ? g.reverse() : g;
  }
  function l(h, u, f) {
    const d = Math.abs(u - h) / f, p = N3(([, , y]) => y).right(o, d);
    if (p === o.length)
      return e.every(C_(h / qO, u / qO, f));
    if (p === 0)
      return Rm.every(Math.max(C_(h, u, f), 1));
    const [g, m] = o[d / o[p - 1][2] < o[p][2] / d ? p - 1 : p];
    return g.every(m);
  }
  return [a, l];
}
bN(ll, yN, G3, mN, gN, pN);
const [Xqt, Gqt] = bN(da, sp, su, pc, ip, rp);
function WO(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function UO(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function hf(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function Hqt(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, s = e.days, o = e.shortDays, a = e.months, l = e.shortMonths, h = uf(i), u = ff(i), f = uf(s), d = ff(s), p = uf(o), g = ff(o), m = uf(a), y = ff(a), O = uf(l), x = ff(l), _ = {
    a: N,
    A: tt,
    b: Z,
    B: z,
    c: null,
    d: sA,
    e: sA,
    f: xWt,
    g: PWt,
    G: LWt,
    H: yWt,
    I: bWt,
    j: OWt,
    L: ON,
    m: vWt,
    M: _Wt,
    p: X,
    q,
    Q: lA,
    s: cA,
    S: kWt,
    u: wWt,
    U: SWt,
    V: CWt,
    w: TWt,
    W: EWt,
    x: null,
    X: null,
    y: AWt,
    Y: DWt,
    Z: MWt,
    "%": aA
  }, w = {
    a: nt,
    A: st,
    b: ct,
    B: Y,
    c: null,
    d: oA,
    e: oA,
    f: NWt,
    g: UWt,
    G: XWt,
    H: RWt,
    I: $Wt,
    j: IWt,
    L: vN,
    m: BWt,
    M: FWt,
    p: Ct,
    q: H,
    Q: lA,
    s: cA,
    S: QWt,
    u: ZWt,
    U: VWt,
    V: YWt,
    w: zWt,
    W: qWt,
    x: null,
    X: null,
    y: WWt,
    Y: jWt,
    Z: GWt,
    "%": aA
  }, E = {
    a: P,
    A: C,
    b: k,
    B: D,
    c: b,
    d: rA,
    e: rA,
    f: dWt,
    g: nA,
    G: eA,
    H: iA,
    I: iA,
    j: cWt,
    L: fWt,
    m: lWt,
    M: hWt,
    p: A,
    q: aWt,
    Q: gWt,
    s: mWt,
    S: uWt,
    u: nWt,
    U: rWt,
    V: iWt,
    w: eWt,
    W: sWt,
    x: M,
    X: v,
    y: nA,
    Y: eA,
    Z: oWt,
    "%": pWt
  };
  _.x = T(n, _), _.X = T(r, _), _.c = T(t, _), w.x = T(n, w), w.X = T(r, w), w.c = T(t, w);
  function T(et, U) {
    return function(W) {
      var $ = [], F = -1, G = 0, I = et.length, ht, L, $t;
      for (W instanceof Date || (W = new Date(+W)); ++F < I; )
        et.charCodeAt(F) === 37 && ($.push(et.slice(G, F)), (L = tA[ht = et.charAt(++F)]) != null ? ht = et.charAt(++F) : L = ht === "e" ? " " : "0", ($t = U[ht]) && (ht = $t(W, L)), $.push(ht), G = F + 1);
      return $.push(et.slice(G, F)), $.join("");
    };
  }
  function S(et, U) {
    return function(W) {
      var $ = hf(1900, void 0, 1), F = R($, et, W += "", 0), G, I;
      if (F != W.length)
        return null;
      if ("Q" in $)
        return new Date($.Q);
      if ("s" in $)
        return new Date($.s * 1e3 + ("L" in $ ? $.L : 0));
      if (U && !("Z" in $) && ($.Z = 0), "p" in $ && ($.H = $.H % 12 + $.p * 12), $.m === void 0 && ($.m = "q" in $ ? $.q : 0), "V" in $) {
        if ($.V < 1 || $.V > 53)
          return null;
        "w" in $ || ($.w = 1), "Z" in $ ? (G = UO(hf($.y, 0, 1)), I = G.getUTCDay(), G = I > 4 || I === 0 ? Im.ceil(G) : Im(G), G = X3.offset(G, ($.V - 1) * 7), $.y = G.getUTCFullYear(), $.m = G.getUTCMonth(), $.d = G.getUTCDate() + ($.w + 6) % 7) : (G = WO(hf($.y, 0, 1)), I = G.getDay(), G = I > 4 || I === 0 ? $m.ceil(G) : $m(G), G = pc.offset(G, ($.V - 1) * 7), $.y = G.getFullYear(), $.m = G.getMonth(), $.d = G.getDate() + ($.w + 6) % 7);
      } else
        ("W" in $ || "U" in $) && ("w" in $ || ($.w = "u" in $ ? $.u % 7 : "W" in $ ? 1 : 0), I = "Z" in $ ? UO(hf($.y, 0, 1)).getUTCDay() : WO(hf($.y, 0, 1)).getDay(), $.m = 0, $.d = "W" in $ ? ($.w + 6) % 7 + $.W * 7 - (I + 5) % 7 : $.w + $.U * 7 - (I + 6) % 7);
      return "Z" in $ ? ($.H += $.Z / 100 | 0, $.M += $.Z % 100, UO($)) : WO($);
    };
  }
  function R(et, U, W, $) {
    for (var F = 0, G = U.length, I = W.length, ht, L; F < G; ) {
      if ($ >= I)
        return -1;
      if (ht = U.charCodeAt(F++), ht === 37) {
        if (ht = U.charAt(F++), L = E[ht in tA ? U.charAt(F++) : ht], !L || ($ = L(et, W, $)) < 0)
          return -1;
      } else if (ht != W.charCodeAt($++))
        return -1;
    }
    return $;
  }
  function A(et, U, W) {
    var $ = h.exec(U.slice(W));
    return $ ? (et.p = u.get($[0].toLowerCase()), W + $[0].length) : -1;
  }
  function P(et, U, W) {
    var $ = p.exec(U.slice(W));
    return $ ? (et.w = g.get($[0].toLowerCase()), W + $[0].length) : -1;
  }
  function C(et, U, W) {
    var $ = f.exec(U.slice(W));
    return $ ? (et.w = d.get($[0].toLowerCase()), W + $[0].length) : -1;
  }
  function k(et, U, W) {
    var $ = O.exec(U.slice(W));
    return $ ? (et.m = x.get($[0].toLowerCase()), W + $[0].length) : -1;
  }
  function D(et, U, W) {
    var $ = m.exec(U.slice(W));
    return $ ? (et.m = y.get($[0].toLowerCase()), W + $[0].length) : -1;
  }
  function b(et, U, W) {
    return R(et, t, U, W);
  }
  function M(et, U, W) {
    return R(et, n, U, W);
  }
  function v(et, U, W) {
    return R(et, r, U, W);
  }
  function N(et) {
    return o[et.getDay()];
  }
  function tt(et) {
    return s[et.getDay()];
  }
  function Z(et) {
    return l[et.getMonth()];
  }
  function z(et) {
    return a[et.getMonth()];
  }
  function X(et) {
    return i[+(et.getHours() >= 12)];
  }
  function q(et) {
    return 1 + ~~(et.getMonth() / 3);
  }
  function nt(et) {
    return o[et.getUTCDay()];
  }
  function st(et) {
    return s[et.getUTCDay()];
  }
  function ct(et) {
    return l[et.getUTCMonth()];
  }
  function Y(et) {
    return a[et.getUTCMonth()];
  }
  function Ct(et) {
    return i[+(et.getUTCHours() >= 12)];
  }
  function H(et) {
    return 1 + ~~(et.getUTCMonth() / 3);
  }
  return {
    format: function(et) {
      var U = T(et += "", _);
      return U.toString = function() {
        return et;
      }, U;
    },
    parse: function(et) {
      var U = S(et += "", !1);
      return U.toString = function() {
        return et;
      }, U;
    },
    utcFormat: function(et) {
      var U = T(et += "", w);
      return U.toString = function() {
        return et;
      }, U;
    },
    utcParse: function(et) {
      var U = S(et += "", !0);
      return U.toString = function() {
        return et;
      }, U;
    }
  };
}
var tA = { "-": "", _: " ", 0: "0" }, hr = /^\s*\d+/, Kqt = /^%/, Jqt = /[\\^$*+?|[\]().{}]/g;
function Fe(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", s = i.length;
  return r + (s < n ? new Array(n - s + 1).join(t) + i : i);
}
function tWt(e) {
  return e.replace(Jqt, "\\$&");
}
function uf(e) {
  return new RegExp("^(?:" + e.map(tWt).join("|") + ")", "i");
}
function ff(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function eWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function nWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function rWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function iWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function sWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function eA(e, t, n) {
  var r = hr.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function nA(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function oWt(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function aWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function lWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function rA(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function cWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function iA(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function hWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function uWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function fWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function dWt(e, t, n) {
  var r = hr.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function pWt(e, t, n) {
  var r = Kqt.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function gWt(e, t, n) {
  var r = hr.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function mWt(e, t, n) {
  var r = hr.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function sA(e, t) {
  return Fe(e.getDate(), t, 2);
}
function yWt(e, t) {
  return Fe(e.getHours(), t, 2);
}
function bWt(e, t) {
  return Fe(e.getHours() % 12 || 12, t, 2);
}
function OWt(e, t) {
  return Fe(1 + pc.count(da(e), e), t, 3);
}
function ON(e, t) {
  return Fe(e.getMilliseconds(), t, 3);
}
function xWt(e, t) {
  return ON(e, t) + "000";
}
function vWt(e, t) {
  return Fe(e.getMonth() + 1, t, 2);
}
function _Wt(e, t) {
  return Fe(e.getMinutes(), t, 2);
}
function kWt(e, t) {
  return Fe(e.getSeconds(), t, 2);
}
function wWt(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function SWt(e, t) {
  return Fe(su.count(da(e) - 1, e), t, 2);
}
function xN(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ou(e) : ou.ceil(e);
}
function CWt(e, t) {
  return e = xN(e), Fe(ou.count(da(e), e) + (da(e).getDay() === 4), t, 2);
}
function TWt(e) {
  return e.getDay();
}
function EWt(e, t) {
  return Fe($m.count(da(e) - 1, e), t, 2);
}
function AWt(e, t) {
  return Fe(e.getFullYear() % 100, t, 2);
}
function PWt(e, t) {
  return e = xN(e), Fe(e.getFullYear() % 100, t, 2);
}
function DWt(e, t) {
  return Fe(e.getFullYear() % 1e4, t, 4);
}
function LWt(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? ou(e) : ou.ceil(e), Fe(e.getFullYear() % 1e4, t, 4);
}
function MWt(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Fe(t / 60 | 0, "0", 2) + Fe(t % 60, "0", 2);
}
function oA(e, t) {
  return Fe(e.getUTCDate(), t, 2);
}
function RWt(e, t) {
  return Fe(e.getUTCHours(), t, 2);
}
function $Wt(e, t) {
  return Fe(e.getUTCHours() % 12 || 12, t, 2);
}
function IWt(e, t) {
  return Fe(1 + X3.count(ll(e), e), t, 3);
}
function vN(e, t) {
  return Fe(e.getUTCMilliseconds(), t, 3);
}
function NWt(e, t) {
  return vN(e, t) + "000";
}
function BWt(e, t) {
  return Fe(e.getUTCMonth() + 1, t, 2);
}
function FWt(e, t) {
  return Fe(e.getUTCMinutes(), t, 2);
}
function QWt(e, t) {
  return Fe(e.getUTCSeconds(), t, 2);
}
function ZWt(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function VWt(e, t) {
  return Fe(G3.count(ll(e) - 1, e), t, 2);
}
function _N(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? au(e) : au.ceil(e);
}
function YWt(e, t) {
  return e = _N(e), Fe(au.count(ll(e), e) + (ll(e).getUTCDay() === 4), t, 2);
}
function zWt(e) {
  return e.getUTCDay();
}
function qWt(e, t) {
  return Fe(Im.count(ll(e) - 1, e), t, 2);
}
function WWt(e, t) {
  return Fe(e.getUTCFullYear() % 100, t, 2);
}
function UWt(e, t) {
  return e = _N(e), Fe(e.getUTCFullYear() % 100, t, 2);
}
function jWt(e, t) {
  return Fe(e.getUTCFullYear() % 1e4, t, 4);
}
function XWt(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? au(e) : au.ceil(e), Fe(e.getUTCFullYear() % 1e4, t, 4);
}
function GWt() {
  return "+0000";
}
function aA() {
  return "%";
}
function lA(e) {
  return +e;
}
function cA(e) {
  return Math.floor(+e / 1e3);
}
var Vc, Nm;
HWt({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function HWt(e) {
  return Vc = Hqt(e), Nm = Vc.format, Vc.parse, Vc.utcFormat, Vc.utcParse, Vc;
}
function KWt(e) {
  return new Date(e);
}
function JWt(e) {
  return e instanceof Date ? +e : +new Date(+e);
}
function kN(e, t, n, r, i, s, o, a, l, h) {
  var u = fN(), f = u.invert, d = u.domain, p = h(".%L"), g = h(":%S"), m = h("%I:%M"), y = h("%I %p"), O = h("%a %d"), x = h("%b %d"), _ = h("%B"), w = h("%Y");
  function E(T) {
    return (l(T) < T ? p : a(T) < T ? g : o(T) < T ? m : s(T) < T ? y : r(T) < T ? i(T) < T ? O : x : n(T) < T ? _ : w)(T);
  }
  return u.invert = function(T) {
    return new Date(f(T));
  }, u.domain = function(T) {
    return arguments.length ? d(Array.from(T, JWt)) : d().map(KWt);
  }, u.ticks = function(T) {
    var S = d();
    return e(S[0], S[S.length - 1], T == null ? 10 : T);
  }, u.tickFormat = function(T, S) {
    return S == null ? E : h(S);
  }, u.nice = function(T) {
    var S = d();
    return (!T || typeof T.range != "function") && (T = t(S[0], S[S.length - 1], T == null ? 10 : T)), T ? d(Qqt(S, T)) : u;
  }, u.copy = function() {
    return uN(u, kN(e, t, n, r, i, s, o, a, l, h));
  }, u;
}
function tUt() {
  return U3.apply(kN(Xqt, Gqt, da, sp, su, pc, ip, rp, rh, Nm).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Tn(e) {
  return function() {
    return e;
  };
}
const hA = Math.abs, Or = Math.atan2, wl = Math.cos, eUt = Math.max, jO = Math.min, Ys = Math.sin, ih = Math.sqrt, xr = 1e-12, op = Math.PI, Bm = op / 2, ng = 2 * op;
function nUt(e) {
  return e > 1 ? 0 : e < -1 ? op : Math.acos(e);
}
function uA(e) {
  return e >= 1 ? Bm : e <= -1 ? -Bm : Math.asin(e);
}
function wN(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length)
      return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0))
        throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new mqt(t);
}
function rUt(e) {
  return e.innerRadius;
}
function iUt(e) {
  return e.outerRadius;
}
function sUt(e) {
  return e.startAngle;
}
function oUt(e) {
  return e.endAngle;
}
function aUt(e) {
  return e && e.padAngle;
}
function lUt(e, t, n, r, i, s, o, a) {
  var l = n - e, h = r - t, u = o - i, f = a - s, d = f * l - u * h;
  if (!(d * d < xr))
    return d = (u * (t - s) - f * (e - i)) / d, [e + d * l, t + d * h];
}
function h1(e, t, n, r, i, s, o) {
  var a = e - n, l = t - r, h = (o ? s : -s) / ih(a * a + l * l), u = h * l, f = -h * a, d = e + u, p = t + f, g = n + u, m = r + f, y = (d + g) / 2, O = (p + m) / 2, x = g - d, _ = m - p, w = x * x + _ * _, E = i - s, T = d * m - g * p, S = (_ < 0 ? -1 : 1) * ih(eUt(0, E * E * w - T * T)), R = (T * _ - x * S) / w, A = (-T * x - _ * S) / w, P = (T * _ + x * S) / w, C = (-T * x + _ * S) / w, k = R - y, D = A - O, b = P - y, M = C - O;
  return k * k + D * D > b * b + M * M && (R = P, A = C), {
    cx: R,
    cy: A,
    x01: -u,
    y01: -f,
    x11: R * (i / E - 1),
    y11: A * (i / E - 1)
  };
}
function F_() {
  var e = rUt, t = iUt, n = Tn(0), r = null, i = sUt, s = oUt, o = aUt, a = null, l = wN(h);
  function h() {
    var u, f, d = +e.apply(this, arguments), p = +t.apply(this, arguments), g = i.apply(this, arguments) - Bm, m = s.apply(this, arguments) - Bm, y = hA(m - g), O = m > g;
    if (a || (a = u = l()), p < d && (f = p, p = d, d = f), !(p > xr))
      a.moveTo(0, 0);
    else if (y > ng - xr)
      a.moveTo(p * wl(g), p * Ys(g)), a.arc(0, 0, p, g, m, !O), d > xr && (a.moveTo(d * wl(m), d * Ys(m)), a.arc(0, 0, d, m, g, O));
    else {
      var x = g, _ = m, w = g, E = m, T = y, S = y, R = o.apply(this, arguments) / 2, A = R > xr && (r ? +r.apply(this, arguments) : ih(d * d + p * p)), P = jO(hA(p - d) / 2, +n.apply(this, arguments)), C = P, k = P, D, b;
      if (A > xr) {
        var M = uA(A / d * Ys(R)), v = uA(A / p * Ys(R));
        (T -= M * 2) > xr ? (M *= O ? 1 : -1, w += M, E -= M) : (T = 0, w = E = (g + m) / 2), (S -= v * 2) > xr ? (v *= O ? 1 : -1, x += v, _ -= v) : (S = 0, x = _ = (g + m) / 2);
      }
      var N = p * wl(x), tt = p * Ys(x), Z = d * wl(E), z = d * Ys(E);
      if (P > xr) {
        var X = p * wl(_), q = p * Ys(_), nt = d * wl(w), st = d * Ys(w), ct;
        if (y < op)
          if (ct = lUt(N, tt, nt, st, X, q, Z, z)) {
            var Y = N - ct[0], Ct = tt - ct[1], H = X - ct[0], et = q - ct[1], U = 1 / Ys(nUt((Y * H + Ct * et) / (ih(Y * Y + Ct * Ct) * ih(H * H + et * et))) / 2), W = ih(ct[0] * ct[0] + ct[1] * ct[1]);
            C = jO(P, (d - W) / (U - 1)), k = jO(P, (p - W) / (U + 1));
          } else
            C = k = 0;
      }
      S > xr ? k > xr ? (D = h1(nt, st, N, tt, p, k, O), b = h1(X, q, Z, z, p, k, O), a.moveTo(D.cx + D.x01, D.cy + D.y01), k < P ? a.arc(D.cx, D.cy, k, Or(D.y01, D.x01), Or(b.y01, b.x01), !O) : (a.arc(D.cx, D.cy, k, Or(D.y01, D.x01), Or(D.y11, D.x11), !O), a.arc(0, 0, p, Or(D.cy + D.y11, D.cx + D.x11), Or(b.cy + b.y11, b.cx + b.x11), !O), a.arc(b.cx, b.cy, k, Or(b.y11, b.x11), Or(b.y01, b.x01), !O))) : (a.moveTo(N, tt), a.arc(0, 0, p, x, _, !O)) : a.moveTo(N, tt), !(d > xr) || !(T > xr) ? a.lineTo(Z, z) : C > xr ? (D = h1(Z, z, X, q, d, -C, O), b = h1(N, tt, nt, st, d, -C, O), a.lineTo(D.cx + D.x01, D.cy + D.y01), C < P ? a.arc(D.cx, D.cy, C, Or(D.y01, D.x01), Or(b.y01, b.x01), !O) : (a.arc(D.cx, D.cy, C, Or(D.y01, D.x01), Or(D.y11, D.x11), !O), a.arc(0, 0, d, Or(D.cy + D.y11, D.cx + D.x11), Or(b.cy + b.y11, b.cx + b.x11), O), a.arc(b.cx, b.cy, C, Or(b.y11, b.x11), Or(b.y01, b.x01), !O))) : a.arc(0, 0, d, E, w, O);
    }
    if (a.closePath(), u)
      return a = null, u + "" || null;
  }
  return h.centroid = function() {
    var u = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, f = (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 - op / 2;
    return [wl(f) * u, Ys(f) * u];
  }, h.innerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Tn(+u), h) : e;
  }, h.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Tn(+u), h) : t;
  }, h.cornerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Tn(+u), h) : n;
  }, h.padRadius = function(u) {
    return arguments.length ? (r = u == null ? null : typeof u == "function" ? u : Tn(+u), h) : r;
  }, h.startAngle = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : Tn(+u), h) : i;
  }, h.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : Tn(+u), h) : s;
  }, h.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Tn(+u), h) : o;
  }, h.context = function(u) {
    return arguments.length ? (a = u == null ? null : u, h) : a;
  }, h;
}
function SN(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function CN(e) {
  this._context = e;
}
CN.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Oi(e) {
  return new CN(e);
}
function cUt(e) {
  return e[0];
}
function hUt(e) {
  return e[1];
}
function Qu(e, t) {
  var n = Tn(!0), r = null, i = Oi, s = null, o = wN(a);
  e = typeof e == "function" ? e : e === void 0 ? cUt : Tn(e), t = typeof t == "function" ? t : t === void 0 ? hUt : Tn(t);
  function a(l) {
    var h, u = (l = SN(l)).length, f, d = !1, p;
    for (r == null && (s = i(p = o())), h = 0; h <= u; ++h)
      !(h < u && n(f = l[h], h, l)) === d && ((d = !d) ? s.lineStart() : s.lineEnd()), d && s.point(+e(f, h, l), +t(f, h, l));
    if (p)
      return s = null, p + "" || null;
  }
  return a.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Tn(+l), a) : e;
  }, a.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : Tn(+l), a) : t;
  }, a.defined = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : Tn(!!l), a) : n;
  }, a.curve = function(l) {
    return arguments.length ? (i = l, r != null && (s = i(r)), a) : i;
  }, a.context = function(l) {
    return arguments.length ? (l == null ? r = s = null : s = i(r = l), a) : r;
  }, a;
}
function uUt(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function fUt(e) {
  return e;
}
function dUt() {
  var e = fUt, t = uUt, n = null, r = Tn(0), i = Tn(ng), s = Tn(0);
  function o(a) {
    var l, h = (a = SN(a)).length, u, f, d = 0, p = new Array(h), g = new Array(h), m = +r.apply(this, arguments), y = Math.min(ng, Math.max(-ng, i.apply(this, arguments) - m)), O, x = Math.min(Math.abs(y) / h, s.apply(this, arguments)), _ = x * (y < 0 ? -1 : 1), w;
    for (l = 0; l < h; ++l)
      (w = g[p[l] = l] = +e(a[l], l, a)) > 0 && (d += w);
    for (t != null ? p.sort(function(E, T) {
      return t(g[E], g[T]);
    }) : n != null && p.sort(function(E, T) {
      return n(a[E], a[T]);
    }), l = 0, f = d ? (y - h * _) / d : 0; l < h; ++l, m = O)
      u = p[l], w = g[u], O = m + (w > 0 ? w * f : 0) + _, g[u] = {
        data: a[u],
        index: l,
        value: w,
        startAngle: m,
        endAngle: O,
        padAngle: x
      };
    return g;
  }
  return o.value = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : Tn(+a), o) : e;
  }, o.sortValues = function(a) {
    return arguments.length ? (t = a, n = null, o) : t;
  }, o.sort = function(a) {
    return arguments.length ? (n = a, t = null, o) : n;
  }, o.startAngle = function(a) {
    return arguments.length ? (r = typeof a == "function" ? a : Tn(+a), o) : r;
  }, o.endAngle = function(a) {
    return arguments.length ? (i = typeof a == "function" ? a : Tn(+a), o) : i;
  }, o.padAngle = function(a) {
    return arguments.length ? (s = typeof a == "function" ? a : Tn(+a), o) : s;
  }, o;
}
class TN {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function pUt(e) {
  return new TN(e, !0);
}
function gUt(e) {
  return new TN(e, !1);
}
function cl() {
}
function Fm(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function ky(e) {
  this._context = e;
}
ky.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Fm(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        Fm(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function lu(e) {
  return new ky(e);
}
function EN(e) {
  this._context = e;
}
EN.prototype = {
  areaStart: cl,
  areaEnd: cl,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        Fm(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function mUt(e) {
  return new EN(e);
}
function AN(e) {
  this._context = e;
}
AN.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        Fm(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function yUt(e) {
  return new AN(e);
}
function PN(e, t) {
  this._basis = new ky(e), this._beta = t;
}
PN.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], s = e[n] - r, o = t[n] - i, a = -1, l; ++a <= n; )
        l = a / n, this._basis.point(
          this._beta * e[a] + (1 - this._beta) * (r + l * s),
          this._beta * t[a] + (1 - this._beta) * (i + l * o)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const bUt = function e(t) {
  function n(r) {
    return t === 1 ? new ky(r) : new PN(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function Qm(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function H3(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
H3.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Qm(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        Qm(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const OUt = function e(t) {
  function n(r) {
    return new H3(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function K3(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
K3.prototype = {
  areaStart: cl,
  areaEnd: cl,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        Qm(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const xUt = function e(t) {
  function n(r) {
    return new K3(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function J3(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
J3.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Qm(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const vUt = function e(t) {
  function n(r) {
    return new J3(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function t5(e, t, n) {
  var r = e._x1, i = e._y1, s = e._x2, o = e._y2;
  if (e._l01_a > xr) {
    var a = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, i = (i * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;
  }
  if (e._l23_a > xr) {
    var h = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, u = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * h + e._x1 * e._l23_2a - t * e._l12_2a) / u, o = (o * h + e._y1 * e._l23_2a - n * e._l12_2a) / u;
  }
  e._context.bezierCurveTo(r, i, s, o, e._x2, e._y2);
}
function DN(e, t) {
  this._context = e, this._alpha = t;
}
DN.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        t5(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const _Ut = function e(t) {
  function n(r) {
    return t ? new DN(r, t) : new H3(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function LN(e, t) {
  this._context = e, this._alpha = t;
}
LN.prototype = {
  areaStart: cl,
  areaEnd: cl,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        t5(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const kUt = function e(t) {
  function n(r) {
    return t ? new LN(r, t) : new K3(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function MN(e, t) {
  this._context = e, this._alpha = t;
}
MN.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        t5(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const wUt = function e(t) {
  function n(r) {
    return t ? new MN(r, t) : new J3(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function RN(e) {
  this._context = e;
}
RN.prototype = {
  areaStart: cl,
  areaEnd: cl,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function SUt(e) {
  return new RN(e);
}
function fA(e) {
  return e < 0 ? -1 : 1;
}
function dA(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, s = (e._y1 - e._y0) / (r || i < 0 && -0), o = (n - e._y1) / (i || r < 0 && -0), a = (s * i + o * r) / (r + i);
  return (fA(s) + fA(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(a)) || 0;
}
function pA(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function XO(e, t, n) {
  var r = e._x0, i = e._y0, s = e._x1, o = e._y1, a = (s - r) / 3;
  e._context.bezierCurveTo(r + a, i + a * t, s - a, o - a * n, s, o);
}
function Zm(e) {
  this._context = e;
}
Zm.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        XO(this, this._t0, pA(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, XO(this, pA(this, n = dA(this, e, t)), n);
          break;
        default:
          XO(this, this._t0, n = dA(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function $N(e) {
  this._context = new IN(e);
}
($N.prototype = Object.create(Zm.prototype)).point = function(e, t) {
  Zm.prototype.point.call(this, t, e);
};
function IN(e) {
  this._context = e;
}
IN.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, s) {
    this._context.bezierCurveTo(t, e, r, n, s, i);
  }
};
function CUt(e) {
  return new Zm(e);
}
function TUt(e) {
  return new $N(e);
}
function NN(e) {
  this._context = e;
}
NN.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = gA(e), i = gA(t), s = 0, o = 1; o < n; ++s, ++o)
          this._context.bezierCurveTo(r[0][s], i[0][s], r[1][s], i[1][s], e[o], t[o]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function gA(e) {
  var t, n = e.length - 1, r, i = new Array(n), s = new Array(n), o = new Array(n);
  for (i[0] = 0, s[0] = 2, o[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, s[t] = 4, o[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, s[n - 1] = 7, o[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = i[t] / s[t - 1], s[t] -= r, o[t] -= r * o[t - 1];
  for (i[n - 1] = o[n - 1] / s[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (o[t] - i[t + 1]) / s[t];
  for (s[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    s[t] = 2 * e[t + 1] - i[t + 1];
  return [i, s];
}
function EUt(e) {
  return new NN(e);
}
function wy(e, t) {
  this._context = e, this._t = t;
}
wy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function AUt(e) {
  return new wy(e, 0.5);
}
function PUt(e) {
  return new wy(e, 0);
}
function DUt(e) {
  return new wy(e, 1);
}
function sh(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
sh.prototype = {
  constructor: sh,
  scale: function(e) {
    return e === 1 ? this : new sh(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new sh(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
new sh(1, 0, 0);
sh.prototype;
/*! @license DOMPurify 2.4.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.3/LICENSE */
function Ma(e) {
  return Ma = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ma(e);
}
function Q_(e, t) {
  return Q_ = Object.setPrototypeOf || function(r, i) {
    return r.__proto__ = i, r;
  }, Q_(e, t);
}
function LUt() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function rg(e, t, n) {
  return LUt() ? rg = Reflect.construct : rg = function(i, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(i, a), h = new l();
    return o && Q_(h, o.prototype), h;
  }, rg.apply(null, arguments);
}
function rs(e) {
  return MUt(e) || RUt(e) || $Ut(e) || IUt();
}
function MUt(e) {
  if (Array.isArray(e))
    return Z_(e);
}
function RUt(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function $Ut(e, t) {
  if (!!e) {
    if (typeof e == "string")
      return Z_(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Z_(e, t);
  }
}
function Z_(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function IUt() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var NUt = Object.hasOwnProperty, mA = Object.setPrototypeOf, BUt = Object.isFrozen, FUt = Object.getPrototypeOf, QUt = Object.getOwnPropertyDescriptor, qr = Object.freeze, ws = Object.seal, ZUt = Object.create, BN = typeof Reflect < "u" && Reflect, Vm = BN.apply, V_ = BN.construct;
Vm || (Vm = function(t, n, r) {
  return t.apply(n, r);
});
qr || (qr = function(t) {
  return t;
});
ws || (ws = function(t) {
  return t;
});
V_ || (V_ = function(t, n) {
  return rg(t, rs(n));
});
var VUt = Ui(Array.prototype.forEach), yA = Ui(Array.prototype.pop), df = Ui(Array.prototype.push), ig = Ui(String.prototype.toLowerCase), GO = Ui(String.prototype.toString), YUt = Ui(String.prototype.match), es = Ui(String.prototype.replace), zUt = Ui(String.prototype.indexOf), qUt = Ui(String.prototype.trim), $r = Ui(RegExp.prototype.test), HO = WUt(TypeError);
function Ui(e) {
  return function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      r[i - 1] = arguments[i];
    return Vm(e, t, r);
  };
}
function WUt(e) {
  return function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return V_(e, n);
  };
}
function Ae(e, t, n) {
  n = n || ig, mA && mA(e, null);
  for (var r = t.length; r--; ) {
    var i = t[r];
    if (typeof i == "string") {
      var s = n(i);
      s !== i && (BUt(t) || (t[r] = s), i = s);
    }
    e[i] = !0;
  }
  return e;
}
function Sl(e) {
  var t = ZUt(null), n;
  for (n in e)
    Vm(NUt, e, [n]) === !0 && (t[n] = e[n]);
  return t;
}
function u1(e, t) {
  for (; e !== null; ) {
    var n = QUt(e, t);
    if (n) {
      if (n.get)
        return Ui(n.get);
      if (typeof n.value == "function")
        return Ui(n.value);
    }
    e = FUt(e);
  }
  function r(i) {
    return console.warn("fallback value for", i), null;
  }
  return r;
}
var bA = qr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), KO = qr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), JO = qr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), UUt = qr(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), tx = qr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), jUt = qr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), OA = qr(["#text"]), xA = qr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), ex = qr(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), vA = qr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), f1 = qr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), XUt = ws(/\{\{[\w\W]*|[\w\W]*\}\}/gm), GUt = ws(/<%[\w\W]*|[\w\W]*%>/gm), HUt = ws(/\${[\w\W]*}/gm), KUt = ws(/^data-[\-\w.\u00B7-\uFFFF]/), JUt = ws(/^aria-[\-\w]+$/), tjt = ws(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), ejt = ws(/^(?:\w+script|data):/i), njt = ws(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), rjt = ws(/^html$/i), ijt = function() {
  return typeof window > "u" ? null : window;
}, sjt = function(t, n) {
  if (Ma(t) !== "object" || typeof t.createPolicy != "function")
    return null;
  var r = null, i = "data-tt-policy-suffix";
  n.currentScript && n.currentScript.hasAttribute(i) && (r = n.currentScript.getAttribute(i));
  var s = "dompurify" + (r ? "#" + r : "");
  try {
    return t.createPolicy(s, {
      createHTML: function(a) {
        return a;
      },
      createScriptURL: function(a) {
        return a;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function FN() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ijt(), t = function(V) {
    return FN(V);
  };
  if (t.version = "2.4.3", t.removed = [], !e || !e.document || e.document.nodeType !== 9)
    return t.isSupported = !1, t;
  var n = e.document, r = e.document, i = e.DocumentFragment, s = e.HTMLTemplateElement, o = e.Node, a = e.Element, l = e.NodeFilter, h = e.NamedNodeMap, u = h === void 0 ? e.NamedNodeMap || e.MozNamedAttrMap : h, f = e.HTMLFormElement, d = e.DOMParser, p = e.trustedTypes, g = a.prototype, m = u1(g, "cloneNode"), y = u1(g, "nextSibling"), O = u1(g, "childNodes"), x = u1(g, "parentNode");
  if (typeof s == "function") {
    var _ = r.createElement("template");
    _.content && _.content.ownerDocument && (r = _.content.ownerDocument);
  }
  var w = sjt(p, n), E = w ? w.createHTML("") : "", T = r, S = T.implementation, R = T.createNodeIterator, A = T.createDocumentFragment, P = T.getElementsByTagName, C = n.importNode, k = {};
  try {
    k = Sl(r).documentMode ? r.documentMode : {};
  } catch {
  }
  var D = {};
  t.isSupported = typeof x == "function" && S && typeof S.createHTMLDocument < "u" && k !== 9;
  var b = XUt, M = GUt, v = HUt, N = KUt, tt = JUt, Z = ejt, z = njt, X = tjt, q = null, nt = Ae({}, [].concat(rs(bA), rs(KO), rs(JO), rs(tx), rs(OA))), st = null, ct = Ae({}, [].concat(rs(xA), rs(ex), rs(vA), rs(f1))), Y = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Ct = null, H = null, et = !0, U = !0, W = !1, $ = !1, F = !1, G = !1, I = !1, ht = !1, L = !1, $t = !1, it = !0, At = !1, St = "user-content-", bt = !0, gt = !1, yt = {}, dt = null, xt = Ae({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Re = null, ye = Ae({}, ["audio", "video", "img", "source", "image", "track"]), zt = null, Yt = Ae({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ce = "http://www.w3.org/1998/Math/MathML", Ie = "http://www.w3.org/2000/svg", re = "http://www.w3.org/1999/xhtml", Qt = re, Lt = !1, kt = null, _t = Ae({}, [ce, Ie, re], GO), Et, pt = ["application/xhtml+xml", "text/html"], Zt = "text/html", lt, Vt = null, ut = r.createElement("form"), he = function(V) {
    return V instanceof RegExp || V instanceof Function;
  }, pe = function(V) {
    Vt && Vt === V || ((!V || Ma(V) !== "object") && (V = {}), V = Sl(V), Et = pt.indexOf(V.PARSER_MEDIA_TYPE) === -1 ? Et = Zt : Et = V.PARSER_MEDIA_TYPE, lt = Et === "application/xhtml+xml" ? GO : ig, q = "ALLOWED_TAGS" in V ? Ae({}, V.ALLOWED_TAGS, lt) : nt, st = "ALLOWED_ATTR" in V ? Ae({}, V.ALLOWED_ATTR, lt) : ct, kt = "ALLOWED_NAMESPACES" in V ? Ae({}, V.ALLOWED_NAMESPACES, GO) : _t, zt = "ADD_URI_SAFE_ATTR" in V ? Ae(
      Sl(Yt),
      V.ADD_URI_SAFE_ATTR,
      lt
    ) : Yt, Re = "ADD_DATA_URI_TAGS" in V ? Ae(
      Sl(ye),
      V.ADD_DATA_URI_TAGS,
      lt
    ) : ye, dt = "FORBID_CONTENTS" in V ? Ae({}, V.FORBID_CONTENTS, lt) : xt, Ct = "FORBID_TAGS" in V ? Ae({}, V.FORBID_TAGS, lt) : {}, H = "FORBID_ATTR" in V ? Ae({}, V.FORBID_ATTR, lt) : {}, yt = "USE_PROFILES" in V ? V.USE_PROFILES : !1, et = V.ALLOW_ARIA_ATTR !== !1, U = V.ALLOW_DATA_ATTR !== !1, W = V.ALLOW_UNKNOWN_PROTOCOLS || !1, $ = V.SAFE_FOR_TEMPLATES || !1, F = V.WHOLE_DOCUMENT || !1, ht = V.RETURN_DOM || !1, L = V.RETURN_DOM_FRAGMENT || !1, $t = V.RETURN_TRUSTED_TYPE || !1, I = V.FORCE_BODY || !1, it = V.SANITIZE_DOM !== !1, At = V.SANITIZE_NAMED_PROPS || !1, bt = V.KEEP_CONTENT !== !1, gt = V.IN_PLACE || !1, X = V.ALLOWED_URI_REGEXP || X, Qt = V.NAMESPACE || re, V.CUSTOM_ELEMENT_HANDLING && he(V.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Y.tagNameCheck = V.CUSTOM_ELEMENT_HANDLING.tagNameCheck), V.CUSTOM_ELEMENT_HANDLING && he(V.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Y.attributeNameCheck = V.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), V.CUSTOM_ELEMENT_HANDLING && typeof V.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Y.allowCustomizedBuiltInElements = V.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), $ && (U = !1), L && (ht = !0), yt && (q = Ae({}, rs(OA)), st = [], yt.html === !0 && (Ae(q, bA), Ae(st, xA)), yt.svg === !0 && (Ae(q, KO), Ae(st, ex), Ae(st, f1)), yt.svgFilters === !0 && (Ae(q, JO), Ae(st, ex), Ae(st, f1)), yt.mathMl === !0 && (Ae(q, tx), Ae(st, vA), Ae(st, f1))), V.ADD_TAGS && (q === nt && (q = Sl(q)), Ae(q, V.ADD_TAGS, lt)), V.ADD_ATTR && (st === ct && (st = Sl(st)), Ae(st, V.ADD_ATTR, lt)), V.ADD_URI_SAFE_ATTR && Ae(zt, V.ADD_URI_SAFE_ATTR, lt), V.FORBID_CONTENTS && (dt === xt && (dt = Sl(dt)), Ae(dt, V.FORBID_CONTENTS, lt)), bt && (q["#text"] = !0), F && Ae(q, ["html", "head", "body"]), q.table && (Ae(q, ["tbody"]), delete Ct.tbody), qr && qr(V), Vt = V);
  }, be = Ae({}, ["mi", "mo", "mn", "ms", "mtext"]), Oe = Ae({}, ["foreignobject", "desc", "title", "annotation-xml"]), ke = Ae({}, ["title", "style", "font", "a", "script"]), qt = Ae({}, KO);
  Ae(qt, JO), Ae(qt, UUt);
  var ne = Ae({}, tx);
  Ae(ne, jUt);
  var ge = function(V) {
    var Q = x(V);
    (!Q || !Q.tagName) && (Q = {
      namespaceURI: Qt,
      tagName: "template"
    });
    var ot = ig(V.tagName), vt = ig(Q.tagName);
    return kt[V.namespaceURI] ? V.namespaceURI === Ie ? Q.namespaceURI === re ? ot === "svg" : Q.namespaceURI === ce ? ot === "svg" && (vt === "annotation-xml" || be[vt]) : Boolean(qt[ot]) : V.namespaceURI === ce ? Q.namespaceURI === re ? ot === "math" : Q.namespaceURI === Ie ? ot === "math" && Oe[vt] : Boolean(ne[ot]) : V.namespaceURI === re ? Q.namespaceURI === Ie && !Oe[vt] || Q.namespaceURI === ce && !be[vt] ? !1 : !ne[ot] && (ke[ot] || !qt[ot]) : !!(Et === "application/xhtml+xml" && kt[V.namespaceURI]) : !1;
  }, ie = function(V) {
    df(t.removed, {
      element: V
    });
    try {
      V.parentNode.removeChild(V);
    } catch {
      try {
        V.outerHTML = E;
      } catch {
        V.remove();
      }
    }
  }, qn = function(V, Q) {
    try {
      df(t.removed, {
        attribute: Q.getAttributeNode(V),
        from: Q
      });
    } catch {
      df(t.removed, {
        attribute: null,
        from: Q
      });
    }
    if (Q.removeAttribute(V), V === "is" && !st[V])
      if (ht || L)
        try {
          ie(Q);
        } catch {
        }
      else
        try {
          Q.setAttribute(V, "");
        } catch {
        }
  }, Ji = function(V) {
    var Q, ot;
    if (I)
      V = "<remove></remove>" + V;
    else {
      var vt = YUt(V, /^[\r\n\t ]+/);
      ot = vt && vt[0];
    }
    Et === "application/xhtml+xml" && Qt === re && (V = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + V + "</body></html>");
    var Gt = w ? w.createHTML(V) : V;
    if (Qt === re)
      try {
        Q = new d().parseFromString(Gt, Et);
      } catch {
      }
    if (!Q || !Q.documentElement) {
      Q = S.createDocument(Qt, "template", null);
      try {
        Q.documentElement.innerHTML = Lt ? E : Gt;
      } catch {
      }
    }
    var Ce = Q.body || Q.documentElement;
    return V && ot && Ce.insertBefore(r.createTextNode(ot), Ce.childNodes[0] || null), Qt === re ? P.call(Q, F ? "html" : "body")[0] : F ? Q.documentElement : Ce;
  }, qe = function(V) {
    return R.call(
      V.ownerDocument || V,
      V,
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT,
      null,
      !1
    );
  }, ae = function(V) {
    return V instanceof f && (typeof V.nodeName != "string" || typeof V.textContent != "string" || typeof V.removeChild != "function" || !(V.attributes instanceof u) || typeof V.removeAttribute != "function" || typeof V.setAttribute != "function" || typeof V.namespaceURI != "string" || typeof V.insertBefore != "function" || typeof V.hasChildNodes != "function");
  }, fn = function(V) {
    return Ma(o) === "object" ? V instanceof o : V && Ma(V) === "object" && typeof V.nodeType == "number" && typeof V.nodeName == "string";
  }, On = function(V, Q, ot) {
    !D[V] || VUt(D[V], function(vt) {
      vt.call(t, Q, ot, Vt);
    });
  }, Qe = function(V) {
    var Q;
    if (On("beforeSanitizeElements", V, null), ae(V) || $r(/[\u0080-\uFFFF]/, V.nodeName))
      return ie(V), !0;
    var ot = lt(V.nodeName);
    if (On("uponSanitizeElement", V, {
      tagName: ot,
      allowedTags: q
    }), V.hasChildNodes() && !fn(V.firstElementChild) && (!fn(V.content) || !fn(V.content.firstElementChild)) && $r(/<[/\w]/g, V.innerHTML) && $r(/<[/\w]/g, V.textContent) || ot === "select" && $r(/<template/i, V.innerHTML))
      return ie(V), !0;
    if (!q[ot] || Ct[ot]) {
      if (!Ct[ot] && We(ot) && (Y.tagNameCheck instanceof RegExp && $r(Y.tagNameCheck, ot) || Y.tagNameCheck instanceof Function && Y.tagNameCheck(ot)))
        return !1;
      if (bt && !dt[ot]) {
        var vt = x(V) || V.parentNode, Gt = O(V) || V.childNodes;
        if (Gt && vt)
          for (var Ce = Gt.length, Le = Ce - 1; Le >= 0; --Le)
            vt.insertBefore(m(Gt[Le], !0), y(V));
      }
      return ie(V), !0;
    }
    return V instanceof a && !ge(V) || (ot === "noscript" || ot === "noembed") && $r(/<\/no(script|embed)/i, V.innerHTML) ? (ie(V), !0) : ($ && V.nodeType === 3 && (Q = V.textContent, Q = es(Q, b, " "), Q = es(Q, M, " "), Q = es(Q, v, " "), V.textContent !== Q && (df(t.removed, {
      element: V.cloneNode()
    }), V.textContent = Q)), On("afterSanitizeElements", V, null), !1);
  }, xn = function(V, Q, ot) {
    if (it && (Q === "id" || Q === "name") && (ot in r || ot in ut))
      return !1;
    if (!(U && !H[Q] && $r(N, Q))) {
      if (!(et && $r(tt, Q))) {
        if (!st[Q] || H[Q]) {
          if (!(We(V) && (Y.tagNameCheck instanceof RegExp && $r(Y.tagNameCheck, V) || Y.tagNameCheck instanceof Function && Y.tagNameCheck(V)) && (Y.attributeNameCheck instanceof RegExp && $r(Y.attributeNameCheck, Q) || Y.attributeNameCheck instanceof Function && Y.attributeNameCheck(Q)) || Q === "is" && Y.allowCustomizedBuiltInElements && (Y.tagNameCheck instanceof RegExp && $r(Y.tagNameCheck, ot) || Y.tagNameCheck instanceof Function && Y.tagNameCheck(ot))))
            return !1;
        } else if (!zt[Q]) {
          if (!$r(X, es(ot, z, ""))) {
            if (!((Q === "src" || Q === "xlink:href" || Q === "href") && V !== "script" && zUt(ot, "data:") === 0 && Re[V])) {
              if (!(W && !$r(Z, es(ot, z, "")))) {
                if (ot)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, We = function(V) {
    return V.indexOf("-") > 0;
  }, Rn = function(V) {
    var Q, ot, vt, Gt;
    On("beforeSanitizeAttributes", V, null);
    var Ce = V.attributes;
    if (!!Ce) {
      var Le = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: st
      };
      for (Gt = Ce.length; Gt--; ) {
        Q = Ce[Gt];
        var $e = Q, Ue = $e.name, ln = $e.namespaceURI;
        if (ot = Ue === "value" ? Q.value : qUt(Q.value), vt = lt(Ue), Le.attrName = vt, Le.attrValue = ot, Le.keepAttr = !0, Le.forceKeepAttr = void 0, On("uponSanitizeAttribute", V, Le), ot = Le.attrValue, !Le.forceKeepAttr && (qn(Ue, V), !!Le.keepAttr)) {
          if ($r(/\/>/i, ot)) {
            qn(Ue, V);
            continue;
          }
          $ && (ot = es(ot, b, " "), ot = es(ot, M, " "), ot = es(ot, v, " "));
          var Bs = lt(V.nodeName);
          if (!!xn(Bs, vt, ot)) {
            if (At && (vt === "id" || vt === "name") && (qn(Ue, V), ot = St + ot), w && Ma(p) === "object" && typeof p.getAttributeType == "function" && !ln)
              switch (p.getAttributeType(Bs, vt)) {
                case "TrustedHTML":
                  ot = w.createHTML(ot);
                  break;
                case "TrustedScriptURL":
                  ot = w.createScriptURL(ot);
                  break;
              }
            try {
              ln ? V.setAttributeNS(ln, Ue, ot) : V.setAttribute(Ue, ot), yA(t.removed);
            } catch {
            }
          }
        }
      }
      On("afterSanitizeAttributes", V, null);
    }
  }, kn = function It(V) {
    var Q, ot = qe(V);
    for (On("beforeSanitizeShadowDOM", V, null); Q = ot.nextNode(); )
      On("uponSanitizeShadowNode", Q, null), !Qe(Q) && (Q.content instanceof i && It(Q.content), Rn(Q));
    On("afterSanitizeShadowDOM", V, null);
  };
  return t.sanitize = function(It) {
    var V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Q, ot, vt, Gt, Ce;
    if (Lt = !It, Lt && (It = "<!-->"), typeof It != "string" && !fn(It)) {
      if (typeof It.toString != "function")
        throw HO("toString is not a function");
      if (It = It.toString(), typeof It != "string")
        throw HO("dirty is not a string, aborting");
    }
    if (!t.isSupported) {
      if (Ma(e.toStaticHTML) === "object" || typeof e.toStaticHTML == "function") {
        if (typeof It == "string")
          return e.toStaticHTML(It);
        if (fn(It))
          return e.toStaticHTML(It.outerHTML);
      }
      return It;
    }
    if (G || pe(V), t.removed = [], typeof It == "string" && (gt = !1), gt) {
      if (It.nodeName) {
        var Le = lt(It.nodeName);
        if (!q[Le] || Ct[Le])
          throw HO("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (It instanceof o)
      Q = Ji("<!---->"), ot = Q.ownerDocument.importNode(It, !0), ot.nodeType === 1 && ot.nodeName === "BODY" || ot.nodeName === "HTML" ? Q = ot : Q.appendChild(ot);
    else {
      if (!ht && !$ && !F && It.indexOf("<") === -1)
        return w && $t ? w.createHTML(It) : It;
      if (Q = Ji(It), !Q)
        return ht ? null : $t ? E : "";
    }
    Q && I && ie(Q.firstChild);
    for (var $e = qe(gt ? It : Q); vt = $e.nextNode(); )
      vt.nodeType === 3 && vt === Gt || Qe(vt) || (vt.content instanceof i && kn(vt.content), Rn(vt), Gt = vt);
    if (Gt = null, gt)
      return It;
    if (ht) {
      if (L)
        for (Ce = A.call(Q.ownerDocument); Q.firstChild; )
          Ce.appendChild(Q.firstChild);
      else
        Ce = Q;
      return st.shadowroot && (Ce = C.call(n, Ce, !0)), Ce;
    }
    var Ue = F ? Q.outerHTML : Q.innerHTML;
    return F && q["!doctype"] && Q.ownerDocument && Q.ownerDocument.doctype && Q.ownerDocument.doctype.name && $r(rjt, Q.ownerDocument.doctype.name) && (Ue = "<!DOCTYPE " + Q.ownerDocument.doctype.name + `>
` + Ue), $ && (Ue = es(Ue, b, " "), Ue = es(Ue, M, " "), Ue = es(Ue, v, " ")), w && $t ? w.createHTML(Ue) : Ue;
  }, t.setConfig = function(It) {
    pe(It), G = !0;
  }, t.clearConfig = function() {
    Vt = null, G = !1;
  }, t.isValidAttribute = function(It, V, Q) {
    Vt || pe({});
    var ot = lt(It), vt = lt(V);
    return xn(ot, vt, Q);
  }, t.addHook = function(It, V) {
    typeof V == "function" && (D[It] = D[It] || [], df(D[It], V));
  }, t.removeHook = function(It) {
    if (D[It])
      return yA(D[It]);
  }, t.removeHooks = function(It) {
    D[It] && (D[It] = []);
  }, t.removeAllHooks = function() {
    D = {};
  }, t;
}
var ap = FN();
const sg = {
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (e) => e >= 255 ? 255 : e < 0 ? 0 : e,
    g: (e) => e >= 255 ? 255 : e < 0 ? 0 : e,
    b: (e) => e >= 255 ? 255 : e < 0 ? 0 : e,
    h: (e) => e % 360,
    s: (e) => e >= 100 ? 100 : e < 0 ? 0 : e,
    l: (e) => e >= 100 ? 100 : e < 0 ? 0 : e,
    a: (e) => e >= 1 ? 1 : e < 0 ? 0 : e
  },
  toLinear: (e) => {
    const t = e / 255;
    return e > 0.03928 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92;
  },
  hue2rgb: (e, t, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e),
  hsl2rgb: ({ h: e, s: t, l: n }, r) => {
    if (!t)
      return n * 2.55;
    e /= 360, t /= 100, n /= 100;
    const i = n < 0.5 ? n * (1 + t) : n + t - n * t, s = 2 * n - i;
    switch (r) {
      case "r":
        return sg.hue2rgb(s, i, e + 1 / 3) * 255;
      case "g":
        return sg.hue2rgb(s, i, e) * 255;
      case "b":
        return sg.hue2rgb(s, i, e - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: e, g: t, b: n }, r) => {
    e /= 255, t /= 255, n /= 255;
    const i = Math.max(e, t, n), s = Math.min(e, t, n), o = (i + s) / 2;
    if (r === "l")
      return o * 100;
    if (i === s)
      return 0;
    const a = i - s, l = o > 0.5 ? a / (2 - i - s) : a / (i + s);
    if (r === "s")
      return l * 100;
    switch (i) {
      case e:
        return ((t - n) / a + (t < n ? 6 : 0)) * 60;
      case t:
        return ((n - e) / a + 2) * 60;
      case n:
        return ((e - t) / a + 4) * 60;
      default:
        return -1;
    }
  }
}, ojt = sg, ajt = {
  clamp: (e, t, n) => t > n ? Math.min(t, Math.max(n, e)) : Math.min(n, Math.max(t, e)),
  round: (e) => Math.round(e * 1e10) / 1e10
}, ljt = ajt, cjt = {
  dec2hex: (e) => {
    const t = Math.round(e).toString(16);
    return t.length > 1 ? t : `0${t}`;
  }
}, hjt = cjt, ujt = {
  channel: ojt,
  lang: ljt,
  unit: hjt
}, we = ujt, Ca = {};
for (let e = 0; e <= 255; e++)
  Ca[e] = we.unit.dec2hex(e);
const vr = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
class fjt {
  constructor() {
    this.type = vr.ALL;
  }
  get() {
    return this.type;
  }
  set(t) {
    if (this.type && this.type !== t)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = t;
  }
  reset() {
    this.type = vr.ALL;
  }
  is(t) {
    return this.type === t;
  }
}
const djt = fjt;
class pjt {
  constructor(t, n) {
    this.color = n, this.changed = !1, this.data = t, this.type = new djt();
  }
  set(t, n) {
    return this.color = n, this.changed = !1, this.data = t, this.type.type = vr.ALL, this;
  }
  _ensureHSL() {
    const t = this.data, { h: n, s: r, l: i } = t;
    n === void 0 && (t.h = we.channel.rgb2hsl(t, "h")), r === void 0 && (t.s = we.channel.rgb2hsl(t, "s")), i === void 0 && (t.l = we.channel.rgb2hsl(t, "l"));
  }
  _ensureRGB() {
    const t = this.data, { r: n, g: r, b: i } = t;
    n === void 0 && (t.r = we.channel.hsl2rgb(t, "r")), r === void 0 && (t.g = we.channel.hsl2rgb(t, "g")), i === void 0 && (t.b = we.channel.hsl2rgb(t, "b"));
  }
  get r() {
    const t = this.data, n = t.r;
    return !this.type.is(vr.HSL) && n !== void 0 ? n : (this._ensureHSL(), we.channel.hsl2rgb(t, "r"));
  }
  get g() {
    const t = this.data, n = t.g;
    return !this.type.is(vr.HSL) && n !== void 0 ? n : (this._ensureHSL(), we.channel.hsl2rgb(t, "g"));
  }
  get b() {
    const t = this.data, n = t.b;
    return !this.type.is(vr.HSL) && n !== void 0 ? n : (this._ensureHSL(), we.channel.hsl2rgb(t, "b"));
  }
  get h() {
    const t = this.data, n = t.h;
    return !this.type.is(vr.RGB) && n !== void 0 ? n : (this._ensureRGB(), we.channel.rgb2hsl(t, "h"));
  }
  get s() {
    const t = this.data, n = t.s;
    return !this.type.is(vr.RGB) && n !== void 0 ? n : (this._ensureRGB(), we.channel.rgb2hsl(t, "s"));
  }
  get l() {
    const t = this.data, n = t.l;
    return !this.type.is(vr.RGB) && n !== void 0 ? n : (this._ensureRGB(), we.channel.rgb2hsl(t, "l"));
  }
  get a() {
    return this.data.a;
  }
  set r(t) {
    this.type.set(vr.RGB), this.changed = !0, this.data.r = t;
  }
  set g(t) {
    this.type.set(vr.RGB), this.changed = !0, this.data.g = t;
  }
  set b(t) {
    this.type.set(vr.RGB), this.changed = !0, this.data.b = t;
  }
  set h(t) {
    this.type.set(vr.HSL), this.changed = !0, this.data.h = t;
  }
  set s(t) {
    this.type.set(vr.HSL), this.changed = !0, this.data.s = t;
  }
  set l(t) {
    this.type.set(vr.HSL), this.changed = !0, this.data.l = t;
  }
  set a(t) {
    this.changed = !0, this.data.a = t;
  }
}
const gjt = pjt, mjt = new gjt({ r: 0, g: 0, b: 0, a: 0 }, "transparent"), Sy = mjt, QN = {
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  parse: (e) => {
    if (e.charCodeAt(0) !== 35)
      return;
    const t = e.match(QN.re);
    if (!t)
      return;
    const n = t[1], r = parseInt(n, 16), i = n.length, s = i % 4 === 0, o = i > 4, a = o ? 1 : 17, l = o ? 8 : 4, h = s ? 0 : -1, u = o ? 255 : 15;
    return Sy.set({
      r: (r >> l * (h + 3) & u) * a,
      g: (r >> l * (h + 2) & u) * a,
      b: (r >> l * (h + 1) & u) * a,
      a: s ? (r & u) * a / 255 : 1
    }, e);
  },
  stringify: (e) => {
    const { r: t, g: n, b: r, a: i } = e;
    return i < 1 ? `#${Ca[Math.round(t)]}${Ca[Math.round(n)]}${Ca[Math.round(r)]}${Ca[Math.round(i * 255)]}` : `#${Ca[Math.round(t)]}${Ca[Math.round(n)]}${Ca[Math.round(r)]}`;
  }
}, Jf = QN, og = {
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  _hue2deg: (e) => {
    const t = e.match(og.hueRe);
    if (t) {
      const [, n, r] = t;
      switch (r) {
        case "grad":
          return we.channel.clamp.h(parseFloat(n) * 0.9);
        case "rad":
          return we.channel.clamp.h(parseFloat(n) * 180 / Math.PI);
        case "turn":
          return we.channel.clamp.h(parseFloat(n) * 360);
      }
    }
    return we.channel.clamp.h(parseFloat(e));
  },
  parse: (e) => {
    const t = e.charCodeAt(0);
    if (t !== 104 && t !== 72)
      return;
    const n = e.match(og.re);
    if (!n)
      return;
    const [, r, i, s, o, a] = n;
    return Sy.set({
      h: og._hue2deg(r),
      s: we.channel.clamp.s(parseFloat(i)),
      l: we.channel.clamp.l(parseFloat(s)),
      a: o ? we.channel.clamp.a(a ? parseFloat(o) / 100 : parseFloat(o)) : 1
    }, e);
  },
  stringify: (e) => {
    const { h: t, s: n, l: r, a: i } = e;
    return i < 1 ? `hsla(${we.lang.round(t)}, ${we.lang.round(n)}%, ${we.lang.round(r)}%, ${i})` : `hsl(${we.lang.round(t)}, ${we.lang.round(n)}%, ${we.lang.round(r)}%)`;
  }
}, d1 = og, ag = {
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  parse: (e) => {
    e = e.toLowerCase();
    const t = ag.colors[e];
    if (!!t)
      return Jf.parse(t);
  },
  stringify: (e) => {
    const t = Jf.stringify(e);
    for (const n in ag.colors)
      if (ag.colors[n] === t)
        return n;
  }
}, _A = ag, ZN = {
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  parse: (e) => {
    const t = e.charCodeAt(0);
    if (t !== 114 && t !== 82)
      return;
    const n = e.match(ZN.re);
    if (!n)
      return;
    const [, r, i, s, o, a, l, h, u] = n;
    return Sy.set({
      r: we.channel.clamp.r(i ? parseFloat(r) * 2.55 : parseFloat(r)),
      g: we.channel.clamp.g(o ? parseFloat(s) * 2.55 : parseFloat(s)),
      b: we.channel.clamp.b(l ? parseFloat(a) * 2.55 : parseFloat(a)),
      a: h ? we.channel.clamp.a(u ? parseFloat(h) / 100 : parseFloat(h)) : 1
    }, e);
  },
  stringify: (e) => {
    const { r: t, g: n, b: r, a: i } = e;
    return i < 1 ? `rgba(${we.lang.round(t)}, ${we.lang.round(n)}, ${we.lang.round(r)}, ${we.lang.round(i)})` : `rgb(${we.lang.round(t)}, ${we.lang.round(n)}, ${we.lang.round(r)})`;
  }
}, p1 = ZN, yjt = {
  format: {
    keyword: _A,
    hex: Jf,
    rgb: p1,
    rgba: p1,
    hsl: d1,
    hsla: d1
  },
  parse: (e) => {
    if (typeof e != "string")
      return e;
    const t = Jf.parse(e) || p1.parse(e) || d1.parse(e) || _A.parse(e);
    if (t)
      return t;
    throw new Error(`Unsupported color format: "${e}"`);
  },
  stringify: (e) => !e.changed && e.color ? e.color : e.type.is(vr.HSL) || e.data.r === void 0 ? d1.stringify(e) : e.a < 1 || !Number.isInteger(e.r) || !Number.isInteger(e.g) || !Number.isInteger(e.b) ? p1.stringify(e) : Jf.stringify(e)
}, pa = yjt, bjt = (e, t) => {
  const n = pa.parse(e);
  for (const r in t)
    n[r] = we.channel.clamp[r](t[r]);
  return pa.stringify(n);
}, VN = bjt, Ojt = (e, t, n = 0, r = 1) => {
  if (typeof e != "number")
    return VN(e, { a: t });
  const i = Sy.set({
    r: we.channel.clamp.r(e),
    g: we.channel.clamp.g(t),
    b: we.channel.clamp.b(n),
    a: we.channel.clamp.a(r)
  });
  return pa.stringify(i);
}, td = Ojt, xjt = (e, t, n) => {
  const r = pa.parse(e), i = r[t], s = we.channel.clamp[t](i + n);
  return i !== s && (r[t] = s), pa.stringify(r);
}, YN = xjt, vjt = (e, t) => YN(e, "l", t), oe = vjt, _jt = (e, t) => YN(e, "l", -t), me = _jt, kjt = (e, t) => {
  const n = pa.parse(e), r = {};
  for (const i in t)
    !t[i] || (r[i] = n[i] + t[i]);
  return VN(e, r);
}, ft = kjt, wjt = (e, t, n = 50) => {
  const { r, g: i, b: s, a: o } = pa.parse(e), { r: a, g: l, b: h, a: u } = pa.parse(t), f = n / 100, d = f * 2 - 1, p = o - u, m = ((d * p === -1 ? d : (d + p) / (1 + d * p)) + 1) / 2, y = 1 - m, O = r * m + a * y, x = i * m + l * y, _ = s * m + h * y, w = o * f + u * (1 - f);
  return td(O, x, _, w);
}, Sjt = wjt, Cjt = (e, t = 100) => {
  const n = pa.parse(e);
  return n.r = 255 - n.r, n.g = 255 - n.g, n.b = 255 - n.b, Sjt(n, e, t);
}, Nt = Cjt;
var Tjt = typeof global == "object" && global && global.Object === Object && global;
const zN = Tjt;
var Ejt = typeof self == "object" && self && self.Object === Object && self, Ajt = zN || Ejt || Function("return this")();
const Rs = Ajt;
var Pjt = Rs.Symbol;
const ji = Pjt;
var qN = Object.prototype, Djt = qN.hasOwnProperty, Ljt = qN.toString, pf = ji ? ji.toStringTag : void 0;
function Mjt(e) {
  var t = Djt.call(e, pf), n = e[pf];
  try {
    e[pf] = void 0;
    var r = !0;
  } catch {
  }
  var i = Ljt.call(e);
  return r && (t ? e[pf] = n : delete e[pf]), i;
}
var Rjt = Object.prototype, $jt = Rjt.toString;
function Ijt(e) {
  return $jt.call(e);
}
var Njt = "[object Null]", Bjt = "[object Undefined]", kA = ji ? ji.toStringTag : void 0;
function Dc(e) {
  return e == null ? e === void 0 ? Bjt : Njt : kA && kA in Object(e) ? Mjt(e) : Ijt(e);
}
function xi(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Fjt = "[object AsyncFunction]", Qjt = "[object Function]", Zjt = "[object GeneratorFunction]", Vjt = "[object Proxy]";
function cu(e) {
  if (!xi(e))
    return !1;
  var t = Dc(e);
  return t == Qjt || t == Zjt || t == Fjt || t == Vjt;
}
var Yjt = Rs["__core-js_shared__"];
const nx = Yjt;
var wA = function() {
  var e = /[^.]+$/.exec(nx && nx.keys && nx.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function zjt(e) {
  return !!wA && wA in e;
}
var qjt = Function.prototype, Wjt = qjt.toString;
function Lc(e) {
  if (e != null) {
    try {
      return Wjt.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Ujt = /[\\^$.*+?()[\]{}|]/g, jjt = /^\[object .+?Constructor\]$/, Xjt = Function.prototype, Gjt = Object.prototype, Hjt = Xjt.toString, Kjt = Gjt.hasOwnProperty, Jjt = RegExp(
  "^" + Hjt.call(Kjt).replace(Ujt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function tXt(e) {
  if (!xi(e) || zjt(e))
    return !1;
  var t = cu(e) ? Jjt : jjt;
  return t.test(Lc(e));
}
function eXt(e, t) {
  return e == null ? void 0 : e[t];
}
function Mc(e, t) {
  var n = eXt(e, t);
  return tXt(n) ? n : void 0;
}
var nXt = Mc(Object, "create");
const lp = nXt;
function rXt() {
  this.__data__ = lp ? lp(null) : {}, this.size = 0;
}
function iXt(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var sXt = "__lodash_hash_undefined__", oXt = Object.prototype, aXt = oXt.hasOwnProperty;
function lXt(e) {
  var t = this.__data__;
  if (lp) {
    var n = t[e];
    return n === sXt ? void 0 : n;
  }
  return aXt.call(t, e) ? t[e] : void 0;
}
var cXt = Object.prototype, hXt = cXt.hasOwnProperty;
function uXt(e) {
  var t = this.__data__;
  return lp ? t[e] !== void 0 : hXt.call(t, e);
}
var fXt = "__lodash_hash_undefined__";
function dXt(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = lp && t === void 0 ? fXt : t, this;
}
function gc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
gc.prototype.clear = rXt;
gc.prototype.delete = iXt;
gc.prototype.get = lXt;
gc.prototype.has = uXt;
gc.prototype.set = dXt;
function pXt() {
  this.__data__ = [], this.size = 0;
}
function Zu(e, t) {
  return e === t || e !== e && t !== t;
}
function Cy(e, t) {
  for (var n = e.length; n--; )
    if (Zu(e[n][0], t))
      return n;
  return -1;
}
var gXt = Array.prototype, mXt = gXt.splice;
function yXt(e) {
  var t = this.__data__, n = Cy(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : mXt.call(t, n, 1), --this.size, !0;
}
function bXt(e) {
  var t = this.__data__, n = Cy(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function OXt(e) {
  return Cy(this.__data__, e) > -1;
}
function xXt(e, t) {
  var n = this.__data__, r = Cy(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function xa(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
xa.prototype.clear = pXt;
xa.prototype.delete = yXt;
xa.prototype.get = bXt;
xa.prototype.has = OXt;
xa.prototype.set = xXt;
var vXt = Mc(Rs, "Map");
const cp = vXt;
function _Xt() {
  this.size = 0, this.__data__ = {
    hash: new gc(),
    map: new (cp || xa)(),
    string: new gc()
  };
}
function kXt(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Ty(e, t) {
  var n = e.__data__;
  return kXt(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function wXt(e) {
  var t = Ty(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function SXt(e) {
  return Ty(this, e).get(e);
}
function CXt(e) {
  return Ty(this, e).has(e);
}
function TXt(e, t) {
  var n = Ty(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function va(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
va.prototype.clear = _Xt;
va.prototype.delete = wXt;
va.prototype.get = SXt;
va.prototype.has = CXt;
va.prototype.set = TXt;
var EXt = "Expected a function";
function Vu(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(EXt);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var o = e.apply(this, r);
    return n.cache = s.set(i, o) || s, o;
  };
  return n.cache = new (Vu.Cache || va)(), n;
}
Vu.Cache = va;
var WN = "comm", UN = "rule", jN = "decl", AXt = "@import", PXt = "@keyframes", DXt = "@layer", XN = Math.abs, e5 = String.fromCharCode;
function GN(e) {
  return e.trim();
}
function lg(e, t, n) {
  return e.replace(t, n);
}
function LXt(e, t, n) {
  return e.indexOf(t, n);
}
function hp(e, t) {
  return e.charCodeAt(t) | 0;
}
function up(e, t, n) {
  return e.slice(t, n);
}
function Qo(e) {
  return e.length;
}
function MXt(e) {
  return e.length;
}
function g1(e, t) {
  return t.push(e), e;
}
var Ey = 1, hu = 1, HN = 0, Xi = 0, Nn = 0, Yu = "";
function n5(e, t, n, r, i, s, o, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: s, line: Ey, column: hu, length: o, return: "", siblings: a };
}
function RXt() {
  return Nn;
}
function $Xt() {
  return Nn = Xi > 0 ? hp(Yu, --Xi) : 0, hu--, Nn === 10 && (hu = 1, Ey--), Nn;
}
function ps() {
  return Nn = Xi < HN ? hp(Yu, Xi++) : 0, hu++, Nn === 10 && (hu = 1, Ey++), Nn;
}
function Kl() {
  return hp(Yu, Xi);
}
function cg() {
  return Xi;
}
function Ay(e, t) {
  return up(Yu, e, t);
}
function Y_(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function IXt(e) {
  return Ey = hu = 1, HN = Qo(Yu = e), Xi = 0, [];
}
function NXt(e) {
  return Yu = "", e;
}
function rx(e) {
  return GN(Ay(Xi - 1, z_(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function BXt(e) {
  for (; (Nn = Kl()) && Nn < 33; )
    ps();
  return Y_(e) > 2 || Y_(Nn) > 3 ? "" : " ";
}
function FXt(e, t) {
  for (; --t && ps() && !(Nn < 48 || Nn > 102 || Nn > 57 && Nn < 65 || Nn > 70 && Nn < 97); )
    ;
  return Ay(e, cg() + (t < 6 && Kl() == 32 && ps() == 32));
}
function z_(e) {
  for (; ps(); )
    switch (Nn) {
      case e:
        return Xi;
      case 34:
      case 39:
        e !== 34 && e !== 39 && z_(Nn);
        break;
      case 40:
        e === 41 && z_(e);
        break;
      case 92:
        ps();
        break;
    }
  return Xi;
}
function QXt(e, t) {
  for (; ps() && e + Nn !== 47 + 10; )
    if (e + Nn === 42 + 42 && Kl() === 47)
      break;
  return "/*" + Ay(t, Xi - 1) + "*" + e5(e === 47 ? e : ps());
}
function ZXt(e) {
  for (; !Y_(Kl()); )
    ps();
  return Ay(e, Xi);
}
function VXt(e) {
  return NXt(hg("", null, null, null, [""], e = IXt(e), 0, [0], e));
}
function hg(e, t, n, r, i, s, o, a, l) {
  for (var h = 0, u = 0, f = o, d = 0, p = 0, g = 0, m = 1, y = 1, O = 1, x = 0, _ = "", w = i, E = s, T = r, S = _; y; )
    switch (g = x, x = ps()) {
      case 40:
        if (g != 108 && hp(S, f - 1) == 58) {
          LXt(S += lg(rx(x), "&", "&\f"), "&\f", XN(h ? a[h - 1] : 0)) != -1 && (O = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        S += rx(x);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        S += BXt(g);
        break;
      case 92:
        S += FXt(cg() - 1, 7);
        continue;
      case 47:
        switch (Kl()) {
          case 42:
          case 47:
            g1(YXt(QXt(ps(), cg()), t, n, l), l);
            break;
          default:
            S += "/";
        }
        break;
      case 123 * m:
        a[h++] = Qo(S) * O;
      case 125 * m:
      case 59:
      case 0:
        switch (x) {
          case 0:
          case 125:
            y = 0;
          case 59 + u:
            O == -1 && (S = lg(S, /\f/g, "")), p > 0 && Qo(S) - f && g1(p > 32 ? CA(S + ";", r, n, f - 1, l) : CA(lg(S, " ", "") + ";", r, n, f - 2, l), l);
            break;
          case 59:
            S += ";";
          default:
            if (g1(T = SA(S, t, n, h, u, i, a, _, w = [], E = [], f, s), s), x === 123)
              if (u === 0)
                hg(S, t, T, T, w, s, f, a, E);
              else
                switch (d === 99 && hp(S, 3) === 110 ? 100 : d) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    hg(e, T, T, r && g1(SA(e, T, T, 0, 0, i, a, _, i, w = [], f, E), E), i, E, f, a, r ? w : E);
                    break;
                  default:
                    hg(S, T, T, T, [""], E, 0, a, E);
                }
        }
        h = u = p = 0, m = O = 1, _ = S = "", f = o;
        break;
      case 58:
        f = 1 + Qo(S), p = g;
      default:
        if (m < 1) {
          if (x == 123)
            --m;
          else if (x == 125 && m++ == 0 && $Xt() == 125)
            continue;
        }
        switch (S += e5(x), x * m) {
          case 38:
            O = u > 0 ? 1 : (S += "\f", -1);
            break;
          case 44:
            a[h++] = (Qo(S) - 1) * O, O = 1;
            break;
          case 64:
            Kl() === 45 && (S += rx(ps())), d = Kl(), u = f = Qo(_ = S += ZXt(cg())), x++;
            break;
          case 45:
            g === 45 && Qo(S) == 2 && (m = 0);
        }
    }
  return s;
}
function SA(e, t, n, r, i, s, o, a, l, h, u, f) {
  for (var d = i - 1, p = i === 0 ? s : [""], g = MXt(p), m = 0, y = 0, O = 0; m < r; ++m)
    for (var x = 0, _ = up(e, d + 1, d = XN(y = o[m])), w = e; x < g; ++x)
      (w = GN(y > 0 ? p[x] + " " + _ : lg(_, /&\f/g, p[x]))) && (l[O++] = w);
  return n5(e, t, n, i === 0 ? UN : a, l, h, u, f);
}
function YXt(e, t, n, r) {
  return n5(e, t, n, WN, e5(RXt()), up(e, 2, -2), 0, r);
}
function CA(e, t, n, r, i) {
  return n5(e, t, n, jN, up(e, 0, r), up(e, r + 1, -1), r, i);
}
function q_(e, t) {
  for (var n = "", r = 0; r < e.length; r++)
    n += t(e[r], r, e, t) || "";
  return n;
}
function zXt(e, t, n, r) {
  switch (e.type) {
    case DXt:
      if (e.children.length)
        break;
    case AXt:
    case jN:
      return e.return = e.return || e.value;
    case WN:
      return "";
    case PXt:
      return e.return = e.value + "{" + q_(e.children, r) + "}";
    case UN:
      if (!Qo(e.value = e.props.join(",")))
        return "";
  }
  return Qo(n = q_(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function yo(e) {
  return e != null && typeof e == "object";
}
var qXt = "[object Symbol]";
function mc(e) {
  return typeof e == "symbol" || yo(e) && Dc(e) == qXt;
}
function Sh(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var WXt = Array.isArray;
const Yn = WXt;
var UXt = 1 / 0, TA = ji ? ji.prototype : void 0, EA = TA ? TA.toString : void 0;
function KN(e) {
  if (typeof e == "string")
    return e;
  if (Yn(e))
    return Sh(e, KN) + "";
  if (mc(e))
    return EA ? EA.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -UXt ? "-0" : t;
}
var jXt = /\s/;
function XXt(e) {
  for (var t = e.length; t-- && jXt.test(e.charAt(t)); )
    ;
  return t;
}
var GXt = /^\s+/;
function HXt(e) {
  return e && e.slice(0, XXt(e) + 1).replace(GXt, "");
}
var AA = 0 / 0, KXt = /^[-+]0x[0-9a-f]+$/i, JXt = /^0b[01]+$/i, tGt = /^0o[0-7]+$/i, eGt = parseInt;
function nGt(e) {
  if (typeof e == "number")
    return e;
  if (mc(e))
    return AA;
  if (xi(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = xi(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = HXt(e);
  var n = JXt.test(e);
  return n || tGt.test(e) ? eGt(e.slice(2), n ? 2 : 8) : KXt.test(e) ? AA : +e;
}
var PA = 1 / 0, rGt = 17976931348623157e292;
function ug(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = nGt(e), e === PA || e === -PA) {
    var t = e < 0 ? -1 : 1;
    return t * rGt;
  }
  return e === e ? e : 0;
}
function iGt(e) {
  var t = ug(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function Rc(e) {
  return e;
}
var sGt = Mc(Rs, "WeakMap");
const W_ = sGt;
var DA = Object.create, oGt = function() {
  function e() {
  }
  return function(t) {
    if (!xi(t))
      return {};
    if (DA)
      return DA(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
const aGt = oGt;
function lGt(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function cGt() {
}
function JN(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var hGt = 800, uGt = 16, fGt = Date.now;
function dGt(e) {
  var t = 0, n = 0;
  return function() {
    var r = fGt(), i = uGt - (r - n);
    if (n = r, i > 0) {
      if (++t >= hGt)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function oh(e) {
  return function() {
    return e;
  };
}
var pGt = function() {
  try {
    var e = Mc(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
const Ym = pGt;
var gGt = Ym ? function(e, t) {
  return Ym(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: oh(t),
    writable: !0
  });
} : Rc;
const mGt = gGt;
var yGt = dGt(mGt);
const tB = yGt;
function eB(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function nB(e, t, n, r) {
  for (var i = e.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
function bGt(e) {
  return e !== e;
}
function OGt(e, t, n) {
  for (var r = n - 1, i = e.length; ++r < i; )
    if (e[r] === t)
      return r;
  return -1;
}
function xGt(e, t, n) {
  return t === t ? OGt(e, t, n) : nB(e, bGt, n);
}
function vGt(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && xGt(e, t, 0) > -1;
}
var _Gt = 9007199254740991, kGt = /^(?:0|[1-9]\d*)$/;
function Py(e, t) {
  var n = typeof e;
  return t = t == null ? _Gt : t, !!t && (n == "number" || n != "symbol" && kGt.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function Dy(e, t, n) {
  t == "__proto__" && Ym ? Ym(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var wGt = Object.prototype, SGt = wGt.hasOwnProperty;
function Ly(e, t, n) {
  var r = e[t];
  (!(SGt.call(e, t) && Zu(r, n)) || n === void 0 && !(t in e)) && Dy(e, t, n);
}
function Jp(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, o = t.length; ++s < o; ) {
    var a = t[s], l = r ? r(n[a], e[a], a, n, e) : void 0;
    l === void 0 && (l = e[a]), i ? Dy(n, a, l) : Ly(n, a, l);
  }
  return n;
}
var LA = Math.max;
function rB(e, t, n) {
  return t = LA(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, s = LA(r.length - t, 0), o = Array(s); ++i < s; )
      o[i] = r[t + i];
    i = -1;
    for (var a = Array(t + 1); ++i < t; )
      a[i] = r[i];
    return a[t] = n(o), lGt(e, this, a);
  };
}
function My(e, t) {
  return tB(rB(e, t, Rc), e + "");
}
var CGt = 9007199254740991;
function r5(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= CGt;
}
function gl(e) {
  return e != null && r5(e.length) && !cu(e);
}
function fp(e, t, n) {
  if (!xi(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? gl(n) && Py(t, n.length) : r == "string" && t in n) ? Zu(n[t], e) : !1;
}
function TGt(e) {
  return My(function(t, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, o = i > 2 ? n[2] : void 0;
    for (s = e.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && fp(n[0], n[1], o) && (s = i < 3 ? void 0 : s, i = 1), t = Object(t); ++r < i; ) {
      var a = n[r];
      a && e(t, a, r, s);
    }
    return t;
  });
}
var EGt = Object.prototype;
function Ry(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || EGt;
  return e === n;
}
function AGt(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var PGt = "[object Arguments]";
function MA(e) {
  return yo(e) && Dc(e) == PGt;
}
var iB = Object.prototype, DGt = iB.hasOwnProperty, LGt = iB.propertyIsEnumerable, MGt = MA(function() {
  return arguments;
}()) ? MA : function(e) {
  return yo(e) && DGt.call(e, "callee") && !LGt.call(e, "callee");
};
const uu = MGt;
function RGt() {
  return !1;
}
var sB = typeof exports == "object" && exports && !exports.nodeType && exports, RA = sB && typeof module == "object" && module && !module.nodeType && module, $Gt = RA && RA.exports === sB, $A = $Gt ? Rs.Buffer : void 0, IGt = $A ? $A.isBuffer : void 0, NGt = IGt || RGt;
const fu = NGt;
var BGt = "[object Arguments]", FGt = "[object Array]", QGt = "[object Boolean]", ZGt = "[object Date]", VGt = "[object Error]", YGt = "[object Function]", zGt = "[object Map]", qGt = "[object Number]", WGt = "[object Object]", UGt = "[object RegExp]", jGt = "[object Set]", XGt = "[object String]", GGt = "[object WeakMap]", HGt = "[object ArrayBuffer]", KGt = "[object DataView]", JGt = "[object Float32Array]", tHt = "[object Float64Array]", eHt = "[object Int8Array]", nHt = "[object Int16Array]", rHt = "[object Int32Array]", iHt = "[object Uint8Array]", sHt = "[object Uint8ClampedArray]", oHt = "[object Uint16Array]", aHt = "[object Uint32Array]", rn = {};
rn[JGt] = rn[tHt] = rn[eHt] = rn[nHt] = rn[rHt] = rn[iHt] = rn[sHt] = rn[oHt] = rn[aHt] = !0;
rn[BGt] = rn[FGt] = rn[HGt] = rn[QGt] = rn[KGt] = rn[ZGt] = rn[VGt] = rn[YGt] = rn[zGt] = rn[qGt] = rn[WGt] = rn[UGt] = rn[jGt] = rn[XGt] = rn[GGt] = !1;
function lHt(e) {
  return yo(e) && r5(e.length) && !!rn[Dc(e)];
}
function $y(e) {
  return function(t) {
    return e(t);
  };
}
var oB = typeof exports == "object" && exports && !exports.nodeType && exports, ed = oB && typeof module == "object" && module && !module.nodeType && module, cHt = ed && ed.exports === oB, ix = cHt && zN.process, hHt = function() {
  try {
    var e = ed && ed.require && ed.require("util").types;
    return e || ix && ix.binding && ix.binding("util");
  } catch {
  }
}();
const du = hHt;
var IA = du && du.isTypedArray, uHt = IA ? $y(IA) : lHt;
const Iy = uHt;
var fHt = Object.prototype, dHt = fHt.hasOwnProperty;
function aB(e, t) {
  var n = Yn(e), r = !n && uu(e), i = !n && !r && fu(e), s = !n && !r && !i && Iy(e), o = n || r || i || s, a = o ? AGt(e.length, String) : [], l = a.length;
  for (var h in e)
    (t || dHt.call(e, h)) && !(o && (h == "length" || i && (h == "offset" || h == "parent") || s && (h == "buffer" || h == "byteLength" || h == "byteOffset") || Py(h, l))) && a.push(h);
  return a;
}
function lB(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var pHt = lB(Object.keys, Object);
const gHt = pHt;
var mHt = Object.prototype, yHt = mHt.hasOwnProperty;
function cB(e) {
  if (!Ry(e))
    return gHt(e);
  var t = [];
  for (var n in Object(e))
    yHt.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function gi(e) {
  return gl(e) ? aB(e) : cB(e);
}
function bHt(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var OHt = Object.prototype, xHt = OHt.hasOwnProperty;
function vHt(e) {
  if (!xi(e))
    return bHt(e);
  var t = Ry(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !xHt.call(e, r)) || n.push(r);
  return n;
}
function $c(e) {
  return gl(e) ? aB(e, !0) : vHt(e);
}
var _Ht = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, kHt = /^\w*$/;
function i5(e, t) {
  if (Yn(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || mc(e) ? !0 : kHt.test(e) || !_Ht.test(e) || t != null && e in Object(t);
}
var wHt = 500;
function SHt(e) {
  var t = Vu(e, function(r) {
    return n.size === wHt && n.clear(), r;
  }), n = t.cache;
  return t;
}
var CHt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, THt = /\\(\\)?/g, EHt = SHt(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(CHt, function(n, r, i, s) {
    t.push(i ? s.replace(THt, "$1") : r || n);
  }), t;
});
const AHt = EHt;
function hB(e) {
  return e == null ? "" : KN(e);
}
function Ny(e, t) {
  return Yn(e) ? e : i5(e, t) ? [e] : AHt(hB(e));
}
var PHt = 1 / 0;
function t0(e) {
  if (typeof e == "string" || mc(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -PHt ? "-0" : t;
}
function By(e, t) {
  t = Ny(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[t0(t[n++])];
  return n && n == r ? e : void 0;
}
function DHt(e, t, n) {
  var r = e == null ? void 0 : By(e, t);
  return r === void 0 ? n : r;
}
function s5(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var NA = ji ? ji.isConcatSpreadable : void 0;
function LHt(e) {
  return Yn(e) || uu(e) || !!(NA && e && e[NA]);
}
function Fy(e, t, n, r, i) {
  var s = -1, o = e.length;
  for (n || (n = LHt), i || (i = []); ++s < o; ) {
    var a = e[s];
    t > 0 && n(a) ? t > 1 ? Fy(a, t - 1, n, r, i) : s5(i, a) : r || (i[i.length] = a);
  }
  return i;
}
function zu(e) {
  var t = e == null ? 0 : e.length;
  return t ? Fy(e, 1) : [];
}
function MHt(e) {
  return tB(rB(e, void 0, zu), e + "");
}
var RHt = lB(Object.getPrototypeOf, Object);
const o5 = RHt;
var $Ht = "[object Object]", IHt = Function.prototype, NHt = Object.prototype, uB = IHt.toString, BHt = NHt.hasOwnProperty, FHt = uB.call(Object);
function fB(e) {
  if (!yo(e) || Dc(e) != $Ht)
    return !1;
  var t = o5(e);
  if (t === null)
    return !0;
  var n = BHt.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && uB.call(n) == FHt;
}
function QHt(e, t, n, r) {
  var i = -1, s = e == null ? 0 : e.length;
  for (r && s && (n = e[++i]); ++i < s; )
    n = t(n, e[i], i, e);
  return n;
}
function ZHt() {
  this.__data__ = new xa(), this.size = 0;
}
function VHt(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function YHt(e) {
  return this.__data__.get(e);
}
function zHt(e) {
  return this.__data__.has(e);
}
var qHt = 200;
function WHt(e, t) {
  var n = this.__data__;
  if (n instanceof xa) {
    var r = n.__data__;
    if (!cp || r.length < qHt - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new va(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function gs(e) {
  var t = this.__data__ = new xa(e);
  this.size = t.size;
}
gs.prototype.clear = ZHt;
gs.prototype.delete = VHt;
gs.prototype.get = YHt;
gs.prototype.has = zHt;
gs.prototype.set = WHt;
function UHt(e, t) {
  return e && Jp(t, gi(t), e);
}
function jHt(e, t) {
  return e && Jp(t, $c(t), e);
}
var dB = typeof exports == "object" && exports && !exports.nodeType && exports, BA = dB && typeof module == "object" && module && !module.nodeType && module, XHt = BA && BA.exports === dB, FA = XHt ? Rs.Buffer : void 0, QA = FA ? FA.allocUnsafe : void 0;
function pB(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = QA ? QA(n) : new e.constructor(n);
  return e.copy(r), r;
}
function gB(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var o = e[n];
    t(o, n, e) && (s[i++] = o);
  }
  return s;
}
function mB() {
  return [];
}
var GHt = Object.prototype, HHt = GHt.propertyIsEnumerable, ZA = Object.getOwnPropertySymbols, KHt = ZA ? function(e) {
  return e == null ? [] : (e = Object(e), gB(ZA(e), function(t) {
    return HHt.call(e, t);
  }));
} : mB;
const a5 = KHt;
function JHt(e, t) {
  return Jp(e, a5(e), t);
}
var tKt = Object.getOwnPropertySymbols, eKt = tKt ? function(e) {
  for (var t = []; e; )
    s5(t, a5(e)), e = o5(e);
  return t;
} : mB;
const yB = eKt;
function nKt(e, t) {
  return Jp(e, yB(e), t);
}
function bB(e, t, n) {
  var r = t(e);
  return Yn(e) ? r : s5(r, n(e));
}
function U_(e) {
  return bB(e, gi, a5);
}
function rKt(e) {
  return bB(e, $c, yB);
}
var iKt = Mc(Rs, "DataView");
const j_ = iKt;
var sKt = Mc(Rs, "Promise");
const X_ = sKt;
var oKt = Mc(Rs, "Set");
const Ch = oKt;
var VA = "[object Map]", aKt = "[object Object]", YA = "[object Promise]", zA = "[object Set]", qA = "[object WeakMap]", WA = "[object DataView]", lKt = Lc(j_), cKt = Lc(cp), hKt = Lc(X_), uKt = Lc(Ch), fKt = Lc(W_), Al = Dc;
(j_ && Al(new j_(new ArrayBuffer(1))) != WA || cp && Al(new cp()) != VA || X_ && Al(X_.resolve()) != YA || Ch && Al(new Ch()) != zA || W_ && Al(new W_()) != qA) && (Al = function(e) {
  var t = Dc(e), n = t == aKt ? e.constructor : void 0, r = n ? Lc(n) : "";
  if (r)
    switch (r) {
      case lKt:
        return WA;
      case cKt:
        return VA;
      case hKt:
        return YA;
      case uKt:
        return zA;
      case fKt:
        return qA;
    }
  return t;
});
const pu = Al;
var dKt = Object.prototype, pKt = dKt.hasOwnProperty;
function gKt(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && pKt.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var mKt = Rs.Uint8Array;
const zm = mKt;
function l5(e) {
  var t = new e.constructor(e.byteLength);
  return new zm(t).set(new zm(e)), t;
}
function yKt(e, t) {
  var n = t ? l5(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var bKt = /\w*$/;
function OKt(e) {
  var t = new e.constructor(e.source, bKt.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var UA = ji ? ji.prototype : void 0, jA = UA ? UA.valueOf : void 0;
function xKt(e) {
  return jA ? Object(jA.call(e)) : {};
}
function OB(e, t) {
  var n = t ? l5(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var vKt = "[object Boolean]", _Kt = "[object Date]", kKt = "[object Map]", wKt = "[object Number]", SKt = "[object RegExp]", CKt = "[object Set]", TKt = "[object String]", EKt = "[object Symbol]", AKt = "[object ArrayBuffer]", PKt = "[object DataView]", DKt = "[object Float32Array]", LKt = "[object Float64Array]", MKt = "[object Int8Array]", RKt = "[object Int16Array]", $Kt = "[object Int32Array]", IKt = "[object Uint8Array]", NKt = "[object Uint8ClampedArray]", BKt = "[object Uint16Array]", FKt = "[object Uint32Array]";
function QKt(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case AKt:
      return l5(e);
    case vKt:
    case _Kt:
      return new r(+e);
    case PKt:
      return yKt(e, n);
    case DKt:
    case LKt:
    case MKt:
    case RKt:
    case $Kt:
    case IKt:
    case NKt:
    case BKt:
    case FKt:
      return OB(e, n);
    case kKt:
      return new r();
    case wKt:
    case TKt:
      return new r(e);
    case SKt:
      return OKt(e);
    case CKt:
      return new r();
    case EKt:
      return xKt(e);
  }
}
function xB(e) {
  return typeof e.constructor == "function" && !Ry(e) ? aGt(o5(e)) : {};
}
var ZKt = "[object Map]";
function VKt(e) {
  return yo(e) && pu(e) == ZKt;
}
var XA = du && du.isMap, YKt = XA ? $y(XA) : VKt;
const zKt = YKt;
var qKt = "[object Set]";
function WKt(e) {
  return yo(e) && pu(e) == qKt;
}
var GA = du && du.isSet, UKt = GA ? $y(GA) : WKt;
const jKt = UKt;
var XKt = 1, GKt = 2, HKt = 4, vB = "[object Arguments]", KKt = "[object Array]", JKt = "[object Boolean]", tJt = "[object Date]", eJt = "[object Error]", _B = "[object Function]", nJt = "[object GeneratorFunction]", rJt = "[object Map]", iJt = "[object Number]", kB = "[object Object]", sJt = "[object RegExp]", oJt = "[object Set]", aJt = "[object String]", lJt = "[object Symbol]", cJt = "[object WeakMap]", hJt = "[object ArrayBuffer]", uJt = "[object DataView]", fJt = "[object Float32Array]", dJt = "[object Float64Array]", pJt = "[object Int8Array]", gJt = "[object Int16Array]", mJt = "[object Int32Array]", yJt = "[object Uint8Array]", bJt = "[object Uint8ClampedArray]", OJt = "[object Uint16Array]", xJt = "[object Uint32Array]", Ke = {};
Ke[vB] = Ke[KKt] = Ke[hJt] = Ke[uJt] = Ke[JKt] = Ke[tJt] = Ke[fJt] = Ke[dJt] = Ke[pJt] = Ke[gJt] = Ke[mJt] = Ke[rJt] = Ke[iJt] = Ke[kB] = Ke[sJt] = Ke[oJt] = Ke[aJt] = Ke[lJt] = Ke[yJt] = Ke[bJt] = Ke[OJt] = Ke[xJt] = !0;
Ke[eJt] = Ke[_B] = Ke[cJt] = !1;
function nd(e, t, n, r, i, s) {
  var o, a = t & XKt, l = t & GKt, h = t & HKt;
  if (n && (o = i ? n(e, r, i, s) : n(e)), o !== void 0)
    return o;
  if (!xi(e))
    return e;
  var u = Yn(e);
  if (u) {
    if (o = gKt(e), !a)
      return JN(e, o);
  } else {
    var f = pu(e), d = f == _B || f == nJt;
    if (fu(e))
      return pB(e, a);
    if (f == kB || f == vB || d && !i) {
      if (o = l || d ? {} : xB(e), !a)
        return l ? nKt(e, jHt(o, e)) : JHt(e, UHt(o, e));
    } else {
      if (!Ke[f])
        return i ? e : {};
      o = QKt(e, f, a);
    }
  }
  s || (s = new gs());
  var p = s.get(e);
  if (p)
    return p;
  s.set(e, o), jKt(e) ? e.forEach(function(y) {
    o.add(nd(y, t, n, y, e, s));
  }) : zKt(e) && e.forEach(function(y, O) {
    o.set(O, nd(y, t, n, O, e, s));
  });
  var g = h ? l ? rKt : U_ : l ? $c : gi, m = u ? void 0 : g(e);
  return eB(m || e, function(y, O) {
    m && (O = y, y = e[O]), Ly(o, O, nd(y, t, n, O, e, s));
  }), o;
}
var vJt = 4;
function _Jt(e) {
  return nd(e, vJt);
}
var kJt = 1, wJt = 4;
function SJt(e) {
  return nd(e, kJt | wJt);
}
var CJt = "__lodash_hash_undefined__";
function TJt(e) {
  return this.__data__.set(e, CJt), this;
}
function EJt(e) {
  return this.__data__.has(e);
}
function dp(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new va(); ++t < n; )
    this.add(e[t]);
}
dp.prototype.add = dp.prototype.push = TJt;
dp.prototype.has = EJt;
function AJt(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function wB(e, t) {
  return e.has(t);
}
var PJt = 1, DJt = 2;
function SB(e, t, n, r, i, s) {
  var o = n & PJt, a = e.length, l = t.length;
  if (a != l && !(o && l > a))
    return !1;
  var h = s.get(e), u = s.get(t);
  if (h && u)
    return h == t && u == e;
  var f = -1, d = !0, p = n & DJt ? new dp() : void 0;
  for (s.set(e, t), s.set(t, e); ++f < a; ) {
    var g = e[f], m = t[f];
    if (r)
      var y = o ? r(m, g, f, t, e, s) : r(g, m, f, e, t, s);
    if (y !== void 0) {
      if (y)
        continue;
      d = !1;
      break;
    }
    if (p) {
      if (!AJt(t, function(O, x) {
        if (!wB(p, x) && (g === O || i(g, O, n, r, s)))
          return p.push(x);
      })) {
        d = !1;
        break;
      }
    } else if (!(g === m || i(g, m, n, r, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), d;
}
function LJt(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
function c5(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var MJt = 1, RJt = 2, $Jt = "[object Boolean]", IJt = "[object Date]", NJt = "[object Error]", BJt = "[object Map]", FJt = "[object Number]", QJt = "[object RegExp]", ZJt = "[object Set]", VJt = "[object String]", YJt = "[object Symbol]", zJt = "[object ArrayBuffer]", qJt = "[object DataView]", HA = ji ? ji.prototype : void 0, sx = HA ? HA.valueOf : void 0;
function WJt(e, t, n, r, i, s, o) {
  switch (n) {
    case qJt:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case zJt:
      return !(e.byteLength != t.byteLength || !s(new zm(e), new zm(t)));
    case $Jt:
    case IJt:
    case FJt:
      return Zu(+e, +t);
    case NJt:
      return e.name == t.name && e.message == t.message;
    case QJt:
    case VJt:
      return e == t + "";
    case BJt:
      var a = LJt;
    case ZJt:
      var l = r & MJt;
      if (a || (a = c5), e.size != t.size && !l)
        return !1;
      var h = o.get(e);
      if (h)
        return h == t;
      r |= RJt, o.set(e, t);
      var u = SB(a(e), a(t), r, i, s, o);
      return o.delete(e), u;
    case YJt:
      if (sx)
        return sx.call(e) == sx.call(t);
  }
  return !1;
}
var UJt = 1, jJt = Object.prototype, XJt = jJt.hasOwnProperty;
function GJt(e, t, n, r, i, s) {
  var o = n & UJt, a = U_(e), l = a.length, h = U_(t), u = h.length;
  if (l != u && !o)
    return !1;
  for (var f = l; f--; ) {
    var d = a[f];
    if (!(o ? d in t : XJt.call(t, d)))
      return !1;
  }
  var p = s.get(e), g = s.get(t);
  if (p && g)
    return p == t && g == e;
  var m = !0;
  s.set(e, t), s.set(t, e);
  for (var y = o; ++f < l; ) {
    d = a[f];
    var O = e[d], x = t[d];
    if (r)
      var _ = o ? r(x, O, d, t, e, s) : r(O, x, d, e, t, s);
    if (!(_ === void 0 ? O === x || i(O, x, n, r, s) : _)) {
      m = !1;
      break;
    }
    y || (y = d == "constructor");
  }
  if (m && !y) {
    var w = e.constructor, E = t.constructor;
    w != E && "constructor" in e && "constructor" in t && !(typeof w == "function" && w instanceof w && typeof E == "function" && E instanceof E) && (m = !1);
  }
  return s.delete(e), s.delete(t), m;
}
var HJt = 1, KA = "[object Arguments]", JA = "[object Array]", m1 = "[object Object]", KJt = Object.prototype, t8 = KJt.hasOwnProperty;
function JJt(e, t, n, r, i, s) {
  var o = Yn(e), a = Yn(t), l = o ? JA : pu(e), h = a ? JA : pu(t);
  l = l == KA ? m1 : l, h = h == KA ? m1 : h;
  var u = l == m1, f = h == m1, d = l == h;
  if (d && fu(e)) {
    if (!fu(t))
      return !1;
    o = !0, u = !1;
  }
  if (d && !u)
    return s || (s = new gs()), o || Iy(e) ? SB(e, t, n, r, i, s) : WJt(e, t, l, n, r, i, s);
  if (!(n & HJt)) {
    var p = u && t8.call(e, "__wrapped__"), g = f && t8.call(t, "__wrapped__");
    if (p || g) {
      var m = p ? e.value() : e, y = g ? t.value() : t;
      return s || (s = new gs()), i(m, y, n, r, s);
    }
  }
  return d ? (s || (s = new gs()), GJt(e, t, n, r, i, s)) : !1;
}
function h5(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !yo(e) && !yo(t) ? e !== e && t !== t : JJt(e, t, n, r, h5, i);
}
var tte = 1, ete = 2;
function nte(e, t, n, r) {
  var i = n.length, s = i, o = !r;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var a = n[i];
    if (o && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    a = n[i];
    var l = a[0], h = e[l], u = a[1];
    if (o && a[2]) {
      if (h === void 0 && !(l in e))
        return !1;
    } else {
      var f = new gs();
      if (r)
        var d = r(h, u, l, e, t, f);
      if (!(d === void 0 ? h5(u, h, tte | ete, r, f) : d))
        return !1;
    }
  }
  return !0;
}
function CB(e) {
  return e === e && !xi(e);
}
function rte(e) {
  for (var t = gi(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, CB(i)];
  }
  return t;
}
function TB(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function ite(e) {
  var t = rte(e);
  return t.length == 1 && t[0][2] ? TB(t[0][0], t[0][1]) : function(n) {
    return n === e || nte(n, e, t);
  };
}
function ste(e, t) {
  return e != null && t in Object(e);
}
function EB(e, t, n) {
  t = Ny(t, e);
  for (var r = -1, i = t.length, s = !1; ++r < i; ) {
    var o = t0(t[r]);
    if (!(s = e != null && n(e, o)))
      break;
    e = e[o];
  }
  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && r5(i) && Py(o, i) && (Yn(e) || uu(e)));
}
function AB(e, t) {
  return e != null && EB(e, t, ste);
}
var ote = 1, ate = 2;
function lte(e, t) {
  return i5(e) && CB(t) ? TB(t0(e), t) : function(n) {
    var r = DHt(n, e);
    return r === void 0 && r === t ? AB(n, e) : h5(t, r, ote | ate);
  };
}
function cte(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function hte(e) {
  return function(t) {
    return By(t, e);
  };
}
function ute(e) {
  return i5(e) ? cte(t0(e)) : hte(e);
}
function ml(e) {
  return typeof e == "function" ? e : e == null ? Rc : typeof e == "object" ? Yn(e) ? lte(e[0], e[1]) : ite(e) : ute(e);
}
function fte(e) {
  return function(t, n, r) {
    for (var i = -1, s = Object(t), o = r(t), a = o.length; a--; ) {
      var l = o[e ? a : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return t;
  };
}
var dte = fte();
const u5 = dte;
function PB(e, t) {
  return e && u5(e, t, gi);
}
function pte(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!gl(n))
      return e(n, r);
    for (var i = n.length, s = t ? i : -1, o = Object(n); (t ? s-- : ++s < i) && r(o[s], s, o) !== !1; )
      ;
    return n;
  };
}
var gte = pte(PB);
const Qy = gte;
var mte = function() {
  return Rs.Date.now();
};
const e8 = mte;
var DB = Object.prototype, yte = DB.hasOwnProperty, bte = My(function(e, t) {
  e = Object(e);
  var n = -1, r = t.length, i = r > 2 ? t[2] : void 0;
  for (i && fp(t[0], t[1], i) && (r = 1); ++n < r; )
    for (var s = t[n], o = $c(s), a = -1, l = o.length; ++a < l; ) {
      var h = o[a], u = e[h];
      (u === void 0 || Zu(u, DB[h]) && !yte.call(e, h)) && (e[h] = s[h]);
    }
  return e;
});
const Xc = bte;
function G_(e, t, n) {
  (n !== void 0 && !Zu(e[t], n) || n === void 0 && !(t in e)) && Dy(e, t, n);
}
function LB(e) {
  return yo(e) && gl(e);
}
function H_(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function Ote(e) {
  return Jp(e, $c(e));
}
function xte(e, t, n, r, i, s, o) {
  var a = H_(e, n), l = H_(t, n), h = o.get(l);
  if (h) {
    G_(e, n, h);
    return;
  }
  var u = s ? s(a, l, n + "", e, t, o) : void 0, f = u === void 0;
  if (f) {
    var d = Yn(l), p = !d && fu(l), g = !d && !p && Iy(l);
    u = l, d || p || g ? Yn(a) ? u = a : LB(a) ? u = JN(a) : p ? (f = !1, u = pB(l, !0)) : g ? (f = !1, u = OB(l, !0)) : u = [] : fB(l) || uu(l) ? (u = a, uu(a) ? u = Ote(a) : (!xi(a) || cu(a)) && (u = xB(l))) : f = !1;
  }
  f && (o.set(l, u), i(u, l, r, s, o), o.delete(l)), G_(e, n, u);
}
function MB(e, t, n, r, i) {
  e !== t && u5(t, function(s, o) {
    if (i || (i = new gs()), xi(s))
      xte(e, t, o, n, MB, r, i);
    else {
      var a = r ? r(H_(e, o), s, o + "", e, t, i) : void 0;
      a === void 0 && (a = s), G_(e, o, a);
    }
  }, $c);
}
function vte(e, t, n) {
  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
    if (n(t, e[r]))
      return !0;
  return !1;
}
function qm(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function RB(e) {
  return typeof e == "function" ? e : Rc;
}
function Ot(e, t) {
  var n = Yn(e) ? eB : Qy;
  return n(e, RB(t));
}
function _te(e, t) {
  var n = [];
  return Qy(e, function(r, i, s) {
    t(r, i, s) && n.push(r);
  }), n;
}
function Uo(e, t) {
  var n = Yn(e) ? gB : _te;
  return n(e, ml(t));
}
function kte(e) {
  return function(t, n, r) {
    var i = Object(t);
    if (!gl(t)) {
      var s = ml(n);
      t = gi(t), n = function(a) {
        return s(i[a], a, i);
      };
    }
    var o = e(t, n, r);
    return o > -1 ? i[s ? t[o] : o] : void 0;
  };
}
var wte = Math.max;
function Ste(e, t, n) {
  var r = e == null ? 0 : e.length;
  if (!r)
    return -1;
  var i = n == null ? 0 : iGt(n);
  return i < 0 && (i = wte(r + i, 0)), nB(e, ml(t), i);
}
var Cte = kte(Ste);
const f5 = Cte;
function $B(e, t) {
  var n = -1, r = gl(e) ? Array(e.length) : [];
  return Qy(e, function(i, s, o) {
    r[++n] = t(i, s, o);
  }), r;
}
function Vn(e, t) {
  var n = Yn(e) ? Sh : $B;
  return n(e, ml(t));
}
function Tte(e, t) {
  return e == null ? e : u5(e, RB(t), $c);
}
function Ete(e, t) {
  return e > t;
}
var Ate = Object.prototype, Pte = Ate.hasOwnProperty;
function Dte(e, t) {
  return e != null && Pte.call(e, t);
}
function ve(e, t) {
  return e != null && EB(e, t, Dte);
}
function Lte(e, t) {
  return Sh(t, function(n) {
    return e[n];
  });
}
function na(e) {
  return e == null ? [] : Lte(e, gi(e));
}
var Mte = "[object Map]", Rte = "[object Set]", $te = Object.prototype, Ite = $te.hasOwnProperty;
function Th(e) {
  if (e == null)
    return !0;
  if (gl(e) && (Yn(e) || typeof e == "string" || typeof e.splice == "function" || fu(e) || Iy(e) || uu(e)))
    return !e.length;
  var t = pu(e);
  if (t == Mte || t == Rte)
    return !e.size;
  if (Ry(e))
    return !cB(e).length;
  for (var n in e)
    if (Ite.call(e, n))
      return !1;
  return !0;
}
function An(e) {
  return e === void 0;
}
function IB(e, t) {
  return e < t;
}
function Zy(e, t) {
  var n = {};
  return t = ml(t), PB(e, function(r, i, s) {
    Dy(n, i, t(r, i, s));
  }), n;
}
function d5(e, t, n) {
  for (var r = -1, i = e.length; ++r < i; ) {
    var s = e[r], o = t(s);
    if (o != null && (a === void 0 ? o === o && !mc(o) : n(o, a)))
      var a = o, l = s;
  }
  return l;
}
function yc(e) {
  return e && e.length ? d5(e, Rc, Ete) : void 0;
}
var Nte = TGt(function(e, t, n) {
  MB(e, t, n);
});
const K_ = Nte;
function pp(e) {
  return e && e.length ? d5(e, Rc, IB) : void 0;
}
function p5(e, t) {
  return e && e.length ? d5(e, ml(t), IB) : void 0;
}
function Bte(e, t, n, r) {
  if (!xi(e))
    return e;
  t = Ny(t, e);
  for (var i = -1, s = t.length, o = s - 1, a = e; a != null && ++i < s; ) {
    var l = t0(t[i]), h = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (i != o) {
      var u = a[l];
      h = r ? r(u, l, a) : void 0, h === void 0 && (h = xi(u) ? u : Py(t[i + 1]) ? [] : {});
    }
    Ly(a, l, h), a = a[l];
  }
  return e;
}
function Fte(e, t, n) {
  for (var r = -1, i = t.length, s = {}; ++r < i; ) {
    var o = t[r], a = By(e, o);
    n(a, o) && Bte(s, Ny(o, e), a);
  }
  return s;
}
function Qte(e, t) {
  var n = e.length;
  for (e.sort(t); n--; )
    e[n] = e[n].value;
  return e;
}
function Zte(e, t) {
  if (e !== t) {
    var n = e !== void 0, r = e === null, i = e === e, s = mc(e), o = t !== void 0, a = t === null, l = t === t, h = mc(t);
    if (!a && !h && !s && e > t || s && o && l && !a && !h || r && o && l || !n && l || !i)
      return 1;
    if (!r && !s && !h && e < t || h && n && i && !r && !s || a && n && i || !o && i || !l)
      return -1;
  }
  return 0;
}
function Vte(e, t, n) {
  for (var r = -1, i = e.criteria, s = t.criteria, o = i.length, a = n.length; ++r < o; ) {
    var l = Zte(i[r], s[r]);
    if (l) {
      if (r >= a)
        return l;
      var h = n[r];
      return l * (h == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
function Yte(e, t, n) {
  t.length ? t = Sh(t, function(s) {
    return Yn(s) ? function(o) {
      return By(o, s.length === 1 ? s[0] : s);
    } : s;
  }) : t = [Rc];
  var r = -1;
  t = Sh(t, $y(ml));
  var i = $B(e, function(s, o, a) {
    var l = Sh(t, function(h) {
      return h(s);
    });
    return { criteria: l, index: ++r, value: s };
  });
  return Qte(i, function(s, o) {
    return Vte(s, o, n);
  });
}
function zte(e, t) {
  return Fte(e, t, function(n, r) {
    return AB(e, r);
  });
}
var qte = MHt(function(e, t) {
  return e == null ? {} : zte(e, t);
});
const gp = qte;
var Wte = Math.ceil, Ute = Math.max;
function jte(e, t, n, r) {
  for (var i = -1, s = Ute(Wte((t - e) / (n || 1)), 0), o = Array(s); s--; )
    o[r ? s : ++i] = e, e += n;
  return o;
}
function Xte(e) {
  return function(t, n, r) {
    return r && typeof r != "number" && fp(t, n, r) && (n = r = void 0), t = ug(t), n === void 0 ? (n = t, t = 0) : n = ug(n), r = r === void 0 ? t < n ? 1 : -1 : ug(r), jte(t, n, r, e);
  };
}
var Gte = Xte();
const bc = Gte;
function Hte(e, t, n, r, i) {
  return i(e, function(s, o, a) {
    n = r ? (r = !1, s) : t(n, s, o, a);
  }), n;
}
function e0(e, t, n) {
  var r = Yn(e) ? QHt : Hte, i = arguments.length < 3;
  return r(e, ml(t), n, i, Qy);
}
var Kte = My(function(e, t) {
  if (e == null)
    return [];
  var n = t.length;
  return n > 1 && fp(e, t[0], t[1]) ? t = [] : n > 2 && fp(t[0], t[1], t[2]) && (t = [t[0]]), Yte(e, Fy(t, 1), []);
});
const n0 = Kte;
var Jte = 1 / 0, tee = Ch && 1 / c5(new Ch([, -0]))[1] == Jte ? function(e) {
  return new Ch(e);
} : cGt;
const eee = tee;
var nee = 200;
function ree(e, t, n) {
  var r = -1, i = vGt, s = e.length, o = !0, a = [], l = a;
  if (n)
    o = !1, i = vte;
  else if (s >= nee) {
    var h = t ? null : eee(e);
    if (h)
      return c5(h);
    o = !1, i = wB, l = new dp();
  } else
    l = t ? [] : a;
  t:
    for (; ++r < s; ) {
      var u = e[r], f = t ? t(u) : u;
      if (u = n || u !== 0 ? u : 0, o && f === f) {
        for (var d = l.length; d--; )
          if (l[d] === f)
            continue t;
        t && l.push(f), a.push(u);
      } else
        i(l, f, n) || (l !== a && l.push(f), a.push(u));
    }
  return a;
}
var iee = My(function(e) {
  return ree(Fy(e, 1, LB, !0));
});
const see = iee;
var oee = 0;
function Vy(e) {
  var t = ++oee;
  return hB(e) + t;
}
function aee(e, t, n) {
  for (var r = -1, i = e.length, s = t.length, o = {}; ++r < i; ) {
    var a = r < s ? t[r] : void 0;
    n(o, e[r], a);
  }
  return o;
}
function lee(e, t) {
  return aee(e || [], t || [], Ly);
}
var cee = "\0", Cl = "\0", n8 = "";
class zn {
  constructor(t = {}) {
    this._isDirected = ve(t, "directed") ? t.directed : !0, this._isMultigraph = ve(t, "multigraph") ? t.multigraph : !1, this._isCompound = ve(t, "compound") ? t.compound : !1, this._label = void 0, this._defaultNodeLabelFn = oh(void 0), this._defaultEdgeLabelFn = oh(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[Cl] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  isDirected() {
    return this._isDirected;
  }
  isMultigraph() {
    return this._isMultigraph;
  }
  isCompound() {
    return this._isCompound;
  }
  setGraph(t) {
    return this._label = t, this;
  }
  graph() {
    return this._label;
  }
  setDefaultNodeLabel(t) {
    return cu(t) || (t = oh(t)), this._defaultNodeLabelFn = t, this;
  }
  nodeCount() {
    return this._nodeCount;
  }
  nodes() {
    return gi(this._nodes);
  }
  sources() {
    var t = this;
    return Uo(this.nodes(), function(n) {
      return Th(t._in[n]);
    });
  }
  sinks() {
    var t = this;
    return Uo(this.nodes(), function(n) {
      return Th(t._out[n]);
    });
  }
  setNodes(t, n) {
    var r = arguments, i = this;
    return Ot(t, function(s) {
      r.length > 1 ? i.setNode(s, n) : i.setNode(s);
    }), this;
  }
  setNode(t, n) {
    return ve(this._nodes, t) ? (arguments.length > 1 && (this._nodes[t] = n), this) : (this._nodes[t] = arguments.length > 1 ? n : this._defaultNodeLabelFn(t), this._isCompound && (this._parent[t] = Cl, this._children[t] = {}, this._children[Cl][t] = !0), this._in[t] = {}, this._preds[t] = {}, this._out[t] = {}, this._sucs[t] = {}, ++this._nodeCount, this);
  }
  node(t) {
    return this._nodes[t];
  }
  hasNode(t) {
    return ve(this._nodes, t);
  }
  removeNode(t) {
    var n = this;
    if (ve(this._nodes, t)) {
      var r = function(i) {
        n.removeEdge(n._edgeObjs[i]);
      };
      delete this._nodes[t], this._isCompound && (this._removeFromParentsChildList(t), delete this._parent[t], Ot(this.children(t), function(i) {
        n.setParent(i);
      }), delete this._children[t]), Ot(gi(this._in[t]), r), delete this._in[t], delete this._preds[t], Ot(gi(this._out[t]), r), delete this._out[t], delete this._sucs[t], --this._nodeCount;
    }
    return this;
  }
  setParent(t, n) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (An(n))
      n = Cl;
    else {
      n += "";
      for (var r = n; !An(r); r = this.parent(r))
        if (r === t)
          throw new Error("Setting " + n + " as parent of " + t + " would create a cycle");
      this.setNode(n);
    }
    return this.setNode(t), this._removeFromParentsChildList(t), this._parent[t] = n, this._children[n][t] = !0, this;
  }
  _removeFromParentsChildList(t) {
    delete this._children[this._parent[t]][t];
  }
  parent(t) {
    if (this._isCompound) {
      var n = this._parent[t];
      if (n !== Cl)
        return n;
    }
  }
  children(t) {
    if (An(t) && (t = Cl), this._isCompound) {
      var n = this._children[t];
      if (n)
        return gi(n);
    } else {
      if (t === Cl)
        return this.nodes();
      if (this.hasNode(t))
        return [];
    }
  }
  predecessors(t) {
    var n = this._preds[t];
    if (n)
      return gi(n);
  }
  successors(t) {
    var n = this._sucs[t];
    if (n)
      return gi(n);
  }
  neighbors(t) {
    var n = this.predecessors(t);
    if (n)
      return see(n, this.successors(t));
  }
  isLeaf(t) {
    var n;
    return this.isDirected() ? n = this.successors(t) : n = this.neighbors(t), n.length === 0;
  }
  filterNodes(t) {
    var n = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    n.setGraph(this.graph());
    var r = this;
    Ot(this._nodes, function(o, a) {
      t(a) && n.setNode(a, o);
    }), Ot(this._edgeObjs, function(o) {
      n.hasNode(o.v) && n.hasNode(o.w) && n.setEdge(o, r.edge(o));
    });
    var i = {};
    function s(o) {
      var a = r.parent(o);
      return a === void 0 || n.hasNode(a) ? (i[o] = a, a) : a in i ? i[a] : s(a);
    }
    return this._isCompound && Ot(n.nodes(), function(o) {
      n.setParent(o, s(o));
    }), n;
  }
  setDefaultEdgeLabel(t) {
    return cu(t) || (t = oh(t)), this._defaultEdgeLabelFn = t, this;
  }
  edgeCount() {
    return this._edgeCount;
  }
  edges() {
    return na(this._edgeObjs);
  }
  setPath(t, n) {
    var r = this, i = arguments;
    return e0(t, function(s, o) {
      return i.length > 1 ? r.setEdge(s, o, n) : r.setEdge(s, o), o;
    }), this;
  }
  setEdge() {
    var t, n, r, i, s = !1, o = arguments[0];
    typeof o == "object" && o !== null && "v" in o ? (t = o.v, n = o.w, r = o.name, arguments.length === 2 && (i = arguments[1], s = !0)) : (t = o, n = arguments[1], r = arguments[3], arguments.length > 2 && (i = arguments[2], s = !0)), t = "" + t, n = "" + n, An(r) || (r = "" + r);
    var a = Rf(this._isDirected, t, n, r);
    if (ve(this._edgeLabels, a))
      return s && (this._edgeLabels[a] = i), this;
    if (!An(r) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(t), this.setNode(n), this._edgeLabels[a] = s ? i : this._defaultEdgeLabelFn(t, n, r);
    var l = hee(this._isDirected, t, n, r);
    return t = l.v, n = l.w, Object.freeze(l), this._edgeObjs[a] = l, r8(this._preds[n], t), r8(this._sucs[t], n), this._in[n][a] = l, this._out[t][a] = l, this._edgeCount++, this;
  }
  edge(t, n, r) {
    var i = arguments.length === 1 ? ox(this._isDirected, arguments[0]) : Rf(this._isDirected, t, n, r);
    return this._edgeLabels[i];
  }
  hasEdge(t, n, r) {
    var i = arguments.length === 1 ? ox(this._isDirected, arguments[0]) : Rf(this._isDirected, t, n, r);
    return ve(this._edgeLabels, i);
  }
  removeEdge(t, n, r) {
    var i = arguments.length === 1 ? ox(this._isDirected, arguments[0]) : Rf(this._isDirected, t, n, r), s = this._edgeObjs[i];
    return s && (t = s.v, n = s.w, delete this._edgeLabels[i], delete this._edgeObjs[i], i8(this._preds[n], t), i8(this._sucs[t], n), delete this._in[n][i], delete this._out[t][i], this._edgeCount--), this;
  }
  inEdges(t, n) {
    var r = this._in[t];
    if (r) {
      var i = na(r);
      return n ? Uo(i, function(s) {
        return s.v === n;
      }) : i;
    }
  }
  outEdges(t, n) {
    var r = this._out[t];
    if (r) {
      var i = na(r);
      return n ? Uo(i, function(s) {
        return s.w === n;
      }) : i;
    }
  }
  nodeEdges(t, n) {
    var r = this.inEdges(t, n);
    if (r)
      return r.concat(this.outEdges(t, n));
  }
}
zn.prototype._nodeCount = 0;
zn.prototype._edgeCount = 0;
function r8(e, t) {
  e[t] ? e[t]++ : e[t] = 1;
}
function i8(e, t) {
  --e[t] || delete e[t];
}
function Rf(e, t, n, r) {
  var i = "" + t, s = "" + n;
  if (!e && i > s) {
    var o = i;
    i = s, s = o;
  }
  return i + n8 + s + n8 + (An(r) ? cee : r);
}
function hee(e, t, n, r) {
  var i = "" + t, s = "" + n;
  if (!e && i > s) {
    var o = i;
    i = s, s = o;
  }
  var a = { v: i, w: s };
  return r && (a.name = r), a;
}
function ox(e, t) {
  return Rf(e, t.v, t.w, t.name);
}
class uee {
  constructor() {
    var t = {};
    t._next = t._prev = t, this._sentinel = t;
  }
  dequeue() {
    var t = this._sentinel, n = t._prev;
    if (n !== t)
      return s8(n), n;
  }
  enqueue(t) {
    var n = this._sentinel;
    t._prev && t._next && s8(t), t._next = n._next, n._next._prev = t, n._next = t, t._prev = n;
  }
  toString() {
    for (var t = [], n = this._sentinel, r = n._prev; r !== n; )
      t.push(JSON.stringify(r, fee)), r = r._prev;
    return "[" + t.join(", ") + "]";
  }
}
function s8(e) {
  e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;
}
function fee(e, t) {
  if (e !== "_next" && e !== "_prev")
    return t;
}
var dee = oh(1);
function pee(e, t) {
  if (e.nodeCount() <= 1)
    return [];
  var n = mee(e, t || dee), r = gee(n.graph, n.buckets, n.zeroIdx);
  return zu(
    Vn(r, function(i) {
      return e.outEdges(i.v, i.w);
    })
  );
}
function gee(e, t, n) {
  for (var r = [], i = t[t.length - 1], s = t[0], o; e.nodeCount(); ) {
    for (; o = s.dequeue(); )
      ax(e, t, n, o);
    for (; o = i.dequeue(); )
      ax(e, t, n, o);
    if (e.nodeCount()) {
      for (var a = t.length - 2; a > 0; --a)
        if (o = t[a].dequeue(), o) {
          r = r.concat(ax(e, t, n, o, !0));
          break;
        }
    }
  }
  return r;
}
function ax(e, t, n, r, i) {
  var s = i ? [] : void 0;
  return Ot(e.inEdges(r.v), function(o) {
    var a = e.edge(o), l = e.node(o.v);
    i && s.push({ v: o.v, w: o.w }), l.out -= a, J_(t, n, l);
  }), Ot(e.outEdges(r.v), function(o) {
    var a = e.edge(o), l = o.w, h = e.node(l);
    h.in -= a, J_(t, n, h);
  }), e.removeNode(r.v), s;
}
function mee(e, t) {
  var n = new zn(), r = 0, i = 0;
  Ot(e.nodes(), function(a) {
    n.setNode(a, { v: a, in: 0, out: 0 });
  }), Ot(e.edges(), function(a) {
    var l = n.edge(a.v, a.w) || 0, h = t(a), u = l + h;
    n.setEdge(a.v, a.w, u), i = Math.max(i, n.node(a.v).out += h), r = Math.max(r, n.node(a.w).in += h);
  });
  var s = bc(i + r + 3).map(function() {
    return new uee();
  }), o = r + 1;
  return Ot(n.nodes(), function(a) {
    J_(s, o, n.node(a));
  }), { graph: n, buckets: s, zeroIdx: o };
}
function J_(e, t, n) {
  n.out ? n.in ? e[n.out - n.in + t].enqueue(n) : e[e.length - 1].enqueue(n) : e[0].enqueue(n);
}
function yee(e) {
  var t = e.graph().acyclicer === "greedy" ? pee(e, n(e)) : bee(e);
  Ot(t, function(r) {
    var i = e.edge(r);
    e.removeEdge(r), i.forwardName = r.name, i.reversed = !0, e.setEdge(r.w, r.v, i, Vy("rev"));
  });
  function n(r) {
    return function(i) {
      return r.edge(i).weight;
    };
  }
}
function bee(e) {
  var t = [], n = {}, r = {};
  function i(s) {
    ve(r, s) || (r[s] = !0, n[s] = !0, Ot(e.outEdges(s), function(o) {
      ve(n, o.w) ? t.push(o) : i(o.w);
    }), delete n[s]);
  }
  return Ot(e.nodes(), i), t;
}
function Oee(e) {
  Ot(e.edges(), function(t) {
    var n = e.edge(t);
    if (n.reversed) {
      e.removeEdge(t);
      var r = n.forwardName;
      delete n.reversed, delete n.forwardName, e.setEdge(t.w, t.v, n, r);
    }
  });
}
function qu(e, t, n, r) {
  var i;
  do
    i = Vy(r);
  while (e.hasNode(i));
  return n.dummy = t, e.setNode(i, n), i;
}
function xee(e) {
  var t = new zn().setGraph(e.graph());
  return Ot(e.nodes(), function(n) {
    t.setNode(n, e.node(n));
  }), Ot(e.edges(), function(n) {
    var r = t.edge(n.v, n.w) || { weight: 0, minlen: 1 }, i = e.edge(n);
    t.setEdge(n.v, n.w, {
      weight: r.weight + i.weight,
      minlen: Math.max(r.minlen, i.minlen)
    });
  }), t;
}
function NB(e) {
  var t = new zn({ multigraph: e.isMultigraph() }).setGraph(e.graph());
  return Ot(e.nodes(), function(n) {
    e.children(n).length || t.setNode(n, e.node(n));
  }), Ot(e.edges(), function(n) {
    t.setEdge(n, e.edge(n));
  }), t;
}
function o8(e, t) {
  var n = e.x, r = e.y, i = t.x - n, s = t.y - r, o = e.width / 2, a = e.height / 2;
  if (!i && !s)
    throw new Error("Not possible to find intersection inside of the rectangle");
  var l, h;
  return Math.abs(s) * o > Math.abs(i) * a ? (s < 0 && (a = -a), l = a * i / s, h = a) : (i < 0 && (o = -o), l = o, h = o * s / i), { x: n + l, y: r + h };
}
function Yy(e) {
  var t = Vn(bc(BB(e) + 1), function() {
    return [];
  });
  return Ot(e.nodes(), function(n) {
    var r = e.node(n), i = r.rank;
    An(i) || (t[i][r.order] = n);
  }), t;
}
function vee(e) {
  var t = pp(
    Vn(e.nodes(), function(n) {
      return e.node(n).rank;
    })
  );
  Ot(e.nodes(), function(n) {
    var r = e.node(n);
    ve(r, "rank") && (r.rank -= t);
  });
}
function _ee(e) {
  var t = pp(
    Vn(e.nodes(), function(s) {
      return e.node(s).rank;
    })
  ), n = [];
  Ot(e.nodes(), function(s) {
    var o = e.node(s).rank - t;
    n[o] || (n[o] = []), n[o].push(s);
  });
  var r = 0, i = e.graph().nodeRankFactor;
  Ot(n, function(s, o) {
    An(s) && o % i !== 0 ? --r : r && Ot(s, function(a) {
      e.node(a).rank += r;
    });
  });
}
function a8(e, t, n, r) {
  var i = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (i.rank = n, i.order = r), qu(e, "border", i, t);
}
function BB(e) {
  return yc(
    Vn(e.nodes(), function(t) {
      var n = e.node(t).rank;
      if (!An(n))
        return n;
    })
  );
}
function kee(e, t) {
  var n = { lhs: [], rhs: [] };
  return Ot(e, function(r) {
    t(r) ? n.lhs.push(r) : n.rhs.push(r);
  }), n;
}
function wee(e, t) {
  var n = e8();
  try {
    return t();
  } finally {
    console.log(e + " time: " + (e8() - n) + "ms");
  }
}
function See(e, t) {
  return t();
}
function Cee(e) {
  function t(n) {
    var r = e.children(n), i = e.node(n);
    if (r.length && Ot(r, t), ve(i, "minRank")) {
      i.borderLeft = [], i.borderRight = [];
      for (var s = i.minRank, o = i.maxRank + 1; s < o; ++s)
        l8(e, "borderLeft", "_bl", n, i, s), l8(e, "borderRight", "_br", n, i, s);
    }
  }
  Ot(e.children(), t);
}
function l8(e, t, n, r, i, s) {
  var o = { width: 0, height: 0, rank: s, borderType: t }, a = i[t][s - 1], l = qu(e, "border", o, n);
  i[t][s] = l, e.setParent(l, r), a && e.setEdge(a, l, { weight: 1 });
}
function Tee(e) {
  var t = e.graph().rankdir.toLowerCase();
  (t === "lr" || t === "rl") && FB(e);
}
function Eee(e) {
  var t = e.graph().rankdir.toLowerCase();
  (t === "bt" || t === "rl") && Aee(e), (t === "lr" || t === "rl") && (Pee(e), FB(e));
}
function FB(e) {
  Ot(e.nodes(), function(t) {
    c8(e.node(t));
  }), Ot(e.edges(), function(t) {
    c8(e.edge(t));
  });
}
function c8(e) {
  var t = e.width;
  e.width = e.height, e.height = t;
}
function Aee(e) {
  Ot(e.nodes(), function(t) {
    lx(e.node(t));
  }), Ot(e.edges(), function(t) {
    var n = e.edge(t);
    Ot(n.points, lx), ve(n, "y") && lx(n);
  });
}
function lx(e) {
  e.y = -e.y;
}
function Pee(e) {
  Ot(e.nodes(), function(t) {
    cx(e.node(t));
  }), Ot(e.edges(), function(t) {
    var n = e.edge(t);
    Ot(n.points, cx), ve(n, "x") && cx(n);
  });
}
function cx(e) {
  var t = e.x;
  e.x = e.y, e.y = t;
}
function Dee(e) {
  e.graph().dummyChains = [], Ot(e.edges(), function(t) {
    Lee(e, t);
  });
}
function Lee(e, t) {
  var n = t.v, r = e.node(n).rank, i = t.w, s = e.node(i).rank, o = t.name, a = e.edge(t), l = a.labelRank;
  if (s !== r + 1) {
    e.removeEdge(t);
    var h, u, f;
    for (f = 0, ++r; r < s; ++f, ++r)
      a.points = [], u = {
        width: 0,
        height: 0,
        edgeLabel: a,
        edgeObj: t,
        rank: r
      }, h = qu(e, "edge", u, "_d"), r === l && (u.width = a.width, u.height = a.height, u.dummy = "edge-label", u.labelpos = a.labelpos), e.setEdge(n, h, { weight: a.weight }, o), f === 0 && e.graph().dummyChains.push(h), n = h;
    e.setEdge(n, i, { weight: a.weight }, o);
  }
}
function Mee(e) {
  Ot(e.graph().dummyChains, function(t) {
    var n = e.node(t), r = n.edgeLabel, i;
    for (e.setEdge(n.edgeObj, r); n.dummy; )
      i = e.successors(t)[0], e.removeNode(t), r.points.push({ x: n.x, y: n.y }), n.dummy === "edge-label" && (r.x = n.x, r.y = n.y, r.width = n.width, r.height = n.height), t = i, n = e.node(t);
  });
}
function g5(e) {
  var t = {};
  function n(r) {
    var i = e.node(r);
    if (ve(t, r))
      return i.rank;
    t[r] = !0;
    var s = pp(
      Vn(e.outEdges(r), function(o) {
        return n(o.w) - e.edge(o).minlen;
      })
    );
    return (s === Number.POSITIVE_INFINITY || s === void 0 || s === null) && (s = 0), i.rank = s;
  }
  Ot(e.sources(), n);
}
function mp(e, t) {
  return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen;
}
function QB(e) {
  var t = new zn({ directed: !1 }), n = e.nodes()[0], r = e.nodeCount();
  t.setNode(n, {});
  for (var i, s; Ree(t, e) < r; )
    i = $ee(t, e), s = t.hasNode(i.v) ? mp(e, i) : -mp(e, i), Iee(t, e, s);
  return t;
}
function Ree(e, t) {
  function n(r) {
    Ot(t.nodeEdges(r), function(i) {
      var s = i.v, o = r === s ? i.w : s;
      !e.hasNode(o) && !mp(t, i) && (e.setNode(o, {}), e.setEdge(r, o, {}), n(o));
    });
  }
  return Ot(e.nodes(), n), e.nodeCount();
}
function $ee(e, t) {
  return p5(t.edges(), function(n) {
    if (e.hasNode(n.v) !== e.hasNode(n.w))
      return mp(t, n);
  });
}
function Iee(e, t, n) {
  Ot(e.nodes(), function(r) {
    t.node(r).rank += n;
  });
}
function Nee() {
}
Nee.prototype = new Error();
function ZB(e, t, n) {
  Yn(t) || (t = [t]);
  var r = (e.isDirected() ? e.successors : e.neighbors).bind(e), i = [], s = {};
  return Ot(t, function(o) {
    if (!e.hasNode(o))
      throw new Error("Graph does not have node: " + o);
    VB(e, o, n === "post", s, r, i);
  }), i;
}
function VB(e, t, n, r, i, s) {
  ve(r, t) || (r[t] = !0, n || s.push(t), Ot(i(t), function(o) {
    VB(e, o, n, r, i, s);
  }), n && s.push(t));
}
function Bee(e, t) {
  return ZB(e, t, "post");
}
function Fee(e, t) {
  return ZB(e, t, "pre");
}
Ic.initLowLimValues = y5;
Ic.initCutValues = m5;
Ic.calcCutValue = YB;
Ic.leaveEdge = qB;
Ic.enterEdge = WB;
Ic.exchangeEdges = UB;
function Ic(e) {
  e = xee(e), g5(e);
  var t = QB(e);
  y5(t), m5(t, e);
  for (var n, r; n = qB(t); )
    r = WB(t, e, n), UB(t, e, n, r);
}
function m5(e, t) {
  var n = Bee(e, e.nodes());
  n = n.slice(0, n.length - 1), Ot(n, function(r) {
    Qee(e, t, r);
  });
}
function Qee(e, t, n) {
  var r = e.node(n), i = r.parent;
  e.edge(n, i).cutvalue = YB(e, t, n);
}
function YB(e, t, n) {
  var r = e.node(n), i = r.parent, s = !0, o = t.edge(n, i), a = 0;
  return o || (s = !1, o = t.edge(i, n)), a = o.weight, Ot(t.nodeEdges(n), function(l) {
    var h = l.v === n, u = h ? l.w : l.v;
    if (u !== i) {
      var f = h === s, d = t.edge(l).weight;
      if (a += f ? d : -d, Vee(e, n, u)) {
        var p = e.edge(n, u).cutvalue;
        a += f ? -p : p;
      }
    }
  }), a;
}
function y5(e, t) {
  arguments.length < 2 && (t = e.nodes()[0]), zB(e, {}, 1, t);
}
function zB(e, t, n, r, i) {
  var s = n, o = e.node(r);
  return t[r] = !0, Ot(e.neighbors(r), function(a) {
    ve(t, a) || (n = zB(e, t, n, a, r));
  }), o.low = s, o.lim = n++, i ? o.parent = i : delete o.parent, n;
}
function qB(e) {
  return f5(e.edges(), function(t) {
    return e.edge(t).cutvalue < 0;
  });
}
function WB(e, t, n) {
  var r = n.v, i = n.w;
  t.hasEdge(r, i) || (r = n.w, i = n.v);
  var s = e.node(r), o = e.node(i), a = s, l = !1;
  s.lim > o.lim && (a = o, l = !0);
  var h = Uo(t.edges(), function(u) {
    return l === h8(e, e.node(u.v), a) && l !== h8(e, e.node(u.w), a);
  });
  return p5(h, function(u) {
    return mp(t, u);
  });
}
function UB(e, t, n, r) {
  var i = n.v, s = n.w;
  e.removeEdge(i, s), e.setEdge(r.v, r.w, {}), y5(e), m5(e, t), Zee(e, t);
}
function Zee(e, t) {
  var n = f5(e.nodes(), function(i) {
    return !t.node(i).parent;
  }), r = Fee(e, n);
  r = r.slice(1), Ot(r, function(i) {
    var s = e.node(i).parent, o = t.edge(i, s), a = !1;
    o || (o = t.edge(s, i), a = !0), t.node(i).rank = t.node(s).rank + (a ? o.minlen : -o.minlen);
  });
}
function Vee(e, t, n) {
  return e.hasEdge(t, n);
}
function h8(e, t, n) {
  return n.low <= t.lim && t.lim <= n.lim;
}
function Yee(e) {
  switch (e.graph().ranker) {
    case "network-simplex":
      u8(e);
      break;
    case "tight-tree":
      qee(e);
      break;
    case "longest-path":
      zee(e);
      break;
    default:
      u8(e);
  }
}
var zee = g5;
function qee(e) {
  g5(e), QB(e);
}
function u8(e) {
  Ic(e);
}
function Wee(e) {
  var t = qu(e, "root", {}, "_root"), n = Uee(e), r = yc(na(n)) - 1, i = 2 * r + 1;
  e.graph().nestingRoot = t, Ot(e.edges(), function(o) {
    e.edge(o).minlen *= i;
  });
  var s = jee(e) + 1;
  Ot(e.children(), function(o) {
    jB(e, t, i, s, r, n, o);
  }), e.graph().nodeRankFactor = i;
}
function jB(e, t, n, r, i, s, o) {
  var a = e.children(o);
  if (!a.length) {
    o !== t && e.setEdge(t, o, { weight: 0, minlen: n });
    return;
  }
  var l = a8(e, "_bt"), h = a8(e, "_bb"), u = e.node(o);
  e.setParent(l, o), u.borderTop = l, e.setParent(h, o), u.borderBottom = h, Ot(a, function(f) {
    jB(e, t, n, r, i, s, f);
    var d = e.node(f), p = d.borderTop ? d.borderTop : f, g = d.borderBottom ? d.borderBottom : f, m = d.borderTop ? r : 2 * r, y = p !== g ? 1 : i - s[o] + 1;
    e.setEdge(l, p, {
      weight: m,
      minlen: y,
      nestingEdge: !0
    }), e.setEdge(g, h, {
      weight: m,
      minlen: y,
      nestingEdge: !0
    });
  }), e.parent(o) || e.setEdge(t, l, { weight: 0, minlen: i + s[o] });
}
function Uee(e) {
  var t = {};
  function n(r, i) {
    var s = e.children(r);
    s && s.length && Ot(s, function(o) {
      n(o, i + 1);
    }), t[r] = i;
  }
  return Ot(e.children(), function(r) {
    n(r, 1);
  }), t;
}
function jee(e) {
  return e0(
    e.edges(),
    function(t, n) {
      return t + e.edge(n).weight;
    },
    0
  );
}
function Xee(e) {
  var t = e.graph();
  e.removeNode(t.nestingRoot), delete t.nestingRoot, Ot(e.edges(), function(n) {
    var r = e.edge(n);
    r.nestingEdge && e.removeEdge(n);
  });
}
function Gee(e, t, n) {
  var r = {}, i;
  Ot(n, function(s) {
    for (var o = e.parent(s), a, l; o; ) {
      if (a = e.parent(o), a ? (l = r[a], r[a] = o) : (l = i, i = o), l && l !== o) {
        t.setEdge(l, o);
        return;
      }
      o = a;
    }
  });
}
function Hee(e, t, n) {
  var r = Kee(e), i = new zn({ compound: !0 }).setGraph({ root: r }).setDefaultNodeLabel(function(s) {
    return e.node(s);
  });
  return Ot(e.nodes(), function(s) {
    var o = e.node(s), a = e.parent(s);
    (o.rank === t || o.minRank <= t && t <= o.maxRank) && (i.setNode(s), i.setParent(s, a || r), Ot(e[n](s), function(l) {
      var h = l.v === s ? l.w : l.v, u = i.edge(h, s), f = An(u) ? 0 : u.weight;
      i.setEdge(h, s, { weight: e.edge(l).weight + f });
    }), ve(o, "minRank") && i.setNode(s, {
      borderLeft: o.borderLeft[t],
      borderRight: o.borderRight[t]
    }));
  }), i;
}
function Kee(e) {
  for (var t; e.hasNode(t = Vy("_root")); )
    ;
  return t;
}
function Jee(e, t) {
  for (var n = 0, r = 1; r < t.length; ++r)
    n += tne(e, t[r - 1], t[r]);
  return n;
}
function tne(e, t, n) {
  for (var r = lee(
    n,
    Vn(n, function(h, u) {
      return u;
    })
  ), i = zu(
    Vn(t, function(h) {
      return n0(
        Vn(e.outEdges(h), function(u) {
          return { pos: r[u.w], weight: e.edge(u).weight };
        }),
        "pos"
      );
    })
  ), s = 1; s < n.length; )
    s <<= 1;
  var o = 2 * s - 1;
  s -= 1;
  var a = Vn(new Array(o), function() {
    return 0;
  }), l = 0;
  return Ot(
    i.forEach(function(h) {
      var u = h.pos + s;
      a[u] += h.weight;
      for (var f = 0; u > 0; )
        u % 2 && (f += a[u + 1]), u = u - 1 >> 1, a[u] += h.weight;
      l += h.weight * f;
    })
  ), l;
}
function ene(e) {
  var t = {}, n = Uo(e.nodes(), function(a) {
    return !e.children(a).length;
  }), r = yc(
    Vn(n, function(a) {
      return e.node(a).rank;
    })
  ), i = Vn(bc(r + 1), function() {
    return [];
  });
  function s(a) {
    if (!ve(t, a)) {
      t[a] = !0;
      var l = e.node(a);
      i[l.rank].push(a), Ot(e.successors(a), s);
    }
  }
  var o = n0(n, function(a) {
    return e.node(a).rank;
  });
  return Ot(o, s), i;
}
function nne(e, t) {
  return Vn(t, function(n) {
    var r = e.inEdges(n);
    if (r.length) {
      var i = e0(
        r,
        function(s, o) {
          var a = e.edge(o), l = e.node(o.v);
          return {
            sum: s.sum + a.weight * l.order,
            weight: s.weight + a.weight
          };
        },
        { sum: 0, weight: 0 }
      );
      return {
        v: n,
        barycenter: i.sum / i.weight,
        weight: i.weight
      };
    } else
      return { v: n };
  });
}
function rne(e, t) {
  var n = {};
  Ot(e, function(i, s) {
    var o = n[i.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [i.v],
      i: s
    };
    An(i.barycenter) || (o.barycenter = i.barycenter, o.weight = i.weight);
  }), Ot(t.edges(), function(i) {
    var s = n[i.v], o = n[i.w];
    !An(s) && !An(o) && (o.indegree++, s.out.push(n[i.w]));
  });
  var r = Uo(n, function(i) {
    return !i.indegree;
  });
  return ine(r);
}
function ine(e) {
  var t = [];
  function n(s) {
    return function(o) {
      o.merged || (An(o.barycenter) || An(s.barycenter) || o.barycenter >= s.barycenter) && sne(s, o);
    };
  }
  function r(s) {
    return function(o) {
      o.in.push(s), --o.indegree === 0 && e.push(o);
    };
  }
  for (; e.length; ) {
    var i = e.pop();
    t.push(i), Ot(i.in.reverse(), n(i)), Ot(i.out, r(i));
  }
  return Vn(
    Uo(t, function(s) {
      return !s.merged;
    }),
    function(s) {
      return gp(s, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function sne(e, t) {
  var n = 0, r = 0;
  e.weight && (n += e.barycenter * e.weight, r += e.weight), t.weight && (n += t.barycenter * t.weight, r += t.weight), e.vs = t.vs.concat(e.vs), e.barycenter = n / r, e.weight = r, e.i = Math.min(t.i, e.i), t.merged = !0;
}
function one(e, t) {
  var n = kee(e, function(u) {
    return ve(u, "barycenter");
  }), r = n.lhs, i = n0(n.rhs, function(u) {
    return -u.i;
  }), s = [], o = 0, a = 0, l = 0;
  r.sort(ane(!!t)), l = f8(s, i, l), Ot(r, function(u) {
    l += u.vs.length, s.push(u.vs), o += u.barycenter * u.weight, a += u.weight, l = f8(s, i, l);
  });
  var h = { vs: zu(s) };
  return a && (h.barycenter = o / a, h.weight = a), h;
}
function f8(e, t, n) {
  for (var r; t.length && (r = qm(t)).i <= n; )
    t.pop(), e.push(r.vs), n++;
  return n;
}
function ane(e) {
  return function(t, n) {
    return t.barycenter < n.barycenter ? -1 : t.barycenter > n.barycenter ? 1 : e ? n.i - t.i : t.i - n.i;
  };
}
function XB(e, t, n, r) {
  var i = e.children(t), s = e.node(t), o = s ? s.borderLeft : void 0, a = s ? s.borderRight : void 0, l = {};
  o && (i = Uo(i, function(g) {
    return g !== o && g !== a;
  }));
  var h = nne(e, i);
  Ot(h, function(g) {
    if (e.children(g.v).length) {
      var m = XB(e, g.v, n, r);
      l[g.v] = m, ve(m, "barycenter") && cne(g, m);
    }
  });
  var u = rne(h, n);
  lne(u, l);
  var f = one(u, r);
  if (o && (f.vs = zu([o, f.vs, a]), e.predecessors(o).length)) {
    var d = e.node(e.predecessors(o)[0]), p = e.node(e.predecessors(a)[0]);
    ve(f, "barycenter") || (f.barycenter = 0, f.weight = 0), f.barycenter = (f.barycenter * f.weight + d.order + p.order) / (f.weight + 2), f.weight += 2;
  }
  return f;
}
function lne(e, t) {
  Ot(e, function(n) {
    n.vs = zu(
      n.vs.map(function(r) {
        return t[r] ? t[r].vs : r;
      })
    );
  });
}
function cne(e, t) {
  An(e.barycenter) ? (e.barycenter = t.barycenter, e.weight = t.weight) : (e.barycenter = (e.barycenter * e.weight + t.barycenter * t.weight) / (e.weight + t.weight), e.weight += t.weight);
}
function hne(e) {
  var t = BB(e), n = d8(e, bc(1, t + 1), "inEdges"), r = d8(e, bc(t - 1, -1, -1), "outEdges"), i = ene(e);
  p8(e, i);
  for (var s = Number.POSITIVE_INFINITY, o, a = 0, l = 0; l < 4; ++a, ++l) {
    une(a % 2 ? n : r, a % 4 >= 2), i = Yy(e);
    var h = Jee(e, i);
    h < s && (l = 0, o = SJt(i), s = h);
  }
  p8(e, o);
}
function d8(e, t, n) {
  return Vn(t, function(r) {
    return Hee(e, r, n);
  });
}
function une(e, t) {
  var n = new zn();
  Ot(e, function(r) {
    var i = r.graph().root, s = XB(r, i, n, t);
    Ot(s.vs, function(o, a) {
      r.node(o).order = a;
    }), Gee(r, n, s.vs);
  });
}
function p8(e, t) {
  Ot(t, function(n) {
    Ot(n, function(r, i) {
      e.node(r).order = i;
    });
  });
}
function fne(e) {
  var t = pne(e);
  Ot(e.graph().dummyChains, function(n) {
    for (var r = e.node(n), i = r.edgeObj, s = dne(e, t, i.v, i.w), o = s.path, a = s.lca, l = 0, h = o[l], u = !0; n !== i.w; ) {
      if (r = e.node(n), u) {
        for (; (h = o[l]) !== a && e.node(h).maxRank < r.rank; )
          l++;
        h === a && (u = !1);
      }
      if (!u) {
        for (; l < o.length - 1 && e.node(h = o[l + 1]).minRank <= r.rank; )
          l++;
        h = o[l];
      }
      e.setParent(n, h), n = e.successors(n)[0];
    }
  });
}
function dne(e, t, n, r) {
  var i = [], s = [], o = Math.min(t[n].low, t[r].low), a = Math.max(t[n].lim, t[r].lim), l, h;
  l = n;
  do
    l = e.parent(l), i.push(l);
  while (l && (t[l].low > o || a > t[l].lim));
  for (h = l, l = r; (l = e.parent(l)) !== h; )
    s.push(l);
  return { path: i.concat(s.reverse()), lca: h };
}
function pne(e) {
  var t = {}, n = 0;
  function r(i) {
    var s = n;
    Ot(e.children(i), r), t[i] = { low: s, lim: n++ };
  }
  return Ot(e.children(), r), t;
}
function gne(e, t) {
  var n = {};
  function r(i, s) {
    var o = 0, a = 0, l = i.length, h = qm(s);
    return Ot(s, function(u, f) {
      var d = yne(e, u), p = d ? e.node(d).order : l;
      (d || u === h) && (Ot(s.slice(a, f + 1), function(g) {
        Ot(e.predecessors(g), function(m) {
          var y = e.node(m), O = y.order;
          (O < o || p < O) && !(y.dummy && e.node(g).dummy) && GB(n, m, g);
        });
      }), a = f + 1, o = p);
    }), s;
  }
  return e0(t, r), n;
}
function mne(e, t) {
  var n = {};
  function r(s, o, a, l, h) {
    var u;
    Ot(bc(o, a), function(f) {
      u = s[f], e.node(u).dummy && Ot(e.predecessors(u), function(d) {
        var p = e.node(d);
        p.dummy && (p.order < l || p.order > h) && GB(n, d, u);
      });
    });
  }
  function i(s, o) {
    var a = -1, l, h = 0;
    return Ot(o, function(u, f) {
      if (e.node(u).dummy === "border") {
        var d = e.predecessors(u);
        d.length && (l = e.node(d[0]).order, r(o, h, f, a, l), h = f, a = l);
      }
      r(o, h, o.length, l, s.length);
    }), o;
  }
  return e0(t, i), n;
}
function yne(e, t) {
  if (e.node(t).dummy)
    return f5(e.predecessors(t), function(n) {
      return e.node(n).dummy;
    });
}
function GB(e, t, n) {
  if (t > n) {
    var r = t;
    t = n, n = r;
  }
  var i = e[t];
  i || (e[t] = i = {}), i[n] = !0;
}
function bne(e, t, n) {
  if (t > n) {
    var r = t;
    t = n, n = r;
  }
  return ve(e[t], n);
}
function One(e, t, n, r) {
  var i = {}, s = {}, o = {};
  return Ot(t, function(a) {
    Ot(a, function(l, h) {
      i[l] = l, s[l] = l, o[l] = h;
    });
  }), Ot(t, function(a) {
    var l = -1;
    Ot(a, function(h) {
      var u = r(h);
      if (u.length) {
        u = n0(u, function(m) {
          return o[m];
        });
        for (var f = (u.length - 1) / 2, d = Math.floor(f), p = Math.ceil(f); d <= p; ++d) {
          var g = u[d];
          s[h] === h && l < o[g] && !bne(n, h, g) && (s[g] = h, s[h] = i[h] = i[g], l = o[g]);
        }
      }
    });
  }), { root: i, align: s };
}
function xne(e, t, n, r, i) {
  var s = {}, o = vne(e, t, n, i), a = i ? "borderLeft" : "borderRight";
  function l(f, d) {
    for (var p = o.nodes(), g = p.pop(), m = {}; g; )
      m[g] ? f(g) : (m[g] = !0, p.push(g), p = p.concat(d(g))), g = p.pop();
  }
  function h(f) {
    s[f] = o.inEdges(f).reduce(function(d, p) {
      return Math.max(d, s[p.v] + o.edge(p));
    }, 0);
  }
  function u(f) {
    var d = o.outEdges(f).reduce(function(g, m) {
      return Math.min(g, s[m.w] - o.edge(m));
    }, Number.POSITIVE_INFINITY), p = e.node(f);
    d !== Number.POSITIVE_INFINITY && p.borderType !== a && (s[f] = Math.max(s[f], d));
  }
  return l(h, o.predecessors.bind(o)), l(u, o.successors.bind(o)), Ot(r, function(f) {
    s[f] = s[n[f]];
  }), s;
}
function vne(e, t, n, r) {
  var i = new zn(), s = e.graph(), o = Cne(s.nodesep, s.edgesep, r);
  return Ot(t, function(a) {
    var l;
    Ot(a, function(h) {
      var u = n[h];
      if (i.setNode(u), l) {
        var f = n[l], d = i.edge(f, u);
        i.setEdge(f, u, Math.max(o(e, h, l), d || 0));
      }
      l = h;
    });
  }), i;
}
function _ne(e, t) {
  return p5(na(t), function(n) {
    var r = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    return Tte(n, function(s, o) {
      var a = Tne(e, o) / 2;
      r = Math.max(s + a, r), i = Math.min(s - a, i);
    }), r - i;
  });
}
function kne(e, t) {
  var n = na(t), r = pp(n), i = yc(n);
  Ot(["u", "d"], function(s) {
    Ot(["l", "r"], function(o) {
      var a = s + o, l = e[a], h;
      if (l !== t) {
        var u = na(l);
        h = o === "l" ? r - pp(u) : i - yc(u), h && (e[a] = Zy(l, function(f) {
          return f + h;
        }));
      }
    });
  });
}
function wne(e, t) {
  return Zy(e.ul, function(n, r) {
    if (t)
      return e[t.toLowerCase()][r];
    var i = n0(Vn(e, r));
    return (i[1] + i[2]) / 2;
  });
}
function Sne(e) {
  var t = Yy(e), n = K_(gne(e, t), mne(e, t)), r = {}, i;
  Ot(["u", "d"], function(o) {
    i = o === "u" ? t : na(t).reverse(), Ot(["l", "r"], function(a) {
      a === "r" && (i = Vn(i, function(f) {
        return na(f).reverse();
      }));
      var l = (o === "u" ? e.predecessors : e.successors).bind(e), h = One(e, i, n, l), u = xne(e, i, h.root, h.align, a === "r");
      a === "r" && (u = Zy(u, function(f) {
        return -f;
      })), r[o + a] = u;
    });
  });
  var s = _ne(e, r);
  return kne(r, s), wne(r, e.graph().align);
}
function Cne(e, t, n) {
  return function(r, i, s) {
    var o = r.node(i), a = r.node(s), l = 0, h;
    if (l += o.width / 2, ve(o, "labelpos"))
      switch (o.labelpos.toLowerCase()) {
        case "l":
          h = -o.width / 2;
          break;
        case "r":
          h = o.width / 2;
          break;
      }
    if (h && (l += n ? h : -h), h = 0, l += (o.dummy ? t : e) / 2, l += (a.dummy ? t : e) / 2, l += a.width / 2, ve(a, "labelpos"))
      switch (a.labelpos.toLowerCase()) {
        case "l":
          h = a.width / 2;
          break;
        case "r":
          h = -a.width / 2;
          break;
      }
    return h && (l += n ? h : -h), h = 0, l;
  };
}
function Tne(e, t) {
  return e.node(t).width;
}
function Ene(e) {
  e = NB(e), Ane(e), Ot(Sne(e), function(t, n) {
    e.node(n).x = t;
  });
}
function Ane(e) {
  var t = Yy(e), n = e.graph().ranksep, r = 0;
  Ot(t, function(i) {
    var s = yc(
      Vn(i, function(o) {
        return e.node(o).height;
      })
    );
    Ot(i, function(o) {
      e.node(o).y = r + s / 2;
    }), r += s + n;
  });
}
function Wu(e, t) {
  var n = t && t.debugTiming ? wee : See;
  n("layout", function() {
    var r = n("  buildLayoutGraph", function() {
      return Qne(e);
    });
    n("  runLayout", function() {
      Pne(r, n);
    }), n("  updateInputGraph", function() {
      Dne(e, r);
    });
  });
}
function Pne(e, t) {
  t("    makeSpaceForEdgeLabels", function() {
    Zne(e);
  }), t("    removeSelfEdges", function() {
    Gne(e);
  }), t("    acyclic", function() {
    yee(e);
  }), t("    nestingGraph.run", function() {
    Wee(e);
  }), t("    rank", function() {
    Yee(NB(e));
  }), t("    injectEdgeLabelProxies", function() {
    Vne(e);
  }), t("    removeEmptyRanks", function() {
    _ee(e);
  }), t("    nestingGraph.cleanup", function() {
    Xee(e);
  }), t("    normalizeRanks", function() {
    vee(e);
  }), t("    assignRankMinMax", function() {
    Yne(e);
  }), t("    removeEdgeLabelProxies", function() {
    zne(e);
  }), t("    normalize.run", function() {
    Dee(e);
  }), t("    parentDummyChains", function() {
    fne(e);
  }), t("    addBorderSegments", function() {
    Cee(e);
  }), t("    order", function() {
    hne(e);
  }), t("    insertSelfEdges", function() {
    Hne(e);
  }), t("    adjustCoordinateSystem", function() {
    Tee(e);
  }), t("    position", function() {
    Ene(e);
  }), t("    positionSelfEdges", function() {
    Kne(e);
  }), t("    removeBorderNodes", function() {
    Xne(e);
  }), t("    normalize.undo", function() {
    Mee(e);
  }), t("    fixupEdgeLabelCoords", function() {
    Une(e);
  }), t("    undoCoordinateSystem", function() {
    Eee(e);
  }), t("    translateGraph", function() {
    qne(e);
  }), t("    assignNodeIntersects", function() {
    Wne(e);
  }), t("    reversePoints", function() {
    jne(e);
  }), t("    acyclic.undo", function() {
    Oee(e);
  });
}
function Dne(e, t) {
  Ot(e.nodes(), function(n) {
    var r = e.node(n), i = t.node(n);
    r && (r.x = i.x, r.y = i.y, t.children(n).length && (r.width = i.width, r.height = i.height));
  }), Ot(e.edges(), function(n) {
    var r = e.edge(n), i = t.edge(n);
    r.points = i.points, ve(i, "x") && (r.x = i.x, r.y = i.y);
  }), e.graph().width = t.graph().width, e.graph().height = t.graph().height;
}
var Lne = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], Mne = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, Rne = ["acyclicer", "ranker", "rankdir", "align"], $ne = ["width", "height"], Ine = { width: 0, height: 0 }, Nne = ["minlen", "weight", "width", "height", "labeloffset"], Bne = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, Fne = ["labelpos"];
function Qne(e) {
  var t = new zn({ multigraph: !0, compound: !0 }), n = ux(e.graph());
  return t.setGraph(
    K_({}, Mne, hx(n, Lne), gp(n, Rne))
  ), Ot(e.nodes(), function(r) {
    var i = ux(e.node(r));
    t.setNode(r, Xc(hx(i, $ne), Ine)), t.setParent(r, e.parent(r));
  }), Ot(e.edges(), function(r) {
    var i = ux(e.edge(r));
    t.setEdge(
      r,
      K_({}, Bne, hx(i, Nne), gp(i, Fne))
    );
  }), t;
}
function Zne(e) {
  var t = e.graph();
  t.ranksep /= 2, Ot(e.edges(), function(n) {
    var r = e.edge(n);
    r.minlen *= 2, r.labelpos.toLowerCase() !== "c" && (t.rankdir === "TB" || t.rankdir === "BT" ? r.width += r.labeloffset : r.height += r.labeloffset);
  });
}
function Vne(e) {
  Ot(e.edges(), function(t) {
    var n = e.edge(t);
    if (n.width && n.height) {
      var r = e.node(t.v), i = e.node(t.w), s = { rank: (i.rank - r.rank) / 2 + r.rank, e: t };
      qu(e, "edge-proxy", s, "_ep");
    }
  });
}
function Yne(e) {
  var t = 0;
  Ot(e.nodes(), function(n) {
    var r = e.node(n);
    r.borderTop && (r.minRank = e.node(r.borderTop).rank, r.maxRank = e.node(r.borderBottom).rank, t = yc(t, r.maxRank));
  }), e.graph().maxRank = t;
}
function zne(e) {
  Ot(e.nodes(), function(t) {
    var n = e.node(t);
    n.dummy === "edge-proxy" && (e.edge(n.e).labelRank = n.rank, e.removeNode(t));
  });
}
function qne(e) {
  var t = Number.POSITIVE_INFINITY, n = 0, r = Number.POSITIVE_INFINITY, i = 0, s = e.graph(), o = s.marginx || 0, a = s.marginy || 0;
  function l(h) {
    var u = h.x, f = h.y, d = h.width, p = h.height;
    t = Math.min(t, u - d / 2), n = Math.max(n, u + d / 2), r = Math.min(r, f - p / 2), i = Math.max(i, f + p / 2);
  }
  Ot(e.nodes(), function(h) {
    l(e.node(h));
  }), Ot(e.edges(), function(h) {
    var u = e.edge(h);
    ve(u, "x") && l(u);
  }), t -= o, r -= a, Ot(e.nodes(), function(h) {
    var u = e.node(h);
    u.x -= t, u.y -= r;
  }), Ot(e.edges(), function(h) {
    var u = e.edge(h);
    Ot(u.points, function(f) {
      f.x -= t, f.y -= r;
    }), ve(u, "x") && (u.x -= t), ve(u, "y") && (u.y -= r);
  }), s.width = n - t + o, s.height = i - r + a;
}
function Wne(e) {
  Ot(e.edges(), function(t) {
    var n = e.edge(t), r = e.node(t.v), i = e.node(t.w), s, o;
    n.points ? (s = n.points[0], o = n.points[n.points.length - 1]) : (n.points = [], s = i, o = r), n.points.unshift(o8(r, s)), n.points.push(o8(i, o));
  });
}
function Une(e) {
  Ot(e.edges(), function(t) {
    var n = e.edge(t);
    if (ve(n, "x"))
      switch ((n.labelpos === "l" || n.labelpos === "r") && (n.width -= n.labeloffset), n.labelpos) {
        case "l":
          n.x -= n.width / 2 + n.labeloffset;
          break;
        case "r":
          n.x += n.width / 2 + n.labeloffset;
          break;
      }
  });
}
function jne(e) {
  Ot(e.edges(), function(t) {
    var n = e.edge(t);
    n.reversed && n.points.reverse();
  });
}
function Xne(e) {
  Ot(e.nodes(), function(t) {
    if (e.children(t).length) {
      var n = e.node(t), r = e.node(n.borderTop), i = e.node(n.borderBottom), s = e.node(qm(n.borderLeft)), o = e.node(qm(n.borderRight));
      n.width = Math.abs(o.x - s.x), n.height = Math.abs(i.y - r.y), n.x = s.x + n.width / 2, n.y = r.y + n.height / 2;
    }
  }), Ot(e.nodes(), function(t) {
    e.node(t).dummy === "border" && e.removeNode(t);
  });
}
function Gne(e) {
  Ot(e.edges(), function(t) {
    if (t.v === t.w) {
      var n = e.node(t.v);
      n.selfEdges || (n.selfEdges = []), n.selfEdges.push({ e: t, label: e.edge(t) }), e.removeEdge(t);
    }
  });
}
function Hne(e) {
  var t = Yy(e);
  Ot(t, function(n) {
    var r = 0;
    Ot(n, function(i, s) {
      var o = e.node(i);
      o.order = s + r, Ot(o.selfEdges, function(a) {
        qu(
          e,
          "selfedge",
          {
            width: a.label.width,
            height: a.label.height,
            rank: o.rank,
            order: s + ++r,
            e: a.e,
            label: a.label
          },
          "_se"
        );
      }), delete o.selfEdges;
    });
  });
}
function Kne(e) {
  Ot(e.nodes(), function(t) {
    var n = e.node(t);
    if (n.dummy === "selfedge") {
      var r = e.node(n.e.v), i = r.x + r.width / 2, s = r.y, o = n.x - i, a = r.height / 2;
      e.setEdge(n.e, n.label), e.removeNode(t), n.label.points = [
        { x: i + 2 * o / 3, y: s - a },
        { x: i + 5 * o / 6, y: s - a },
        { x: i + o, y: s },
        { x: i + 5 * o / 6, y: s + a },
        { x: i + 2 * o / 3, y: s + a }
      ], n.label.x = n.x, n.label.y = n.y;
    }
  });
}
function hx(e, t) {
  return Zy(gp(e, t), Number);
}
function ux(e) {
  var t = {};
  return Ot(e, function(n, r) {
    t[r.toLowerCase()] = n;
  }), t;
}
function jo(e) {
  var t = {
    options: {
      directed: e.isDirected(),
      multigraph: e.isMultigraph(),
      compound: e.isCompound()
    },
    nodes: Jne(e),
    edges: tre(e)
  };
  return An(e.graph()) || (t.value = _Jt(e.graph())), t;
}
function Jne(e) {
  return Vn(e.nodes(), function(t) {
    var n = e.node(t), r = e.parent(t), i = { v: t };
    return An(n) || (i.value = n), An(r) || (i.parent = r), i;
  });
}
function tre(e) {
  return Vn(e.edges(), function(t) {
    var n = e.edge(t), r = { v: t.v, w: t.w };
    return An(t.name) || (r.name = t.name), An(n) || (r.value = n), r;
  });
}
const ere = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function nre(e) {
  return typeof e == "string" && ere.test(e);
}
const ur = [];
for (let e = 0; e < 256; ++e)
  ur.push((e + 256).toString(16).slice(1));
function rre(e, t = 0) {
  return ur[e[t + 0]] + ur[e[t + 1]] + ur[e[t + 2]] + ur[e[t + 3]] + "-" + ur[e[t + 4]] + ur[e[t + 5]] + "-" + ur[e[t + 6]] + ur[e[t + 7]] + "-" + ur[e[t + 8]] + ur[e[t + 9]] + "-" + ur[e[t + 10]] + ur[e[t + 11]] + ur[e[t + 12]] + ur[e[t + 13]] + ur[e[t + 14]] + ur[e[t + 15]];
}
function ire(e) {
  if (!nre(e))
    throw TypeError("Invalid UUID");
  let t;
  const n = new Uint8Array(16);
  return n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, n[1] = t >>> 16 & 255, n[2] = t >>> 8 & 255, n[3] = t & 255, n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, n[5] = t & 255, n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, n[7] = t & 255, n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, n[9] = t & 255, n[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = t / 4294967296 & 255, n[12] = t >>> 24 & 255, n[13] = t >>> 16 & 255, n[14] = t >>> 8 & 255, n[15] = t & 255, n;
}
function sre(e) {
  e = unescape(encodeURIComponent(e));
  const t = [];
  for (let n = 0; n < e.length; ++n)
    t.push(e.charCodeAt(n));
  return t;
}
const ore = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", are = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function lre(e, t, n) {
  function r(i, s, o, a) {
    var l;
    if (typeof i == "string" && (i = sre(i)), typeof s == "string" && (s = ire(s)), ((l = s) === null || l === void 0 ? void 0 : l.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let h = new Uint8Array(16 + i.length);
    if (h.set(s), h.set(i, s.length), h = n(h), h[6] = h[6] & 15 | t, h[8] = h[8] & 63 | 128, o) {
      a = a || 0;
      for (let u = 0; u < 16; ++u)
        o[a + u] = h[u];
      return o;
    }
    return rre(h);
  }
  try {
    r.name = e;
  } catch {
  }
  return r.DNS = ore, r.URL = are, r;
}
function cre(e, t, n, r) {
  switch (e) {
    case 0:
      return t & n ^ ~t & r;
    case 1:
      return t ^ n ^ r;
    case 2:
      return t & n ^ t & r ^ n & r;
    case 3:
      return t ^ n ^ r;
  }
}
function fx(e, t) {
  return e << t | e >>> 32 - t;
}
function hre(e) {
  const t = [1518500249, 1859775393, 2400959708, 3395469782], n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof e == "string") {
    const o = unescape(encodeURIComponent(e));
    e = [];
    for (let a = 0; a < o.length; ++a)
      e.push(o.charCodeAt(a));
  } else
    Array.isArray(e) || (e = Array.prototype.slice.call(e));
  e.push(128);
  const r = e.length / 4 + 2, i = Math.ceil(r / 16), s = new Array(i);
  for (let o = 0; o < i; ++o) {
    const a = new Uint32Array(16);
    for (let l = 0; l < 16; ++l)
      a[l] = e[o * 64 + l * 4] << 24 | e[o * 64 + l * 4 + 1] << 16 | e[o * 64 + l * 4 + 2] << 8 | e[o * 64 + l * 4 + 3];
    s[o] = a;
  }
  s[i - 1][14] = (e.length - 1) * 8 / Math.pow(2, 32), s[i - 1][14] = Math.floor(s[i - 1][14]), s[i - 1][15] = (e.length - 1) * 8 & 4294967295;
  for (let o = 0; o < i; ++o) {
    const a = new Uint32Array(80);
    for (let p = 0; p < 16; ++p)
      a[p] = s[o][p];
    for (let p = 16; p < 80; ++p)
      a[p] = fx(a[p - 3] ^ a[p - 8] ^ a[p - 14] ^ a[p - 16], 1);
    let l = n[0], h = n[1], u = n[2], f = n[3], d = n[4];
    for (let p = 0; p < 80; ++p) {
      const g = Math.floor(p / 20), m = fx(l, 5) + cre(g, h, u, f) + d + t[g] + a[p] >>> 0;
      d = f, f = u, u = fx(h, 30) >>> 0, h = l, l = m;
    }
    n[0] = n[0] + l >>> 0, n[1] = n[1] + h >>> 0, n[2] = n[2] + u >>> 0, n[3] = n[3] + f >>> 0, n[4] = n[4] + d >>> 0;
  }
  return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255];
}
const ure = lre("v5", 80, hre), fre = ure;
function HB(e, t) {
  return !!e.children(t).length;
}
function KB(e) {
  return dx(e.v) + ":" + dx(e.w) + ":" + dx(e.name);
}
var dre = /:/g;
function dx(e) {
  return e ? String(e).replace(dre, "\\:") : "";
}
function Co(e, t) {
  t && e.attr("style", t);
}
function JB(e, t, n) {
  t && e.attr("class", t).attr("class", n + " " + e.attr("class"));
}
function Ss(e, t) {
  var n = t.graph();
  if (fB(n)) {
    var r = n.transition;
    if (cu(r))
      return r(e);
  }
  return e;
}
var tk = {
  normal: gre,
  vee: mre,
  undirected: yre
};
function pre(e) {
  tk = e;
}
function gre(e, t, n, r) {
  var i = e.append("marker").attr("id", t).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto"), s = i.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  Co(s, n[r + "Style"]), n[r + "Class"] && s.attr("class", n[r + "Class"]);
}
function mre(e, t, n, r) {
  var i = e.append("marker").attr("id", t).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto"), s = i.append("path").attr("d", "M 0 0 L 10 5 L 0 10 L 4 5 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  Co(s, n[r + "Style"]), n[r + "Class"] && s.attr("class", n[r + "Class"]);
}
function yre(e, t, n, r) {
  var i = e.append("marker").attr("id", t).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto"), s = i.append("path").attr("d", "M 0 5 L 10 5").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  Co(s, n[r + "Style"]), n[r + "Class"] && s.attr("class", n[r + "Class"]);
}
function b5(e, t) {
  var n = e.append("foreignObject").attr("width", "100000"), r = n.append("xhtml:div");
  r.attr("xmlns", "http://www.w3.org/1999/xhtml");
  var i = t.label;
  switch (typeof i) {
    case "function":
      r.insert(i);
      break;
    case "object":
      r.insert(function() {
        return i;
      });
      break;
    default:
      r.html(i);
  }
  Co(r, t.labelStyle), r.style("display", "inline-block"), r.style("white-space", "nowrap");
  var s = r.node().getBoundingClientRect();
  return n.attr("width", s.width).attr("height", s.height), n;
}
function bre(e, t) {
  var n = e;
  return n.node().appendChild(t.label), Co(n, t.labelStyle), n;
}
function Ore(e, t) {
  for (var n = e.append("text"), r = xre(t.label).split(`
`), i = 0; i < r.length; i++)
    n.append("tspan").attr("xml:space", "preserve").attr("dy", "1em").attr("x", "1").text(r[i]);
  return Co(n, t.labelStyle), n;
}
function xre(e) {
  for (var t = "", n = !1, r, i = 0; i < e.length; ++i)
    if (r = e[i], n) {
      switch (r) {
        case "n":
          t += `
`;
          break;
        default:
          t += r;
      }
      n = !1;
    } else
      r === "\\" ? n = !0 : t += r;
  return t;
}
function O5(e, t, n) {
  var r = t.label, i = e.append("g");
  t.labelType === "svg" ? bre(i, t) : typeof r != "string" || t.labelType === "html" ? b5(i, t) : Ore(i, t);
  var s = i.node().getBBox(), o;
  switch (n) {
    case "top":
      o = -t.height / 2;
      break;
    case "bottom":
      o = t.height / 2 - s.height;
      break;
    default:
      o = -s.height / 2;
  }
  return i.attr("transform", "translate(" + -s.width / 2 + "," + o + ")"), i;
}
var ek = function(e, t) {
  var n = t.nodes().filter(function(s) {
    return HB(t, s);
  }), r = e.selectAll("g.cluster").data(n, function(s) {
    return s;
  });
  Ss(r.exit(), t).style("opacity", 0).remove();
  var i = r.enter().append("g").attr("class", "cluster").attr("id", function(s) {
    var o = t.node(s);
    return o.id;
  }).style("opacity", 0).each(function(s) {
    var o = t.node(s), a = wt(this);
    wt(this).append("rect");
    var l = a.append("g").attr("class", "label");
    O5(l, o, o.clusterLabelPos);
  });
  return r = r.merge(i), r = Ss(r, t).style("opacity", 1), r.selectAll("rect").each(function(s) {
    var o = t.node(s), a = wt(this);
    Co(a, o.style);
  }), r;
};
function vre(e) {
  ek = e;
}
let nk = function(e, t) {
  var n = e.selectAll("g.edgeLabel").data(t.edges(), function(i) {
    return KB(i);
  }).classed("update", !0);
  n.exit().remove(), n.enter().append("g").classed("edgeLabel", !0).style("opacity", 0), n = e.selectAll("g.edgeLabel"), n.each(function(i) {
    var s = wt(this);
    s.select(".label").remove();
    var o = t.edge(i), a = O5(s, t.edge(i), 0).classed("label", !0), l = a.node().getBBox();
    o.labelId && a.attr("id", o.labelId), ve(o, "width") || (o.width = l.width), ve(o, "height") || (o.height = l.height);
  });
  var r;
  return n.exit ? r = n.exit() : r = n.selectAll(null), Ss(r, t).style("opacity", 0).remove(), n;
};
function _re(e) {
  nk = e;
}
function g8(e, t) {
  return e.intersect(t);
}
var rk = function(e, t, n) {
  var r = e.selectAll("g.edgePath").data(t.edges(), function(o) {
    return KB(o);
  }).classed("update", !0), i = Tre(r, t);
  Ere(r, t);
  var s = r.merge !== void 0 ? r.merge(i) : r;
  return Ss(s, t).style("opacity", 1), s.each(function(o) {
    var a = wt(this), l = t.edge(o);
    l.elem = this, l.id && a.attr("id", l.id), JB(
      a,
      l.class,
      (a.classed("update") ? "update " : "") + "edgePath"
    );
  }), s.selectAll("path.path").each(function(o) {
    var a = t.edge(o);
    a.arrowheadId = Vy("arrowhead");
    var l = wt(this).attr("marker-end", function() {
      return "url(" + wre(location.href, a.arrowheadId) + ")";
    }).style("fill", "none");
    Ss(l, t).attr("d", function(h) {
      return Sre(t, h);
    }), Co(l, a.style);
  }), s.selectAll("defs *").remove(), s.selectAll("defs").each(function(o) {
    var a = t.edge(o), l = n[a.arrowhead];
    l(wt(this), a.arrowheadId, a, "arrowhead");
  }), s;
};
function kre(e) {
  rk = e;
}
function wre(e, t) {
  var n = e.split("#")[0];
  return n + "#" + t;
}
function Sre(e, t) {
  var n = e.edge(t), r = e.node(t.v), i = e.node(t.w), s = n.points.slice(1, n.points.length - 1);
  return s.unshift(g8(r, s[0])), s.push(g8(i, s[s.length - 1])), tF(n, s);
}
function tF(e, t) {
  var n = (Qu || xqt.line)().x(function(r) {
    return r.x;
  }).y(function(r) {
    return r.y;
  });
  return (n.curve || n.interpolate)(e.curve), n(t);
}
function Cre(e) {
  var t = e.getBBox(), n = e.ownerSVGElement.getScreenCTM().inverse().multiply(e.getScreenCTM()).translate(t.width / 2, t.height / 2);
  return { x: n.e, y: n.f };
}
function Tre(e, t) {
  var n = e.enter().append("g").attr("class", "edgePath").style("opacity", 0);
  return n.append("path").attr("class", "path").attr("d", function(r) {
    var i = t.edge(r), s = t.node(r.v).elem, o = bc(i.points.length).map(function() {
      return Cre(s);
    });
    return tF(i, o);
  }), n.append("defs"), n;
}
function Ere(e, t) {
  var n = e.exit();
  Ss(n, t).style("opacity", 0).remove();
}
var ik = function(e, t, n) {
  var r = t.nodes().filter(function(o) {
    return !HB(t, o);
  }), i = e.selectAll("g.node").data(r, function(o) {
    return o;
  }).classed("update", !0);
  i.exit().remove(), i.enter().append("g").attr("class", "node").style("opacity", 0), i = e.selectAll("g.node"), i.each(function(o) {
    var a = t.node(o), l = wt(this);
    JB(
      l,
      a.class,
      (l.classed("update") ? "update " : "") + "node"
    ), l.select("g.label").remove();
    var h = l.append("g").attr("class", "label"), u = O5(h, a), f = n[a.shape], d = gp(u.node().getBBox(), "width", "height");
    a.elem = this, a.id && l.attr("id", a.id), a.labelId && h.attr("id", a.labelId), ve(a, "width") && (d.width = a.width), ve(a, "height") && (d.height = a.height), d.width += a.paddingLeft + a.paddingRight, d.height += a.paddingTop + a.paddingBottom, h.attr(
      "transform",
      "translate(" + (a.paddingLeft - a.paddingRight) / 2 + "," + (a.paddingTop - a.paddingBottom) / 2 + ")"
    );
    var p = wt(this);
    p.select(".label-container").remove();
    var g = f(p, d, a).classed("label-container", !0);
    Co(g, a.style);
    var m = g.node().getBBox();
    a.width = m.width, a.height = m.height;
  });
  var s;
  return i.exit ? s = i.exit() : s = i.selectAll(null), Ss(s, t).style("opacity", 0).remove(), i;
};
function Are(e) {
  ik = e;
}
function Pre(e, t) {
  var n = e.filter(function() {
    return !wt(this).classed("update");
  });
  function r(i) {
    var s = t.node(i);
    return "translate(" + s.x + "," + s.y + ")";
  }
  n.attr("transform", r), Ss(e, t).style("opacity", 1).attr("transform", r), Ss(n.selectAll("rect"), t).attr("width", function(i) {
    return t.node(i).width;
  }).attr("height", function(i) {
    return t.node(i).height;
  }).attr("x", function(i) {
    var s = t.node(i);
    return -s.width / 2;
  }).attr("y", function(i) {
    var s = t.node(i);
    return -s.height / 2;
  });
}
function Dre(e, t) {
  var n = e.filter(function() {
    return !wt(this).classed("update");
  });
  function r(i) {
    var s = t.edge(i);
    return ve(s, "x") ? "translate(" + s.x + "," + s.y + ")" : "";
  }
  n.attr("transform", r), Ss(e, t).style("opacity", 1).attr("transform", r);
}
function Lre(e, t) {
  var n = e.filter(function() {
    return !wt(this).classed("update");
  });
  function r(i) {
    var s = t.node(i);
    return "translate(" + s.x + "," + s.y + ")";
  }
  n.attr("transform", r), Ss(e, t).style("opacity", 1).attr("transform", r);
}
function eF(e, t, n, r) {
  var i = e.x, s = e.y, o = i - r.x, a = s - r.y, l = Math.sqrt(t * t * a * a + n * n * o * o), h = Math.abs(t * n * o / l);
  r.x < i && (h = -h);
  var u = Math.abs(t * n * a / l);
  return r.y < s && (u = -u), { x: i + h, y: s + u };
}
function Mre(e, t, n) {
  return eF(e, t, t, n);
}
function Rre(e, t, n, r) {
  var i, s, o, a, l, h, u, f, d, p, g, m, y, O, x;
  if (i = t.y - e.y, o = e.x - t.x, l = t.x * e.y - e.x * t.y, d = i * n.x + o * n.y + l, p = i * r.x + o * r.y + l, !(d !== 0 && p !== 0 && m8(d, p)) && (s = r.y - n.y, a = n.x - r.x, h = r.x * n.y - n.x * r.y, u = s * e.x + a * e.y + h, f = s * t.x + a * t.y + h, !(u !== 0 && f !== 0 && m8(u, f)) && (g = i * a - s * o, g !== 0)))
    return m = Math.abs(g / 2), y = o * h - a * l, O = y < 0 ? (y - m) / g : (y + m) / g, y = s * l - i * h, x = y < 0 ? (y - m) / g : (y + m) / g, { x: O, y: x };
}
function m8(e, t) {
  return e * t > 0;
}
function To(e, t, n) {
  var r = e.x, i = e.y, s = [], o = Number.POSITIVE_INFINITY, a = Number.POSITIVE_INFINITY;
  t.forEach(function(g) {
    o = Math.min(o, g.x), a = Math.min(a, g.y);
  });
  for (var l = r - e.width / 2 - o, h = i - e.height / 2 - a, u = 0; u < t.length; u++) {
    var f = t[u], d = t[u < t.length - 1 ? u + 1 : 0], p = Rre(
      e,
      n,
      { x: l + f.x, y: h + f.y },
      { x: l + d.x, y: h + d.y }
    );
    p && s.push(p);
  }
  return s.length ? (s.length > 1 && s.sort(function(g, m) {
    var y = g.x - n.x, O = g.y - n.y, x = Math.sqrt(y * y + O * O), _ = m.x - n.x, w = m.y - n.y, E = Math.sqrt(_ * _ + w * w);
    return x < E ? -1 : x === E ? 0 : 1;
  }), s[0]) : (console.log("NO INTERSECTION FOUND, RETURN NODE CENTER", e), e);
}
function x5(e, t) {
  var n = e.x, r = e.y, i = t.x - n, s = t.y - r, o = e.width / 2, a = e.height / 2, l, h;
  return Math.abs(s) * o > Math.abs(i) * a ? (s < 0 && (a = -a), l = s === 0 ? 0 : a * i / s, h = a) : (i < 0 && (o = -o), l = o, h = i === 0 ? 0 : o * s / i), { x: n + l, y: r + h };
}
var sk = {
  rect: Ire,
  ellipse: Nre,
  circle: Bre,
  diamond: Fre
};
function $re(e) {
  sk = e;
}
function Ire(e, t, n) {
  var r = e.insert("rect", ":first-child").attr("rx", n.rx).attr("ry", n.ry).attr("x", -t.width / 2).attr("y", -t.height / 2).attr("width", t.width).attr("height", t.height);
  return n.intersect = function(i) {
    return x5(n, i);
  }, r;
}
function Nre(e, t, n) {
  var r = t.width / 2, i = t.height / 2, s = e.insert("ellipse", ":first-child").attr("x", -t.width / 2).attr("y", -t.height / 2).attr("rx", r).attr("ry", i);
  return n.intersect = function(o) {
    return eF(n, r, i, o);
  }, s;
}
function Bre(e, t, n) {
  var r = Math.max(t.width, t.height) / 2, i = e.insert("circle", ":first-child").attr("x", -t.width / 2).attr("y", -t.height / 2).attr("r", r);
  return n.intersect = function(s) {
    return Mre(n, r, s);
  }, i;
}
function Fre(e, t, n) {
  var r = t.width * Math.SQRT2 / 2, i = t.height * Math.SQRT2 / 2, s = [
    { x: 0, y: -i },
    { x: -r, y: 0 },
    { x: 0, y: i },
    { x: r, y: 0 }
  ], o = e.insert("polygon", ":first-child").attr(
    "points",
    s.map(function(a) {
      return a.x + "," + a.y;
    }).join(" ")
  );
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function Qre() {
  var e = function(t, n) {
    Yre(n);
    var r = gf(t, "output"), i = gf(r, "clusters"), s = gf(r, "edgePaths"), o = nk(gf(r, "edgeLabels"), n), a = ik(gf(r, "nodes"), n, sk);
    Wu(n), Lre(a, n), Dre(o, n), rk(s, n, tk);
    var l = ek(i, n);
    Pre(l, n), zre(n);
  };
  return e.createNodes = function(t) {
    return arguments.length ? (Are(t), e) : ik;
  }, e.createClusters = function(t) {
    return arguments.length ? (vre(t), e) : ek;
  }, e.createEdgeLabels = function(t) {
    return arguments.length ? (_re(t), e) : nk;
  }, e.createEdgePaths = function(t) {
    return arguments.length ? (kre(t), e) : rk;
  }, e.shapes = function(t) {
    return arguments.length ? ($re(t), e) : sk;
  }, e.arrows = function(t) {
    return arguments.length ? (pre(t), e) : tk;
  }, e;
}
var Zre = {
  paddingLeft: 10,
  paddingRight: 10,
  paddingTop: 10,
  paddingBottom: 10,
  rx: 0,
  ry: 0,
  shape: "rect"
}, Vre = {
  arrowhead: "normal",
  curve: Oi
};
function Yre(e) {
  e.nodes().forEach(function(t) {
    var n = e.node(t);
    !ve(n, "label") && !e.children(t).length && (n.label = t), ve(n, "paddingX") && Xc(n, {
      paddingLeft: n.paddingX,
      paddingRight: n.paddingX
    }), ve(n, "paddingY") && Xc(n, {
      paddingTop: n.paddingY,
      paddingBottom: n.paddingY
    }), ve(n, "padding") && Xc(n, {
      paddingLeft: n.padding,
      paddingRight: n.padding,
      paddingTop: n.padding,
      paddingBottom: n.padding
    }), Xc(n, Zre), Ot(["paddingLeft", "paddingRight", "paddingTop", "paddingBottom"], function(r) {
      n[r] = Number(n[r]);
    }), ve(n, "width") && (n._prevWidth = n.width), ve(n, "height") && (n._prevHeight = n.height);
  }), e.edges().forEach(function(t) {
    var n = e.edge(t);
    ve(n, "label") || (n.label = ""), Xc(n, Vre);
  });
}
function zre(e) {
  Ot(e.nodes(), function(t) {
    var n = e.node(t);
    ve(n, "_prevWidth") ? n.width = n._prevWidth : delete n.width, ve(n, "_prevHeight") ? n.height = n._prevHeight : delete n.height, delete n._prevWidth, delete n._prevHeight;
  });
}
function gf(e, t) {
  var n = e.select("g." + t);
  return n.empty() && (n = e.append("g").attr("class", t)), n;
}
var nF = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(E2, function() {
    var n = "day";
    return function(r, i, s) {
      var o = function(h) {
        return h.add(4 - h.isoWeekday(), n);
      }, a = i.prototype;
      a.isoWeekYear = function() {
        return o(this).year();
      }, a.isoWeek = function(h) {
        if (!this.$utils().u(h))
          return this.add(7 * (h - this.isoWeek()), n);
        var u, f, d, p, g = o(this), m = (u = this.isoWeekYear(), f = this.$u, d = (f ? s.utc : s)().year(u).startOf("year"), p = 4 - d.isoWeekday(), d.isoWeekday() > 4 && (p += 7), d.add(p, n));
        return g.diff(m, "week") + 1;
      }, a.isoWeekday = function(h) {
        return this.$utils().u(h) ? this.day() || 7 : this.day(this.day() % 7 ? h : h - 7);
      };
      var l = a.startOf;
      a.startOf = function(h, u) {
        var f = this.$utils(), d = !!f.u(u) || u;
        return f.p(h) === "isoweek" ? d ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : l.bind(this)(h, u);
      };
    };
  });
})(nF);
const qre = nF.exports;
var rF = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(E2, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, i = /\d\d/, s = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, a = {}, l = function(m) {
      return (m = +m) + (m > 68 ? 1900 : 2e3);
    }, h = function(m) {
      return function(y) {
        this[m] = +y;
      };
    }, u = [/[+-]\d\d:?(\d\d)?|Z/, function(m) {
      (this.zone || (this.zone = {})).offset = function(y) {
        if (!y || y === "Z")
          return 0;
        var O = y.match(/([+-]|\d\d)/g), x = 60 * O[1] + (+O[2] || 0);
        return x === 0 ? 0 : O[0] === "+" ? -x : x;
      }(m);
    }], f = function(m) {
      var y = a[m];
      return y && (y.indexOf ? y : y.s.concat(y.f));
    }, d = function(m, y) {
      var O, x = a.meridiem;
      if (x) {
        for (var _ = 1; _ <= 24; _ += 1)
          if (m.indexOf(x(_, 0, y)) > -1) {
            O = _ > 12;
            break;
          }
      } else
        O = m === (y ? "pm" : "PM");
      return O;
    }, p = { A: [o, function(m) {
      this.afternoon = d(m, !1);
    }], a: [o, function(m) {
      this.afternoon = d(m, !0);
    }], S: [/\d/, function(m) {
      this.milliseconds = 100 * +m;
    }], SS: [i, function(m) {
      this.milliseconds = 10 * +m;
    }], SSS: [/\d{3}/, function(m) {
      this.milliseconds = +m;
    }], s: [s, h("seconds")], ss: [s, h("seconds")], m: [s, h("minutes")], mm: [s, h("minutes")], H: [s, h("hours")], h: [s, h("hours")], HH: [s, h("hours")], hh: [s, h("hours")], D: [s, h("day")], DD: [i, h("day")], Do: [o, function(m) {
      var y = a.ordinal, O = m.match(/\d+/);
      if (this.day = O[0], y)
        for (var x = 1; x <= 31; x += 1)
          y(x).replace(/\[|\]/g, "") === m && (this.day = x);
    }], M: [s, h("month")], MM: [i, h("month")], MMM: [o, function(m) {
      var y = f("months"), O = (f("monthsShort") || y.map(function(x) {
        return x.slice(0, 3);
      })).indexOf(m) + 1;
      if (O < 1)
        throw new Error();
      this.month = O % 12 || O;
    }], MMMM: [o, function(m) {
      var y = f("months").indexOf(m) + 1;
      if (y < 1)
        throw new Error();
      this.month = y % 12 || y;
    }], Y: [/[+-]?\d+/, h("year")], YY: [i, function(m) {
      this.year = l(m);
    }], YYYY: [/\d{4}/, h("year")], Z: u, ZZ: u };
    function g(m) {
      var y, O;
      y = m, O = a && a.formats;
      for (var x = (m = y.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(A, P, C) {
        var k = C && C.toUpperCase();
        return P || O[C] || n[C] || O[k].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(D, b, M) {
          return b || M.slice(1);
        });
      })).match(r), _ = x.length, w = 0; w < _; w += 1) {
        var E = x[w], T = p[E], S = T && T[0], R = T && T[1];
        x[w] = R ? { regex: S, parser: R } : E.replace(/^\[|\]$/g, "");
      }
      return function(A) {
        for (var P = {}, C = 0, k = 0; C < _; C += 1) {
          var D = x[C];
          if (typeof D == "string")
            k += D.length;
          else {
            var b = D.regex, M = D.parser, v = A.slice(k), N = b.exec(v)[0];
            M.call(P, N), A = A.replace(N, "");
          }
        }
        return function(tt) {
          var Z = tt.afternoon;
          if (Z !== void 0) {
            var z = tt.hours;
            Z ? z < 12 && (tt.hours += 12) : z === 12 && (tt.hours = 0), delete tt.afternoon;
          }
        }(P), P;
      };
    }
    return function(m, y, O) {
      O.p.customParseFormat = !0, m && m.parseTwoDigitYear && (l = m.parseTwoDigitYear);
      var x = y.prototype, _ = x.parse;
      x.parse = function(w) {
        var E = w.date, T = w.utc, S = w.args;
        this.$u = T;
        var R = S[1];
        if (typeof R == "string") {
          var A = S[2] === !0, P = S[3] === !0, C = A || P, k = S[2];
          P && (k = S[2]), a = this.$locale(), !A && k && (a = O.Ls[k]), this.$d = function(v, N, tt) {
            try {
              if (["x", "X"].indexOf(N) > -1)
                return new Date((N === "X" ? 1e3 : 1) * v);
              var Z = g(N)(v), z = Z.year, X = Z.month, q = Z.day, nt = Z.hours, st = Z.minutes, ct = Z.seconds, Y = Z.milliseconds, Ct = Z.zone, H = new Date(), et = q || (z || X ? 1 : H.getDate()), U = z || H.getFullYear(), W = 0;
              z && !X || (W = X > 0 ? X - 1 : H.getMonth());
              var $ = nt || 0, F = st || 0, G = ct || 0, I = Y || 0;
              return Ct ? new Date(Date.UTC(U, W, et, $, F, G, I + 60 * Ct.offset * 1e3)) : tt ? new Date(Date.UTC(U, W, et, $, F, G, I)) : new Date(U, W, et, $, F, G, I);
            } catch {
              return new Date("");
            }
          }(E, R, T), this.init(), k && k !== !0 && (this.$L = this.locale(k).$L), C && E != this.format(R) && (this.$d = new Date("")), a = {};
        } else if (R instanceof Array)
          for (var D = R.length, b = 1; b <= D; b += 1) {
            S[1] = R[b - 1];
            var M = O.apply(this, S);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            b === D && (this.$d = new Date(""));
          }
        else
          _.call(this, w);
      };
    };
  });
})(rF);
const Wre = rF.exports;
var iF = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(E2, function() {
    return function(n, r) {
      var i = r.prototype, s = i.format;
      i.format = function(o) {
        var a = this, l = this.$locale();
        if (!this.isValid())
          return s.bind(this)(o);
        var h = this.$utils(), u = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(f) {
          switch (f) {
            case "Q":
              return Math.ceil((a.$M + 1) / 3);
            case "Do":
              return l.ordinal(a.$D);
            case "gggg":
              return a.weekYear();
            case "GGGG":
              return a.isoWeekYear();
            case "wo":
              return l.ordinal(a.week(), "W");
            case "w":
            case "ww":
              return h.s(a.week(), f === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return h.s(a.isoWeek(), f === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return h.s(String(a.$H === 0 ? 24 : a.$H), f === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(a.$d.getTime() / 1e3);
            case "x":
              return a.$d.getTime();
            case "z":
              return "[" + a.offsetName() + "]";
            case "zzz":
              return "[" + a.offsetName("long") + "]";
            default:
              return f;
          }
        });
        return s.bind(this)(u);
      };
    };
  });
})(iF);
const Ure = iF.exports, Do = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
}, B = {
  trace: (...e) => {
  },
  debug: (...e) => {
  },
  info: (...e) => {
  },
  warn: (...e) => {
  },
  error: (...e) => {
  },
  fatal: (...e) => {
  }
}, v5 = function(e = "fatal") {
  let t = Do.fatal;
  typeof e == "string" ? (e = e.toLowerCase(), e in Do && (t = Do[e])) : typeof e == "number" && (t = e), B.trace = () => {
  }, B.debug = () => {
  }, B.info = () => {
  }, B.warn = () => {
  }, B.error = () => {
  }, B.fatal = () => {
  }, t <= Do.fatal && (B.fatal = console.error ? console.error.bind(console, Ai("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", Ai("FATAL"))), t <= Do.error && (B.error = console.error ? console.error.bind(console, Ai("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", Ai("ERROR"))), t <= Do.warn && (B.warn = console.warn ? console.warn.bind(console, Ai("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", Ai("WARN"))), t <= Do.info && (B.info = console.info ? console.info.bind(console, Ai("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", Ai("INFO"))), t <= Do.debug && (B.debug = console.debug ? console.debug.bind(console, Ai("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Ai("DEBUG"))), t <= Do.trace && (B.trace = console.debug ? console.debug.bind(console, Ai("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Ai("TRACE")));
}, Ai = (e) => `%c${ri().format("ss.SSS")} : ${e} : `, jre = (e) => e ? oF(e).replace(/\\n/g, "#br#").split("#br#") : [""], sF = (e) => ap.sanitize(e), y8 = (e, t) => {
  var n;
  if (((n = t.flowchart) == null ? void 0 : n.htmlLabels) !== !1) {
    const r = t.securityLevel;
    r === "antiscript" || r === "strict" ? e = sF(e) : r !== "loose" && (e = oF(e), e = e.replace(/</g, "&lt;").replace(/>/g, "&gt;"), e = e.replace(/=/g, "&equals;"), e = Kre(e));
  }
  return e;
}, Gi = (e, t) => e && (t.dompurifyConfig ? e = ap.sanitize(y8(e, t), t.dompurifyConfig).toString() : e = ap.sanitize(y8(e, t), {
  FORBID_TAGS: ["style"]
}).toString(), e), Xre = (e, t) => typeof e == "string" ? Gi(e, t) : e.flat().map((n) => Gi(n, t)), zy = /<br\s*\/?>/gi, Gre = (e) => zy.test(e), Hre = (e) => e.split(zy), Kre = (e) => e.replace(/#br#/g, "<br/>"), oF = (e) => e.replace(zy, "#br#"), Jre = (e) => {
  let t = "";
  return e && (t = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, t = t.replaceAll(/\(/g, "\\("), t = t.replaceAll(/\)/g, "\\)")), t;
}, ar = (e) => !(e === !1 || ["false", "null", "0"].includes(String(e).trim().toLowerCase())), Ua = function(e) {
  let t = e;
  if (e.split("~").length - 1 >= 2) {
    let n = t;
    do
      t = n, n = t.replace(/~([^\s,:;]+)~/, "<$1>");
    while (n != t);
    return Ua(n);
  } else
    return t;
}, de = {
  getRows: jre,
  sanitizeText: Gi,
  sanitizeTextOrArray: Xre,
  hasBreaks: Gre,
  splitBreaks: Hre,
  lineBreakRegex: zy,
  removeScript: sF,
  getUrl: Jre,
  evaluate: ar
}, Br = (e, t) => t ? ft(e, { s: -40, l: 10 }) : ft(e, { s: -40, l: -10 }), qy = "#ffffff", Wy = "#f2f2f2";
let tie = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
  }
  updateColors() {
    if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || ft(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || ft(this.primaryColor, { h: 180, l: 5 }), this.primaryBorderColor = this.primaryBorderColor || Br(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || Br(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || Br(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || Br(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || Nt(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || Nt(this.tertiaryColor), this.lineColor = this.lineColor || Nt(this.background), this.textColor = this.textColor || this.primaryTextColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? me(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || "grey", this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || me(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || Nt(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || oe(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ft(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ft(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ft(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ft(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ft(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ft(this.primaryColor, { h: 210, l: 150 }), this.cScale9 = this.cScale9 || ft(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ft(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ft(this.primaryColor, { h: 330 }), this.darkMode)
      for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
        this["cScale" + n] = me(this["cScale" + n], 75);
    else
      for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
        this["cScale" + n] = me(this["cScale" + n], 25);
    for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
      this["cScaleInv" + n] = this["cScaleInv" + n] || Nt(this["cScale" + n]);
    for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
      this.darkMode ? this["cScalePeer" + n] = this["cScalePeer" + n] || oe(this["cScale" + n], 10) : this["cScalePeer" + n] = this["cScalePeer" + n] || me(this["cScale" + n], 10);
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
      this["cScaleLabel" + n] = this["cScaleLabel" + n] || this.scaleLabelColor;
    const t = this.darkMode ? -4 : -1;
    for (let n = 0; n < 5; n++)
      this["surface" + n] = this["surface" + n] || ft(this.mainBkg, { h: 180, s: -15, l: t * (5 + n * 3) }), this["surfacePeer" + n] = this["surfacePeer" + n] || ft(this.mainBkg, { h: 180, s: -15, l: t * (8 + n * 3) });
    this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || ft(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || ft(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || ft(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || ft(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || ft(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || ft(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || ft(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || ft(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || ft(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || ft(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || ft(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || ft(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || ft(this.primaryColor, { h: 60, l: -20 }), this.pie11 = this.pie11 || ft(this.primaryColor, { h: -60, l: -20 }), this.pie12 = this.pie12 || ft(this.primaryColor, { h: 120, l: -10 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? me(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || ft(this.primaryColor, { h: -30 }), this.git4 = this.git4 || ft(this.primaryColor, { h: -60 }), this.git5 = this.git5 || ft(this.primaryColor, { h: -90 }), this.git6 = this.git6 || ft(this.primaryColor, { h: 60 }), this.git7 = this.git7 || ft(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = oe(this.git0, 25), this.git1 = oe(this.git1, 25), this.git2 = oe(this.git2, 25), this.git3 = oe(this.git3, 25), this.git4 = oe(this.git4, 25), this.git5 = oe(this.git5, 25), this.git6 = oe(this.git6, 25), this.git7 = oe(this.git7, 25)) : (this.git0 = me(this.git0, 25), this.git1 = me(this.git1, 25), this.git2 = me(this.git2, 25), this.git3 = me(this.git3, 25), this.git4 = me(this.git4, 25), this.git5 = me(this.git5, 25), this.git6 = me(this.git6, 25), this.git7 = me(this.git7, 25)), this.gitInv0 = this.gitInv0 || Nt(this.git0), this.gitInv1 = this.gitInv1 || Nt(this.git1), this.gitInv2 = this.gitInv2 || Nt(this.git2), this.gitInv3 = this.gitInv3 || Nt(this.git3), this.gitInv4 = this.gitInv4 || Nt(this.git4), this.gitInv5 = this.gitInv5 || Nt(this.git5), this.gitInv6 = this.gitInv6 || Nt(this.git6), this.gitInv7 = this.gitInv7 || Nt(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || qy, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Wy;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const n = Object.keys(t);
    n.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), n.forEach((r) => {
      this[r] = t[r];
    });
  }
};
const eie = (e) => {
  const t = new tie();
  return t.calculate(e), t;
};
let nie = class {
  constructor() {
    this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = oe(this.primaryColor, 16), this.tertiaryColor = ft(this.primaryColor, { h: -160 }), this.primaryBorderColor = Nt(this.background), this.secondaryBorderColor = Br(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Br(this.tertiaryColor, this.darkMode), this.primaryTextColor = Nt(this.primaryColor), this.secondaryTextColor = Nt(this.secondaryColor), this.tertiaryTextColor = Nt(this.tertiaryColor), this.lineColor = Nt(this.background), this.textColor = Nt(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = oe(Nt("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#81B1DB", this.border2 = td(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = me("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.taskBorderColor = td(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = td(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
  }
  updateColors() {
    this.secondBkg = oe(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = oe(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.mainContrastColor, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = oe(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ft(this.primaryColor, { h: 64 }), this.fillType3 = ft(this.secondaryColor, { h: 64 }), this.fillType4 = ft(this.primaryColor, { h: -64 }), this.fillType5 = ft(this.secondaryColor, { h: -64 }), this.fillType6 = ft(this.primaryColor, { h: 128 }), this.fillType7 = ft(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ft(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ft(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ft(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ft(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ft(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ft(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || ft(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ft(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ft(this.primaryColor, { h: 330 });
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || Nt(this["cScale" + t]);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScalePeer" + t] = this["cScalePeer" + t] || oe(this["cScale" + t], 10);
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || ft(this.mainBkg, { h: 30, s: -30, l: -(-10 + t * 4) }), this["surfacePeer" + t] = this["surfacePeer" + t] || ft(this.mainBkg, { h: 30, s: -30, l: -(-7 + t * 4) });
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["pie" + t] = this["cScale" + t];
    this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? me(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = oe(this.secondaryColor, 20), this.git1 = oe(this.pie2 || this.secondaryColor, 20), this.git2 = oe(this.pie3 || this.tertiaryColor, 20), this.git3 = oe(this.pie4 || ft(this.primaryColor, { h: -30 }), 20), this.git4 = oe(this.pie5 || ft(this.primaryColor, { h: -60 }), 20), this.git5 = oe(this.pie6 || ft(this.primaryColor, { h: -90 }), 10), this.git6 = oe(this.pie7 || ft(this.primaryColor, { h: 60 }), 10), this.git7 = oe(this.pie8 || ft(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || Nt(this.git0), this.gitInv1 = this.gitInv1 || Nt(this.git1), this.gitInv2 = this.gitInv2 || Nt(this.git2), this.gitInv3 = this.gitInv3 || Nt(this.git3), this.gitInv4 = this.gitInv4 || Nt(this.git4), this.gitInv5 = this.gitInv5 || Nt(this.git5), this.gitInv6 = this.gitInv6 || Nt(this.git6), this.gitInv7 = this.gitInv7 || Nt(this.git7), this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oe(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oe(this.background, 2);
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const n = Object.keys(t);
    n.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), n.forEach((r) => {
      this[r] = t[r];
    });
  }
};
const rie = (e) => {
  const t = new nie();
  return t.calculate(e), t;
};
let iie = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = ft(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = ft(this.primaryColor, { h: -160 }), this.primaryBorderColor = Br(this.primaryColor, this.darkMode), this.secondaryBorderColor = Br(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Br(this.tertiaryColor, this.darkMode), this.primaryTextColor = Nt(this.primaryColor), this.secondaryTextColor = Nt(this.secondaryColor), this.tertiaryTextColor = Nt(this.tertiaryColor), this.lineColor = Nt(this.background), this.textColor = Nt(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#e8e8e8", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "grey", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.sectionBkgColor = td(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ft(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ft(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ft(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ft(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ft(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ft(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || ft(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ft(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ft(this.primaryColor, { h: 330 }), this["cScalePeer" + 1] = this["cScalePeer" + 1] || me(this.secondaryColor, 45), this["cScalePeer" + 2] = this["cScalePeer" + 2] || me(this.tertiaryColor, 40);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScale" + t] = me(this["cScale" + t], 10), this["cScalePeer" + t] = this["cScalePeer" + t] || me(this["cScale" + t], 25);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || ft(this["cScale" + t], { h: 180 });
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || ft(this.mainBkg, { h: 30, l: -(5 + t * 5) }), this["surfacePeer" + t] = this["surfacePeer" + t] || ft(this.mainBkg, { h: 30, l: -(7 + t * 5) });
    if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || Nt(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || Nt(this.labelTextColor);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
        this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.labelTextColor;
    }
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = oe(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ft(this.primaryColor, { h: 64 }), this.fillType3 = ft(this.secondaryColor, { h: 64 }), this.fillType4 = ft(this.primaryColor, { h: -64 }), this.fillType5 = ft(this.secondaryColor, { h: -64 }), this.fillType6 = ft(this.primaryColor, { h: 128 }), this.fillType7 = ft(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || ft(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || ft(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || ft(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || ft(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || ft(this.primaryColor, { h: 60, l: -20 }), this.pie8 = this.pie8 || ft(this.primaryColor, { h: -60, l: -40 }), this.pie9 = this.pie9 || ft(this.primaryColor, { h: 120, l: -40 }), this.pie10 = this.pie10 || ft(this.primaryColor, { h: 60, l: -40 }), this.pie11 = this.pie11 || ft(this.primaryColor, { h: -90, l: -40 }), this.pie12 = this.pie12 || ft(this.primaryColor, { h: 120, l: -30 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || ft(this.primaryColor, { h: -30 }), this.git4 = this.git4 || ft(this.primaryColor, { h: -60 }), this.git5 = this.git5 || ft(this.primaryColor, { h: -90 }), this.git6 = this.git6 || ft(this.primaryColor, { h: 60 }), this.git7 = this.git7 || ft(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = oe(this.git0, 25), this.git1 = oe(this.git1, 25), this.git2 = oe(this.git2, 25), this.git3 = oe(this.git3, 25), this.git4 = oe(this.git4, 25), this.git5 = oe(this.git5, 25), this.git6 = oe(this.git6, 25), this.git7 = oe(this.git7, 25)) : (this.git0 = me(this.git0, 25), this.git1 = me(this.git1, 25), this.git2 = me(this.git2, 25), this.git3 = me(this.git3, 25), this.git4 = me(this.git4, 25), this.git5 = me(this.git5, 25), this.git6 = me(this.git6, 25), this.git7 = me(this.git7, 25)), this.gitInv0 = this.gitInv0 || me(Nt(this.git0), 25), this.gitInv1 = this.gitInv1 || Nt(this.git1), this.gitInv2 = this.gitInv2 || Nt(this.git2), this.gitInv3 = this.gitInv3 || Nt(this.git3), this.gitInv4 = this.gitInv4 || Nt(this.git4), this.gitInv5 = this.gitInv5 || Nt(this.git5), this.gitInv6 = this.gitInv6 || Nt(this.git6), this.gitInv7 = this.gitInv7 || Nt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || Nt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || Nt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || qy, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Wy;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const n = Object.keys(t);
    n.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), n.forEach((r) => {
      this[r] = t[r];
    });
  }
};
const sie = (e) => {
  const t = new iie();
  return t.calculate(e), t;
};
let oie = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = oe("#cde498", 10), this.primaryBorderColor = Br(this.primaryColor, this.darkMode), this.secondaryBorderColor = Br(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Br(this.tertiaryColor, this.darkMode), this.primaryTextColor = Nt(this.primaryColor), this.secondaryTextColor = Nt(this.secondaryColor), this.tertiaryTextColor = Nt(this.primaryColor), this.lineColor = Nt(this.background), this.textColor = Nt(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "grey", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ft(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ft(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ft(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ft(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ft(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ft(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || ft(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ft(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ft(this.primaryColor, { h: 330 }), this["cScalePeer" + 1] = this["cScalePeer" + 1] || me(this.secondaryColor, 45), this["cScalePeer" + 2] = this["cScalePeer" + 2] || me(this.tertiaryColor, 40);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScale" + t] = me(this["cScale" + t], 10), this["cScalePeer" + t] = this["cScalePeer" + t] || me(this["cScale" + t], 25);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || ft(this["cScale" + t], { h: 180 });
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || ft(this.mainBkg, { h: 30, s: -30, l: -(5 + t * 5) }), this["surfacePeer" + t] = this["surfacePeer" + t] || ft(this.mainBkg, { h: 30, s: -30, l: -(8 + t * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.actorBorder = me(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ft(this.primaryColor, { h: 64 }), this.fillType3 = ft(this.secondaryColor, { h: 64 }), this.fillType4 = ft(this.primaryColor, { h: -64 }), this.fillType5 = ft(this.secondaryColor, { h: -64 }), this.fillType6 = ft(this.primaryColor, { h: 128 }), this.fillType7 = ft(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || ft(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || ft(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || ft(this.tertiaryColor, { h: 40, l: -40 }), this.pie7 = this.pie7 || ft(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || ft(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || ft(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || ft(this.primaryColor, { h: 60, l: -50 }), this.pie11 = this.pie11 || ft(this.primaryColor, { h: -60, l: -50 }), this.pie12 = this.pie12 || ft(this.primaryColor, { h: 120, l: -50 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || ft(this.primaryColor, { h: -30 }), this.git4 = this.git4 || ft(this.primaryColor, { h: -60 }), this.git5 = this.git5 || ft(this.primaryColor, { h: -90 }), this.git6 = this.git6 || ft(this.primaryColor, { h: 60 }), this.git7 = this.git7 || ft(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = oe(this.git0, 25), this.git1 = oe(this.git1, 25), this.git2 = oe(this.git2, 25), this.git3 = oe(this.git3, 25), this.git4 = oe(this.git4, 25), this.git5 = oe(this.git5, 25), this.git6 = oe(this.git6, 25), this.git7 = oe(this.git7, 25)) : (this.git0 = me(this.git0, 25), this.git1 = me(this.git1, 25), this.git2 = me(this.git2, 25), this.git3 = me(this.git3, 25), this.git4 = me(this.git4, 25), this.git5 = me(this.git5, 25), this.git6 = me(this.git6, 25), this.git7 = me(this.git7, 25)), this.gitInv0 = this.gitInv0 || Nt(this.git0), this.gitInv1 = this.gitInv1 || Nt(this.git1), this.gitInv2 = this.gitInv2 || Nt(this.git2), this.gitInv3 = this.gitInv3 || Nt(this.git3), this.gitInv4 = this.gitInv4 || Nt(this.git4), this.gitInv5 = this.gitInv5 || Nt(this.git5), this.gitInv6 = this.gitInv6 || Nt(this.git6), this.gitInv7 = this.gitInv7 || Nt(this.git7), this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || qy, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Wy;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const n = Object.keys(t);
    n.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), n.forEach((r) => {
      this[r] = t[r];
    });
  }
};
const aie = (e) => {
  const t = new oie();
  return t.calculate(e), t;
};
class lie {
  constructor() {
    this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = oe(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = ft(this.primaryColor, { h: -160 }), this.primaryBorderColor = Br(this.primaryColor, this.darkMode), this.secondaryBorderColor = Br(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = Br(this.tertiaryColor, this.darkMode), this.primaryTextColor = Nt(this.primaryColor), this.secondaryTextColor = Nt(this.secondaryColor), this.tertiaryTextColor = Nt(this.tertiaryColor), this.lineColor = Nt(this.background), this.textColor = Nt(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.secondBkg = oe(this.contrast, 55), this.border2 = this.contrast, this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleInv" + t] = this["cScaleInv" + t] || Nt(this["cScale" + t]);
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this.darkMode ? this["cScalePeer" + t] = this["cScalePeer" + t] || oe(this["cScale" + t], 10) : this["cScalePeer" + t] = this["cScalePeer" + t] || me(this["cScale" + t], 10);
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
    for (let t = 0; t < 5; t++)
      this["surface" + t] = this["surface" + t] || ft(this.mainBkg, { l: -(5 + t * 5) }), this["surfacePeer" + t] = this["surfacePeer" + t] || ft(this.mainBkg, { l: -(8 + t * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.actorBorder = oe(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.lineColor, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.sectionBkgColor = oe(this.contrast, 30), this.sectionBkgColor2 = oe(this.contrast, 30), this.taskBorderColor = me(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = oe(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = me(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ft(this.primaryColor, { h: 64 }), this.fillType3 = ft(this.secondaryColor, { h: 64 }), this.fillType4 = ft(this.primaryColor, { h: -64 }), this.fillType5 = ft(this.secondaryColor, { h: -64 }), this.fillType6 = ft(this.primaryColor, { h: 128 }), this.fillType7 = ft(this.secondaryColor, { h: 128 });
    for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
      this["pie" + t] = this["cScale" + t];
    this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = me(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || ft(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || ft(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || ft(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || ft(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || ft(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || Nt(this.git0), this.gitInv1 = this.gitInv1 || Nt(this.git1), this.gitInv2 = this.gitInv2 || Nt(this.git2), this.gitInv3 = this.gitInv3 || Nt(this.git3), this.gitInv4 = this.gitInv4 || Nt(this.git4), this.gitInv5 = this.gitInv5 || Nt(this.git5), this.gitInv6 = this.gitInv6 || Nt(this.git6), this.gitInv7 = this.gitInv7 || Nt(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || qy, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Wy;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const n = Object.keys(t);
    n.forEach((r) => {
      this[r] = t[r];
    }), this.updateColors(), n.forEach((r) => {
      this[r] = t[r];
    });
  }
}
const cie = (e) => {
  const t = new lie();
  return t.calculate(e), t;
}, ra = {
  base: {
    getThemeVariables: eie
  },
  dark: {
    getThemeVariables: rie
  },
  default: {
    getThemeVariables: sie
  },
  forest: {
    getThemeVariables: aie
  },
  neutral: {
    getThemeVariables: cie
  }
}, ja = {
  theme: "default",
  themeVariables: ra.default.getThemeVariables(),
  themeCSS: void 0,
  maxTextSize: 5e4,
  darkMode: !1,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: !0,
  arrowMarkerAbsolute: !1,
  secure: ["secure", "securityLevel", "startOnLoad", "maxTextSize"],
  deterministicIds: !1,
  deterministicIDSeed: void 0,
  flowchart: {
    titleTopMargin: 25,
    diagramPadding: 8,
    htmlLabels: !0,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    useMaxWidth: !0,
    defaultRenderer: "dagre-wrapper"
  },
  sequence: {
    hideUnusedParticipants: !1,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: !0,
    forceMenus: !1,
    bottomMarginAdj: 1,
    useMaxWidth: !0,
    rightAngles: !1,
    showSequenceNumbers: !1,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: !1,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20,
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    noteFont: function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    },
    actorFont: function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }
  },
  gantt: {
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    tickInterval: void 0,
    useMaxWidth: !0,
    topAxis: !1,
    useWidth: void 0
  },
  journey: {
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    useMaxWidth: !0,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
    sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
    sectionColours: ["#fff"]
  },
  timeline: {
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    useMaxWidth: !0,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
    sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
    sectionColours: ["#fff"],
    disableMulticolor: !1
  },
  class: {
    titleTopMargin: 25,
    arrowMarkerAbsolute: !1,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    useMaxWidth: !0,
    defaultRenderer: "dagre-wrapper"
  },
  state: {
    titleTopMargin: 25,
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    useMaxWidth: !0,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    titleTopMargin: 25,
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12,
    useMaxWidth: !0
  },
  pie: {
    useWidth: void 0,
    useMaxWidth: !0
  },
  requirement: {
    useWidth: void 0,
    useMaxWidth: !0,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  gitGraph: {
    titleTopMargin: 25,
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: !0,
    showBranches: !0,
    rotateCommitLabel: !0
  },
  c4: {
    useWidth: void 0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    useMaxWidth: !0,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: !0,
    wrapPadding: 10,
    personFont: function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    },
    external_personFont: function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    },
    systemFont: function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    },
    external_systemFont: function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    },
    system_dbFont: function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    },
    external_system_dbFont: function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    },
    system_queueFont: function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    },
    external_system_queueFont: function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    },
    containerFont: function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    },
    external_containerFont: function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    },
    container_dbFont: function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    },
    external_container_dbFont: function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    },
    container_queueFont: function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    },
    external_container_queueFont: function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    },
    componentFont: function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    },
    external_componentFont: function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    },
    component_dbFont: function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    },
    external_component_dbFont: function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    },
    component_queueFont: function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    },
    external_component_queueFont: function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    },
    boundaryFont: function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    },
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  mindmap: {
    useMaxWidth: !0,
    padding: 10,
    maxNodeWidth: 200
  },
  fontSize: 16
};
ja.class && (ja.class.arrowMarkerAbsolute = ja.arrowMarkerAbsolute);
ja.gitGraph && (ja.gitGraph.arrowMarkerAbsolute = ja.arrowMarkerAbsolute);
const aF = (e, t = "") => Object.keys(e).reduce((n, r) => Array.isArray(e[r]) ? n : typeof e[r] == "object" && e[r] !== null ? [...n, t + r, ...aF(e[r], "")] : [...n, t + r], []), hie = aF(ja, ""), uie = ja;
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function lF(e) {
  return typeof e > "u" || e === null;
}
function fie(e) {
  return typeof e == "object" && e !== null;
}
function die(e) {
  return Array.isArray(e) ? e : lF(e) ? [] : [e];
}
function pie(e, t) {
  var n, r, i, s;
  if (t)
    for (s = Object.keys(t), n = 0, r = s.length; n < r; n += 1)
      i = s[n], e[i] = t[i];
  return e;
}
function gie(e, t) {
  var n = "", r;
  for (r = 0; r < t; r += 1)
    n += e;
  return n;
}
function mie(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
var yie = lF, bie = fie, Oie = die, xie = gie, vie = mie, _ie = pie, Nr = {
  isNothing: yie,
  isObject: bie,
  toArray: Oie,
  repeat: xie,
  isNegativeZero: vie,
  extend: _ie
};
function cF(e, t) {
  var n = "", r = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (n += 'in "' + e.mark.name + '" '), n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (n += `

` + e.mark.snippet), r + " " + n) : r;
}
function yp(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = cF(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
yp.prototype = Object.create(Error.prototype);
yp.prototype.constructor = yp;
yp.prototype.toString = function(t) {
  return this.name + ": " + cF(this, t);
};
var Zo = yp;
function px(e, t, n, r, i) {
  var s = "", o = "", a = Math.floor(i / 2) - 1;
  return r - t > a && (s = " ... ", t = r - a + s.length), n - r > a && (o = " ...", n = r + a - o.length), {
    str: s + e.slice(t, n).replace(/\t/g, "\u2192") + o,
    pos: r - t + s.length
  };
}
function gx(e, t) {
  return Nr.repeat(" ", t - e.length) + e;
}
function kie(e, t) {
  if (t = Object.create(t || null), !e.buffer)
    return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], s, o = -1; s = n.exec(e.buffer); )
    i.push(s.index), r.push(s.index + s[0].length), e.position <= s.index && o < 0 && (o = r.length - 2);
  o < 0 && (o = r.length - 1);
  var a = "", l, h, u = Math.min(e.line + t.linesAfter, i.length).toString().length, f = t.maxLength - (t.indent + u + 3);
  for (l = 1; l <= t.linesBefore && !(o - l < 0); l++)
    h = px(
      e.buffer,
      r[o - l],
      i[o - l],
      e.position - (r[o] - r[o - l]),
      f
    ), a = Nr.repeat(" ", t.indent) + gx((e.line - l + 1).toString(), u) + " | " + h.str + `
` + a;
  for (h = px(e.buffer, r[o], i[o], e.position, f), a += Nr.repeat(" ", t.indent) + gx((e.line + 1).toString(), u) + " | " + h.str + `
`, a += Nr.repeat("-", t.indent + u + 3 + h.pos) + `^
`, l = 1; l <= t.linesAfter && !(o + l >= i.length); l++)
    h = px(
      e.buffer,
      r[o + l],
      i[o + l],
      e.position - (r[o] - r[o + l]),
      f
    ), a += Nr.repeat(" ", t.indent) + gx((e.line + l + 1).toString(), u) + " | " + h.str + `
`;
  return a.replace(/\n$/, "");
}
var wie = kie, Sie = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], Cie = [
  "scalar",
  "sequence",
  "mapping"
];
function Tie(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(n) {
    e[n].forEach(function(r) {
      t[String(r)] = n;
    });
  }), t;
}
function Eie(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(n) {
    if (Sie.indexOf(n) === -1)
      throw new Zo('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(n) {
    return n;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = Tie(t.styleAliases || null), Cie.indexOf(this.kind) === -1)
    throw new Zo('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var Pr = Eie;
function b8(e, t) {
  var n = [];
  return e[t].forEach(function(r) {
    var i = n.length;
    n.forEach(function(s, o) {
      s.tag === r.tag && s.kind === r.kind && s.multi === r.multi && (i = o);
    }), n[i] = r;
  }), n;
}
function Aie() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, n;
  function r(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (t = 0, n = arguments.length; t < n; t += 1)
    arguments[t].forEach(r);
  return e;
}
function ok(e) {
  return this.extend(e);
}
ok.prototype.extend = function(t) {
  var n = [], r = [];
  if (t instanceof Pr)
    r.push(t);
  else if (Array.isArray(t))
    r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)), t.explicit && (r = r.concat(t.explicit));
  else
    throw new Zo("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(s) {
    if (!(s instanceof Pr))
      throw new Zo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Zo("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Zo("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(s) {
    if (!(s instanceof Pr))
      throw new Zo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(ok.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = b8(i, "implicit"), i.compiledExplicit = b8(i, "explicit"), i.compiledTypeMap = Aie(i.compiledImplicit, i.compiledExplicit), i;
};
var Pie = ok, Die = new Pr("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), Lie = new Pr("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), Mie = new Pr("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), hF = new Pie({
  explicit: [
    Die,
    Lie,
    Mie
  ]
});
function Rie(e) {
  if (e === null)
    return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function $ie() {
  return null;
}
function Iie(e) {
  return e === null;
}
var Nie = new Pr("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: Rie,
  construct: $ie,
  predicate: Iie,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function Bie(e) {
  if (e === null)
    return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function Fie(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function Qie(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Zie = new Pr("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: Bie,
  construct: Fie,
  predicate: Qie,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function Vie(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function Yie(e) {
  return 48 <= e && e <= 55;
}
function zie(e) {
  return 48 <= e && e <= 57;
}
function qie(e) {
  if (e === null)
    return !1;
  var t = e.length, n = 0, r = !1, i;
  if (!t)
    return !1;
  if (i = e[n], (i === "-" || i === "+") && (i = e[++n]), i === "0") {
    if (n + 1 === t)
      return !0;
    if (i = e[++n], i === "b") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!Vie(e.charCodeAt(n)))
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!Yie(e.charCodeAt(n)))
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_")
    return !1;
  for (; n < t; n++)
    if (i = e[n], i !== "_") {
      if (!zie(e.charCodeAt(n)))
        return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function Wie(e) {
  var t = e, n = 1, r;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), r = t[0], (r === "-" || r === "+") && (r === "-" && (n = -1), t = t.slice(1), r = t[0]), t === "0")
    return 0;
  if (r === "0") {
    if (t[1] === "b")
      return n * parseInt(t.slice(2), 2);
    if (t[1] === "x")
      return n * parseInt(t.slice(2), 16);
    if (t[1] === "o")
      return n * parseInt(t.slice(2), 8);
  }
  return n * parseInt(t, 10);
}
function Uie(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !Nr.isNegativeZero(e);
}
var jie = new Pr("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: qie,
  construct: Wie,
  predicate: Uie,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), Xie = new RegExp(
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function Gie(e) {
  return !(e === null || !Xie.test(e) || e[e.length - 1] === "_");
}
function Hie(e) {
  var t, n;
  return t = e.replace(/_/g, "").toLowerCase(), n = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : n * parseFloat(t, 10);
}
var Kie = /^[-+]?[0-9]+e/;
function Jie(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Nr.isNegativeZero(e))
    return "-0.0";
  return n = e.toString(10), Kie.test(n) ? n.replace("e", ".e") : n;
}
function tse(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Nr.isNegativeZero(e));
}
var ese = new Pr("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: Gie,
  construct: Hie,
  predicate: tse,
  represent: Jie,
  defaultStyle: "lowercase"
}), nse = hF.extend({
  implicit: [
    Nie,
    Zie,
    jie,
    ese
  ]
}), rse = nse, uF = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), fF = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function ise(e) {
  return e === null ? !1 : uF.exec(e) !== null || fF.exec(e) !== null;
}
function sse(e) {
  var t, n, r, i, s, o, a, l = 0, h = null, u, f, d;
  if (t = uF.exec(e), t === null && (t = fF.exec(e)), t === null)
    throw new Error("Date resolve error");
  if (n = +t[1], r = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(n, r, i));
  if (s = +t[4], o = +t[5], a = +t[6], t[7]) {
    for (l = t[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return t[9] && (u = +t[10], f = +(t[11] || 0), h = (u * 60 + f) * 6e4, t[9] === "-" && (h = -h)), d = new Date(Date.UTC(n, r, i, s, o, a, l)), h && d.setTime(d.getTime() - h), d;
}
function ose(e) {
  return e.toISOString();
}
var ase = new Pr("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: ise,
  construct: sse,
  instanceOf: Date,
  represent: ose
});
function lse(e) {
  return e === "<<" || e === null;
}
var cse = new Pr("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: lse
}), _5 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function hse(e) {
  if (e === null)
    return !1;
  var t, n, r = 0, i = e.length, s = _5;
  for (n = 0; n < i; n++)
    if (t = s.indexOf(e.charAt(n)), !(t > 64)) {
      if (t < 0)
        return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function use(e) {
  var t, n, r = e.replace(/[\r\n=]/g, ""), i = r.length, s = _5, o = 0, a = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)), o = o << 6 | s.indexOf(r.charAt(t));
  return n = i % 4 * 6, n === 0 ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)) : n === 18 ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : n === 12 && a.push(o >> 4 & 255), new Uint8Array(a);
}
function fse(e) {
  var t = "", n = 0, r, i, s = e.length, o = _5;
  for (r = 0; r < s; r++)
    r % 3 === 0 && r && (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]), n = (n << 8) + e[r];
  return i = s % 3, i === 0 ? (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]) : i === 2 ? (t += o[n >> 10 & 63], t += o[n >> 4 & 63], t += o[n << 2 & 63], t += o[64]) : i === 1 && (t += o[n >> 2 & 63], t += o[n << 4 & 63], t += o[64], t += o[64]), t;
}
function dse(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var pse = new Pr("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: hse,
  construct: use,
  predicate: dse,
  represent: fse
}), gse = Object.prototype.hasOwnProperty, mse = Object.prototype.toString;
function yse(e) {
  if (e === null)
    return !0;
  var t = [], n, r, i, s, o, a = e;
  for (n = 0, r = a.length; n < r; n += 1) {
    if (i = a[n], o = !1, mse.call(i) !== "[object Object]")
      return !1;
    for (s in i)
      if (gse.call(i, s))
        if (!o)
          o = !0;
        else
          return !1;
    if (!o)
      return !1;
    if (t.indexOf(s) === -1)
      t.push(s);
    else
      return !1;
  }
  return !0;
}
function bse(e) {
  return e !== null ? e : [];
}
var Ose = new Pr("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: yse,
  construct: bse
}), xse = Object.prototype.toString;
function vse(e) {
  if (e === null)
    return !0;
  var t, n, r, i, s, o = e;
  for (s = new Array(o.length), t = 0, n = o.length; t < n; t += 1) {
    if (r = o[t], xse.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1))
      return !1;
    s[t] = [i[0], r[i[0]]];
  }
  return !0;
}
function _se(e) {
  if (e === null)
    return [];
  var t, n, r, i, s, o = e;
  for (s = new Array(o.length), t = 0, n = o.length; t < n; t += 1)
    r = o[t], i = Object.keys(r), s[t] = [i[0], r[i[0]]];
  return s;
}
var kse = new Pr("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: vse,
  construct: _se
}), wse = Object.prototype.hasOwnProperty;
function Sse(e) {
  if (e === null)
    return !0;
  var t, n = e;
  for (t in n)
    if (wse.call(n, t) && n[t] !== null)
      return !1;
  return !0;
}
function Cse(e) {
  return e !== null ? e : {};
}
var Tse = new Pr("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: Sse,
  construct: Cse
}), Ese = rse.extend({
  implicit: [
    ase,
    cse
  ],
  explicit: [
    pse,
    Ose,
    kse,
    Tse
  ]
}), hl = Object.prototype.hasOwnProperty, Wm = 1, dF = 2, pF = 3, Um = 4, mx = 1, Ase = 2, O8 = 3, Pse = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Dse = /[\x85\u2028\u2029]/, Lse = /[,\[\]\{\}]/, gF = /^(?:!|!!|![a-z\-]+!)$/i, mF = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function x8(e) {
  return Object.prototype.toString.call(e);
}
function fo(e) {
  return e === 10 || e === 13;
}
function Jl(e) {
  return e === 9 || e === 32;
}
function ii(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function ah(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function Mse(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function Rse(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function $se(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function v8(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "\x85" : e === 95 ? "\xA0" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function Ise(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var yF = new Array(256), bF = new Array(256);
for (var Yc = 0; Yc < 256; Yc++)
  yF[Yc] = v8(Yc) ? 1 : 0, bF[Yc] = v8(Yc);
function Nse(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || Ese, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function OF(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return n.snippet = wie(n), new Zo(t, n);
}
function te(e, t) {
  throw OF(e, t);
}
function jm(e, t) {
  e.onWarning && e.onWarning.call(null, OF(e, t));
}
var _8 = {
  YAML: function(t, n, r) {
    var i, s, o;
    t.version !== null && te(t, "duplication of %YAML directive"), r.length !== 1 && te(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && te(t, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), o = parseInt(i[2], 10), s !== 1 && te(t, "unacceptable YAML version of the document"), t.version = r[0], t.checkLineBreaks = o < 2, o !== 1 && o !== 2 && jm(t, "unsupported YAML version of the document");
  },
  TAG: function(t, n, r) {
    var i, s;
    r.length !== 2 && te(t, "TAG directive accepts exactly two arguments"), i = r[0], s = r[1], gF.test(i) || te(t, "ill-formed tag handle (first argument) of the TAG directive"), hl.call(t.tagMap, i) && te(t, 'there is a previously declared suffix for "' + i + '" tag handle'), mF.test(s) || te(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      te(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[i] = s;
  }
};
function Xa(e, t, n, r) {
  var i, s, o, a;
  if (t < n) {
    if (a = e.input.slice(t, n), r)
      for (i = 0, s = a.length; i < s; i += 1)
        o = a.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || te(e, "expected valid JSON character");
    else
      Pse.test(a) && te(e, "the stream contains non-printable characters");
    e.result += a;
  }
}
function k8(e, t, n, r) {
  var i, s, o, a;
  for (Nr.isObject(n) || te(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), o = 0, a = i.length; o < a; o += 1)
    s = i[o], hl.call(t, s) || (t[s] = n[s], r[s] = !0);
}
function lh(e, t, n, r, i, s, o, a, l) {
  var h, u;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), h = 0, u = i.length; h < u; h += 1)
      Array.isArray(i[h]) && te(e, "nested arrays are not supported inside keys"), typeof i == "object" && x8(i[h]) === "[object Object]" && (i[h] = "[object Object]");
  if (typeof i == "object" && x8(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), r === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (h = 0, u = s.length; h < u; h += 1)
        k8(e, t, s[h], n);
    else
      k8(e, t, s, n);
  else
    !e.json && !hl.call(n, i) && hl.call(t, i) && (e.line = o || e.line, e.lineStart = a || e.lineStart, e.position = l || e.position, te(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[i] = s, delete n[i];
  return t;
}
function k5(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : te(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function Qn(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Jl(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (fo(i))
      for (k5(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return n !== -1 && r !== 0 && e.lineIndent < n && jm(e, "deficient indentation"), r;
}
function Uy(e) {
  var t = e.position, n;
  return n = e.input.charCodeAt(t), !!((n === 45 || n === 46) && n === e.input.charCodeAt(t + 1) && n === e.input.charCodeAt(t + 2) && (t += 3, n = e.input.charCodeAt(t), n === 0 || ii(n)));
}
function w5(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Nr.repeat(`
`, t - 1));
}
function Bse(e, t, n) {
  var r, i, s, o, a, l, h, u, f = e.kind, d = e.result, p;
  if (p = e.input.charCodeAt(e.position), ii(p) || ah(p) || p === 35 || p === 38 || p === 42 || p === 33 || p === 124 || p === 62 || p === 39 || p === 34 || p === 37 || p === 64 || p === 96 || (p === 63 || p === 45) && (i = e.input.charCodeAt(e.position + 1), ii(i) || n && ah(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = o = e.position, a = !1; p !== 0; ) {
    if (p === 58) {
      if (i = e.input.charCodeAt(e.position + 1), ii(i) || n && ah(i))
        break;
    } else if (p === 35) {
      if (r = e.input.charCodeAt(e.position - 1), ii(r))
        break;
    } else {
      if (e.position === e.lineStart && Uy(e) || n && ah(p))
        break;
      if (fo(p))
        if (l = e.line, h = e.lineStart, u = e.lineIndent, Qn(e, !1, -1), e.lineIndent >= t) {
          a = !0, p = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = l, e.lineStart = h, e.lineIndent = u;
          break;
        }
    }
    a && (Xa(e, s, o, !1), w5(e, e.line - l), s = o = e.position, a = !1), Jl(p) || (o = e.position + 1), p = e.input.charCodeAt(++e.position);
  }
  return Xa(e, s, o, !1), e.result ? !0 : (e.kind = f, e.result = d, !1);
}
function Fse(e, t) {
  var n, r, i;
  if (n = e.input.charCodeAt(e.position), n !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
    if (n === 39)
      if (Xa(e, r, e.position, !0), n = e.input.charCodeAt(++e.position), n === 39)
        r = e.position, e.position++, i = e.position;
      else
        return !0;
    else
      fo(n) ? (Xa(e, r, i, !0), w5(e, Qn(e, !1, t)), r = i = e.position) : e.position === e.lineStart && Uy(e) ? te(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  te(e, "unexpected end of the stream within a single quoted scalar");
}
function Qse(e, t) {
  var n, r, i, s, o, a;
  if (a = e.input.charCodeAt(e.position), a !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; (a = e.input.charCodeAt(e.position)) !== 0; ) {
    if (a === 34)
      return Xa(e, n, e.position, !0), e.position++, !0;
    if (a === 92) {
      if (Xa(e, n, e.position, !0), a = e.input.charCodeAt(++e.position), fo(a))
        Qn(e, !1, t);
      else if (a < 256 && yF[a])
        e.result += bF[a], e.position++;
      else if ((o = Rse(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          a = e.input.charCodeAt(++e.position), (o = Mse(a)) >= 0 ? s = (s << 4) + o : te(e, "expected hexadecimal character");
        e.result += Ise(s), e.position++;
      } else
        te(e, "unknown escape sequence");
      n = r = e.position;
    } else
      fo(a) ? (Xa(e, n, r, !0), w5(e, Qn(e, !1, t)), n = r = e.position) : e.position === e.lineStart && Uy(e) ? te(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
  }
  te(e, "unexpected end of the stream within a double quoted scalar");
}
function Zse(e, t) {
  var n = !0, r, i, s, o = e.tag, a, l = e.anchor, h, u, f, d, p, g = /* @__PURE__ */ Object.create(null), m, y, O, x;
  if (x = e.input.charCodeAt(e.position), x === 91)
    u = 93, p = !1, a = [];
  else if (x === 123)
    u = 125, p = !0, a = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), x = e.input.charCodeAt(++e.position); x !== 0; ) {
    if (Qn(e, !0, t), x = e.input.charCodeAt(e.position), x === u)
      return e.position++, e.tag = o, e.anchor = l, e.kind = p ? "mapping" : "sequence", e.result = a, !0;
    n ? x === 44 && te(e, "expected the node content, but found ','") : te(e, "missed comma between flow collection entries"), y = m = O = null, f = d = !1, x === 63 && (h = e.input.charCodeAt(e.position + 1), ii(h) && (f = d = !0, e.position++, Qn(e, !0, t))), r = e.line, i = e.lineStart, s = e.position, gu(e, t, Wm, !1, !0), y = e.tag, m = e.result, Qn(e, !0, t), x = e.input.charCodeAt(e.position), (d || e.line === r) && x === 58 && (f = !0, x = e.input.charCodeAt(++e.position), Qn(e, !0, t), gu(e, t, Wm, !1, !0), O = e.result), p ? lh(e, a, g, y, m, O, r, i, s) : f ? a.push(lh(e, null, g, y, m, O, r, i, s)) : a.push(m), Qn(e, !0, t), x = e.input.charCodeAt(e.position), x === 44 ? (n = !0, x = e.input.charCodeAt(++e.position)) : n = !1;
  }
  te(e, "unexpected end of the stream within a flow collection");
}
function Vse(e, t) {
  var n, r, i = mx, s = !1, o = !1, a = t, l = 0, h = !1, u, f;
  if (f = e.input.charCodeAt(e.position), f === 124)
    r = !1;
  else if (f === 62)
    r = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; f !== 0; )
    if (f = e.input.charCodeAt(++e.position), f === 43 || f === 45)
      mx === i ? i = f === 43 ? O8 : Ase : te(e, "repeat of a chomping mode identifier");
    else if ((u = $se(f)) >= 0)
      u === 0 ? te(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? te(e, "repeat of an indentation width identifier") : (a = t + u - 1, o = !0);
    else
      break;
  if (Jl(f)) {
    do
      f = e.input.charCodeAt(++e.position);
    while (Jl(f));
    if (f === 35)
      do
        f = e.input.charCodeAt(++e.position);
      while (!fo(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (k5(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position); (!o || e.lineIndent < a) && f === 32; )
      e.lineIndent++, f = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > a && (a = e.lineIndent), fo(f)) {
      l++;
      continue;
    }
    if (e.lineIndent < a) {
      i === O8 ? e.result += Nr.repeat(`
`, s ? 1 + l : l) : i === mx && s && (e.result += `
`);
      break;
    }
    for (r ? Jl(f) ? (h = !0, e.result += Nr.repeat(`
`, s ? 1 + l : l)) : h ? (h = !1, e.result += Nr.repeat(`
`, l + 1)) : l === 0 ? s && (e.result += " ") : e.result += Nr.repeat(`
`, l) : e.result += Nr.repeat(`
`, s ? 1 + l : l), s = !0, o = !0, l = 0, n = e.position; !fo(f) && f !== 0; )
      f = e.input.charCodeAt(++e.position);
    Xa(e, n, e.position, !1);
  }
  return !0;
}
function w8(e, t) {
  var n, r = e.tag, i = e.anchor, s = [], o, a = !1, l;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), l = e.input.charCodeAt(e.position); l !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, te(e, "tab characters must not be used in indentation")), !(l !== 45 || (o = e.input.charCodeAt(e.position + 1), !ii(o)))); ) {
    if (a = !0, e.position++, Qn(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), l = e.input.charCodeAt(e.position);
      continue;
    }
    if (n = e.line, gu(e, t, pF, !1, !0), s.push(e.result), Qn(e, !0, -1), l = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && l !== 0)
      te(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return a ? (e.tag = r, e.anchor = i, e.kind = "sequence", e.result = s, !0) : !1;
}
function Yse(e, t, n) {
  var r, i, s, o, a, l, h = e.tag, u = e.anchor, f = {}, d = /* @__PURE__ */ Object.create(null), p = null, g = null, m = null, y = !1, O = !1, x;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = f), x = e.input.charCodeAt(e.position); x !== 0; ) {
    if (!y && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, te(e, "tab characters must not be used in indentation")), r = e.input.charCodeAt(e.position + 1), s = e.line, (x === 63 || x === 58) && ii(r))
      x === 63 ? (y && (lh(e, f, d, p, g, null, o, a, l), p = g = m = null), O = !0, y = !0, i = !0) : y ? (y = !1, i = !0) : te(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, x = r;
    else {
      if (o = e.line, a = e.lineStart, l = e.position, !gu(e, n, dF, !1, !0))
        break;
      if (e.line === s) {
        for (x = e.input.charCodeAt(e.position); Jl(x); )
          x = e.input.charCodeAt(++e.position);
        if (x === 58)
          x = e.input.charCodeAt(++e.position), ii(x) || te(e, "a whitespace character is expected after the key-value separator within a block mapping"), y && (lh(e, f, d, p, g, null, o, a, l), p = g = m = null), O = !0, y = !1, i = !1, p = e.tag, g = e.result;
        else if (O)
          te(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = h, e.anchor = u, !0;
      } else if (O)
        te(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = h, e.anchor = u, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (y && (o = e.line, a = e.lineStart, l = e.position), gu(e, t, Um, !0, i) && (y ? g = e.result : m = e.result), y || (lh(e, f, d, p, g, m, o, a, l), p = g = m = null), Qn(e, !0, -1), x = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && x !== 0)
      te(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return y && lh(e, f, d, p, g, null, o, a, l), O && (e.tag = h, e.anchor = u, e.kind = "mapping", e.result = f), O;
}
function zse(e) {
  var t, n = !1, r = !1, i, s, o;
  if (o = e.input.charCodeAt(e.position), o !== 33)
    return !1;
  if (e.tag !== null && te(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (n = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (r = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, n) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), o = e.input.charCodeAt(++e.position)) : te(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !ii(o); )
      o === 33 && (r ? te(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), gF.test(i) || te(e, "named tag handle cannot contain such characters"), r = !0, t = e.position + 1)), o = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), Lse.test(s) && te(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !mF.test(s) && te(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    te(e, "tag name is malformed: " + s);
  }
  return n ? e.tag = s : hl.call(e.tagMap, i) ? e.tag = e.tagMap[i] + s : i === "!" ? e.tag = "!" + s : i === "!!" ? e.tag = "tag:yaml.org,2002:" + s : te(e, 'undeclared tag handle "' + i + '"'), !0;
}
function qse(e) {
  var t, n;
  if (n = e.input.charCodeAt(e.position), n !== 38)
    return !1;
  for (e.anchor !== null && te(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !ii(n) && !ah(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && te(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function Wse(e) {
  var t, n, r;
  if (r = e.input.charCodeAt(e.position), r !== 42)
    return !1;
  for (r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !ii(r) && !ah(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && te(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), hl.call(e.anchorMap, n) || te(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], Qn(e, !0, -1), !0;
}
function gu(e, t, n, r, i) {
  var s, o, a, l = 1, h = !1, u = !1, f, d, p, g, m, y;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = o = a = Um === n || pF === n, r && Qn(e, !0, -1) && (h = !0, e.lineIndent > t ? l = 1 : e.lineIndent === t ? l = 0 : e.lineIndent < t && (l = -1)), l === 1)
    for (; zse(e) || qse(e); )
      Qn(e, !0, -1) ? (h = !0, a = s, e.lineIndent > t ? l = 1 : e.lineIndent === t ? l = 0 : e.lineIndent < t && (l = -1)) : a = !1;
  if (a && (a = h || i), (l === 1 || Um === n) && (Wm === n || dF === n ? m = t : m = t + 1, y = e.position - e.lineStart, l === 1 ? a && (w8(e, y) || Yse(e, y, m)) || Zse(e, m) ? u = !0 : (o && Vse(e, m) || Fse(e, m) || Qse(e, m) ? u = !0 : Wse(e) ? (u = !0, (e.tag !== null || e.anchor !== null) && te(e, "alias node should not have any properties")) : Bse(e, m, Wm === n) && (u = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : l === 0 && (u = a && w8(e, y))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && te(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), f = 0, d = e.implicitTypes.length; f < d; f += 1)
      if (g = e.implicitTypes[f], g.resolve(e.result)) {
        e.result = g.construct(e.result), e.tag = g.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (hl.call(e.typeMap[e.kind || "fallback"], e.tag))
      g = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (g = null, p = e.typeMap.multi[e.kind || "fallback"], f = 0, d = p.length; f < d; f += 1)
        if (e.tag.slice(0, p[f].tag.length) === p[f].tag) {
          g = p[f];
          break;
        }
    g || te(e, "unknown tag !<" + e.tag + ">"), e.result !== null && g.kind !== e.kind && te(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + g.kind + '", not "' + e.kind + '"'), g.resolve(e.result, e.tag) ? (e.result = g.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : te(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || u;
}
function Use(e) {
  var t = e.position, n, r, i, s = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (o = e.input.charCodeAt(e.position)) !== 0 && (Qn(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = e.input.charCodeAt(++e.position), n = e.position; o !== 0 && !ii(o); )
      o = e.input.charCodeAt(++e.position);
    for (r = e.input.slice(n, e.position), i = [], r.length < 1 && te(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; Jl(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !fo(o));
        break;
      }
      if (fo(o))
        break;
      for (n = e.position; o !== 0 && !ii(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    o !== 0 && k5(e), hl.call(_8, r) ? _8[r](e, r, i) : jm(e, 'unknown document directive "' + r + '"');
  }
  if (Qn(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, Qn(e, !0, -1)) : s && te(e, "directives end mark is expected"), gu(e, e.lineIndent - 1, Um, !1, !0), Qn(e, !0, -1), e.checkLineBreaks && Dse.test(e.input.slice(t, e.position)) && jm(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Uy(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, Qn(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    te(e, "end of the stream or a document separator is expected");
  else
    return;
}
function xF(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new Nse(e, t), r = e.indexOf("\0");
  for (r !== -1 && (n.position = r, te(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    Use(n);
  return n.documents;
}
function jse(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && (n = t, t = null);
  var r = xF(e, n);
  if (typeof t != "function")
    return r;
  for (var i = 0, s = r.length; i < s; i += 1)
    t(r[i]);
}
function Xse(e, t) {
  var n = xF(e, t);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new Zo("expected a single document in the stream, but found more");
  }
}
var Gse = jse, Hse = Xse, Kse = {
  loadAll: Gse,
  load: Hse
}, Jse = hF, toe = Kse.load;
const vF = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s;
function eoe(e, t) {
  var n;
  const r = e.match(vF);
  if (r) {
    const i = toe(r[1], {
      schema: Jse
    });
    return i != null && i.title && ((n = t.setDiagramTitle) == null || n.call(t, i.title)), e.slice(r[0].length);
  } else
    return e;
}
const noe = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, roe = /\s*%%.*\n/gm, Xm = {}, S5 = function(e, t) {
  e = e.replace(vF, "").replace(noe, "").replace(roe, `
`);
  for (const [n, { detector: r }] of Object.entries(Xm))
    if (r(e, t))
      return n;
  throw new Error(`No diagram type detected for text: ${e}`);
}, _F = (...e) => {
  for (const { id: t, detector: n, loader: r } of e)
    kF(t, n, r);
}, kF = (e, t, n) => {
  Xm[e] ? B.error(`Detector with key ${e} already exists`) : Xm[e] = { detector: t, loader: n }, B.debug(`Detector with key ${e} added${n ? " with loader" : ""}`);
}, ioe = (e) => Xm[e].loader, ak = function(e, t, n) {
  const { depth: r, clobber: i } = Object.assign({ depth: 2, clobber: !1 }, n);
  return Array.isArray(t) && !Array.isArray(e) ? (t.forEach((s) => ak(e, s, n)), e) : Array.isArray(t) && Array.isArray(e) ? (t.forEach((s) => {
    e.includes(s) || e.push(s);
  }), e) : e === void 0 || r <= 0 ? e != null && typeof e == "object" && typeof t == "object" ? Object.assign(e, t) : t : (t !== void 0 && typeof e == "object" && typeof t == "object" && Object.keys(t).forEach((s) => {
    typeof t[s] == "object" && (e[s] === void 0 || typeof e[s] == "object") ? (e[s] === void 0 && (e[s] = Array.isArray(t[s]) ? [] : {}), e[s] = ak(e[s], t[s], { depth: r - 1, clobber: i })) : (i || typeof e[s] != "object" && typeof t[s] != "object") && (e[s] = t[s]);
  }), e);
}, or = ak, soe = {
  curveBasis: lu,
  curveBasisClosed: mUt,
  curveBasisOpen: yUt,
  curveBumpX: pUt,
  curveBumpY: gUt,
  curveBundle: bUt,
  curveCardinalClosed: xUt,
  curveCardinalOpen: vUt,
  curveCardinal: OUt,
  curveCatmullRomClosed: kUt,
  curveCatmullRomOpen: wUt,
  curveCatmullRom: _Ut,
  curveLinear: Oi,
  curveLinearClosed: SUt,
  curveMonotoneX: CUt,
  curveMonotoneY: TUt,
  curveNatural: EUt,
  curveStep: AUt,
  curveStepAfter: DUt,
  curveStepBefore: PUt
}, yx = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, ooe = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, aoe = function(e, t) {
  const n = wF(e, /(?:init\b)|(?:initialize\b)/);
  let r = {};
  if (Array.isArray(n)) {
    const i = n.map((s) => s.args);
    Oc(i), r = or(r, [...i]);
  } else
    r = n.args;
  if (r) {
    let i = S5(e, t);
    ["config"].forEach((s) => {
      r[s] !== void 0 && (i === "flowchart-v2" && (i = "flowchart"), r[i] = r[s], delete r[s]);
    });
  }
  return r;
}, wF = function(e, t = null) {
  try {
    const n = new RegExp(
      `[%]{2}(?![{]${ooe.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    e = e.trim().replace(n, "").replace(/'/gm, '"'), B.debug(
      `Detecting diagram directive${t !== null ? " type:" + t : ""} based on the text:${e}`
    );
    let r;
    const i = [];
    for (; (r = yx.exec(e)) !== null; )
      if (r.index === yx.lastIndex && yx.lastIndex++, r && !t || t && r[1] && r[1].match(t) || t && r[2] && r[2].match(t)) {
        const s = r[1] ? r[1] : r[2], o = r[3] ? r[3].trim() : r[4] ? JSON.parse(r[4].trim()) : null;
        i.push({ type: s, args: o });
      }
    return i.length === 0 && i.push({ type: e, args: null }), i.length === 1 ? i[0] : i;
  } catch (n) {
    return B.error(
      `ERROR: ${n.message} - Unable to parse directive
      ${t !== null ? " type:" + t : ""} based on the text:${e}`
    ), { type: null, args: null };
  }
}, loe = function(e, t) {
  for (const [n, r] of t.entries())
    if (r.match(e))
      return n;
  return -1;
};
function ms(e, t) {
  if (!e)
    return t;
  const n = `curve${e.charAt(0).toUpperCase() + e.slice(1)}`;
  return soe[n] || t;
}
function coe(e, t) {
  const n = e.trim();
  if (n)
    return t.securityLevel !== "loose" ? Oa.sanitizeUrl(n) : n;
}
const hoe = (e, ...t) => {
  const n = e.split("."), r = n.length - 1, i = n[r];
  let s = window;
  for (let o = 0; o < r; o++)
    if (s = s[n[o]], !s)
      return;
  s[i](...t);
};
function Gm(e, t) {
  return e && t ? Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) : 0;
}
function uoe(e) {
  let t, n = 0;
  e.forEach((s) => {
    n += Gm(s, t), t = s;
  });
  let r = n / 2, i;
  return t = void 0, e.forEach((s) => {
    if (t && !i) {
      const o = Gm(s, t);
      if (o < r)
        r -= o;
      else {
        const a = r / o;
        a <= 0 && (i = t), a >= 1 && (i = { x: s.x, y: s.y }), a > 0 && a < 1 && (i = {
          x: (1 - a) * t.x + a * s.x,
          y: (1 - a) * t.y + a * s.y
        });
      }
    }
    t = s;
  }), i;
}
function foe(e) {
  return e.length === 1 ? e[0] : uoe(e);
}
const doe = (e, t, n) => {
  let r;
  B.info(`our points ${JSON.stringify(t)}`), t[0] !== n && (t = t.reverse());
  let s = 25, o;
  r = void 0, t.forEach((u) => {
    if (r && !o) {
      const f = Gm(u, r);
      if (f < s)
        s -= f;
      else {
        const d = s / f;
        d <= 0 && (o = r), d >= 1 && (o = { x: u.x, y: u.y }), d > 0 && d < 1 && (o = {
          x: (1 - d) * r.x + d * u.x,
          y: (1 - d) * r.y + d * u.y
        });
      }
    }
    r = u;
  });
  const a = e ? 10 : 5, l = Math.atan2(t[0].y - o.y, t[0].x - o.x), h = { x: 0, y: 0 };
  return h.x = Math.sin(l) * a + (t[0].x + o.x) / 2, h.y = -Math.cos(l) * a + (t[0].y + o.y) / 2, h;
};
function poe(e, t, n) {
  let r = JSON.parse(JSON.stringify(n)), i;
  B.info("our points", r), t !== "start_left" && t !== "start_right" && (r = r.reverse()), r.forEach((f) => {
    i = f;
  });
  let o = 25 + e, a;
  i = void 0, r.forEach((f) => {
    if (i && !a) {
      const d = Gm(f, i);
      if (d < o)
        o -= d;
      else {
        const p = o / d;
        p <= 0 && (a = i), p >= 1 && (a = { x: f.x, y: f.y }), p > 0 && p < 1 && (a = {
          x: (1 - p) * i.x + p * f.x,
          y: (1 - p) * i.y + p * f.y
        });
      }
    }
    i = f;
  });
  const l = 10 + e * 0.5, h = Math.atan2(r[0].y - a.y, r[0].x - a.x), u = { x: 0, y: 0 };
  return u.x = Math.sin(h) * l + (r[0].x + a.x) / 2, u.y = -Math.cos(h) * l + (r[0].y + a.y) / 2, t === "start_left" && (u.x = Math.sin(h + Math.PI) * l + (r[0].x + a.x) / 2, u.y = -Math.cos(h + Math.PI) * l + (r[0].y + a.y) / 2), t === "end_right" && (u.x = Math.sin(h - Math.PI) * l + (r[0].x + a.x) / 2 - 5, u.y = -Math.cos(h - Math.PI) * l + (r[0].y + a.y) / 2 - 5), t === "end_left" && (u.x = Math.sin(h) * l + (r[0].x + a.x) / 2 - 5, u.y = -Math.cos(h) * l + (r[0].y + a.y) / 2 - 5), u;
}
function ul(e) {
  let t = "", n = "";
  for (const r of e)
    r !== void 0 && (r.startsWith("color:") || r.startsWith("text-align:") ? n = n + r + ";" : t = t + r + ";");
  return { style: t, labelStyle: n };
}
let S8 = 0;
const SF = () => (S8++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + S8);
function goe(e) {
  let t = "";
  const n = "0123456789abcdef", r = n.length;
  for (let i = 0; i < e; i++)
    t += n.charAt(Math.floor(Math.random() * r));
  return t;
}
const CF = (e) => goe(e.length), moe = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0
  };
}, yoe = function(e, t) {
  const n = t.text.replace(de.lineBreakRegex, " "), [, r] = r0(t.fontSize), i = e.append("text");
  i.attr("x", t.x), i.attr("y", t.y), i.style("text-anchor", t.anchor), i.style("font-family", t.fontFamily), i.style("font-size", r), i.style("font-weight", t.fontWeight), i.attr("fill", t.fill), t.class !== void 0 && i.attr("class", t.class);
  const s = i.append("tspan");
  return s.attr("x", t.x + t.textMargin * 2), s.attr("fill", t.fill), s.text(n), i;
}, TF = Vu(
  (e, t, n) => {
    if (!e || (n = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      n
    ), de.lineBreakRegex.test(e)))
      return e;
    const r = e.split(" "), i = [];
    let s = "";
    return r.forEach((o, a) => {
      const l = po(`${o} `, n), h = po(s, n);
      if (l > t) {
        const { hyphenatedStrings: d, remainingWord: p } = boe(o, t, "-", n);
        i.push(s, ...d), s = p;
      } else
        h + l >= t ? (i.push(s), s = o) : s = [s, o].filter(Boolean).join(" ");
      a + 1 === r.length && i.push(s);
    }), i.filter((o) => o !== "").join(n.joinWith);
  },
  (e, t, n) => `${e}${t}${n.fontSize}${n.fontWeight}${n.fontFamily}${n.joinWith}`
), boe = Vu(
  (e, t, n = "-", r) => {
    r = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      r
    );
    const i = [...e], s = [];
    let o = "";
    return i.forEach((a, l) => {
      const h = `${o}${a}`;
      if (po(h, r) >= t) {
        const f = l + 1, d = i.length === f, p = `${h}${n}`;
        s.push(d ? h : p), o = "";
      } else
        o = h;
    }), { hyphenatedStrings: s, remainingWord: o };
  },
  (e, t, n = "-", r) => `${e}${t}${n}${r.fontSize}${r.fontWeight}${r.fontFamily}`
);
function lk(e, t) {
  return t = Object.assign(
    { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 15 },
    t
  ), C5(e, t).height;
}
function po(e, t) {
  return t = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, t), C5(e, t).width;
}
const C5 = Vu(
  (e, t) => {
    t = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, t);
    const { fontSize: n, fontFamily: r, fontWeight: i } = t;
    if (!e)
      return { width: 0, height: 0 };
    const [, s] = r0(n), o = ["sans-serif", r], a = e.split(de.lineBreakRegex), l = [], h = wt("body");
    if (!h.remove)
      return { width: 0, height: 0, lineHeight: 0 };
    const u = h.append("svg");
    for (const d of o) {
      let p = 0;
      const g = { width: 0, height: 0, lineHeight: 0 };
      for (const m of a) {
        const y = moe();
        y.text = m;
        const O = yoe(u, y).style("font-size", s).style("font-weight", i).style("font-family", d), x = (O._groups || O)[0][0].getBBox();
        g.width = Math.round(Math.max(g.width, x.width)), p = Math.round(x.height), g.height += p, g.lineHeight = Math.round(Math.max(g.lineHeight, p));
      }
      l.push(g);
    }
    u.remove();
    const f = isNaN(l[1].height) || isNaN(l[1].width) || isNaN(l[1].lineHeight) || l[0].height > l[1].height && l[0].width > l[1].width && l[0].lineHeight > l[1].lineHeight ? 0 : 1;
    return l[f];
  },
  (e, t) => `${e}${t.fontSize}${t.fontWeight}${t.fontFamily}`
), Ooe = class {
  constructor(t, n) {
    this.deterministic = t, this.seed = n, this.count = n ? n.length : 0;
  }
  next() {
    return this.deterministic ? this.count++ : Date.now();
  }
};
let y1;
const xoe = function(e) {
  return y1 = y1 || document.createElement("div"), e = escape(e).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), y1.innerHTML = e, unescape(y1.textContent);
}, Oc = (e) => {
  if (B.debug("directiveSanitizer called with", e), typeof e == "object" && (e.length ? e.forEach((t) => Oc(t)) : Object.keys(e).forEach((t) => {
    B.debug("Checking key", t), t.startsWith("__") && (B.debug("sanitize deleting __ option", t), delete e[t]), t.includes("proto") && (B.debug("sanitize deleting proto option", t), delete e[t]), t.includes("constr") && (B.debug("sanitize deleting constr option", t), delete e[t]), t.includes("themeCSS") && (B.debug("sanitizing themeCss option"), e[t] = fg(e[t])), t.includes("fontFamily") && (B.debug("sanitizing fontFamily option"), e[t] = fg(e[t])), t.includes("altFontFamily") && (B.debug("sanitizing altFontFamily option"), e[t] = fg(e[t])), hie.includes(t) ? typeof e[t] == "object" && (B.debug("sanitize deleting object", t), Oc(e[t])) : (B.debug("sanitize deleting option", t), delete e[t]);
  })), e.themeVariables) {
    const t = Object.keys(e.themeVariables);
    for (const n of t) {
      const r = e.themeVariables[n];
      r && r.match && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (e.themeVariables[n] = "");
    }
  }
  B.debug("After sanitization", e);
}, fg = (e) => {
  let t = 0, n = 0;
  for (const r of e) {
    if (t < n)
      return "{ /* ERROR: Unbalanced CSS */ }";
    r === "{" ? t++ : r === "}" && n++;
  }
  return t !== n ? "{ /* ERROR: Unbalanced CSS */ }" : e;
};
function T5(e) {
  return "str" in e;
}
function voe(e) {
  return e instanceof Error ? e.message : String(e);
}
const _oe = (e, t, n, r) => {
  if (!r)
    return;
  const i = e.node().getBBox();
  e.append("text").text(r).attr("x", i.x + i.width / 2).attr("y", -n).attr("class", t);
}, r0 = (e) => {
  if (typeof e == "number")
    return [e, e + "px"];
  const t = parseInt(e, 10);
  return Number.isNaN(t) ? [void 0, void 0] : e === String(t) ? [t, e + "px"] : [t, e];
}, fe = {
  assignWithDepth: or,
  wrapLabel: TF,
  calculateTextHeight: lk,
  calculateTextWidth: po,
  calculateTextDimensions: C5,
  detectInit: aoe,
  detectDirective: wF,
  isSubstringInArray: loe,
  interpolateToCurve: ms,
  calcLabelPosition: foe,
  calcCardinalityPosition: doe,
  calcTerminalLabelPosition: poe,
  formatUrl: coe,
  getStylesFromArray: ul,
  generateId: SF,
  random: CF,
  runFunc: hoe,
  entityDecode: xoe,
  initIdGenerator: Ooe,
  directiveSanitizer: Oc,
  sanitizeCss: fg,
  insertTitle: _oe,
  parseFontSize: r0
}, Hm = "9.4.3", mu = Object.freeze(uie);
let Xr = or({}, mu), EF, yu = [], rd = or({}, mu);
const jy = (e, t) => {
  let n = or({}, e), r = {};
  for (const i of t)
    DF(i), r = or(r, i);
  if (n = or(n, r), r.theme && r.theme in ra) {
    const i = or({}, EF), s = or(
      i.themeVariables || {},
      r.themeVariables
    );
    n.theme && n.theme in ra && (n.themeVariables = ra[n.theme].getThemeVariables(s));
  }
  return rd = n, MF(rd), rd;
}, koe = (e) => (Xr = or({}, mu), Xr = or(Xr, e), e.theme && ra[e.theme] && (Xr.themeVariables = ra[e.theme].getThemeVariables(e.themeVariables)), jy(Xr, yu), Xr), woe = (e) => {
  EF = or({}, e);
}, Soe = (e) => (Xr = or(Xr, e), jy(Xr, yu), Xr), AF = () => or({}, Xr), PF = (e) => (MF(e), or(rd, e), J()), J = () => or({}, rd), DF = (e) => {
  var t;
  ["secure", ...(t = Xr.secure) != null ? t : []].forEach((n) => {
    e[n] !== void 0 && (B.debug(`Denied attempt to modify a secure key ${n}`, e[n]), delete e[n]);
  }), Object.keys(e).forEach((n) => {
    n.indexOf("__") === 0 && delete e[n];
  }), Object.keys(e).forEach((n) => {
    typeof e[n] == "string" && (e[n].includes("<") || e[n].includes(">") || e[n].includes("url(data:")) && delete e[n], typeof e[n] == "object" && DF(e[n]);
  });
}, E5 = (e) => {
  e.fontFamily && (e.themeVariables ? e.themeVariables.fontFamily || (e.themeVariables = { fontFamily: e.fontFamily }) : e.themeVariables = { fontFamily: e.fontFamily }), yu.push(e), jy(Xr, yu);
}, bp = (e = Xr) => {
  yu = [], jy(e, yu);
};
var LF = /* @__PURE__ */ ((e) => (e.LAZY_LOAD_DEPRECATED = "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead.", e))(LF || {});
const C8 = {}, Coe = (e) => {
  C8[e] || (B.warn(LF[e]), C8[e] = !0);
}, MF = (e) => {
  !e || (e.lazyLoadedDiagrams || e.loadExternalDiagramsAtStartup) && Coe("LAZY_LOAD_DEPRECATED");
}, Toe = function(e, t) {
  for (let n of t)
    e.attr(n[0], n[1]);
}, Eoe = function(e, t, n) {
  let r = /* @__PURE__ */ new Map();
  return n ? (r.set("width", "100%"), r.set("style", `max-width: ${t}px;`)) : (r.set("height", e), r.set("width", t)), r;
}, $s = function(e, t, n, r) {
  const i = Eoe(t, n, r);
  Toe(e, i);
}, Xy = function(e, t, n, r) {
  const i = t.node().getBBox(), s = i.width, o = i.height;
  B.info(`SVG bounds: ${s}x${o}`, i);
  let a = 0, l = 0;
  B.info(`Graph bounds: ${a}x${l}`, e), a = s + n * 2, l = o + n * 2, B.info(`Calculated bounds: ${a}x${l}`), $s(t, l, a, r);
  const h = `${i.x - n} ${i.y - n} ${i.width + 2 * n} ${i.height + 2 * n}`;
  t.attr("viewBox", h);
}, Aoe = (e) => `g.classGroup text {
  fill: ${e.nodeBorder};
  fill: ${e.classText};
  stroke: none;
  font-family: ${e.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${e.classText};
}
.edgeLabel .label rect {
  fill: ${e.mainBkg};
}
.label text {
  fill: ${e.classText};
}
.edgeLabel .label span {
  background: ${e.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${e.nodeBorder};
  stroke: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.classGroup line {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${e.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${e.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
`, id = Aoe, Poe = (e) => `
  .entityBox {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
  }

  .attributeBoxOdd {
    fill: ${e.attributeBackgroundColorOdd};
    stroke: ${e.nodeBorder};
  }

  .attributeBoxEven {
    fill:  ${e.attributeBackgroundColorEven};
    stroke: ${e.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${e.tertiaryColor};
    opacity: 0.7;
    background-color: ${e.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

    .relationshipLine {
      stroke: ${e.lineColor};
    }

  .entityTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }    
`, RF = Poe, Doe = () => "", ck = Doe, Loe = (e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span {
    color: ${e.titleColor};
  }

  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  .cluster rect {
    fill: ${e.clusterBkg};
    stroke: ${e.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`, Km = Loe, Moe = (e) => `
  .mermaid-main-font {
    font-family: "trebuchet ms", verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  .exclude-range {
    fill: ${e.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${e.sectionBkgColor};
  }

  .section2 {
    fill: ${e.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${e.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${e.titleColor};
  }

  .sectionTitle1 {
    fill: ${e.titleColor};
  }

  .sectionTitle2 {
    fill: ${e.titleColor};
  }

  .sectionTitle3 {
    fill: ${e.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    // font-size: ${e.ganttFontSize};
    // text-height: 14px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${e.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
    text {
      font-family: ${e.fontFamily};
      fill: ${e.textColor};
    }
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${e.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }

  // .taskText:not([font-size]) {
  //   font-size: ${e.ganttFontSize};
  // }

  .taskTextOutsideRight {
    fill: ${e.taskTextDarkColor};
    text-anchor: start;
    // font-size: ${e.ganttFontSize};
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }

  .taskTextOutsideLeft {
    fill: ${e.taskTextDarkColor};
    text-anchor: end;
    // font-size: ${e.ganttFontSize};
  }

  /* Special case clickable */
  .task.clickable {
    cursor: pointer;
  }
  .taskText.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${e.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${e.taskBkgColor};
    stroke: ${e.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${e.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${e.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${e.activeTaskBkgColor};
    stroke: ${e.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${e.doneTaskBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor}    ;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
`, $F = Moe, Roe = () => "", IF = Roe, $oe = (e) => `
  .pieCircle{
    stroke: ${e.pieStrokeColor};
    stroke-width : ${e.pieStrokeWidth};
    opacity : ${e.pieOpacity};
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${e.pieTitleTextSize};
    fill: ${e.pieTitleTextColor};
    font-family: ${e.fontFamily};
  }
  .slice {
    font-family: ${e.fontFamily};
    fill: ${e.pieSectionTextColor};
    font-size:${e.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${e.pieLegendTextColor};
    font-family: ${e.fontFamily};
    font-size: ${e.pieLegendTextSize};
  }
`, NF = $oe, Ioe = (e) => `

  marker {
    fill: ${e.relationColor};
    stroke: ${e.relationColor};
  }

  marker.cross {
    stroke: ${e.lineColor};
  }

  svg {
    font-family: ${e.fontFamily};
    font-size: ${e.fontSize};
  }

  .reqBox {
    fill: ${e.requirementBackground};
    fill-opacity: 100%;
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${e.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${e.relationLabelBackground};
    fill-opacity: 100%;
  }

  .req-title-line {
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${e.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${e.relationLabelColor};
  }

`, BF = Ioe, Noe = (e) => `.actor {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }

  text.actor > tspan {
    fill: ${e.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${e.actorLineColor};
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${e.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${e.signalColor};
  }

  #arrowhead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .sequenceNumber {
    fill: ${e.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${e.signalColor};
  }

  #crosshead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .messageText {
    fill: ${e.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${e.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${e.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${e.noteBorderColor};
    fill: ${e.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${e.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation1 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation2 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${e.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
    stroke-width: 2px;
  }
`, FF = Noe, Boe = (e) => `
defs #statediagram-barbEnd {
    fill: ${e.transitionColor};
    stroke: ${e.transitionColor};
  }
g.stateGroup text {
  fill: ${e.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${e.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${e.stateLabelColor};
}

g.stateGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.stateGroup line {
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${e.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${e.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${e.noteBorderColor};
  fill: ${e.noteBkgColor};

  text {
    fill: ${e.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${e.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel .label text {
  fill: ${e.transitionLabelColor || e.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${e.transitionLabelColor || e.tertiaryTextColor};
}

.stateLabel text {
  fill: ${e.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node .fork-join {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node circle.state-end {
  fill: ${e.innerEndBackground};
  stroke: ${e.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${e.compositeBackground || e.background};
  // stroke: ${e.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${e.stateBkg || e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${e.lineColor};
}

.statediagram-cluster rect {
  fill: ${e.compositeTitleBackground};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${e.stateLabelColor};
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${e.stateBorder || e.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${e.compositeBackground || e.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${e.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${e.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${e.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${e.lineColor};
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
`, Jm = Boe, Foe = (e) => `.label {
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    color: ${e.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${e.textColor}
  }

  .legend {
    fill: ${e.textColor};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${e.textColor}
  }

  .face {
    ${e.faceColor ? `fill: ${e.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${e.fillType0 ? `fill: ${e.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${e.fillType0 ? `fill: ${e.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${e.fillType0 ? `fill: ${e.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${e.fillType0 ? `fill: ${e.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${e.fillType0 ? `fill: ${e.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${e.fillType0 ? `fill: ${e.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${e.fillType0 ? `fill: ${e.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${e.fillType0 ? `fill: ${e.fillType7}` : ""};
  }

  .actor-0 {
    ${e.actor0 ? `fill: ${e.actor0}` : ""};
  }
  .actor-1 {
    ${e.actor1 ? `fill: ${e.actor1}` : ""};
  }
  .actor-2 {
    ${e.actor2 ? `fill: ${e.actor2}` : ""};
  }
  .actor-3 {
    ${e.actor3 ? `fill: ${e.actor3}` : ""};
  }
  .actor-4 {
    ${e.actor4 ? `fill: ${e.actor4}` : ""};
  }
  .actor-5 {
    ${e.actor5 ? `fill: ${e.actor5}` : ""};
  }
`, QF = Foe, Qoe = (e) => `.person {
    stroke: ${e.personBorder};
    fill: ${e.personBkg};
  }
`, ZF = Qoe, dg = {
  flowchart: Km,
  "flowchart-v2": Km,
  sequence: FF,
  gantt: $F,
  classDiagram: id,
  "classDiagram-v2": id,
  class: id,
  stateDiagram: Jm,
  state: Jm,
  info: IF,
  pie: NF,
  er: RF,
  error: ck,
  journey: QF,
  requirement: BF,
  c4: ZF
}, Zoe = (e, t, n) => {
  let r = "";
  return e in dg && dg[e] ? r = dg[e](n) : B.warn(`No theme found for ${e}`), ` & {
    font-family: ${n.fontFamily};
    font-size: ${n.fontSize};
    fill: ${n.textColor}
  }

  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${n.errorBkgColor};
  }
  & .error-text {
    fill: ${n.errorTextColor};
    stroke: ${n.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 2px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }

  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${n.lineColor};
    stroke: ${n.lineColor};
  }
  & .marker.cross {
    stroke: ${n.lineColor};
  }

  & svg {
    font-family: ${n.fontFamily};
    font-size: ${n.fontSize};
  }

  ${r}

  ${t}
`;
}, Voe = (e, t) => {
  dg[e] = t;
}, Yoe = Zoe;
let A5 = "", Gy = "", P5 = "";
const D5 = (e) => Gi(e, J()), _i = function() {
  A5 = "", P5 = "", Gy = "";
}, oi = function(e) {
  A5 = D5(e).replace(/^\s+/g, "");
}, ki = function() {
  return A5 || Gy;
}, wi = function(e) {
  P5 = D5(e).replace(/\n\s+/g, `
`);
}, Si = function() {
  return P5;
}, Is = function(e) {
  Gy = D5(e);
}, Ns = function() {
  return Gy;
}, zoe = {
  setAccTitle: oi,
  getAccTitle: ki,
  setDiagramTitle: Is,
  getDiagramTitle: Ns,
  getAccDescription: Si,
  setAccDescription: wi,
  clear: _i
}, qoe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clear: _i,
  default: zoe,
  getAccDescription: Si,
  getAccTitle: ki,
  getDiagramTitle: Ns,
  setAccDescription: wi,
  setAccTitle: oi,
  setDiagramTitle: Is
}, Symbol.toStringTag, { value: "Module" }));
let Tl = {};
const VF = function(e, t, n, r) {
  B.debug("parseDirective is being called", t, n, r);
  try {
    if (t !== void 0)
      switch (t = t.trim(), n) {
        case "open_directive":
          Tl = {};
          break;
        case "type_directive":
          if (!Tl)
            throw new Error("currentDirective is undefined");
          Tl.type = t.toLowerCase();
          break;
        case "arg_directive":
          if (!Tl)
            throw new Error("currentDirective is undefined");
          Tl.args = JSON.parse(t);
          break;
        case "close_directive":
          Woe(e, Tl, r), Tl = void 0;
          break;
      }
  } catch (i) {
    B.error(
      `Error while rendering sequenceDiagram directive: ${t} jison context: ${n}`
    ), B.error(i.message);
  }
}, Woe = function(e, t, n) {
  switch (B.info(`Directive type=${t.type} with args:`, t.args), t.type) {
    case "init":
    case "initialize": {
      ["config"].forEach((r) => {
        t.args[r] !== void 0 && (n === "flowchart-v2" && (n = "flowchart"), t.args[n] = t.args[r], delete t.args[r]);
      }), B.info("sanitize in handleDirective", t.args), Oc(t.args), B.info("sanitize in handleDirective (done)", t.args), E5(t.args);
      break;
    }
    case "wrap":
    case "nowrap":
      e && e.setWrap && e.setWrap(t.type === "wrap");
      break;
    case "themeCss":
      B.warn("themeCss encountered");
      break;
    default:
      B.warn(
        `Unhandled directive: source: '%%{${t.type}: ${JSON.stringify(
          t.args ? t.args : {}
        )}}%%`,
        t
      );
      break;
  }
}, Uoe = B, joe = v5, i0 = J, Xoe = (e) => Gi(e, i0()), YF = Xy, Goe = () => qoe, Hoe = (e, t, n, r) => VF(e, t, n, r), t2 = {}, Wn = (e, t, n) => {
  if (t2[e])
    throw new Error(`Diagram ${e} already registered.`);
  t2[e] = t, n && kF(e, n), Voe(e, t.styles), t.injectUtils && t.injectUtils(
    Uoe,
    joe,
    i0,
    Xoe,
    YF,
    Goe(),
    Hoe
  );
}, zF = (e) => {
  if (e in t2)
    return t2[e];
  throw new Error(`Diagram ${e} not found.`);
};
var hk = function() {
  var e = function(R, A, P, C) {
    for (P = P || {}, C = R.length; C--; P[R[C]] = A)
      ;
    return P;
  }, t = [1, 4], n = [1, 7], r = [1, 5], i = [1, 9], s = [1, 6], o = [2, 6], a = [1, 16], l = [6, 8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40, 50, 55], h = [8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], u = [8, 13, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], f = [1, 26], d = [6, 8, 14, 50, 55], p = [8, 14, 55], g = [1, 53], m = [1, 52], y = [8, 14, 30, 33, 35, 38, 55], O = [1, 67], x = [1, 68], _ = [1, 69], w = [8, 14, 33, 35, 42, 55], E = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, eol: 4, directive: 5, GG: 6, document: 7, EOF: 8, ":": 9, DIR: 10, options: 11, body: 12, OPT: 13, NL: 14, line: 15, statement: 16, commitStatement: 17, mergeStatement: 18, cherryPickStatement: 19, acc_title: 20, acc_title_value: 21, acc_descr: 22, acc_descr_value: 23, acc_descr_multiline_value: 24, section: 25, branchStatement: 26, CHECKOUT: 27, ref: 28, BRANCH: 29, ORDER: 30, NUM: 31, CHERRY_PICK: 32, COMMIT_ID: 33, STR: 34, COMMIT_TAG: 35, EMPTYSTR: 36, MERGE: 37, COMMIT_TYPE: 38, commitType: 39, COMMIT: 40, commit_arg: 41, COMMIT_MSG: 42, NORMAL: 43, REVERSE: 44, HIGHLIGHT: 45, openDirective: 46, typeDirective: 47, closeDirective: 48, argDirective: 49, open_directive: 50, type_directive: 51, arg_directive: 52, close_directive: 53, ID: 54, ";": 55, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "GG", 8: "EOF", 9: ":", 10: "DIR", 13: "OPT", 14: "NL", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "CHECKOUT", 29: "BRANCH", 30: "ORDER", 31: "NUM", 32: "CHERRY_PICK", 33: "COMMIT_ID", 34: "STR", 35: "COMMIT_TAG", 36: "EMPTYSTR", 37: "MERGE", 38: "COMMIT_TYPE", 40: "COMMIT", 42: "COMMIT_MSG", 43: "NORMAL", 44: "REVERSE", 45: "HIGHLIGHT", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive", 54: "ID", 55: ";" },
    productions_: [0, [3, 2], [3, 2], [3, 3], [3, 4], [3, 5], [7, 0], [7, 2], [11, 2], [11, 1], [12, 0], [12, 2], [15, 2], [15, 1], [16, 1], [16, 1], [16, 1], [16, 2], [16, 2], [16, 1], [16, 1], [16, 1], [16, 2], [26, 2], [26, 4], [19, 3], [19, 5], [19, 5], [19, 5], [19, 5], [18, 2], [18, 4], [18, 4], [18, 4], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [17, 2], [17, 3], [17, 3], [17, 5], [17, 5], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [41, 0], [41, 1], [39, 1], [39, 1], [39, 1], [5, 3], [5, 5], [46, 1], [47, 1], [49, 1], [48, 1], [28, 1], [28, 1], [4, 1], [4, 1], [4, 1]],
    performAction: function(A, P, C, k, D, b, M) {
      var v = b.length - 1;
      switch (D) {
        case 3:
          return b[v];
        case 4:
          return b[v - 1];
        case 5:
          return k.setDirection(b[v - 3]), b[v - 1];
        case 7:
          k.setOptions(b[v - 1]), this.$ = b[v];
          break;
        case 8:
          b[v - 1] += b[v], this.$ = b[v - 1];
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          b[v - 1].push(b[v]), this.$ = b[v - 1];
          break;
        case 12:
          this.$ = b[v - 1];
          break;
        case 17:
          this.$ = b[v].trim(), k.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = b[v].trim(), k.setAccDescription(this.$);
          break;
        case 20:
          k.addSection(b[v].substr(8)), this.$ = b[v].substr(8);
          break;
        case 22:
          k.checkout(b[v]);
          break;
        case 23:
          k.branch(b[v]);
          break;
        case 24:
          k.branch(b[v - 2], b[v]);
          break;
        case 25:
          k.cherryPick(b[v], "", void 0);
          break;
        case 26:
          k.cherryPick(b[v - 2], "", b[v]);
          break;
        case 27:
        case 29:
          k.cherryPick(b[v - 2], "", "");
          break;
        case 28:
          k.cherryPick(b[v], "", b[v - 2]);
          break;
        case 30:
          k.merge(b[v], "", "", "");
          break;
        case 31:
          k.merge(b[v - 2], b[v], "", "");
          break;
        case 32:
          k.merge(b[v - 2], "", b[v], "");
          break;
        case 33:
          k.merge(b[v - 2], "", "", b[v]);
          break;
        case 34:
          k.merge(b[v - 4], b[v], "", b[v - 2]);
          break;
        case 35:
          k.merge(b[v - 4], "", b[v], b[v - 2]);
          break;
        case 36:
          k.merge(b[v - 4], "", b[v - 2], b[v]);
          break;
        case 37:
          k.merge(b[v - 4], b[v - 2], b[v], "");
          break;
        case 38:
          k.merge(b[v - 4], b[v - 2], "", b[v]);
          break;
        case 39:
          k.merge(b[v - 4], b[v], b[v - 2], "");
          break;
        case 40:
          k.merge(b[v - 6], b[v - 4], b[v - 2], b[v]);
          break;
        case 41:
          k.merge(b[v - 6], b[v], b[v - 4], b[v - 2]);
          break;
        case 42:
          k.merge(b[v - 6], b[v - 4], b[v], b[v - 2]);
          break;
        case 43:
          k.merge(b[v - 6], b[v - 2], b[v - 4], b[v]);
          break;
        case 44:
          k.merge(b[v - 6], b[v], b[v - 2], b[v - 4]);
          break;
        case 45:
          k.merge(b[v - 6], b[v - 2], b[v], b[v - 4]);
          break;
        case 46:
          k.commit(b[v]);
          break;
        case 47:
          k.commit("", "", k.commitType.NORMAL, b[v]);
          break;
        case 48:
          k.commit("", "", b[v], "");
          break;
        case 49:
          k.commit("", "", b[v], b[v - 2]);
          break;
        case 50:
          k.commit("", "", b[v - 2], b[v]);
          break;
        case 51:
          k.commit("", b[v], k.commitType.NORMAL, "");
          break;
        case 52:
          k.commit("", b[v - 2], k.commitType.NORMAL, b[v]);
          break;
        case 53:
          k.commit("", b[v], k.commitType.NORMAL, b[v - 2]);
          break;
        case 54:
          k.commit("", b[v - 2], b[v], "");
          break;
        case 55:
          k.commit("", b[v], b[v - 2], "");
          break;
        case 56:
          k.commit("", b[v - 4], b[v - 2], b[v]);
          break;
        case 57:
          k.commit("", b[v - 4], b[v], b[v - 2]);
          break;
        case 58:
          k.commit("", b[v - 2], b[v - 4], b[v]);
          break;
        case 59:
          k.commit("", b[v], b[v - 4], b[v - 2]);
          break;
        case 60:
          k.commit("", b[v], b[v - 2], b[v - 4]);
          break;
        case 61:
          k.commit("", b[v - 2], b[v], b[v - 4]);
          break;
        case 62:
          k.commit(b[v], "", k.commitType.NORMAL, "");
          break;
        case 63:
          k.commit(b[v], "", k.commitType.NORMAL, b[v - 2]);
          break;
        case 64:
          k.commit(b[v - 2], "", k.commitType.NORMAL, b[v]);
          break;
        case 65:
          k.commit(b[v - 2], "", b[v], "");
          break;
        case 66:
          k.commit(b[v], "", b[v - 2], "");
          break;
        case 67:
          k.commit(b[v], b[v - 2], k.commitType.NORMAL, "");
          break;
        case 68:
          k.commit(b[v - 2], b[v], k.commitType.NORMAL, "");
          break;
        case 69:
          k.commit(b[v - 4], "", b[v - 2], b[v]);
          break;
        case 70:
          k.commit(b[v - 4], "", b[v], b[v - 2]);
          break;
        case 71:
          k.commit(b[v - 2], "", b[v - 4], b[v]);
          break;
        case 72:
          k.commit(b[v], "", b[v - 4], b[v - 2]);
          break;
        case 73:
          k.commit(b[v], "", b[v - 2], b[v - 4]);
          break;
        case 74:
          k.commit(b[v - 2], "", b[v], b[v - 4]);
          break;
        case 75:
          k.commit(b[v - 4], b[v], b[v - 2], "");
          break;
        case 76:
          k.commit(b[v - 4], b[v - 2], b[v], "");
          break;
        case 77:
          k.commit(b[v - 2], b[v], b[v - 4], "");
          break;
        case 78:
          k.commit(b[v], b[v - 2], b[v - 4], "");
          break;
        case 79:
          k.commit(b[v], b[v - 4], b[v - 2], "");
          break;
        case 80:
          k.commit(b[v - 2], b[v - 4], b[v], "");
          break;
        case 81:
          k.commit(b[v - 4], b[v], k.commitType.NORMAL, b[v - 2]);
          break;
        case 82:
          k.commit(b[v - 4], b[v - 2], k.commitType.NORMAL, b[v]);
          break;
        case 83:
          k.commit(b[v - 2], b[v], k.commitType.NORMAL, b[v - 4]);
          break;
        case 84:
          k.commit(b[v], b[v - 2], k.commitType.NORMAL, b[v - 4]);
          break;
        case 85:
          k.commit(b[v], b[v - 4], k.commitType.NORMAL, b[v - 2]);
          break;
        case 86:
          k.commit(b[v - 2], b[v - 4], k.commitType.NORMAL, b[v]);
          break;
        case 87:
          k.commit(b[v - 6], b[v - 4], b[v - 2], b[v]);
          break;
        case 88:
          k.commit(b[v - 6], b[v - 4], b[v], b[v - 2]);
          break;
        case 89:
          k.commit(b[v - 6], b[v - 2], b[v - 4], b[v]);
          break;
        case 90:
          k.commit(b[v - 6], b[v], b[v - 4], b[v - 2]);
          break;
        case 91:
          k.commit(b[v - 6], b[v - 2], b[v], b[v - 4]);
          break;
        case 92:
          k.commit(b[v - 6], b[v], b[v - 2], b[v - 4]);
          break;
        case 93:
          k.commit(b[v - 4], b[v - 6], b[v - 2], b[v]);
          break;
        case 94:
          k.commit(b[v - 4], b[v - 6], b[v], b[v - 2]);
          break;
        case 95:
          k.commit(b[v - 2], b[v - 6], b[v - 4], b[v]);
          break;
        case 96:
          k.commit(b[v], b[v - 6], b[v - 4], b[v - 2]);
          break;
        case 97:
          k.commit(b[v - 2], b[v - 6], b[v], b[v - 4]);
          break;
        case 98:
          k.commit(b[v], b[v - 6], b[v - 2], b[v - 4]);
          break;
        case 99:
          k.commit(b[v], b[v - 4], b[v - 2], b[v - 6]);
          break;
        case 100:
          k.commit(b[v - 2], b[v - 4], b[v], b[v - 6]);
          break;
        case 101:
          k.commit(b[v], b[v - 2], b[v - 4], b[v - 6]);
          break;
        case 102:
          k.commit(b[v - 2], b[v], b[v - 4], b[v - 6]);
          break;
        case 103:
          k.commit(b[v - 4], b[v - 2], b[v], b[v - 6]);
          break;
        case 104:
          k.commit(b[v - 4], b[v], b[v - 2], b[v - 6]);
          break;
        case 105:
          k.commit(b[v - 2], b[v - 4], b[v - 6], b[v]);
          break;
        case 106:
          k.commit(b[v], b[v - 4], b[v - 6], b[v - 2]);
          break;
        case 107:
          k.commit(b[v - 2], b[v], b[v - 6], b[v - 4]);
          break;
        case 108:
          k.commit(b[v], b[v - 2], b[v - 6], b[v - 4]);
          break;
        case 109:
          k.commit(b[v - 4], b[v - 2], b[v - 6], b[v]);
          break;
        case 110:
          k.commit(b[v - 4], b[v], b[v - 6], b[v - 2]);
          break;
        case 111:
          this.$ = "";
          break;
        case 112:
          this.$ = b[v];
          break;
        case 113:
          this.$ = k.commitType.NORMAL;
          break;
        case 114:
          this.$ = k.commitType.REVERSE;
          break;
        case 115:
          this.$ = k.commitType.HIGHLIGHT;
          break;
        case 118:
          k.parseDirective("%%{", "open_directive");
          break;
        case 119:
          k.parseDirective(b[v], "type_directive");
          break;
        case 120:
          b[v] = b[v].trim().replace(/'/g, '"'), k.parseDirective(b[v], "arg_directive");
          break;
        case 121:
          k.parseDirective("}%%", "close_directive", "gitGraph");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: t, 8: n, 14: r, 46: 8, 50: i, 55: s }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: t, 8: n, 14: r, 46: 8, 50: i, 55: s }, { 3: 11, 4: 2, 5: 3, 6: t, 8: n, 14: r, 46: 8, 50: i, 55: s }, { 7: 12, 8: o, 9: [1, 13], 10: [1, 14], 11: 15, 14: a }, e(l, [2, 124]), e(l, [2, 125]), e(l, [2, 126]), { 47: 17, 51: [1, 18] }, { 51: [2, 118] }, { 1: [2, 1] }, { 1: [2, 2] }, { 8: [1, 19] }, { 7: 20, 8: o, 11: 15, 14: a }, { 9: [1, 21] }, e(h, [2, 10], { 12: 22, 13: [1, 23] }), e(u, [2, 9]), { 9: [1, 25], 48: 24, 53: f }, e([9, 53], [2, 119]), { 1: [2, 3] }, { 8: [1, 27] }, { 7: 28, 8: o, 11: 15, 14: a }, { 8: [2, 7], 14: [1, 31], 15: 29, 16: 30, 17: 32, 18: 33, 19: 34, 20: [1, 35], 22: [1, 36], 24: [1, 37], 25: [1, 38], 26: 39, 27: [1, 40], 29: [1, 44], 32: [1, 43], 37: [1, 42], 40: [1, 41] }, e(u, [2, 8]), e(d, [2, 116]), { 49: 45, 52: [1, 46] }, e(d, [2, 121]), { 1: [2, 4] }, { 8: [1, 47] }, e(h, [2, 11]), { 4: 48, 8: n, 14: r, 55: s }, e(h, [2, 13]), e(p, [2, 14]), e(p, [2, 15]), e(p, [2, 16]), { 21: [1, 49] }, { 23: [1, 50] }, e(p, [2, 19]), e(p, [2, 20]), e(p, [2, 21]), { 28: 51, 34: g, 54: m }, e(p, [2, 111], { 41: 54, 33: [1, 57], 34: [1, 59], 35: [1, 55], 38: [1, 56], 42: [1, 58] }), { 28: 60, 34: g, 54: m }, { 33: [1, 61], 35: [1, 62] }, { 28: 63, 34: g, 54: m }, { 48: 64, 53: f }, { 53: [2, 120] }, { 1: [2, 5] }, e(h, [2, 12]), e(p, [2, 17]), e(p, [2, 18]), e(p, [2, 22]), e(y, [2, 122]), e(y, [2, 123]), e(p, [2, 46]), { 34: [1, 65] }, { 39: 66, 43: O, 44: x, 45: _ }, { 34: [1, 70] }, { 34: [1, 71] }, e(p, [2, 112]), e(p, [2, 30], { 33: [1, 72], 35: [1, 74], 38: [1, 73] }), { 34: [1, 75] }, { 34: [1, 76], 36: [1, 77] }, e(p, [2, 23], { 30: [1, 78] }), e(d, [2, 117]), e(p, [2, 47], { 33: [1, 80], 38: [1, 79], 42: [1, 81] }), e(p, [2, 48], { 33: [1, 83], 35: [1, 82], 42: [1, 84] }), e(w, [2, 113]), e(w, [2, 114]), e(w, [2, 115]), e(p, [2, 51], { 35: [1, 85], 38: [1, 86], 42: [1, 87] }), e(p, [2, 62], { 33: [1, 90], 35: [1, 88], 38: [1, 89] }), { 34: [1, 91] }, { 39: 92, 43: O, 44: x, 45: _ }, { 34: [1, 93] }, e(p, [2, 25], { 35: [1, 94] }), { 33: [1, 95] }, { 33: [1, 96] }, { 31: [1, 97] }, { 39: 98, 43: O, 44: x, 45: _ }, { 34: [1, 99] }, { 34: [1, 100] }, { 34: [1, 101] }, { 34: [1, 102] }, { 34: [1, 103] }, { 34: [1, 104] }, { 39: 105, 43: O, 44: x, 45: _ }, { 34: [1, 106] }, { 34: [1, 107] }, { 39: 108, 43: O, 44: x, 45: _ }, { 34: [1, 109] }, e(p, [2, 31], { 35: [1, 111], 38: [1, 110] }), e(p, [2, 32], { 33: [1, 113], 35: [1, 112] }), e(p, [2, 33], { 33: [1, 114], 38: [1, 115] }), { 34: [1, 116], 36: [1, 117] }, { 34: [1, 118] }, { 34: [1, 119] }, e(p, [2, 24]), e(p, [2, 49], { 33: [1, 120], 42: [1, 121] }), e(p, [2, 53], { 38: [1, 122], 42: [1, 123] }), e(p, [2, 63], { 33: [1, 125], 38: [1, 124] }), e(p, [2, 50], { 33: [1, 126], 42: [1, 127] }), e(p, [2, 55], { 35: [1, 128], 42: [1, 129] }), e(p, [2, 66], { 33: [1, 131], 35: [1, 130] }), e(p, [2, 52], { 38: [1, 132], 42: [1, 133] }), e(p, [2, 54], { 35: [1, 134], 42: [1, 135] }), e(p, [2, 67], { 35: [1, 137], 38: [1, 136] }), e(p, [2, 64], { 33: [1, 139], 38: [1, 138] }), e(p, [2, 65], { 33: [1, 141], 35: [1, 140] }), e(p, [2, 68], { 35: [1, 143], 38: [1, 142] }), { 39: 144, 43: O, 44: x, 45: _ }, { 34: [1, 145] }, { 34: [1, 146] }, { 34: [1, 147] }, { 34: [1, 148] }, { 39: 149, 43: O, 44: x, 45: _ }, e(p, [2, 26]), e(p, [2, 27]), e(p, [2, 28]), e(p, [2, 29]), { 34: [1, 150] }, { 34: [1, 151] }, { 39: 152, 43: O, 44: x, 45: _ }, { 34: [1, 153] }, { 39: 154, 43: O, 44: x, 45: _ }, { 34: [1, 155] }, { 34: [1, 156] }, { 34: [1, 157] }, { 34: [1, 158] }, { 34: [1, 159] }, { 34: [1, 160] }, { 34: [1, 161] }, { 39: 162, 43: O, 44: x, 45: _ }, { 34: [1, 163] }, { 34: [1, 164] }, { 34: [1, 165] }, { 39: 166, 43: O, 44: x, 45: _ }, { 34: [1, 167] }, { 39: 168, 43: O, 44: x, 45: _ }, { 34: [1, 169] }, { 34: [1, 170] }, { 34: [1, 171] }, { 39: 172, 43: O, 44: x, 45: _ }, { 34: [1, 173] }, e(p, [2, 37], { 35: [1, 174] }), e(p, [2, 38], { 38: [1, 175] }), e(p, [2, 36], { 33: [1, 176] }), e(p, [2, 39], { 35: [1, 177] }), e(p, [2, 34], { 38: [1, 178] }), e(p, [2, 35], { 33: [1, 179] }), e(p, [2, 60], { 42: [1, 180] }), e(p, [2, 73], { 33: [1, 181] }), e(p, [2, 61], { 42: [1, 182] }), e(p, [2, 84], { 38: [1, 183] }), e(p, [2, 74], { 33: [1, 184] }), e(p, [2, 83], { 38: [1, 185] }), e(p, [2, 59], { 42: [1, 186] }), e(p, [2, 72], { 33: [1, 187] }), e(p, [2, 58], { 42: [1, 188] }), e(p, [2, 78], { 35: [1, 189] }), e(p, [2, 71], { 33: [1, 190] }), e(p, [2, 77], { 35: [1, 191] }), e(p, [2, 57], { 42: [1, 192] }), e(p, [2, 85], { 38: [1, 193] }), e(p, [2, 56], { 42: [1, 194] }), e(p, [2, 79], { 35: [1, 195] }), e(p, [2, 80], { 35: [1, 196] }), e(p, [2, 86], { 38: [1, 197] }), e(p, [2, 70], { 33: [1, 198] }), e(p, [2, 81], { 38: [1, 199] }), e(p, [2, 69], { 33: [1, 200] }), e(p, [2, 75], { 35: [1, 201] }), e(p, [2, 76], { 35: [1, 202] }), e(p, [2, 82], { 38: [1, 203] }), { 34: [1, 204] }, { 39: 205, 43: O, 44: x, 45: _ }, { 34: [1, 206] }, { 34: [1, 207] }, { 39: 208, 43: O, 44: x, 45: _ }, { 34: [1, 209] }, { 34: [1, 210] }, { 34: [1, 211] }, { 34: [1, 212] }, { 39: 213, 43: O, 44: x, 45: _ }, { 34: [1, 214] }, { 39: 215, 43: O, 44: x, 45: _ }, { 34: [1, 216] }, { 34: [1, 217] }, { 34: [1, 218] }, { 34: [1, 219] }, { 34: [1, 220] }, { 34: [1, 221] }, { 34: [1, 222] }, { 39: 223, 43: O, 44: x, 45: _ }, { 34: [1, 224] }, { 34: [1, 225] }, { 34: [1, 226] }, { 39: 227, 43: O, 44: x, 45: _ }, { 34: [1, 228] }, { 39: 229, 43: O, 44: x, 45: _ }, { 34: [1, 230] }, { 34: [1, 231] }, { 34: [1, 232] }, { 39: 233, 43: O, 44: x, 45: _ }, e(p, [2, 40]), e(p, [2, 42]), e(p, [2, 41]), e(p, [2, 43]), e(p, [2, 45]), e(p, [2, 44]), e(p, [2, 101]), e(p, [2, 102]), e(p, [2, 99]), e(p, [2, 100]), e(p, [2, 104]), e(p, [2, 103]), e(p, [2, 108]), e(p, [2, 107]), e(p, [2, 106]), e(p, [2, 105]), e(p, [2, 110]), e(p, [2, 109]), e(p, [2, 98]), e(p, [2, 97]), e(p, [2, 96]), e(p, [2, 95]), e(p, [2, 93]), e(p, [2, 94]), e(p, [2, 92]), e(p, [2, 91]), e(p, [2, 90]), e(p, [2, 89]), e(p, [2, 87]), e(p, [2, 88])],
    defaultActions: { 9: [2, 118], 10: [2, 1], 11: [2, 2], 19: [2, 3], 27: [2, 4], 46: [2, 120], 47: [2, 5] },
    parseError: function(A, P) {
      if (P.recoverable)
        this.trace(A);
      else {
        var C = new Error(A);
        throw C.hash = P, C;
      }
    },
    parse: function(A) {
      var P = this, C = [0], k = [], D = [null], b = [], M = this.table, v = "", N = 0, tt = 0, Z = 2, z = 1, X = b.slice.call(arguments, 1), q = Object.create(this.lexer), nt = { yy: {} };
      for (var st in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, st) && (nt.yy[st] = this.yy[st]);
      q.setInput(A, nt.yy), nt.yy.lexer = q, nt.yy.parser = this, typeof q.yylloc > "u" && (q.yylloc = {});
      var ct = q.yylloc;
      b.push(ct);
      var Y = q.options && q.options.ranges;
      typeof nt.yy.parseError == "function" ? this.parseError = nt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Ct() {
        var $t;
        return $t = k.pop() || q.lex() || z, typeof $t != "number" && ($t instanceof Array && (k = $t, $t = k.pop()), $t = P.symbols_[$t] || $t), $t;
      }
      for (var H, et, U, W, $ = {}, F, G, I, ht; ; ) {
        if (et = C[C.length - 1], this.defaultActions[et] ? U = this.defaultActions[et] : ((H === null || typeof H > "u") && (H = Ct()), U = M[et] && M[et][H]), typeof U > "u" || !U.length || !U[0]) {
          var L = "";
          ht = [];
          for (F in M[et])
            this.terminals_[F] && F > Z && ht.push("'" + this.terminals_[F] + "'");
          q.showPosition ? L = "Parse error on line " + (N + 1) + `:
` + q.showPosition() + `
Expecting ` + ht.join(", ") + ", got '" + (this.terminals_[H] || H) + "'" : L = "Parse error on line " + (N + 1) + ": Unexpected " + (H == z ? "end of input" : "'" + (this.terminals_[H] || H) + "'"), this.parseError(L, {
            text: q.match,
            token: this.terminals_[H] || H,
            line: q.yylineno,
            loc: ct,
            expected: ht
          });
        }
        if (U[0] instanceof Array && U.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + et + ", token: " + H);
        switch (U[0]) {
          case 1:
            C.push(H), D.push(q.yytext), b.push(q.yylloc), C.push(U[1]), H = null, tt = q.yyleng, v = q.yytext, N = q.yylineno, ct = q.yylloc;
            break;
          case 2:
            if (G = this.productions_[U[1]][1], $.$ = D[D.length - G], $._$ = {
              first_line: b[b.length - (G || 1)].first_line,
              last_line: b[b.length - 1].last_line,
              first_column: b[b.length - (G || 1)].first_column,
              last_column: b[b.length - 1].last_column
            }, Y && ($._$.range = [
              b[b.length - (G || 1)].range[0],
              b[b.length - 1].range[1]
            ]), W = this.performAction.apply($, [
              v,
              tt,
              N,
              nt.yy,
              U[1],
              D,
              b
            ].concat(X)), typeof W < "u")
              return W;
            G && (C = C.slice(0, -1 * G * 2), D = D.slice(0, -1 * G), b = b.slice(0, -1 * G)), C.push(this.productions_[U[1]][0]), D.push($.$), b.push($._$), I = M[C[C.length - 2]][C[C.length - 1]], C.push(I);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, T = function() {
    var R = {
      EOF: 1,
      parseError: function(P, C) {
        if (this.yy.parser)
          this.yy.parser.parseError(P, C);
        else
          throw new Error(P);
      },
      setInput: function(A, P) {
        return this.yy = P || this.yy || {}, this._input = A, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var A = this._input[0];
        this.yytext += A, this.yyleng++, this.offset++, this.match += A, this.matched += A;
        var P = A.match(/(?:\r\n?|\n).*/g);
        return P ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), A;
      },
      unput: function(A) {
        var P = A.length, C = A.split(/(?:\r\n?|\n)/g);
        this._input = A + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - P), this.offset -= P;
        var k = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), C.length - 1 && (this.yylineno -= C.length - 1);
        var D = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: C ? (C.length === k.length ? this.yylloc.first_column : 0) + k[k.length - C.length].length - C[0].length : this.yylloc.first_column - P
        }, this.options.ranges && (this.yylloc.range = [D[0], D[0] + this.yyleng - P]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(A) {
        this.unput(this.match.slice(A));
      },
      pastInput: function() {
        var A = this.matched.substr(0, this.matched.length - this.match.length);
        return (A.length > 20 ? "..." : "") + A.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var A = this.match;
        return A.length < 20 && (A += this._input.substr(0, 20 - A.length)), (A.substr(0, 20) + (A.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var A = this.pastInput(), P = new Array(A.length + 1).join("-");
        return A + this.upcomingInput() + `
` + P + "^";
      },
      test_match: function(A, P) {
        var C, k, D;
        if (this.options.backtrack_lexer && (D = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (D.yylloc.range = this.yylloc.range.slice(0))), k = A[0].match(/(?:\r\n?|\n).*/g), k && (this.yylineno += k.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: k ? k[k.length - 1].length - k[k.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + A[0].length
        }, this.yytext += A[0], this.match += A[0], this.matches = A, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(A[0].length), this.matched += A[0], C = this.performAction.call(this, this.yy, this, P, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), C)
          return C;
        if (this._backtrack) {
          for (var b in D)
            this[b] = D[b];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var A, P, C, k;
        this._more || (this.yytext = "", this.match = "");
        for (var D = this._currentRules(), b = 0; b < D.length; b++)
          if (C = this._input.match(this.rules[D[b]]), C && (!P || C[0].length > P[0].length)) {
            if (P = C, k = b, this.options.backtrack_lexer) {
              if (A = this.test_match(C, D[b]), A !== !1)
                return A;
              if (this._backtrack) {
                P = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return P ? (A = this.test_match(P, D[k]), A !== !1 ? A : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var P = this.next();
        return P || this.lex();
      },
      begin: function(P) {
        this.conditionStack.push(P);
      },
      popState: function() {
        var P = this.conditionStack.length - 1;
        return P > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(P) {
        return P = this.conditionStack.length - 1 - Math.abs(P || 0), P >= 0 ? this.conditionStack[P] : "INITIAL";
      },
      pushState: function(P) {
        this.begin(P);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(P, C, k, D) {
        switch (k) {
          case 0:
            return this.begin("open_directive"), 50;
          case 1:
            return this.begin("type_directive"), 51;
          case 2:
            return this.popState(), this.begin("arg_directive"), 9;
          case 3:
            return this.popState(), this.popState(), 53;
          case 4:
            return 52;
          case 5:
            return this.begin("acc_title"), 20;
          case 6:
            return this.popState(), "acc_title_value";
          case 7:
            return this.begin("acc_descr"), 22;
          case 8:
            return this.popState(), "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            return 14;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 6;
          case 16:
            return 40;
          case 17:
            return 33;
          case 18:
            return 38;
          case 19:
            return 42;
          case 20:
            return 43;
          case 21:
            return 44;
          case 22:
            return 45;
          case 23:
            return 35;
          case 24:
            return 29;
          case 25:
            return 30;
          case 26:
            return 37;
          case 27:
            return 32;
          case 28:
            return 27;
          case 29:
            return 10;
          case 30:
            return 10;
          case 31:
            return 9;
          case 32:
            return "CARET";
          case 33:
            this.begin("options");
            break;
          case 34:
            this.popState();
            break;
          case 35:
            return 13;
          case 36:
            return 36;
          case 37:
            this.begin("string");
            break;
          case 38:
            this.popState();
            break;
          case 39:
            return 34;
          case 40:
            return 31;
          case 41:
            return 54;
          case 42:
            return 8;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:gitGraph\b)/i, /^(?:commit(?=\s|$))/i, /^(?:id:)/i, /^(?:type:)/i, /^(?:msg:)/i, /^(?:NORMAL\b)/i, /^(?:REVERSE\b)/i, /^(?:HIGHLIGHT\b)/i, /^(?:tag:)/i, /^(?:branch(?=\s|$))/i, /^(?:order:)/i, /^(?:merge(?=\s|$))/i, /^(?:cherry-pick(?=\s|$))/i, /^(?:checkout(?=\s|$))/i, /^(?:LR\b)/i, /^(?:BT\b)/i, /^(?::)/i, /^(?:\^)/i, /^(?:options\r?\n)/i, /^(?:[ \r\n\t]+end\b)/i, /^(?:[\s\S]+(?=[ \r\n\t]+end))/i, /^(?:["]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[0-9]+(?=\s|$))/i, /^(?:\w([-\./\w]*[-\w])?)/i, /^(?:$)/i, /^(?:\s+)/i],
      conditions: { acc_descr_multiline: { rules: [10, 11], inclusive: !1 }, acc_descr: { rules: [8], inclusive: !1 }, acc_title: { rules: [6], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, options: { rules: [34, 35], inclusive: !1 }, string: { rules: [38, 39], inclusive: !1 }, INITIAL: { rules: [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 36, 37, 40, 41, 42, 43], inclusive: !0 } }
    };
    return R;
  }();
  E.lexer = T;
  function S() {
    this.yy = {};
  }
  return S.prototype = E, E.Parser = S, new S();
}();
hk.parser = hk;
const Koe = hk, Joe = (e) => e.match(/^\s*gitGraph/) !== null;
let e2 = J().gitGraph.mainBranchName, tae = J().gitGraph.mainBranchOrder, Kn = {}, Zr = null, Op = {};
Op[e2] = { name: e2, order: tae };
let Bn = {};
Bn[e2] = Zr;
let sr = e2, qF = "LR", xc = 0;
function L5() {
  return CF({ length: 7 });
}
const eae = function(e, t, n) {
  un.parseDirective(this, e, t, n);
};
function nae(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  return e.reduce((r, i) => {
    const s = t(i);
    return n[s] || (n[s] = !0, r.push(i)), r;
  }, []);
}
const rae = function(e) {
  qF = e;
};
let WF = {};
const iae = function(e) {
  B.debug("options str", e), e = e && e.trim(), e = e || "{}";
  try {
    WF = JSON.parse(e);
  } catch (t) {
    B.error("error while parsing gitGraph options", t.message);
  }
}, sae = function() {
  return WF;
}, oae = function(e, t, n, r) {
  B.debug("Entering commit:", e, t, n, r), t = de.sanitizeText(t, J()), e = de.sanitizeText(e, J()), r = de.sanitizeText(r, J());
  const i = {
    id: t || xc + "-" + L5(),
    message: e,
    seq: xc++,
    type: n || xp.NORMAL,
    tag: r || "",
    parents: Zr == null ? [] : [Zr.id],
    branch: sr
  };
  Zr = i, Kn[i.id] = i, Bn[sr] = i.id, B.debug("in pushCommit " + i.id);
}, aae = function(e, t) {
  if (e = de.sanitizeText(e, J()), Bn[e] === void 0)
    Bn[e] = Zr != null ? Zr.id : null, Op[e] = { name: e, order: t ? parseInt(t, 10) : null }, UF(e), B.debug("in createBranch");
  else {
    let n = new Error(
      'Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ' + e + '")'
    );
    throw n.hash = {
      text: "branch " + e,
      token: "branch " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"checkout ' + e + '"']
    }, n;
  }
}, lae = function(e, t, n, r) {
  e = de.sanitizeText(e, J()), t = de.sanitizeText(t, J());
  const i = Kn[Bn[sr]], s = Kn[Bn[e]];
  if (sr === e) {
    let a = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
    throw a.hash = {
      text: "merge " + e,
      token: "merge " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    }, a;
  } else if (i === void 0 || !i) {
    let a = new Error(
      'Incorrect usage of "merge". Current branch (' + sr + ")has no commits"
    );
    throw a.hash = {
      text: "merge " + e,
      token: "merge " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["commit"]
    }, a;
  } else if (Bn[e] === void 0) {
    let a = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + e + ") does not exist"
    );
    throw a.hash = {
      text: "merge " + e,
      token: "merge " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch " + e]
    }, a;
  } else if (s === void 0 || !s) {
    let a = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + e + ") has no commits"
    );
    throw a.hash = {
      text: "merge " + e,
      token: "merge " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"commit"']
    }, a;
  } else if (i === s) {
    let a = new Error('Incorrect usage of "merge". Both branches have same head');
    throw a.hash = {
      text: "merge " + e,
      token: "merge " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    }, a;
  } else if (t && Kn[t] !== void 0) {
    let a = new Error(
      'Incorrect usage of "merge". Commit with id:' + t + " already exists, use different custom Id"
    );
    throw a.hash = {
      text: "merge " + e + t + n + r,
      token: "merge " + e + t + n + r,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: [
        "merge " + e + " " + t + "_UNIQUE " + n + " " + r
      ]
    }, a;
  }
  const o = {
    id: t || xc + "-" + L5(),
    message: "merged branch " + e + " into " + sr,
    seq: xc++,
    parents: [Zr == null ? null : Zr.id, Bn[e]],
    branch: sr,
    type: xp.MERGE,
    customType: n,
    customId: !!t,
    tag: r || ""
  };
  Zr = o, Kn[o.id] = o, Bn[sr] = o.id, B.debug(Bn), B.debug("in mergeBranch");
}, cae = function(e, t, n) {
  if (B.debug("Entering cherryPick:", e, t, n), e = de.sanitizeText(e, J()), t = de.sanitizeText(t, J()), n = de.sanitizeText(n, J()), !e || Kn[e] === void 0) {
    let s = new Error(
      'Incorrect usage of "cherryPick". Source commit id should exist and provided'
    );
    throw s.hash = {
      text: "cherryPick " + e + " " + t,
      token: "cherryPick " + e + " " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    }, s;
  }
  let r = Kn[e], i = r.branch;
  if (r.type === xp.MERGE) {
    let s = new Error(
      'Incorrect usage of "cherryPick". Source commit should not be a merge commit'
    );
    throw s.hash = {
      text: "cherryPick " + e + " " + t,
      token: "cherryPick " + e + " " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    }, s;
  }
  if (!t || Kn[t] === void 0) {
    if (i === sr) {
      let a = new Error(
        'Incorrect usage of "cherryPick". Source commit is already on current branch'
      );
      throw a.hash = {
        text: "cherryPick " + e + " " + t,
        token: "cherryPick " + e + " " + t,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      }, a;
    }
    const s = Kn[Bn[sr]];
    if (s === void 0 || !s) {
      let a = new Error(
        'Incorrect usage of "cherry-pick". Current branch (' + sr + ")has no commits"
      );
      throw a.hash = {
        text: "cherryPick " + e + " " + t,
        token: "cherryPick " + e + " " + t,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      }, a;
    }
    const o = {
      id: xc + "-" + L5(),
      message: "cherry-picked " + r + " into " + sr,
      seq: xc++,
      parents: [Zr == null ? null : Zr.id, r.id],
      branch: sr,
      type: xp.CHERRY_PICK,
      tag: n != null ? n : "cherry-pick:" + r.id
    };
    Zr = o, Kn[o.id] = o, Bn[sr] = o.id, B.debug(Bn), B.debug("in cherryPick");
  }
}, UF = function(e) {
  if (e = de.sanitizeText(e, J()), Bn[e] === void 0) {
    let t = new Error(
      'Trying to checkout branch which is not yet created. (Help try using "branch ' + e + '")'
    );
    throw t.hash = {
      text: "checkout " + e,
      token: "checkout " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"branch ' + e + '"']
    }, t;
  } else {
    sr = e;
    const t = Bn[sr];
    Zr = Kn[t];
  }
};
function T8(e, t, n) {
  const r = e.indexOf(t);
  r === -1 ? e.push(n) : e.splice(r, 1, n);
}
function jF(e) {
  const t = e.reduce((i, s) => i.seq > s.seq ? i : s, e[0]);
  let n = "";
  e.forEach(function(i) {
    i === t ? n += "	*" : n += "	|";
  });
  const r = [n, t.id, t.seq];
  for (let i in Bn)
    Bn[i] === t.id && r.push(i);
  if (B.debug(r.join(" ")), t.parents && t.parents.length == 2) {
    const i = Kn[t.parents[0]];
    T8(e, t, i), e.push(Kn[t.parents[1]]);
  } else {
    if (t.parents.length == 0)
      return;
    {
      const i = Kn[t.parents];
      T8(e, t, i);
    }
  }
  e = nae(e, (i) => i.id), jF(e);
}
const hae = function() {
  B.debug(Kn);
  const e = XF()[0];
  jF([e]);
}, uae = function() {
  Kn = {}, Zr = null;
  let e = J().gitGraph.mainBranchName, t = J().gitGraph.mainBranchOrder;
  Bn = {}, Bn[e] = null, Op = {}, Op[e] = { name: e, order: t }, sr = e, xc = 0, _i();
}, fae = function() {
  return Object.values(Op).map((t, n) => t.order !== null ? t : {
    ...t,
    order: parseFloat(`0.${n}`, 10)
  }).sort((t, n) => t.order - n.order).map(({ name: t }) => ({ name: t }));
}, dae = function() {
  return Bn;
}, pae = function() {
  return Kn;
}, XF = function() {
  const e = Object.keys(Kn).map(function(t) {
    return Kn[t];
  });
  return e.forEach(function(t) {
    B.debug(t.id);
  }), e.sort((t, n) => t.seq - n.seq), e;
}, gae = function() {
  return sr;
}, mae = function() {
  return qF;
}, yae = function() {
  return Zr;
}, xp = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
}, bae = {
  parseDirective: eae,
  getConfig: () => J().gitGraph,
  setDirection: rae,
  setOptions: iae,
  getOptions: sae,
  commit: oae,
  branch: aae,
  merge: lae,
  cherryPick: cae,
  checkout: UF,
  prettyPrint: hae,
  clear: uae,
  getBranchesAsObjArray: fae,
  getBranches: dae,
  getCommits: pae,
  getCommitsArray: XF,
  getCurrentBranch: gae,
  getDirection: mae,
  getHead: yae,
  setAccTitle: oi,
  getAccTitle: ki,
  getAccDescription: Si,
  setAccDescription: wi,
  setDiagramTitle: Is,
  getDiagramTitle: Ns,
  commitType: xp
};
let $f = {};
const hi = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
}, $l = 8;
let Gr = {}, n2 = {}, r2 = [], i2 = 0;
const Oae = () => {
  Gr = {}, n2 = {}, $f = {}, i2 = 0, r2 = [];
}, xae = (e) => {
  const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
  let n = [];
  typeof e == "string" ? n = e.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(e) ? n = e : n = [];
  for (const r of n) {
    const i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    i.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), i.setAttribute("dy", "1em"), i.setAttribute("x", "0"), i.setAttribute("class", "row"), i.textContent = r.trim(), t.appendChild(i);
  }
  return t;
}, E8 = (e, t, n) => {
  const r = i0().gitGraph, i = e.append("g").attr("class", "commit-bullets"), s = e.append("g").attr("class", "commit-labels");
  let o = 0;
  Object.keys(t).sort((h, u) => t[h].seq - t[u].seq).forEach((h) => {
    const u = t[h], f = Gr[u.branch].pos, d = o + 10;
    if (n) {
      let p, g = u.customType !== void 0 && u.customType !== "" ? u.customType : u.type;
      switch (g) {
        case hi.NORMAL:
          p = "commit-normal";
          break;
        case hi.REVERSE:
          p = "commit-reverse";
          break;
        case hi.HIGHLIGHT:
          p = "commit-highlight";
          break;
        case hi.MERGE:
          p = "commit-merge";
          break;
        case hi.CHERRY_PICK:
          p = "commit-cherry-pick";
          break;
        default:
          p = "commit-normal";
      }
      if (g === hi.HIGHLIGHT) {
        const m = i.append("rect");
        m.attr("x", d - 10), m.attr("y", f - 10), m.attr("height", 20), m.attr("width", 20), m.attr(
          "class",
          `commit ${u.id} commit-highlight${Gr[u.branch].index % $l} ${p}-outer`
        ), i.append("rect").attr("x", d - 6).attr("y", f - 6).attr("height", 12).attr("width", 12).attr(
          "class",
          `commit ${u.id} commit${Gr[u.branch].index % $l} ${p}-inner`
        );
      } else if (g === hi.CHERRY_PICK)
        i.append("circle").attr("cx", d).attr("cy", f).attr("r", 10).attr("class", `commit ${u.id} ${p}`), i.append("circle").attr("cx", d - 3).attr("cy", f + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${u.id} ${p}`), i.append("circle").attr("cx", d + 3).attr("cy", f + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${u.id} ${p}`), i.append("line").attr("x1", d + 3).attr("y1", f + 1).attr("x2", d).attr("y2", f - 5).attr("stroke", "#fff").attr("class", `commit ${u.id} ${p}`), i.append("line").attr("x1", d - 3).attr("y1", f + 1).attr("x2", d).attr("y2", f - 5).attr("stroke", "#fff").attr("class", `commit ${u.id} ${p}`);
      else {
        const m = i.append("circle");
        if (m.attr("cx", d), m.attr("cy", f), m.attr("r", u.type === hi.MERGE ? 9 : 10), m.attr(
          "class",
          `commit ${u.id} commit${Gr[u.branch].index % $l}`
        ), g === hi.MERGE) {
          const y = i.append("circle");
          y.attr("cx", d), y.attr("cy", f), y.attr("r", 6), y.attr(
            "class",
            `commit ${p} ${u.id} commit${Gr[u.branch].index % $l}`
          );
        }
        g === hi.REVERSE && i.append("path").attr("d", `M ${d - 5},${f - 5}L${d + 5},${f + 5}M${d - 5},${f + 5}L${d + 5},${f - 5}`).attr(
          "class",
          `commit ${p} ${u.id} commit${Gr[u.branch].index % $l}`
        );
      }
    }
    if (n2[u.id] = { x: o + 10, y: f }, n) {
      if (u.type !== hi.CHERRY_PICK && (u.customId && u.type === hi.MERGE || u.type !== hi.MERGE) && r.showCommitLabel) {
        const m = s.append("g"), y = m.insert("rect").attr("class", "commit-label-bkg"), O = m.append("text").attr("x", o).attr("y", f + 25).attr("class", "commit-label").text(u.id);
        let x = O.node().getBBox();
        if (y.attr("x", o + 10 - x.width / 2 - 2).attr("y", f + 13.5).attr("width", x.width + 2 * 2).attr("height", x.height + 2 * 2), O.attr("x", o + 10 - x.width / 2), r.rotateCommitLabel) {
          let _ = -7.5 - (x.width + 10) / 25 * 9.5, w = 10 + x.width / 25 * 8.5;
          m.attr(
            "transform",
            "translate(" + _ + ", " + w + ") rotate(" + -45 + ", " + o + ", " + f + ")"
          );
        }
      }
      if (u.tag) {
        const m = s.insert("polygon"), y = s.append("circle"), O = s.append("text").attr("y", f - 16).attr("class", "tag-label").text(u.tag);
        let x = O.node().getBBox();
        O.attr("x", o + 10 - x.width / 2);
        const _ = x.height / 2, w = f - 19.2;
        m.attr("class", "tag-label-bkg").attr(
          "points",
          `
          ${o - x.width / 2 - 4 / 2},${w + 2}
          ${o - x.width / 2 - 4 / 2},${w - 2}
          ${o + 10 - x.width / 2 - 4},${w - _ - 2}
          ${o + 10 + x.width / 2 + 4},${w - _ - 2}
          ${o + 10 + x.width / 2 + 4},${w + _ + 2}
          ${o + 10 - x.width / 2 - 4},${w + _ + 2}`
        ), y.attr("cx", o - x.width / 2 + 4 / 2).attr("cy", w).attr("r", 1.5).attr("class", "tag-hole");
      }
    }
    o += 50, o > i2 && (i2 = o);
  });
}, vae = (e, t, n) => Object.keys(n).filter((s) => n[s].branch === t.branch && n[s].seq > e.seq && n[s].seq < t.seq).length > 0, uk = (e, t, n = 0) => {
  const r = e + Math.abs(e - t) / 2;
  if (n > 5)
    return r;
  if (r2.every((o) => Math.abs(o - r) >= 10))
    return r2.push(r), r;
  const s = Math.abs(e - t);
  return uk(e, t - s / 5, n + 1);
}, _ae = (e, t, n, r) => {
  const i = n2[t.id], s = n2[n.id], o = vae(t, n, r);
  let a = "", l = "", h = 0, u = 0, f = Gr[n.branch].index, d;
  if (o) {
    a = "A 10 10, 0, 0, 0,", l = "A 10 10, 0, 0, 1,", h = 10, u = 10, f = Gr[n.branch].index;
    const p = i.y < s.y ? uk(i.y, s.y) : uk(s.y, i.y);
    i.y < s.y ? d = `M ${i.x} ${i.y} L ${i.x} ${p - h} ${a} ${i.x + u} ${p} L ${s.x - h} ${p} ${l} ${s.x} ${p + u} L ${s.x} ${s.y}` : d = `M ${i.x} ${i.y} L ${i.x} ${p + h} ${l} ${i.x + u} ${p} L ${s.x - h} ${p} ${a} ${s.x} ${p - u} L ${s.x} ${s.y}`;
  } else
    i.y < s.y && (a = "A 20 20, 0, 0, 0,", h = 20, u = 20, f = Gr[n.branch].index, d = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${a} ${i.x + u} ${s.y} L ${s.x} ${s.y}`), i.y > s.y && (a = "A 20 20, 0, 0, 0,", h = 20, u = 20, f = Gr[t.branch].index, d = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${a} ${s.x} ${i.y - u} L ${s.x} ${s.y}`), i.y === s.y && (f = Gr[t.branch].index, d = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${a} ${i.x + u} ${s.y} L ${s.x} ${s.y}`);
  e.append("path").attr("d", d).attr("class", "arrow arrow" + f % $l);
}, kae = (e, t) => {
  const n = e.append("g").attr("class", "commit-arrows");
  Object.keys(t).forEach((r) => {
    const i = t[r];
    i.parents && i.parents.length > 0 && i.parents.forEach((s) => {
      _ae(n, t[s], i, t);
    });
  });
}, wae = (e, t) => {
  const n = i0().gitGraph, r = e.append("g");
  t.forEach((i, s) => {
    const o = s % $l, a = Gr[i.name].pos, l = r.append("line");
    l.attr("x1", 0), l.attr("y1", a), l.attr("x2", i2), l.attr("y2", a), l.attr("class", "branch branch" + o), r2.push(a);
    let h = i.name;
    const u = xae(h), f = r.insert("rect"), p = r.insert("g").attr("class", "branchLabel").insert("g").attr("class", "label branch-label" + o);
    p.node().appendChild(u);
    let g = u.getBBox();
    f.attr("class", "branchLabelBkg label" + o).attr("rx", 4).attr("ry", 4).attr("x", -g.width - 4 - (n.rotateCommitLabel === !0 ? 30 : 0)).attr("y", -g.height / 2 + 8).attr("width", g.width + 18).attr("height", g.height + 4), p.attr(
      "transform",
      "translate(" + (-g.width - 14 - (n.rotateCommitLabel === !0 ? 30 : 0)) + ", " + (a - g.height / 2 - 1) + ")"
    ), f.attr("transform", "translate(" + -19 + ", " + (a - g.height / 2) + ")");
  });
}, Sae = function(e, t, n, r) {
  var h;
  Oae();
  const i = i0(), s = i.gitGraph;
  B.debug("in gitgraph renderer", e + `
`, "id:", t, n), $f = r.db.getCommits();
  const o = r.db.getBranchesAsObjArray();
  let a = 0;
  o.forEach((u, f) => {
    Gr[u.name] = { pos: a, index: f }, a += 50 + (s.rotateCommitLabel ? 40 : 0);
  });
  const l = wt(`[id="${t}"]`);
  E8(l, $f, !1), s.showBranches && wae(l, o), kae(l, $f), E8(l, $f, !0), fe.insertTitle(
    l,
    "gitTitleText",
    s.titleTopMargin,
    r.db.getDiagramTitle()
  ), YF(
    void 0,
    l,
    s.diagramPadding,
    (h = s.useMaxWidth) != null ? h : i.useMaxWidth
  );
}, Cae = {
  draw: Sae
}, Tae = (e) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
  (t) => `
        .branch-label${t} { fill: ${e["gitBranchLabel" + t]}; }
        .commit${t} { stroke: ${e["git" + t]}; fill: ${e["git" + t]}; }
        .commit-highlight${t} { stroke: ${e["gitInv" + t]}; fill: ${e["gitInv" + t]}; }
        .label${t}  { fill: ${e["git" + t]}; }
        .arrow${t} { stroke: ${e["git" + t]}; }
        `
).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
  }
`, Eae = Tae;
var s2 = function() {
  var e = function(Lt, kt, _t, Et) {
    for (_t = _t || {}, Et = Lt.length; Et--; _t[Lt[Et]] = kt)
      ;
    return _t;
  }, t = [1, 6], n = [1, 7], r = [1, 8], i = [1, 9], s = [1, 16], o = [1, 11], a = [1, 12], l = [1, 13], h = [1, 14], u = [1, 15], f = [1, 27], d = [1, 33], p = [1, 34], g = [1, 35], m = [1, 36], y = [1, 37], O = [1, 72], x = [1, 73], _ = [1, 74], w = [1, 75], E = [1, 76], T = [1, 77], S = [1, 78], R = [1, 38], A = [1, 39], P = [1, 40], C = [1, 41], k = [1, 42], D = [1, 43], b = [1, 44], M = [1, 45], v = [1, 46], N = [1, 47], tt = [1, 48], Z = [1, 49], z = [1, 50], X = [1, 51], q = [1, 52], nt = [1, 53], st = [1, 54], ct = [1, 55], Y = [1, 56], Ct = [1, 57], H = [1, 59], et = [1, 60], U = [1, 61], W = [1, 62], $ = [1, 63], F = [1, 64], G = [1, 65], I = [1, 66], ht = [1, 67], L = [1, 68], $t = [1, 69], it = [24, 52], At = [24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], St = [15, 24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], bt = [1, 94], gt = [1, 95], yt = [1, 96], dt = [1, 97], xt = [15, 24, 52], Re = [7, 8, 9, 10, 18, 22, 25, 26, 27, 28], ye = [15, 24, 43, 52], zt = [15, 24, 43, 52, 86, 87, 89, 90], Yt = [15, 43], ce = [44, 46, 47, 48, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], Ie = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, direction: 5, directive: 6, direction_tb: 7, direction_bt: 8, direction_rl: 9, direction_lr: 10, graphConfig: 11, openDirective: 12, typeDirective: 13, closeDirective: 14, NEWLINE: 15, ":": 16, argDirective: 17, open_directive: 18, type_directive: 19, arg_directive: 20, close_directive: 21, C4_CONTEXT: 22, statements: 23, EOF: 24, C4_CONTAINER: 25, C4_COMPONENT: 26, C4_DYNAMIC: 27, C4_DEPLOYMENT: 28, otherStatements: 29, diagramStatements: 30, otherStatement: 31, title: 32, accDescription: 33, acc_title: 34, acc_title_value: 35, acc_descr: 36, acc_descr_value: 37, acc_descr_multiline_value: 38, boundaryStatement: 39, boundaryStartStatement: 40, boundaryStopStatement: 41, boundaryStart: 42, LBRACE: 43, ENTERPRISE_BOUNDARY: 44, attributes: 45, SYSTEM_BOUNDARY: 46, BOUNDARY: 47, CONTAINER_BOUNDARY: 48, NODE: 49, NODE_L: 50, NODE_R: 51, RBRACE: 52, diagramStatement: 53, PERSON: 54, PERSON_EXT: 55, SYSTEM: 56, SYSTEM_DB: 57, SYSTEM_QUEUE: 58, SYSTEM_EXT: 59, SYSTEM_EXT_DB: 60, SYSTEM_EXT_QUEUE: 61, CONTAINER: 62, CONTAINER_DB: 63, CONTAINER_QUEUE: 64, CONTAINER_EXT: 65, CONTAINER_EXT_DB: 66, CONTAINER_EXT_QUEUE: 67, COMPONENT: 68, COMPONENT_DB: 69, COMPONENT_QUEUE: 70, COMPONENT_EXT: 71, COMPONENT_EXT_DB: 72, COMPONENT_EXT_QUEUE: 73, REL: 74, BIREL: 75, REL_U: 76, REL_D: 77, REL_L: 78, REL_R: 79, REL_B: 80, REL_INDEX: 81, UPDATE_EL_STYLE: 82, UPDATE_REL_STYLE: 83, UPDATE_LAYOUT_CONFIG: 84, attribute: 85, STR: 86, STR_KEY: 87, STR_VALUE: 88, ATTRIBUTE: 89, ATTRIBUTE_EMPTY: 90, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 7: "direction_tb", 8: "direction_bt", 9: "direction_rl", 10: "direction_lr", 15: "NEWLINE", 16: ":", 18: "open_directive", 19: "type_directive", 20: "arg_directive", 21: "close_directive", 22: "C4_CONTEXT", 24: "EOF", 25: "C4_CONTAINER", 26: "C4_COMPONENT", 27: "C4_DYNAMIC", 28: "C4_DEPLOYMENT", 32: "title", 33: "accDescription", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 43: "LBRACE", 44: "ENTERPRISE_BOUNDARY", 46: "SYSTEM_BOUNDARY", 47: "BOUNDARY", 48: "CONTAINER_BOUNDARY", 49: "NODE", 50: "NODE_L", 51: "NODE_R", 52: "RBRACE", 54: "PERSON", 55: "PERSON_EXT", 56: "SYSTEM", 57: "SYSTEM_DB", 58: "SYSTEM_QUEUE", 59: "SYSTEM_EXT", 60: "SYSTEM_EXT_DB", 61: "SYSTEM_EXT_QUEUE", 62: "CONTAINER", 63: "CONTAINER_DB", 64: "CONTAINER_QUEUE", 65: "CONTAINER_EXT", 66: "CONTAINER_EXT_DB", 67: "CONTAINER_EXT_QUEUE", 68: "COMPONENT", 69: "COMPONENT_DB", 70: "COMPONENT_QUEUE", 71: "COMPONENT_EXT", 72: "COMPONENT_EXT_DB", 73: "COMPONENT_EXT_QUEUE", 74: "REL", 75: "BIREL", 76: "REL_U", 77: "REL_D", 78: "REL_L", 79: "REL_R", 80: "REL_B", 81: "REL_INDEX", 82: "UPDATE_EL_STYLE", 83: "UPDATE_REL_STYLE", 84: "UPDATE_LAYOUT_CONFIG", 86: "STR", 87: "STR_KEY", 88: "STR_VALUE", 89: "ATTRIBUTE", 90: "ATTRIBUTE_EMPTY" },
    productions_: [0, [3, 1], [3, 1], [3, 2], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [6, 4], [6, 6], [12, 1], [13, 1], [17, 1], [14, 1], [11, 4], [11, 4], [11, 4], [11, 4], [11, 4], [23, 1], [23, 1], [23, 2], [29, 1], [29, 2], [29, 3], [31, 1], [31, 1], [31, 2], [31, 2], [31, 1], [39, 3], [40, 3], [40, 3], [40, 4], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [41, 1], [30, 1], [30, 2], [30, 3], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 1], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [45, 1], [45, 2], [85, 1], [85, 2], [85, 1], [85, 1]],
    performAction: function(kt, _t, Et, pt, Zt, lt, Vt) {
      var ut = lt.length - 1;
      switch (Zt) {
        case 4:
          pt.setDirection("TB");
          break;
        case 5:
          pt.setDirection("BT");
          break;
        case 6:
          pt.setDirection("RL");
          break;
        case 7:
          pt.setDirection("LR");
          break;
        case 11:
          pt.parseDirective("%%{", "open_directive");
          break;
        case 12:
          break;
        case 13:
          lt[ut] = lt[ut].trim().replace(/'/g, '"'), pt.parseDirective(lt[ut], "arg_directive");
          break;
        case 14:
          pt.parseDirective("}%%", "close_directive", "c4Context");
          break;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
          pt.setC4Type(lt[ut - 3]);
          break;
        case 26:
          pt.setTitle(lt[ut].substring(6)), this.$ = lt[ut].substring(6);
          break;
        case 27:
          pt.setAccDescription(lt[ut].substring(15)), this.$ = lt[ut].substring(15);
          break;
        case 28:
          this.$ = lt[ut].trim(), pt.setTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = lt[ut].trim(), pt.setAccDescription(this.$);
          break;
        case 35:
        case 36:
          lt[ut].splice(2, 0, "ENTERPRISE"), pt.addPersonOrSystemBoundary(...lt[ut]), this.$ = lt[ut];
          break;
        case 37:
          pt.addPersonOrSystemBoundary(...lt[ut]), this.$ = lt[ut];
          break;
        case 38:
          lt[ut].splice(2, 0, "CONTAINER"), pt.addContainerBoundary(...lt[ut]), this.$ = lt[ut];
          break;
        case 39:
          pt.addDeploymentNode("node", ...lt[ut]), this.$ = lt[ut];
          break;
        case 40:
          pt.addDeploymentNode("nodeL", ...lt[ut]), this.$ = lt[ut];
          break;
        case 41:
          pt.addDeploymentNode("nodeR", ...lt[ut]), this.$ = lt[ut];
          break;
        case 42:
          pt.popBoundaryParseStack();
          break;
        case 46:
          pt.addPersonOrSystem("person", ...lt[ut]), this.$ = lt[ut];
          break;
        case 47:
          pt.addPersonOrSystem("external_person", ...lt[ut]), this.$ = lt[ut];
          break;
        case 48:
          pt.addPersonOrSystem("system", ...lt[ut]), this.$ = lt[ut];
          break;
        case 49:
          pt.addPersonOrSystem("system_db", ...lt[ut]), this.$ = lt[ut];
          break;
        case 50:
          pt.addPersonOrSystem("system_queue", ...lt[ut]), this.$ = lt[ut];
          break;
        case 51:
          pt.addPersonOrSystem("external_system", ...lt[ut]), this.$ = lt[ut];
          break;
        case 52:
          pt.addPersonOrSystem("external_system_db", ...lt[ut]), this.$ = lt[ut];
          break;
        case 53:
          pt.addPersonOrSystem("external_system_queue", ...lt[ut]), this.$ = lt[ut];
          break;
        case 54:
          pt.addContainer("container", ...lt[ut]), this.$ = lt[ut];
          break;
        case 55:
          pt.addContainer("container_db", ...lt[ut]), this.$ = lt[ut];
          break;
        case 56:
          pt.addContainer("container_queue", ...lt[ut]), this.$ = lt[ut];
          break;
        case 57:
          pt.addContainer("external_container", ...lt[ut]), this.$ = lt[ut];
          break;
        case 58:
          pt.addContainer("external_container_db", ...lt[ut]), this.$ = lt[ut];
          break;
        case 59:
          pt.addContainer("external_container_queue", ...lt[ut]), this.$ = lt[ut];
          break;
        case 60:
          pt.addComponent("component", ...lt[ut]), this.$ = lt[ut];
          break;
        case 61:
          pt.addComponent("component_db", ...lt[ut]), this.$ = lt[ut];
          break;
        case 62:
          pt.addComponent("component_queue", ...lt[ut]), this.$ = lt[ut];
          break;
        case 63:
          pt.addComponent("external_component", ...lt[ut]), this.$ = lt[ut];
          break;
        case 64:
          pt.addComponent("external_component_db", ...lt[ut]), this.$ = lt[ut];
          break;
        case 65:
          pt.addComponent("external_component_queue", ...lt[ut]), this.$ = lt[ut];
          break;
        case 67:
          pt.addRel("rel", ...lt[ut]), this.$ = lt[ut];
          break;
        case 68:
          pt.addRel("birel", ...lt[ut]), this.$ = lt[ut];
          break;
        case 69:
          pt.addRel("rel_u", ...lt[ut]), this.$ = lt[ut];
          break;
        case 70:
          pt.addRel("rel_d", ...lt[ut]), this.$ = lt[ut];
          break;
        case 71:
          pt.addRel("rel_l", ...lt[ut]), this.$ = lt[ut];
          break;
        case 72:
          pt.addRel("rel_r", ...lt[ut]), this.$ = lt[ut];
          break;
        case 73:
          pt.addRel("rel_b", ...lt[ut]), this.$ = lt[ut];
          break;
        case 74:
          lt[ut].splice(0, 1), pt.addRel("rel", ...lt[ut]), this.$ = lt[ut];
          break;
        case 75:
          pt.updateElStyle("update_el_style", ...lt[ut]), this.$ = lt[ut];
          break;
        case 76:
          pt.updateRelStyle("update_rel_style", ...lt[ut]), this.$ = lt[ut];
          break;
        case 77:
          pt.updateLayoutConfig("update_layout_config", ...lt[ut]), this.$ = lt[ut];
          break;
        case 78:
          this.$ = [lt[ut]];
          break;
        case 79:
          lt[ut].unshift(lt[ut - 1]), this.$ = lt[ut];
          break;
        case 80:
        case 82:
          this.$ = lt[ut].trim();
          break;
        case 81:
          let he = {};
          he[lt[ut - 1].trim()] = lt[ut].trim(), this.$ = he;
          break;
        case 83:
          this.$ = "";
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: t, 8: n, 9: r, 10: i, 11: 5, 12: 10, 18: s, 22: o, 25: a, 26: l, 27: h, 28: u }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 3: 17, 4: 2, 5: 3, 6: 4, 7: t, 8: n, 9: r, 10: i, 11: 5, 12: 10, 18: s, 22: o, 25: a, 26: l, 27: h, 28: u }, { 1: [2, 8] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 1: [2, 7] }, { 13: 18, 19: [1, 19] }, { 15: [1, 20] }, { 15: [1, 21] }, { 15: [1, 22] }, { 15: [1, 23] }, { 15: [1, 24] }, { 19: [2, 11] }, { 1: [2, 3] }, { 14: 25, 16: [1, 26], 21: f }, e([16, 21], [2, 12]), { 23: 28, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: g, 36: m, 38: y, 39: 58, 40: 70, 42: 71, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 53: 32, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }, { 23: 79, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: g, 36: m, 38: y, 39: 58, 40: 70, 42: 71, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 53: 32, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }, { 23: 80, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: g, 36: m, 38: y, 39: 58, 40: 70, 42: 71, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 53: 32, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }, { 23: 81, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: g, 36: m, 38: y, 39: 58, 40: 70, 42: 71, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 53: 32, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }, { 23: 82, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: g, 36: m, 38: y, 39: 58, 40: 70, 42: 71, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 53: 32, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }, { 15: [1, 83] }, { 17: 84, 20: [1, 85] }, { 15: [2, 14] }, { 24: [1, 86] }, e(it, [2, 20], { 53: 32, 39: 58, 40: 70, 42: 71, 30: 87, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }), e(it, [2, 21]), e(At, [2, 23], { 15: [1, 88] }), e(it, [2, 43], { 15: [1, 89] }), e(St, [2, 26]), e(St, [2, 27]), { 35: [1, 90] }, { 37: [1, 91] }, e(St, [2, 30]), { 45: 92, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 98, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 99, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 100, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 101, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 102, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 103, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 104, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 105, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 106, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 107, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 108, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 109, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 110, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 111, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 112, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 113, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 114, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 115, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 116, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, e(xt, [2, 66]), { 45: 117, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 118, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 119, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 120, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 121, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 122, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 123, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 124, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 125, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 126, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 127, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 30: 128, 39: 58, 40: 70, 42: 71, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 53: 32, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }, { 15: [1, 130], 43: [1, 129] }, { 45: 131, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 132, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 133, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 134, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 135, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 136, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 45: 137, 85: 93, 86: bt, 87: gt, 89: yt, 90: dt }, { 24: [1, 138] }, { 24: [1, 139] }, { 24: [1, 140] }, { 24: [1, 141] }, e(Re, [2, 9]), { 14: 142, 21: f }, { 21: [2, 13] }, { 1: [2, 15] }, e(it, [2, 22]), e(At, [2, 24], { 31: 31, 29: 143, 32: d, 33: p, 34: g, 36: m, 38: y }), e(it, [2, 44], { 29: 29, 30: 30, 31: 31, 53: 32, 39: 58, 40: 70, 42: 71, 23: 144, 32: d, 33: p, 34: g, 36: m, 38: y, 44: O, 46: x, 47: _, 48: w, 49: E, 50: T, 51: S, 54: R, 55: A, 56: P, 57: C, 58: k, 59: D, 60: b, 61: M, 62: v, 63: N, 64: tt, 65: Z, 66: z, 67: X, 68: q, 69: nt, 70: st, 71: ct, 72: Y, 73: Ct, 74: H, 75: et, 76: U, 77: W, 78: $, 79: F, 80: G, 81: I, 82: ht, 83: L, 84: $t }), e(St, [2, 28]), e(St, [2, 29]), e(xt, [2, 46]), e(ye, [2, 78], { 85: 93, 45: 145, 86: bt, 87: gt, 89: yt, 90: dt }), e(zt, [2, 80]), { 88: [1, 146] }, e(zt, [2, 82]), e(zt, [2, 83]), e(xt, [2, 47]), e(xt, [2, 48]), e(xt, [2, 49]), e(xt, [2, 50]), e(xt, [2, 51]), e(xt, [2, 52]), e(xt, [2, 53]), e(xt, [2, 54]), e(xt, [2, 55]), e(xt, [2, 56]), e(xt, [2, 57]), e(xt, [2, 58]), e(xt, [2, 59]), e(xt, [2, 60]), e(xt, [2, 61]), e(xt, [2, 62]), e(xt, [2, 63]), e(xt, [2, 64]), e(xt, [2, 65]), e(xt, [2, 67]), e(xt, [2, 68]), e(xt, [2, 69]), e(xt, [2, 70]), e(xt, [2, 71]), e(xt, [2, 72]), e(xt, [2, 73]), e(xt, [2, 74]), e(xt, [2, 75]), e(xt, [2, 76]), e(xt, [2, 77]), { 41: 147, 52: [1, 148] }, { 15: [1, 149] }, { 43: [1, 150] }, e(Yt, [2, 35]), e(Yt, [2, 36]), e(Yt, [2, 37]), e(Yt, [2, 38]), e(Yt, [2, 39]), e(Yt, [2, 40]), e(Yt, [2, 41]), { 1: [2, 16] }, { 1: [2, 17] }, { 1: [2, 18] }, { 1: [2, 19] }, { 15: [1, 151] }, e(At, [2, 25]), e(it, [2, 45]), e(ye, [2, 79]), e(zt, [2, 81]), e(xt, [2, 31]), e(xt, [2, 42]), e(ce, [2, 32]), e(ce, [2, 33], { 15: [1, 152] }), e(Re, [2, 10]), e(ce, [2, 34])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 5: [2, 8], 6: [2, 4], 7: [2, 5], 8: [2, 6], 9: [2, 7], 16: [2, 11], 17: [2, 3], 27: [2, 14], 85: [2, 13], 86: [2, 15], 138: [2, 16], 139: [2, 17], 140: [2, 18], 141: [2, 19] },
    parseError: function(kt, _t) {
      if (_t.recoverable)
        this.trace(kt);
      else {
        var Et = new Error(kt);
        throw Et.hash = _t, Et;
      }
    },
    parse: function(kt) {
      var _t = this, Et = [0], pt = [], Zt = [null], lt = [], Vt = this.table, ut = "", he = 0, pe = 0, be = 2, Oe = 1, ke = lt.slice.call(arguments, 1), qt = Object.create(this.lexer), ne = { yy: {} };
      for (var ge in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ge) && (ne.yy[ge] = this.yy[ge]);
      qt.setInput(kt, ne.yy), ne.yy.lexer = qt, ne.yy.parser = this, typeof qt.yylloc > "u" && (qt.yylloc = {});
      var ie = qt.yylloc;
      lt.push(ie);
      var qn = qt.options && qt.options.ranges;
      typeof ne.yy.parseError == "function" ? this.parseError = ne.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Ji() {
        var V;
        return V = pt.pop() || qt.lex() || Oe, typeof V != "number" && (V instanceof Array && (pt = V, V = pt.pop()), V = _t.symbols_[V] || V), V;
      }
      for (var qe, ae, fn, On, Qe = {}, xn, We, Rn, kn; ; ) {
        if (ae = Et[Et.length - 1], this.defaultActions[ae] ? fn = this.defaultActions[ae] : ((qe === null || typeof qe > "u") && (qe = Ji()), fn = Vt[ae] && Vt[ae][qe]), typeof fn > "u" || !fn.length || !fn[0]) {
          var It = "";
          kn = [];
          for (xn in Vt[ae])
            this.terminals_[xn] && xn > be && kn.push("'" + this.terminals_[xn] + "'");
          qt.showPosition ? It = "Parse error on line " + (he + 1) + `:
` + qt.showPosition() + `
Expecting ` + kn.join(", ") + ", got '" + (this.terminals_[qe] || qe) + "'" : It = "Parse error on line " + (he + 1) + ": Unexpected " + (qe == Oe ? "end of input" : "'" + (this.terminals_[qe] || qe) + "'"), this.parseError(It, {
            text: qt.match,
            token: this.terminals_[qe] || qe,
            line: qt.yylineno,
            loc: ie,
            expected: kn
          });
        }
        if (fn[0] instanceof Array && fn.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ae + ", token: " + qe);
        switch (fn[0]) {
          case 1:
            Et.push(qe), Zt.push(qt.yytext), lt.push(qt.yylloc), Et.push(fn[1]), qe = null, pe = qt.yyleng, ut = qt.yytext, he = qt.yylineno, ie = qt.yylloc;
            break;
          case 2:
            if (We = this.productions_[fn[1]][1], Qe.$ = Zt[Zt.length - We], Qe._$ = {
              first_line: lt[lt.length - (We || 1)].first_line,
              last_line: lt[lt.length - 1].last_line,
              first_column: lt[lt.length - (We || 1)].first_column,
              last_column: lt[lt.length - 1].last_column
            }, qn && (Qe._$.range = [
              lt[lt.length - (We || 1)].range[0],
              lt[lt.length - 1].range[1]
            ]), On = this.performAction.apply(Qe, [
              ut,
              pe,
              he,
              ne.yy,
              fn[1],
              Zt,
              lt
            ].concat(ke)), typeof On < "u")
              return On;
            We && (Et = Et.slice(0, -1 * We * 2), Zt = Zt.slice(0, -1 * We), lt = lt.slice(0, -1 * We)), Et.push(this.productions_[fn[1]][0]), Zt.push(Qe.$), lt.push(Qe._$), Rn = Vt[Et[Et.length - 2]][Et[Et.length - 1]], Et.push(Rn);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, re = function() {
    var Lt = {
      EOF: 1,
      parseError: function(_t, Et) {
        if (this.yy.parser)
          this.yy.parser.parseError(_t, Et);
        else
          throw new Error(_t);
      },
      setInput: function(kt, _t) {
        return this.yy = _t || this.yy || {}, this._input = kt, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var kt = this._input[0];
        this.yytext += kt, this.yyleng++, this.offset++, this.match += kt, this.matched += kt;
        var _t = kt.match(/(?:\r\n?|\n).*/g);
        return _t ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), kt;
      },
      unput: function(kt) {
        var _t = kt.length, Et = kt.split(/(?:\r\n?|\n)/g);
        this._input = kt + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - _t), this.offset -= _t;
        var pt = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), Et.length - 1 && (this.yylineno -= Et.length - 1);
        var Zt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: Et ? (Et.length === pt.length ? this.yylloc.first_column : 0) + pt[pt.length - Et.length].length - Et[0].length : this.yylloc.first_column - _t
        }, this.options.ranges && (this.yylloc.range = [Zt[0], Zt[0] + this.yyleng - _t]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(kt) {
        this.unput(this.match.slice(kt));
      },
      pastInput: function() {
        var kt = this.matched.substr(0, this.matched.length - this.match.length);
        return (kt.length > 20 ? "..." : "") + kt.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var kt = this.match;
        return kt.length < 20 && (kt += this._input.substr(0, 20 - kt.length)), (kt.substr(0, 20) + (kt.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var kt = this.pastInput(), _t = new Array(kt.length + 1).join("-");
        return kt + this.upcomingInput() + `
` + _t + "^";
      },
      test_match: function(kt, _t) {
        var Et, pt, Zt;
        if (this.options.backtrack_lexer && (Zt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Zt.yylloc.range = this.yylloc.range.slice(0))), pt = kt[0].match(/(?:\r\n?|\n).*/g), pt && (this.yylineno += pt.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: pt ? pt[pt.length - 1].length - pt[pt.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + kt[0].length
        }, this.yytext += kt[0], this.match += kt[0], this.matches = kt, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(kt[0].length), this.matched += kt[0], Et = this.performAction.call(this, this.yy, this, _t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), Et)
          return Et;
        if (this._backtrack) {
          for (var lt in Zt)
            this[lt] = Zt[lt];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var kt, _t, Et, pt;
        this._more || (this.yytext = "", this.match = "");
        for (var Zt = this._currentRules(), lt = 0; lt < Zt.length; lt++)
          if (Et = this._input.match(this.rules[Zt[lt]]), Et && (!_t || Et[0].length > _t[0].length)) {
            if (_t = Et, pt = lt, this.options.backtrack_lexer) {
              if (kt = this.test_match(Et, Zt[lt]), kt !== !1)
                return kt;
              if (this._backtrack) {
                _t = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return _t ? (kt = this.test_match(_t, Zt[pt]), kt !== !1 ? kt : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var _t = this.next();
        return _t || this.lex();
      },
      begin: function(_t) {
        this.conditionStack.push(_t);
      },
      popState: function() {
        var _t = this.conditionStack.length - 1;
        return _t > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(_t) {
        return _t = this.conditionStack.length - 1 - Math.abs(_t || 0), _t >= 0 ? this.conditionStack[_t] : "INITIAL";
      },
      pushState: function(_t) {
        this.begin(_t);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function(_t, Et, pt, Zt) {
        switch (pt) {
          case 0:
            return this.begin("open_directive"), 18;
          case 1:
            return 7;
          case 2:
            return 8;
          case 3:
            return 9;
          case 4:
            return 10;
          case 5:
            return this.begin("type_directive"), 19;
          case 6:
            return this.popState(), this.begin("arg_directive"), 16;
          case 7:
            return this.popState(), this.popState(), 21;
          case 8:
            return 20;
          case 9:
            return 32;
          case 10:
            return 33;
          case 11:
            return this.begin("acc_title"), 34;
          case 12:
            return this.popState(), "acc_title_value";
          case 13:
            return this.begin("acc_descr"), 36;
          case 14:
            return this.popState(), "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            break;
          case 19:
            c;
            break;
          case 20:
            return 15;
          case 21:
            break;
          case 22:
            return 22;
          case 23:
            return 25;
          case 24:
            return 26;
          case 25:
            return 27;
          case 26:
            return 28;
          case 27:
            return this.begin("person_ext"), 55;
          case 28:
            return this.begin("person"), 54;
          case 29:
            return this.begin("system_ext_queue"), 61;
          case 30:
            return this.begin("system_ext_db"), 60;
          case 31:
            return this.begin("system_ext"), 59;
          case 32:
            return this.begin("system_queue"), 58;
          case 33:
            return this.begin("system_db"), 57;
          case 34:
            return this.begin("system"), 56;
          case 35:
            return this.begin("boundary"), 47;
          case 36:
            return this.begin("enterprise_boundary"), 44;
          case 37:
            return this.begin("system_boundary"), 46;
          case 38:
            return this.begin("container_ext_queue"), 67;
          case 39:
            return this.begin("container_ext_db"), 66;
          case 40:
            return this.begin("container_ext"), 65;
          case 41:
            return this.begin("container_queue"), 64;
          case 42:
            return this.begin("container_db"), 63;
          case 43:
            return this.begin("container"), 62;
          case 44:
            return this.begin("container_boundary"), 48;
          case 45:
            return this.begin("component_ext_queue"), 73;
          case 46:
            return this.begin("component_ext_db"), 72;
          case 47:
            return this.begin("component_ext"), 71;
          case 48:
            return this.begin("component_queue"), 70;
          case 49:
            return this.begin("component_db"), 69;
          case 50:
            return this.begin("component"), 68;
          case 51:
            return this.begin("node"), 49;
          case 52:
            return this.begin("node"), 49;
          case 53:
            return this.begin("node_l"), 50;
          case 54:
            return this.begin("node_r"), 51;
          case 55:
            return this.begin("rel"), 74;
          case 56:
            return this.begin("birel"), 75;
          case 57:
            return this.begin("rel_u"), 76;
          case 58:
            return this.begin("rel_u"), 76;
          case 59:
            return this.begin("rel_d"), 77;
          case 60:
            return this.begin("rel_d"), 77;
          case 61:
            return this.begin("rel_l"), 78;
          case 62:
            return this.begin("rel_l"), 78;
          case 63:
            return this.begin("rel_r"), 79;
          case 64:
            return this.begin("rel_r"), 79;
          case 65:
            return this.begin("rel_b"), 80;
          case 66:
            return this.begin("rel_index"), 81;
          case 67:
            return this.begin("update_el_style"), 82;
          case 68:
            return this.begin("update_rel_style"), 83;
          case 69:
            return this.begin("update_layout_config"), 84;
          case 70:
            return "EOF_IN_STRUCT";
          case 71:
            return this.begin("attribute"), "ATTRIBUTE_EMPTY";
          case 72:
            this.begin("attribute");
            break;
          case 73:
            this.popState(), this.popState();
            break;
          case 74:
            return 90;
          case 75:
            break;
          case 76:
            return 90;
          case 77:
            this.begin("string");
            break;
          case 78:
            this.popState();
            break;
          case 79:
            return "STR";
          case 80:
            this.begin("string_kv");
            break;
          case 81:
            return this.begin("string_kv_key"), "STR_KEY";
          case 82:
            this.popState(), this.begin("string_kv_value");
            break;
          case 83:
            return "STR_VALUE";
          case 84:
            this.popState(), this.popState();
            break;
          case 85:
            return "STR";
          case 86:
            return "LBRACE";
          case 87:
            return "RBRACE";
          case 88:
            return "SPACE";
          case 89:
            return "EOL";
          case 90:
            return 24;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
      conditions: { acc_descr_multiline: { rules: [16, 17], inclusive: !1 }, acc_descr: { rules: [14], inclusive: !1 }, acc_title: { rules: [12], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [7, 8], inclusive: !1 }, type_directive: { rules: [6, 7], inclusive: !1 }, open_directive: { rules: [5], inclusive: !1 }, string_kv_value: { rules: [83, 84], inclusive: !1 }, string_kv_key: { rules: [82], inclusive: !1 }, string_kv: { rules: [81], inclusive: !1 }, string: { rules: [78, 79], inclusive: !1 }, attribute: { rules: [73, 74, 75, 76, 77, 80, 85], inclusive: !1 }, update_layout_config: { rules: [70, 71, 72, 73], inclusive: !1 }, update_rel_style: { rules: [70, 71, 72, 73], inclusive: !1 }, update_el_style: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_b: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_r: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_l: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_d: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_u: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_bi: { rules: [], inclusive: !1 }, rel: { rules: [70, 71, 72, 73], inclusive: !1 }, node_r: { rules: [70, 71, 72, 73], inclusive: !1 }, node_l: { rules: [70, 71, 72, 73], inclusive: !1 }, node: { rules: [70, 71, 72, 73], inclusive: !1 }, index: { rules: [], inclusive: !1 }, rel_index: { rules: [70, 71, 72, 73], inclusive: !1 }, component_ext_queue: { rules: [], inclusive: !1 }, component_ext_db: { rules: [70, 71, 72, 73], inclusive: !1 }, component_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, component_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, component_db: { rules: [70, 71, 72, 73], inclusive: !1 }, component: { rules: [70, 71, 72, 73], inclusive: !1 }, container_boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, container_ext_queue: { rules: [], inclusive: !1 }, container_ext_db: { rules: [70, 71, 72, 73], inclusive: !1 }, container_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, container_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, container_db: { rules: [70, 71, 72, 73], inclusive: !1 }, container: { rules: [70, 71, 72, 73], inclusive: !1 }, birel: { rules: [70, 71, 72, 73], inclusive: !1 }, system_boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, enterprise_boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, system_ext_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, system_ext_db: { rules: [70, 71, 72, 73], inclusive: !1 }, system_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, system_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, system_db: { rules: [70, 71, 72, 73], inclusive: !1 }, system: { rules: [70, 71, 72, 73], inclusive: !1 }, person_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, person: { rules: [70, 71, 72, 73], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 86, 87, 88, 89, 90], inclusive: !0 } }
    };
    return Lt;
  }();
  Ie.lexer = re;
  function Qt() {
    this.yy = {};
  }
  return Qt.prototype = Ie, Ie.Parser = Qt, new Qt();
}();
s2.parser = s2;
const Aae = s2, Pae = (e) => e.match(/^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/) !== null;
let Cs = [], Ga = [""], Vr = "global", ys = "", bo = [
  {
    alias: "global",
    label: { text: "global" },
    type: { text: "global" },
    tags: null,
    link: null,
    parentBoundary: ""
  }
], vp = [], M5 = "", R5 = !1, o2 = 4, a2 = 2;
var GF;
const Dae = function() {
  return GF;
}, Lae = function(e) {
  GF = Gi(e, J());
}, Mae = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, Rae = function(e, t, n, r, i, s, o, a, l) {
  if (e == null || t === void 0 || t === null || n === void 0 || n === null || r === void 0 || r === null)
    return;
  let h = {};
  const u = vp.find((f) => f.from === t && f.to === n);
  if (u ? h = u : vp.push(h), h.type = e, h.from = t, h.to = n, h.label = { text: r }, i == null)
    h.techn = { text: "" };
  else if (typeof i == "object") {
    let [f, d] = Object.entries(i)[0];
    h[f] = { text: d };
  } else
    h.techn = { text: i };
  if (s == null)
    h.descr = { text: "" };
  else if (typeof s == "object") {
    let [f, d] = Object.entries(s)[0];
    h[f] = { text: d };
  } else
    h.descr = { text: s };
  if (typeof o == "object") {
    let [f, d] = Object.entries(o)[0];
    h[f] = d;
  } else
    h.sprite = o;
  if (typeof a == "object") {
    let [f, d] = Object.entries(a)[0];
    h[f] = d;
  } else
    h.tags = a;
  if (typeof l == "object") {
    let [f, d] = Object.entries(l)[0];
    h[f] = d;
  } else
    h.link = l;
  h.wrap = yl();
}, $ae = function(e, t, n, r, i, s, o) {
  if (t === null || n === null)
    return;
  let a = {};
  const l = Cs.find((h) => h.alias === t);
  if (l && t === l.alias ? a = l : (a.alias = t, Cs.push(a)), n == null ? a.label = { text: "" } : a.label = { text: n }, r == null)
    a.descr = { text: "" };
  else if (typeof r == "object") {
    let [h, u] = Object.entries(r)[0];
    a[h] = { text: u };
  } else
    a.descr = { text: r };
  if (typeof i == "object") {
    let [h, u] = Object.entries(i)[0];
    a[h] = u;
  } else
    a.sprite = i;
  if (typeof s == "object") {
    let [h, u] = Object.entries(s)[0];
    a[h] = u;
  } else
    a.tags = s;
  if (typeof o == "object") {
    let [h, u] = Object.entries(o)[0];
    a[h] = u;
  } else
    a.link = o;
  a.typeC4Shape = { text: e }, a.parentBoundary = Vr, a.wrap = yl();
}, Iae = function(e, t, n, r, i, s, o, a) {
  if (t === null || n === null)
    return;
  let l = {};
  const h = Cs.find((u) => u.alias === t);
  if (h && t === h.alias ? l = h : (l.alias = t, Cs.push(l)), n == null ? l.label = { text: "" } : l.label = { text: n }, r == null)
    l.techn = { text: "" };
  else if (typeof r == "object") {
    let [u, f] = Object.entries(r)[0];
    l[u] = { text: f };
  } else
    l.techn = { text: r };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [u, f] = Object.entries(i)[0];
    l[u] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof s == "object") {
    let [u, f] = Object.entries(s)[0];
    l[u] = f;
  } else
    l.sprite = s;
  if (typeof o == "object") {
    let [u, f] = Object.entries(o)[0];
    l[u] = f;
  } else
    l.tags = o;
  if (typeof a == "object") {
    let [u, f] = Object.entries(a)[0];
    l[u] = f;
  } else
    l.link = a;
  l.wrap = yl(), l.typeC4Shape = { text: e }, l.parentBoundary = Vr;
}, Nae = function(e, t, n, r, i, s, o, a) {
  if (t === null || n === null)
    return;
  let l = {};
  const h = Cs.find((u) => u.alias === t);
  if (h && t === h.alias ? l = h : (l.alias = t, Cs.push(l)), n == null ? l.label = { text: "" } : l.label = { text: n }, r == null)
    l.techn = { text: "" };
  else if (typeof r == "object") {
    let [u, f] = Object.entries(r)[0];
    l[u] = { text: f };
  } else
    l.techn = { text: r };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [u, f] = Object.entries(i)[0];
    l[u] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof s == "object") {
    let [u, f] = Object.entries(s)[0];
    l[u] = f;
  } else
    l.sprite = s;
  if (typeof o == "object") {
    let [u, f] = Object.entries(o)[0];
    l[u] = f;
  } else
    l.tags = o;
  if (typeof a == "object") {
    let [u, f] = Object.entries(a)[0];
    l[u] = f;
  } else
    l.link = a;
  l.wrap = yl(), l.typeC4Shape = { text: e }, l.parentBoundary = Vr;
}, Bae = function(e, t, n, r, i) {
  if (e === null || t === null)
    return;
  let s = {};
  const o = bo.find((a) => a.alias === e);
  if (o && e === o.alias ? s = o : (s.alias = e, bo.push(s)), t == null ? s.label = { text: "" } : s.label = { text: t }, n == null)
    s.type = { text: "system" };
  else if (typeof n == "object") {
    let [a, l] = Object.entries(n)[0];
    s[a] = { text: l };
  } else
    s.type = { text: n };
  if (typeof r == "object") {
    let [a, l] = Object.entries(r)[0];
    s[a] = l;
  } else
    s.tags = r;
  if (typeof i == "object") {
    let [a, l] = Object.entries(i)[0];
    s[a] = l;
  } else
    s.link = i;
  s.parentBoundary = Vr, s.wrap = yl(), ys = Vr, Vr = e, Ga.push(ys);
}, Fae = function(e, t, n, r, i) {
  if (e === null || t === null)
    return;
  let s = {};
  const o = bo.find((a) => a.alias === e);
  if (o && e === o.alias ? s = o : (s.alias = e, bo.push(s)), t == null ? s.label = { text: "" } : s.label = { text: t }, n == null)
    s.type = { text: "container" };
  else if (typeof n == "object") {
    let [a, l] = Object.entries(n)[0];
    s[a] = { text: l };
  } else
    s.type = { text: n };
  if (typeof r == "object") {
    let [a, l] = Object.entries(r)[0];
    s[a] = l;
  } else
    s.tags = r;
  if (typeof i == "object") {
    let [a, l] = Object.entries(i)[0];
    s[a] = l;
  } else
    s.link = i;
  s.parentBoundary = Vr, s.wrap = yl(), ys = Vr, Vr = e, Ga.push(ys);
}, Qae = function(e, t, n, r, i, s, o, a) {
  if (t === null || n === null)
    return;
  let l = {};
  const h = bo.find((u) => u.alias === t);
  if (h && t === h.alias ? l = h : (l.alias = t, bo.push(l)), n == null ? l.label = { text: "" } : l.label = { text: n }, r == null)
    l.type = { text: "node" };
  else if (typeof r == "object") {
    let [u, f] = Object.entries(r)[0];
    l[u] = { text: f };
  } else
    l.type = { text: r };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [u, f] = Object.entries(i)[0];
    l[u] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof o == "object") {
    let [u, f] = Object.entries(o)[0];
    l[u] = f;
  } else
    l.tags = o;
  if (typeof a == "object") {
    let [u, f] = Object.entries(a)[0];
    l[u] = f;
  } else
    l.link = a;
  l.nodeType = e, l.parentBoundary = Vr, l.wrap = yl(), ys = Vr, Vr = t, Ga.push(ys);
}, Zae = function() {
  Vr = ys, Ga.pop(), ys = Ga.pop(), Ga.push(ys);
}, Vae = function(e, t, n, r, i, s, o, a, l, h, u) {
  let f = Cs.find((d) => d.alias === t);
  if (!(f === void 0 && (f = bo.find((d) => d.alias === t), f === void 0))) {
    if (n != null)
      if (typeof n == "object") {
        let [d, p] = Object.entries(n)[0];
        f[d] = p;
      } else
        f.bgColor = n;
    if (r != null)
      if (typeof r == "object") {
        let [d, p] = Object.entries(r)[0];
        f[d] = p;
      } else
        f.fontColor = r;
    if (i != null)
      if (typeof i == "object") {
        let [d, p] = Object.entries(i)[0];
        f[d] = p;
      } else
        f.borderColor = i;
    if (s != null)
      if (typeof s == "object") {
        let [d, p] = Object.entries(s)[0];
        f[d] = p;
      } else
        f.shadowing = s;
    if (o != null)
      if (typeof o == "object") {
        let [d, p] = Object.entries(o)[0];
        f[d] = p;
      } else
        f.shape = o;
    if (a != null)
      if (typeof a == "object") {
        let [d, p] = Object.entries(a)[0];
        f[d] = p;
      } else
        f.sprite = a;
    if (l != null)
      if (typeof l == "object") {
        let [d, p] = Object.entries(l)[0];
        f[d] = p;
      } else
        f.techn = l;
    if (h != null)
      if (typeof h == "object") {
        let [d, p] = Object.entries(h)[0];
        f[d] = p;
      } else
        f.legendText = h;
    if (u != null)
      if (typeof u == "object") {
        let [d, p] = Object.entries(u)[0];
        f[d] = p;
      } else
        f.legendSprite = u;
  }
}, Yae = function(e, t, n, r, i, s, o) {
  const a = vp.find((l) => l.from === t && l.to === n);
  if (a !== void 0) {
    if (r != null)
      if (typeof r == "object") {
        let [l, h] = Object.entries(r)[0];
        a[l] = h;
      } else
        a.textColor = r;
    if (i != null)
      if (typeof i == "object") {
        let [l, h] = Object.entries(i)[0];
        a[l] = h;
      } else
        a.lineColor = i;
    if (s != null)
      if (typeof s == "object") {
        let [l, h] = Object.entries(s)[0];
        a[l] = parseInt(h);
      } else
        a.offsetX = parseInt(s);
    if (o != null)
      if (typeof o == "object") {
        let [l, h] = Object.entries(o)[0];
        a[l] = parseInt(h);
      } else
        a.offsetY = parseInt(o);
  }
}, zae = function(e, t, n) {
  let r = o2, i = a2;
  if (typeof t == "object") {
    const s = Object.values(t)[0];
    r = parseInt(s);
  } else
    r = parseInt(t);
  if (typeof n == "object") {
    const s = Object.values(n)[0];
    i = parseInt(s);
  } else
    i = parseInt(n);
  r >= 1 && (o2 = r), i >= 1 && (a2 = i);
}, qae = function() {
  return o2;
}, Wae = function() {
  return a2;
}, Uae = function() {
  return Vr;
}, jae = function() {
  return ys;
}, HF = function(e) {
  return e == null ? Cs : Cs.filter((t) => t.parentBoundary === e);
}, Xae = function(e) {
  return Cs.find((t) => t.alias === e);
}, Gae = function(e) {
  return Object.keys(HF(e));
}, Hae = function(e) {
  return e == null ? bo : bo.filter((t) => t.parentBoundary === e);
}, Kae = function() {
  return vp;
}, Jae = function() {
  return M5;
}, tle = function(e) {
  R5 = e;
}, yl = function() {
  return R5;
}, ele = function() {
  Cs = [], bo = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ], ys = "", Vr = "global", Ga = [""], vp = [], Ga = [""], M5 = "", R5 = !1, o2 = 4, a2 = 2;
}, nle = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
}, rle = {
  FILLED: 0,
  OPEN: 1
}, ile = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, sle = function(e) {
  M5 = Gi(e, J());
}, KF = {
  addPersonOrSystem: $ae,
  addPersonOrSystemBoundary: Bae,
  addContainer: Iae,
  addContainerBoundary: Fae,
  addComponent: Nae,
  addDeploymentNode: Qae,
  popBoundaryParseStack: Zae,
  addRel: Rae,
  updateElStyle: Vae,
  updateRelStyle: Yae,
  updateLayoutConfig: zae,
  autoWrap: yl,
  setWrap: tle,
  getC4ShapeArray: HF,
  getC4Shape: Xae,
  getC4ShapeKeys: Gae,
  getBoundarys: Hae,
  getCurrentBoundaryParse: Uae,
  getParentBoundaryParse: jae,
  getRels: Kae,
  getTitle: Jae,
  getC4Type: Dae,
  getC4ShapeInRow: qae,
  getC4BoundaryInRow: Wae,
  setAccTitle: oi,
  getAccTitle: ki,
  getAccDescription: Si,
  setAccDescription: wi,
  parseDirective: Mae,
  getConfig: () => J().c4,
  clear: ele,
  LINETYPE: nle,
  ARROWTYPE: rle,
  PLACEMENT: ile,
  setTitle: sle,
  setC4Type: Lae
}, $5 = function(e, t) {
  const n = e.append("rect");
  if (n.attr("x", t.x), n.attr("y", t.y), n.attr("fill", t.fill), n.attr("stroke", t.stroke), n.attr("width", t.width), n.attr("height", t.height), n.attr("rx", t.rx), n.attr("ry", t.ry), t.attrs !== "undefined" && t.attrs !== null)
    for (let r in t.attrs)
      n.attr(r, t.attrs[r]);
  return t.class !== "undefined" && n.attr("class", t.class), n;
}, JF = function(e, t, n, r, i, s) {
  const o = e.append("image");
  o.attr("width", t), o.attr("height", n), o.attr("x", r), o.attr("y", i);
  let a = s.startsWith("data:image/png;base64") ? s : Oa.sanitizeUrl(s);
  o.attr("xlink:href", a);
}, ole = (e, t, n) => {
  const r = e.append("g");
  let i = 0;
  for (let s of t) {
    let o = s.textColor ? s.textColor : "#444444", a = s.lineColor ? s.lineColor : "#444444", l = s.offsetX ? parseInt(s.offsetX) : 0, h = s.offsetY ? parseInt(s.offsetY) : 0, u = "";
    if (i === 0) {
      let d = r.append("line");
      d.attr("x1", s.startPoint.x), d.attr("y1", s.startPoint.y), d.attr("x2", s.endPoint.x), d.attr("y2", s.endPoint.y), d.attr("stroke-width", "1"), d.attr("stroke", a), d.style("fill", "none"), s.type !== "rel_b" && d.attr("marker-end", "url(" + u + "#arrowhead)"), (s.type === "birel" || s.type === "rel_b") && d.attr("marker-start", "url(" + u + "#arrowend)"), i = -1;
    } else {
      let d = r.append("path");
      d.attr("fill", "none").attr("stroke-width", "1").attr("stroke", a).attr(
        "d",
        "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", s.startPoint.x).replaceAll("starty", s.startPoint.y).replaceAll(
          "controlx",
          s.startPoint.x + (s.endPoint.x - s.startPoint.x) / 2 - (s.endPoint.x - s.startPoint.x) / 4
        ).replaceAll("controly", s.startPoint.y + (s.endPoint.y - s.startPoint.y) / 2).replaceAll("stopx", s.endPoint.x).replaceAll("stopy", s.endPoint.y)
      ), s.type !== "rel_b" && d.attr("marker-end", "url(" + u + "#arrowhead)"), (s.type === "birel" || s.type === "rel_b") && d.attr("marker-start", "url(" + u + "#arrowend)");
    }
    let f = n.messageFont();
    Xo(n)(
      s.label.text,
      r,
      Math.min(s.startPoint.x, s.endPoint.x) + Math.abs(s.endPoint.x - s.startPoint.x) / 2 + l,
      Math.min(s.startPoint.y, s.endPoint.y) + Math.abs(s.endPoint.y - s.startPoint.y) / 2 + h,
      s.label.width,
      s.label.height,
      { fill: o },
      f
    ), s.techn && s.techn.text !== "" && (f = n.messageFont(), Xo(n)(
      "[" + s.techn.text + "]",
      r,
      Math.min(s.startPoint.x, s.endPoint.x) + Math.abs(s.endPoint.x - s.startPoint.x) / 2 + l,
      Math.min(s.startPoint.y, s.endPoint.y) + Math.abs(s.endPoint.y - s.startPoint.y) / 2 + n.messageFontSize + 5 + h,
      Math.max(s.label.width, s.techn.width),
      s.techn.height,
      { fill: o, "font-style": "italic" },
      f
    ));
  }
}, ale = function(e, t, n) {
  const r = e.append("g");
  let i = t.bgColor ? t.bgColor : "none", s = t.borderColor ? t.borderColor : "#444444", o = t.fontColor ? t.fontColor : "black", a = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
  t.nodeType && (a = { "stroke-width": 1 });
  let l = {
    x: t.x,
    y: t.y,
    fill: i,
    stroke: s,
    width: t.width,
    height: t.height,
    rx: 2.5,
    ry: 2.5,
    attrs: a
  };
  $5(r, l);
  let h = n.boundaryFont();
  h.fontWeight = "bold", h.fontSize = h.fontSize + 2, h.fontColor = o, Xo(n)(
    t.label.text,
    r,
    t.x,
    t.y + t.label.Y,
    t.width,
    t.height,
    { fill: "#444444" },
    h
  ), t.type && t.type.text !== "" && (h = n.boundaryFont(), h.fontColor = o, Xo(n)(
    t.type.text,
    r,
    t.x,
    t.y + t.type.Y,
    t.width,
    t.height,
    { fill: "#444444" },
    h
  )), t.descr && t.descr.text !== "" && (h = n.boundaryFont(), h.fontSize = h.fontSize - 2, h.fontColor = o, Xo(n)(
    t.descr.text,
    r,
    t.x,
    t.y + t.descr.Y,
    t.width,
    t.height,
    { fill: "#444444" },
    h
  ));
}, lle = function(e, t, n) {
  var r;
  let i = t.bgColor ? t.bgColor : n[t.typeC4Shape.text + "_bg_color"], s = t.borderColor ? t.borderColor : n[t.typeC4Shape.text + "_border_color"], o = t.fontColor ? t.fontColor : "#FFFFFF", a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
  switch (t.typeC4Shape.text) {
    case "person":
      a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
      break;
    case "external_person":
      a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
      break;
  }
  const l = e.append("g");
  l.attr("class", "person-man");
  const h = tQ();
  switch (t.typeC4Shape.text) {
    case "person":
    case "external_person":
    case "system":
    case "external_system":
    case "container":
    case "external_container":
    case "component":
    case "external_component":
      h.x = t.x, h.y = t.y, h.fill = i, h.width = t.width, h.height = t.height, h.stroke = s, h.rx = 2.5, h.ry = 2.5, h.attrs = { "stroke-width": 0.5 }, $5(l, h);
      break;
    case "system_db":
    case "external_system_db":
    case "container_db":
    case "external_container_db":
    case "component_db":
    case "external_component_db":
      l.append("path").attr("fill", i).attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("half", t.width / 2).replaceAll("height", t.height)
      ), l.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("half", t.width / 2)
      );
      break;
    case "system_queue":
    case "external_system_queue":
    case "container_queue":
    case "external_container_queue":
    case "component_queue":
    case "external_component_queue":
      l.append("path").attr("fill", i).attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("width", t.width).replaceAll("half", t.height / 2)
      ), l.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", t.x + t.width).replaceAll("starty", t.y).replaceAll("half", t.height / 2)
      );
      break;
  }
  let u = yle(n, t.typeC4Shape.text);
  switch (l.append("text").attr("fill", o).attr("font-family", u.fontFamily).attr("font-size", u.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", t.typeC4Shape.width).attr("x", t.x + t.width / 2 - t.typeC4Shape.width / 2).attr("y", t.y + t.typeC4Shape.Y).text("<<" + t.typeC4Shape.text + ">>"), t.typeC4Shape.text) {
    case "person":
    case "external_person":
      JF(
        l,
        48,
        48,
        t.x + t.width / 2 - 24,
        t.y + t.image.Y,
        a
      );
      break;
  }
  let f = n[t.typeC4Shape.text + "Font"]();
  return f.fontWeight = "bold", f.fontSize = f.fontSize + 2, f.fontColor = o, Xo(n)(
    t.label.text,
    l,
    t.x,
    t.y + t.label.Y,
    t.width,
    t.height,
    { fill: o },
    f
  ), f = n[t.typeC4Shape.text + "Font"](), f.fontColor = o, t.techn && ((r = t.techn) == null ? void 0 : r.text) !== "" ? Xo(n)(
    t.techn.text,
    l,
    t.x,
    t.y + t.techn.Y,
    t.width,
    t.height,
    { fill: o, "font-style": "italic" },
    f
  ) : t.type && t.type.text !== "" && Xo(n)(
    t.type.text,
    l,
    t.x,
    t.y + t.type.Y,
    t.width,
    t.height,
    { fill: o, "font-style": "italic" },
    f
  ), t.descr && t.descr.text !== "" && (f = n.personFont(), f.fontColor = o, Xo(n)(
    t.descr.text,
    l,
    t.x,
    t.y + t.descr.Y,
    t.width,
    t.height,
    { fill: o },
    f
  )), t.height;
}, cle = function(e) {
  e.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, hle = function(e) {
  e.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, ule = function(e) {
  e.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, fle = function(e) {
  e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, dle = function(e) {
  e.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
}, ple = function(e) {
  e.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, gle = function(e) {
  e.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, mle = function(e) {
  const n = e.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  n.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z"), n.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
}, tQ = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, yle = (e, t) => ({
  fontFamily: e[t + "FontFamily"],
  fontSize: e[t + "FontSize"],
  fontWeight: e[t + "FontWeight"]
}), Xo = function() {
  function e(i, s, o, a, l, h, u) {
    const f = s.append("text").attr("x", o + l / 2).attr("y", a + h / 2 + 5).style("text-anchor", "middle").text(i);
    r(f, u);
  }
  function t(i, s, o, a, l, h, u, f) {
    const { fontSize: d, fontFamily: p, fontWeight: g } = f, m = i.split(de.lineBreakRegex);
    for (let y = 0; y < m.length; y++) {
      const O = y * d - d * (m.length - 1) / 2, x = s.append("text").attr("x", o + l / 2).attr("y", a).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", d).style("font-weight", g).style("font-family", p);
      x.append("tspan").attr("dy", O).text(m[y]).attr("alignment-baseline", "mathematical"), r(x, u);
    }
  }
  function n(i, s, o, a, l, h, u, f) {
    const d = s.append("switch"), g = d.append("foreignObject").attr("x", o).attr("y", a).attr("width", l).attr("height", h).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), t(i, d, o, a, l, h, u, f), r(g, u);
  }
  function r(i, s) {
    for (const o in s)
      s.hasOwnProperty(o) && i.attr(o, s[o]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? n : i.textPlacement === "old" ? e : t;
  };
}(), Ws = {
  drawRect: $5,
  drawBoundary: ale,
  drawC4Shape: lle,
  drawRels: ole,
  drawImage: JF,
  insertArrowHead: fle,
  insertArrowEnd: dle,
  insertArrowFilledHead: ple,
  insertDynamicNumber: gle,
  insertArrowCrossHead: mle,
  insertDatabaseIcon: cle,
  insertComputerIcon: hle,
  insertClockIcon: ule,
  getNoteRect: tQ,
  sanitizeUrl: Oa.sanitizeUrl
};
let l2 = 0, c2 = 0, eQ = 4, fk = 2;
s2.yy = KF;
let Ut = {};
class nQ {
  constructor(t) {
    this.name = "", this.data = {}, this.data.startx = void 0, this.data.stopx = void 0, this.data.starty = void 0, this.data.stopy = void 0, this.data.widthLimit = void 0, this.nextData = {}, this.nextData.startx = void 0, this.nextData.stopx = void 0, this.nextData.starty = void 0, this.nextData.stopy = void 0, this.nextData.cnt = 0, dk(t.db.getConfig());
  }
  setData(t, n, r, i) {
    this.nextData.startx = this.data.startx = t, this.nextData.stopx = this.data.stopx = n, this.nextData.starty = this.data.starty = r, this.nextData.stopy = this.data.stopy = i;
  }
  updateVal(t, n, r, i) {
    t[n] === void 0 ? t[n] = r : t[n] = i(r, t[n]);
  }
  insert(t) {
    this.nextData.cnt = this.nextData.cnt + 1;
    let n = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + t.margin : this.nextData.stopx + t.margin * 2, r = n + t.width, i = this.nextData.starty + t.margin * 2, s = i + t.height;
    (n >= this.data.widthLimit || r >= this.data.widthLimit || this.nextData.cnt > eQ) && (n = this.nextData.startx + t.margin + Ut.nextLinePaddingX, i = this.nextData.stopy + t.margin * 2, this.nextData.stopx = r = n + t.width, this.nextData.starty = this.nextData.stopy, this.nextData.stopy = s = i + t.height, this.nextData.cnt = 1), t.x = n, t.y = i, this.updateVal(this.data, "startx", n, Math.min), this.updateVal(this.data, "starty", i, Math.min), this.updateVal(this.data, "stopx", r, Math.max), this.updateVal(this.data, "stopy", s, Math.max), this.updateVal(this.nextData, "startx", n, Math.min), this.updateVal(this.nextData, "starty", i, Math.min), this.updateVal(this.nextData, "stopx", r, Math.max), this.updateVal(this.nextData, "stopy", s, Math.max);
  }
  init(t) {
    this.name = "", this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      widthLimit: void 0
    }, this.nextData = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      cnt: 0
    }, dk(t.db.getConfig());
  }
  bumpLastMargin(t) {
    this.data.stopx += t, this.data.stopy += t;
  }
}
const dk = function(e) {
  or(Ut, e), e.fontFamily && (Ut.personFontFamily = Ut.systemFontFamily = Ut.messageFontFamily = e.fontFamily), e.fontSize && (Ut.personFontSize = Ut.systemFontSize = Ut.messageFontSize = e.fontSize), e.fontWeight && (Ut.personFontWeight = Ut.systemFontWeight = Ut.messageFontWeight = e.fontWeight);
}, mf = (e, t) => ({
  fontFamily: e[t + "FontFamily"],
  fontSize: e[t + "FontSize"],
  fontWeight: e[t + "FontWeight"]
}), pg = (e) => ({
  fontFamily: e.boundaryFontFamily,
  fontSize: e.boundaryFontSize,
  fontWeight: e.boundaryFontWeight
}), ble = (e) => ({
  fontFamily: e.messageFontFamily,
  fontSize: e.messageFontSize,
  fontWeight: e.messageFontWeight
});
function cs(e, t, n, r, i) {
  if (!t[e].width)
    if (n)
      t[e].text = TF(t[e].text, i, r), t[e].textLines = t[e].text.split(de.lineBreakRegex).length, t[e].width = i, t[e].height = lk(t[e].text, r);
    else {
      let s = t[e].text.split(de.lineBreakRegex);
      t[e].textLines = s.length;
      let o = 0;
      t[e].height = 0, t[e].width = 0;
      for (const a of s)
        t[e].width = Math.max(
          po(a, r),
          t[e].width
        ), o = lk(a, r), t[e].height = t[e].height + o;
    }
}
const rQ = function(e, t, n) {
  t.x = n.data.startx, t.y = n.data.starty, t.width = n.data.stopx - n.data.startx, t.height = n.data.stopy - n.data.starty, t.label.y = Ut.c4ShapeMargin - 35;
  let r = t.wrap && Ut.wrap, i = pg(Ut);
  i.fontSize = i.fontSize + 2, i.fontWeight = "bold";
  let s = po(t.label.text, i);
  cs("label", t, r, i, s), Ws.drawBoundary(e, t, Ut);
}, iQ = function(e, t, n, r) {
  let i = 0;
  for (const s of r) {
    i = 0;
    const o = n[s];
    let a = mf(Ut, o.typeC4Shape.text);
    switch (a.fontSize = a.fontSize - 2, o.typeC4Shape.width = po(
      "<<" + o.typeC4Shape.text + ">>",
      a
    ), o.typeC4Shape.height = a.fontSize + 2, o.typeC4Shape.Y = Ut.c4ShapePadding, i = o.typeC4Shape.Y + o.typeC4Shape.height - 4, o.image = { width: 0, height: 0, Y: 0 }, o.typeC4Shape.text) {
      case "person":
      case "external_person":
        o.image.width = 48, o.image.height = 48, o.image.Y = i, i = o.image.Y + o.image.height;
        break;
    }
    o.sprite && (o.image.width = 48, o.image.height = 48, o.image.Y = i, i = o.image.Y + o.image.height);
    let l = o.wrap && Ut.wrap, h = Ut.width - Ut.c4ShapePadding * 2, u = mf(Ut, o.typeC4Shape.text);
    if (u.fontSize = u.fontSize + 2, u.fontWeight = "bold", cs("label", o, l, u, h), o.label.Y = i + 8, i = o.label.Y + o.label.height, o.type && o.type.text !== "") {
      o.type.text = "[" + o.type.text + "]";
      let p = mf(Ut, o.typeC4Shape.text);
      cs("type", o, l, p, h), o.type.Y = i + 5, i = o.type.Y + o.type.height;
    } else if (o.techn && o.techn.text !== "") {
      o.techn.text = "[" + o.techn.text + "]";
      let p = mf(Ut, o.techn.text);
      cs("techn", o, l, p, h), o.techn.Y = i + 5, i = o.techn.Y + o.techn.height;
    }
    let f = i, d = o.label.width;
    if (o.descr && o.descr.text !== "") {
      let p = mf(Ut, o.typeC4Shape.text);
      cs("descr", o, l, p, h), o.descr.Y = i + 20, i = o.descr.Y + o.descr.height, d = Math.max(o.label.width, o.descr.width), f = i - o.descr.textLines * 5;
    }
    d = d + Ut.c4ShapePadding, o.width = Math.max(o.width || Ut.width, d, Ut.width), o.height = Math.max(o.height || Ut.height, f, Ut.height), o.margin = o.margin || Ut.c4ShapeMargin, e.insert(o), Ws.drawC4Shape(t, o, Ut);
  }
  e.bumpLastMargin(Ut.c4ShapeMargin);
};
class Pi {
  constructor(t, n) {
    this.x = t, this.y = n;
  }
}
let A8 = function(e, t) {
  let n = e.x, r = e.y, i = t.x, s = t.y, o = n + e.width / 2, a = r + e.height / 2, l = Math.abs(n - i), h = Math.abs(r - s), u = h / l, f = e.height / e.width, d = null;
  return r == s && n < i ? d = new Pi(n + e.width, a) : r == s && n > i ? d = new Pi(n, a) : n == i && r < s ? d = new Pi(o, r + e.height) : n == i && r > s && (d = new Pi(o, r)), n > i && r < s ? f >= u ? d = new Pi(n, a + u * e.width / 2) : d = new Pi(
    o - l / h * e.height / 2,
    r + e.height
  ) : n < i && r < s ? f >= u ? d = new Pi(n + e.width, a + u * e.width / 2) : d = new Pi(
    o + l / h * e.height / 2,
    r + e.height
  ) : n < i && r > s ? f >= u ? d = new Pi(n + e.width, a - u * e.width / 2) : d = new Pi(o + e.height / 2 * l / h, r) : n > i && r > s && (f >= u ? d = new Pi(n, a - e.width / 2 * u) : d = new Pi(o - e.height / 2 * l / h, r)), d;
}, Ole = function(e, t) {
  let n = { x: 0, y: 0 };
  n.x = t.x + t.width / 2, n.y = t.y + t.height / 2;
  let r = A8(e, n);
  n.x = e.x + e.width / 2, n.y = e.y + e.height / 2;
  let i = A8(t, n);
  return { startPoint: r, endPoint: i };
};
const xle = function(e, t, n, r) {
  let i = 0;
  for (let s of t) {
    i = i + 1;
    let o = s.wrap && Ut.wrap, a = ble(Ut);
    r.db.getC4Type() === "C4Dynamic" && (s.label.text = i + ": " + s.label.text);
    let h = po(s.label.text, a);
    cs("label", s, o, a, h), s.techn && s.techn.text !== "" && (h = po(s.techn.text, a), cs("techn", s, o, a, h)), s.descr && s.descr.text !== "" && (h = po(s.descr.text, a), cs("descr", s, o, a, h));
    let u = n(s.from), f = n(s.to), d = Ole(u, f);
    s.startPoint = d.startPoint, s.endPoint = d.endPoint;
  }
  Ws.drawRels(e, t, Ut);
};
function sQ(e, t, n, r, i) {
  let s = new nQ(i);
  s.data.widthLimit = n.data.widthLimit / Math.min(fk, r.length);
  for (let [o, a] of r.entries()) {
    let l = 0;
    a.image = { width: 0, height: 0, Y: 0 }, a.sprite && (a.image.width = 48, a.image.height = 48, a.image.Y = l, l = a.image.Y + a.image.height);
    let h = a.wrap && Ut.wrap, u = pg(Ut);
    if (u.fontSize = u.fontSize + 2, u.fontWeight = "bold", cs(
      "label",
      a,
      h,
      u,
      s.data.widthLimit
    ), a.label.Y = l + 8, l = a.label.Y + a.label.height, a.type && a.type.text !== "") {
      a.type.text = "[" + a.type.text + "]";
      let g = pg(Ut);
      cs(
        "type",
        a,
        h,
        g,
        s.data.widthLimit
      ), a.type.Y = l + 5, l = a.type.Y + a.type.height;
    }
    if (a.descr && a.descr.text !== "") {
      let g = pg(Ut);
      g.fontSize = g.fontSize - 2, cs(
        "descr",
        a,
        h,
        g,
        s.data.widthLimit
      ), a.descr.Y = l + 20, l = a.descr.Y + a.descr.height;
    }
    if (o == 0 || o % fk === 0) {
      let g = n.data.startx + Ut.diagramMarginX, m = n.data.stopy + Ut.diagramMarginY + l;
      s.setData(g, g, m, m);
    } else {
      let g = s.data.stopx !== s.data.startx ? s.data.stopx + Ut.diagramMarginX : s.data.startx, m = s.data.starty;
      s.setData(g, g, m, m);
    }
    s.name = a.alias;
    let f = i.db.getC4ShapeArray(a.alias), d = i.db.getC4ShapeKeys(a.alias);
    d.length > 0 && iQ(
      s,
      e,
      f,
      d
    ), t = a.alias;
    let p = i.db.getBoundarys(t);
    p.length > 0 && sQ(
      e,
      t,
      s,
      p,
      i
    ), a.alias !== "global" && rQ(e, a, s), n.data.stopy = Math.max(
      s.data.stopy + Ut.c4ShapeMargin,
      n.data.stopy
    ), n.data.stopx = Math.max(
      s.data.stopx + Ut.c4ShapeMargin,
      n.data.stopx
    ), l2 = Math.max(l2, n.data.stopx), c2 = Math.max(c2, n.data.stopy);
  }
}
const vle = function(e, t, n, r) {
  Ut = J().c4;
  const i = J().securityLevel;
  let s;
  i === "sandbox" && (s = wt("#i" + t));
  const o = wt(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body");
  let a = r.db;
  r.db.setWrap(Ut.wrap), eQ = a.getC4ShapeInRow(), fk = a.getC4BoundaryInRow(), B.debug(`C:${JSON.stringify(Ut, null, 2)}`);
  const l = i === "sandbox" ? o.select(`[id="${t}"]`) : wt(`[id="${t}"]`);
  Ws.insertComputerIcon(l), Ws.insertDatabaseIcon(l), Ws.insertClockIcon(l);
  let h = new nQ(r);
  h.setData(
    Ut.diagramMarginX,
    Ut.diagramMarginX,
    Ut.diagramMarginY,
    Ut.diagramMarginY
  ), h.data.widthLimit = screen.availWidth, l2 = Ut.diagramMarginX, c2 = Ut.diagramMarginY;
  const u = r.db.getTitle();
  let f = r.db.getBoundarys("");
  sQ(l, "", h, f, r), Ws.insertArrowHead(l), Ws.insertArrowEnd(l), Ws.insertArrowCrossHead(l), Ws.insertArrowFilledHead(l), xle(l, r.db.getRels(), r.db.getC4Shape, r), h.data.stopx = l2, h.data.stopy = c2;
  const d = h.data;
  let g = d.stopy - d.starty + 2 * Ut.diagramMarginY;
  const y = d.stopx - d.startx + 2 * Ut.diagramMarginX;
  u && l.append("text").text(u).attr("x", (d.stopx - d.startx) / 2 - 4 * Ut.diagramMarginX).attr("y", d.starty + Ut.diagramMarginY), $s(l, g, y, Ut.useMaxWidth);
  const O = u ? 60 : 0;
  l.attr(
    "viewBox",
    d.startx - Ut.diagramMarginX + " -" + (Ut.diagramMarginY + O) + " " + y + " " + (g + O)
  ), B.debug("models:", d);
}, P8 = {
  drawPersonOrSystemArray: iQ,
  drawBoundary: rQ,
  setConf: dk,
  draw: vle
};
var pk = function() {
  var e = function(W, $, F, G) {
    for (F = F || {}, G = W.length; G--; F[W[G]] = $)
      ;
    return F;
  }, t = [1, 3], n = [1, 7], r = [1, 8], i = [1, 9], s = [1, 10], o = [1, 13], a = [1, 12], l = [1, 16, 25], h = [1, 20], u = [1, 32], f = [1, 33], d = [1, 34], p = [1, 36], g = [1, 39], m = [1, 37], y = [1, 38], O = [1, 44], x = [1, 45], _ = [1, 40], w = [1, 41], E = [1, 42], T = [1, 43], S = [1, 48], R = [1, 49], A = [1, 50], P = [1, 51], C = [16, 25], k = [1, 65], D = [1, 66], b = [1, 67], M = [1, 68], v = [1, 69], N = [1, 70], tt = [1, 71], Z = [1, 80], z = [16, 25, 32, 45, 46, 54, 60, 61, 62, 63, 64, 65, 66, 71, 73], X = [16, 25, 30, 32, 45, 46, 50, 54, 60, 61, 62, 63, 64, 65, 66, 71, 73, 88, 89, 90, 91], q = [5, 8, 9, 10, 11, 16, 19, 23, 25], nt = [54, 88, 89, 90, 91], st = [54, 65, 66, 88, 89, 90, 91], ct = [54, 60, 61, 62, 63, 64, 88, 89, 90, 91], Y = [16, 25, 32], Ct = [1, 107], H = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, statments: 5, direction: 6, directive: 7, direction_tb: 8, direction_bt: 9, direction_rl: 10, direction_lr: 11, graphConfig: 12, openDirective: 13, typeDirective: 14, closeDirective: 15, NEWLINE: 16, ":": 17, argDirective: 18, open_directive: 19, type_directive: 20, arg_directive: 21, close_directive: 22, CLASS_DIAGRAM: 23, statements: 24, EOF: 25, statement: 26, className: 27, alphaNumToken: 28, classLiteralName: 29, GENERICTYPE: 30, relationStatement: 31, LABEL: 32, classStatement: 33, methodStatement: 34, annotationStatement: 35, clickStatement: 36, cssClassStatement: 37, noteStatement: 38, acc_title: 39, acc_title_value: 40, acc_descr: 41, acc_descr_value: 42, acc_descr_multiline_value: 43, CLASS: 44, STYLE_SEPARATOR: 45, STRUCT_START: 46, members: 47, STRUCT_STOP: 48, ANNOTATION_START: 49, ANNOTATION_END: 50, MEMBER: 51, SEPARATOR: 52, relation: 53, STR: 54, NOTE_FOR: 55, noteText: 56, NOTE: 57, relationType: 58, lineType: 59, AGGREGATION: 60, EXTENSION: 61, COMPOSITION: 62, DEPENDENCY: 63, LOLLIPOP: 64, LINE: 65, DOTTED_LINE: 66, CALLBACK: 67, LINK: 68, LINK_TARGET: 69, CLICK: 70, CALLBACK_NAME: 71, CALLBACK_ARGS: 72, HREF: 73, CSSCLASS: 74, commentToken: 75, textToken: 76, graphCodeTokens: 77, textNoTagsToken: 78, TAGSTART: 79, TAGEND: 80, "==": 81, "--": 82, PCT: 83, DEFAULT: 84, SPACE: 85, MINUS: 86, keywords: 87, UNICODE_TEXT: 88, NUM: 89, ALPHA: 90, BQUOTE_STR: 91, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "statments", 8: "direction_tb", 9: "direction_bt", 10: "direction_rl", 11: "direction_lr", 16: "NEWLINE", 17: ":", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 23: "CLASS_DIAGRAM", 25: "EOF", 30: "GENERICTYPE", 32: "LABEL", 39: "acc_title", 40: "acc_title_value", 41: "acc_descr", 42: "acc_descr_value", 43: "acc_descr_multiline_value", 44: "CLASS", 45: "STYLE_SEPARATOR", 46: "STRUCT_START", 48: "STRUCT_STOP", 49: "ANNOTATION_START", 50: "ANNOTATION_END", 51: "MEMBER", 52: "SEPARATOR", 54: "STR", 55: "NOTE_FOR", 57: "NOTE", 60: "AGGREGATION", 61: "EXTENSION", 62: "COMPOSITION", 63: "DEPENDENCY", 64: "LOLLIPOP", 65: "LINE", 66: "DOTTED_LINE", 67: "CALLBACK", 68: "LINK", 69: "LINK_TARGET", 70: "CLICK", 71: "CALLBACK_NAME", 72: "CALLBACK_ARGS", 73: "HREF", 74: "CSSCLASS", 77: "graphCodeTokens", 79: "TAGSTART", 80: "TAGEND", 81: "==", 82: "--", 83: "PCT", 84: "DEFAULT", 85: "SPACE", 86: "MINUS", 87: "keywords", 88: "UNICODE_TEXT", 89: "NUM", 90: "ALPHA", 91: "BQUOTE_STR" },
    productions_: [0, [3, 1], [3, 1], [3, 1], [3, 2], [6, 1], [6, 1], [6, 1], [6, 1], [4, 1], [7, 4], [7, 6], [13, 1], [14, 1], [18, 1], [15, 1], [12, 4], [24, 1], [24, 2], [24, 3], [27, 1], [27, 1], [27, 2], [27, 2], [27, 2], [26, 1], [26, 2], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 2], [26, 2], [26, 1], [33, 2], [33, 4], [33, 5], [33, 7], [35, 4], [47, 1], [47, 2], [34, 1], [34, 2], [34, 1], [34, 1], [31, 3], [31, 4], [31, 4], [31, 5], [38, 3], [38, 2], [53, 3], [53, 2], [53, 2], [53, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [59, 1], [59, 1], [36, 3], [36, 4], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [37, 3], [75, 1], [75, 1], [76, 1], [76, 1], [76, 1], [76, 1], [76, 1], [76, 1], [76, 1], [78, 1], [78, 1], [78, 1], [78, 1], [28, 1], [28, 1], [28, 1], [29, 1], [56, 1]],
    performAction: function($, F, G, I, ht, L, $t) {
      var it = L.length - 1;
      switch (ht) {
        case 5:
          I.setDirection("TB");
          break;
        case 6:
          I.setDirection("BT");
          break;
        case 7:
          I.setDirection("RL");
          break;
        case 8:
          I.setDirection("LR");
          break;
        case 12:
          I.parseDirective("%%{", "open_directive");
          break;
        case 13:
          I.parseDirective(L[it], "type_directive");
          break;
        case 14:
          L[it] = L[it].trim().replace(/'/g, '"'), I.parseDirective(L[it], "arg_directive");
          break;
        case 15:
          I.parseDirective("}%%", "close_directive", "class");
          break;
        case 20:
        case 21:
          this.$ = L[it];
          break;
        case 22:
          this.$ = L[it - 1] + L[it];
          break;
        case 23:
        case 24:
          this.$ = L[it - 1] + "~" + L[it];
          break;
        case 25:
          I.addRelation(L[it]);
          break;
        case 26:
          L[it - 1].title = I.cleanupLabel(L[it]), I.addRelation(L[it - 1]);
          break;
        case 35:
          this.$ = L[it].trim(), I.setAccTitle(this.$);
          break;
        case 36:
        case 37:
          this.$ = L[it].trim(), I.setAccDescription(this.$);
          break;
        case 38:
          I.addClass(L[it]);
          break;
        case 39:
          I.addClass(L[it - 2]), I.setCssClass(L[it - 2], L[it]);
          break;
        case 40:
          I.addClass(L[it - 3]), I.addMembers(L[it - 3], L[it - 1]);
          break;
        case 41:
          I.addClass(L[it - 5]), I.setCssClass(L[it - 5], L[it - 3]), I.addMembers(L[it - 5], L[it - 1]);
          break;
        case 42:
          I.addAnnotation(L[it], L[it - 2]);
          break;
        case 43:
          this.$ = [L[it]];
          break;
        case 44:
          L[it].push(L[it - 1]), this.$ = L[it];
          break;
        case 45:
          break;
        case 46:
          I.addMember(L[it - 1], I.cleanupLabel(L[it]));
          break;
        case 47:
          break;
        case 48:
          break;
        case 49:
          this.$ = { id1: L[it - 2], id2: L[it], relation: L[it - 1], relationTitle1: "none", relationTitle2: "none" };
          break;
        case 50:
          this.$ = { id1: L[it - 3], id2: L[it], relation: L[it - 1], relationTitle1: L[it - 2], relationTitle2: "none" };
          break;
        case 51:
          this.$ = { id1: L[it - 3], id2: L[it], relation: L[it - 2], relationTitle1: "none", relationTitle2: L[it - 1] };
          break;
        case 52:
          this.$ = { id1: L[it - 4], id2: L[it], relation: L[it - 2], relationTitle1: L[it - 3], relationTitle2: L[it - 1] };
          break;
        case 53:
          I.addNote(L[it], L[it - 1]);
          break;
        case 54:
          I.addNote(L[it]);
          break;
        case 55:
          this.$ = { type1: L[it - 2], type2: L[it], lineType: L[it - 1] };
          break;
        case 56:
          this.$ = { type1: "none", type2: L[it], lineType: L[it - 1] };
          break;
        case 57:
          this.$ = { type1: L[it - 1], type2: "none", lineType: L[it] };
          break;
        case 58:
          this.$ = { type1: "none", type2: "none", lineType: L[it] };
          break;
        case 59:
          this.$ = I.relationType.AGGREGATION;
          break;
        case 60:
          this.$ = I.relationType.EXTENSION;
          break;
        case 61:
          this.$ = I.relationType.COMPOSITION;
          break;
        case 62:
          this.$ = I.relationType.DEPENDENCY;
          break;
        case 63:
          this.$ = I.relationType.LOLLIPOP;
          break;
        case 64:
          this.$ = I.lineType.LINE;
          break;
        case 65:
          this.$ = I.lineType.DOTTED_LINE;
          break;
        case 66:
        case 72:
          this.$ = L[it - 2], I.setClickEvent(L[it - 1], L[it]);
          break;
        case 67:
        case 73:
          this.$ = L[it - 3], I.setClickEvent(L[it - 2], L[it - 1]), I.setTooltip(L[it - 2], L[it]);
          break;
        case 68:
        case 76:
          this.$ = L[it - 2], I.setLink(L[it - 1], L[it]);
          break;
        case 69:
          this.$ = L[it - 3], I.setLink(L[it - 2], L[it - 1], L[it]);
          break;
        case 70:
        case 78:
          this.$ = L[it - 3], I.setLink(L[it - 2], L[it - 1]), I.setTooltip(L[it - 2], L[it]);
          break;
        case 71:
        case 79:
          this.$ = L[it - 4], I.setLink(L[it - 3], L[it - 2], L[it]), I.setTooltip(L[it - 3], L[it - 1]);
          break;
        case 74:
          this.$ = L[it - 3], I.setClickEvent(L[it - 2], L[it - 1], L[it]);
          break;
        case 75:
          this.$ = L[it - 4], I.setClickEvent(L[it - 3], L[it - 2], L[it - 1]), I.setTooltip(L[it - 3], L[it]);
          break;
        case 77:
          this.$ = L[it - 3], I.setLink(L[it - 2], L[it - 1], L[it]);
          break;
        case 80:
          I.setCssClass(L[it - 1], L[it]);
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: t, 6: 4, 7: 5, 8: n, 9: r, 10: i, 11: s, 12: 6, 13: 11, 19: o, 23: a }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 3: 14, 4: 2, 5: t, 6: 4, 7: 5, 8: n, 9: r, 10: i, 11: s, 12: 6, 13: 11, 19: o, 23: a }, { 1: [2, 9] }, e(l, [2, 5]), e(l, [2, 6]), e(l, [2, 7]), e(l, [2, 8]), { 14: 15, 20: [1, 16] }, { 16: [1, 17] }, { 20: [2, 12] }, { 1: [2, 4] }, { 15: 18, 17: [1, 19], 22: h }, e([17, 22], [2, 13]), { 6: 31, 7: 30, 8: n, 9: r, 10: i, 11: s, 13: 11, 19: o, 24: 21, 26: 22, 27: 35, 28: 46, 29: 47, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: 29, 39: u, 41: f, 43: d, 44: p, 49: g, 51: m, 52: y, 55: O, 57: x, 67: _, 68: w, 70: E, 74: T, 88: S, 89: R, 90: A, 91: P }, { 16: [1, 52] }, { 18: 53, 21: [1, 54] }, { 16: [2, 15] }, { 25: [1, 55] }, { 16: [1, 56], 25: [2, 17] }, e(C, [2, 25], { 32: [1, 57] }), e(C, [2, 27]), e(C, [2, 28]), e(C, [2, 29]), e(C, [2, 30]), e(C, [2, 31]), e(C, [2, 32]), e(C, [2, 33]), e(C, [2, 34]), { 40: [1, 58] }, { 42: [1, 59] }, e(C, [2, 37]), e(C, [2, 45], { 53: 60, 58: 63, 59: 64, 32: [1, 62], 54: [1, 61], 60: k, 61: D, 62: b, 63: M, 64: v, 65: N, 66: tt }), { 27: 72, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, e(C, [2, 47]), e(C, [2, 48]), { 28: 73, 88: S, 89: R, 90: A }, { 27: 74, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, { 27: 75, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, { 27: 76, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, { 54: [1, 77] }, { 27: 78, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, { 54: Z, 56: 79 }, e(z, [2, 20], { 28: 46, 29: 47, 27: 81, 30: [1, 82], 88: S, 89: R, 90: A, 91: P }), e(z, [2, 21], { 30: [1, 83] }), e(X, [2, 94]), e(X, [2, 95]), e(X, [2, 96]), e([16, 25, 30, 32, 45, 46, 54, 60, 61, 62, 63, 64, 65, 66, 71, 73], [2, 97]), e(q, [2, 10]), { 15: 84, 22: h }, { 22: [2, 14] }, { 1: [2, 16] }, { 6: 31, 7: 30, 8: n, 9: r, 10: i, 11: s, 13: 11, 19: o, 24: 85, 25: [2, 18], 26: 22, 27: 35, 28: 46, 29: 47, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: 29, 39: u, 41: f, 43: d, 44: p, 49: g, 51: m, 52: y, 55: O, 57: x, 67: _, 68: w, 70: E, 74: T, 88: S, 89: R, 90: A, 91: P }, e(C, [2, 26]), e(C, [2, 35]), e(C, [2, 36]), { 27: 86, 28: 46, 29: 47, 54: [1, 87], 88: S, 89: R, 90: A, 91: P }, { 53: 88, 58: 63, 59: 64, 60: k, 61: D, 62: b, 63: M, 64: v, 65: N, 66: tt }, e(C, [2, 46]), { 59: 89, 65: N, 66: tt }, e(nt, [2, 58], { 58: 90, 60: k, 61: D, 62: b, 63: M, 64: v }), e(st, [2, 59]), e(st, [2, 60]), e(st, [2, 61]), e(st, [2, 62]), e(st, [2, 63]), e(ct, [2, 64]), e(ct, [2, 65]), e(C, [2, 38], { 45: [1, 91], 46: [1, 92] }), { 50: [1, 93] }, { 54: [1, 94] }, { 54: [1, 95] }, { 71: [1, 96], 73: [1, 97] }, { 28: 98, 88: S, 89: R, 90: A }, { 54: Z, 56: 99 }, e(C, [2, 54]), e(C, [2, 98]), e(z, [2, 22]), e(z, [2, 23]), e(z, [2, 24]), { 16: [1, 100] }, { 25: [2, 19] }, e(Y, [2, 49]), { 27: 101, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, { 27: 102, 28: 46, 29: 47, 54: [1, 103], 88: S, 89: R, 90: A, 91: P }, e(nt, [2, 57], { 58: 104, 60: k, 61: D, 62: b, 63: M, 64: v }), e(nt, [2, 56]), { 28: 105, 88: S, 89: R, 90: A }, { 47: 106, 51: Ct }, { 27: 108, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, e(C, [2, 66], { 54: [1, 109] }), e(C, [2, 68], { 54: [1, 111], 69: [1, 110] }), e(C, [2, 72], { 54: [1, 112], 72: [1, 113] }), e(C, [2, 76], { 54: [1, 115], 69: [1, 114] }), e(C, [2, 80]), e(C, [2, 53]), e(q, [2, 11]), e(Y, [2, 51]), e(Y, [2, 50]), { 27: 116, 28: 46, 29: 47, 88: S, 89: R, 90: A, 91: P }, e(nt, [2, 55]), e(C, [2, 39], { 46: [1, 117] }), { 48: [1, 118] }, { 47: 119, 48: [2, 43], 51: Ct }, e(C, [2, 42]), e(C, [2, 67]), e(C, [2, 69]), e(C, [2, 70], { 69: [1, 120] }), e(C, [2, 73]), e(C, [2, 74], { 54: [1, 121] }), e(C, [2, 77]), e(C, [2, 78], { 69: [1, 122] }), e(Y, [2, 52]), { 47: 123, 51: Ct }, e(C, [2, 40]), { 48: [2, 44] }, e(C, [2, 71]), e(C, [2, 75]), e(C, [2, 79]), { 48: [1, 124] }, e(C, [2, 41])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 6: [2, 9], 13: [2, 12], 14: [2, 4], 20: [2, 15], 54: [2, 14], 55: [2, 16], 85: [2, 19], 119: [2, 44] },
    parseError: function($, F) {
      if (F.recoverable)
        this.trace($);
      else {
        var G = new Error($);
        throw G.hash = F, G;
      }
    },
    parse: function($) {
      var F = this, G = [0], I = [], ht = [null], L = [], $t = this.table, it = "", At = 0, St = 0, bt = 2, gt = 1, yt = L.slice.call(arguments, 1), dt = Object.create(this.lexer), xt = { yy: {} };
      for (var Re in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Re) && (xt.yy[Re] = this.yy[Re]);
      dt.setInput($, xt.yy), xt.yy.lexer = dt, xt.yy.parser = this, typeof dt.yylloc > "u" && (dt.yylloc = {});
      var ye = dt.yylloc;
      L.push(ye);
      var zt = dt.options && dt.options.ranges;
      typeof xt.yy.parseError == "function" ? this.parseError = xt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Yt() {
        var lt;
        return lt = I.pop() || dt.lex() || gt, typeof lt != "number" && (lt instanceof Array && (I = lt, lt = I.pop()), lt = F.symbols_[lt] || lt), lt;
      }
      for (var ce, Ie, re, Qt, Lt = {}, kt, _t, Et, pt; ; ) {
        if (Ie = G[G.length - 1], this.defaultActions[Ie] ? re = this.defaultActions[Ie] : ((ce === null || typeof ce > "u") && (ce = Yt()), re = $t[Ie] && $t[Ie][ce]), typeof re > "u" || !re.length || !re[0]) {
          var Zt = "";
          pt = [];
          for (kt in $t[Ie])
            this.terminals_[kt] && kt > bt && pt.push("'" + this.terminals_[kt] + "'");
          dt.showPosition ? Zt = "Parse error on line " + (At + 1) + `:
` + dt.showPosition() + `
Expecting ` + pt.join(", ") + ", got '" + (this.terminals_[ce] || ce) + "'" : Zt = "Parse error on line " + (At + 1) + ": Unexpected " + (ce == gt ? "end of input" : "'" + (this.terminals_[ce] || ce) + "'"), this.parseError(Zt, {
            text: dt.match,
            token: this.terminals_[ce] || ce,
            line: dt.yylineno,
            loc: ye,
            expected: pt
          });
        }
        if (re[0] instanceof Array && re.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ie + ", token: " + ce);
        switch (re[0]) {
          case 1:
            G.push(ce), ht.push(dt.yytext), L.push(dt.yylloc), G.push(re[1]), ce = null, St = dt.yyleng, it = dt.yytext, At = dt.yylineno, ye = dt.yylloc;
            break;
          case 2:
            if (_t = this.productions_[re[1]][1], Lt.$ = ht[ht.length - _t], Lt._$ = {
              first_line: L[L.length - (_t || 1)].first_line,
              last_line: L[L.length - 1].last_line,
              first_column: L[L.length - (_t || 1)].first_column,
              last_column: L[L.length - 1].last_column
            }, zt && (Lt._$.range = [
              L[L.length - (_t || 1)].range[0],
              L[L.length - 1].range[1]
            ]), Qt = this.performAction.apply(Lt, [
              it,
              St,
              At,
              xt.yy,
              re[1],
              ht,
              L
            ].concat(yt)), typeof Qt < "u")
              return Qt;
            _t && (G = G.slice(0, -1 * _t * 2), ht = ht.slice(0, -1 * _t), L = L.slice(0, -1 * _t)), G.push(this.productions_[re[1]][0]), ht.push(Lt.$), L.push(Lt._$), Et = $t[G[G.length - 2]][G[G.length - 1]], G.push(Et);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, et = function() {
    var W = {
      EOF: 1,
      parseError: function(F, G) {
        if (this.yy.parser)
          this.yy.parser.parseError(F, G);
        else
          throw new Error(F);
      },
      setInput: function($, F) {
        return this.yy = F || this.yy || {}, this._input = $, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var $ = this._input[0];
        this.yytext += $, this.yyleng++, this.offset++, this.match += $, this.matched += $;
        var F = $.match(/(?:\r\n?|\n).*/g);
        return F ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), $;
      },
      unput: function($) {
        var F = $.length, G = $.split(/(?:\r\n?|\n)/g);
        this._input = $ + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - F), this.offset -= F;
        var I = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), G.length - 1 && (this.yylineno -= G.length - 1);
        var ht = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: G ? (G.length === I.length ? this.yylloc.first_column : 0) + I[I.length - G.length].length - G[0].length : this.yylloc.first_column - F
        }, this.options.ranges && (this.yylloc.range = [ht[0], ht[0] + this.yyleng - F]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function($) {
        this.unput(this.match.slice($));
      },
      pastInput: function() {
        var $ = this.matched.substr(0, this.matched.length - this.match.length);
        return ($.length > 20 ? "..." : "") + $.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var $ = this.match;
        return $.length < 20 && ($ += this._input.substr(0, 20 - $.length)), ($.substr(0, 20) + ($.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var $ = this.pastInput(), F = new Array($.length + 1).join("-");
        return $ + this.upcomingInput() + `
` + F + "^";
      },
      test_match: function($, F) {
        var G, I, ht;
        if (this.options.backtrack_lexer && (ht = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (ht.yylloc.range = this.yylloc.range.slice(0))), I = $[0].match(/(?:\r\n?|\n).*/g), I && (this.yylineno += I.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: I ? I[I.length - 1].length - I[I.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + $[0].length
        }, this.yytext += $[0], this.match += $[0], this.matches = $, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice($[0].length), this.matched += $[0], G = this.performAction.call(this, this.yy, this, F, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), G)
          return G;
        if (this._backtrack) {
          for (var L in ht)
            this[L] = ht[L];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var $, F, G, I;
        this._more || (this.yytext = "", this.match = "");
        for (var ht = this._currentRules(), L = 0; L < ht.length; L++)
          if (G = this._input.match(this.rules[ht[L]]), G && (!F || G[0].length > F[0].length)) {
            if (F = G, I = L, this.options.backtrack_lexer) {
              if ($ = this.test_match(G, ht[L]), $ !== !1)
                return $;
              if (this._backtrack) {
                F = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return F ? ($ = this.test_match(F, ht[I]), $ !== !1 ? $ : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var F = this.next();
        return F || this.lex();
      },
      begin: function(F) {
        this.conditionStack.push(F);
      },
      popState: function() {
        var F = this.conditionStack.length - 1;
        return F > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(F) {
        return F = this.conditionStack.length - 1 - Math.abs(F || 0), F >= 0 ? this.conditionStack[F] : "INITIAL";
      },
      pushState: function(F) {
        this.begin(F);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function(F, G, I, ht) {
        switch (I) {
          case 0:
            return this.begin("open_directive"), 19;
          case 1:
            return 8;
          case 2:
            return 9;
          case 3:
            return 10;
          case 4:
            return 11;
          case 5:
            return this.begin("type_directive"), 20;
          case 6:
            return this.popState(), this.begin("arg_directive"), 17;
          case 7:
            return this.popState(), this.popState(), 22;
          case 8:
            return 21;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return this.begin("acc_title"), 39;
          case 12:
            return this.popState(), "acc_title_value";
          case 13:
            return this.begin("acc_descr"), 41;
          case 14:
            return this.popState(), "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            return 16;
          case 19:
            break;
          case 20:
            return 23;
          case 21:
            return 23;
          case 22:
            return this.begin("struct"), 46;
          case 23:
            return "EDGE_STATE";
          case 24:
            return "EOF_IN_STRUCT";
          case 25:
            return "OPEN_IN_STRUCT";
          case 26:
            return this.popState(), 48;
          case 27:
            break;
          case 28:
            return "MEMBER";
          case 29:
            return 44;
          case 30:
            return 74;
          case 31:
            return 67;
          case 32:
            return 68;
          case 33:
            return 70;
          case 34:
            return 55;
          case 35:
            return 57;
          case 36:
            return 49;
          case 37:
            return 50;
          case 38:
            this.begin("generic");
            break;
          case 39:
            this.popState();
            break;
          case 40:
            return "GENERICTYPE";
          case 41:
            this.begin("string");
            break;
          case 42:
            this.popState();
            break;
          case 43:
            return "STR";
          case 44:
            this.begin("bqstring");
            break;
          case 45:
            this.popState();
            break;
          case 46:
            return "BQUOTE_STR";
          case 47:
            this.begin("href");
            break;
          case 48:
            this.popState();
            break;
          case 49:
            return 73;
          case 50:
            this.begin("callback_name");
            break;
          case 51:
            this.popState();
            break;
          case 52:
            this.popState(), this.begin("callback_args");
            break;
          case 53:
            return 71;
          case 54:
            this.popState();
            break;
          case 55:
            return 72;
          case 56:
            return 69;
          case 57:
            return 69;
          case 58:
            return 69;
          case 59:
            return 69;
          case 60:
            return 61;
          case 61:
            return 61;
          case 62:
            return 63;
          case 63:
            return 63;
          case 64:
            return 62;
          case 65:
            return 60;
          case 66:
            return 64;
          case 67:
            return 65;
          case 68:
            return 66;
          case 69:
            return 32;
          case 70:
            return 45;
          case 71:
            return 86;
          case 72:
            return "DOT";
          case 73:
            return "PLUS";
          case 74:
            return 83;
          case 75:
            return "EQUALS";
          case 76:
            return "EQUALS";
          case 77:
            return 90;
          case 78:
            return "PUNCTUATION";
          case 79:
            return 89;
          case 80:
            return 88;
          case 81:
            return 85;
          case 82:
            return 25;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:[{])/, /^(?:\[\*\])/, /^(?:$)/, /^(?:[{])/, /^(?:[}])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:class\b)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:note for\b)/, /^(?:note\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:[~])/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[`])/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:$)/],
      conditions: { acc_descr_multiline: { rules: [16, 17], inclusive: !1 }, acc_descr: { rules: [14], inclusive: !1 }, acc_title: { rules: [12], inclusive: !1 }, arg_directive: { rules: [7, 8], inclusive: !1 }, type_directive: { rules: [6, 7], inclusive: !1 }, open_directive: { rules: [5], inclusive: !1 }, callback_args: { rules: [54, 55], inclusive: !1 }, callback_name: { rules: [51, 52, 53], inclusive: !1 }, href: { rules: [48, 49], inclusive: !1 }, struct: { rules: [23, 24, 25, 26, 27, 28], inclusive: !1 }, generic: { rules: [39, 40], inclusive: !1 }, bqstring: { rules: [45, 46], inclusive: !1 }, string: { rules: [42, 43], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 41, 44, 47, 50, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82], inclusive: !0 } }
    };
    return W;
  }();
  H.lexer = et;
  function U() {
    this.yy = {};
  }
  return U.prototype = H, H.Parser = U, new U();
}();
pk.parser = pk;
const D8 = pk, _le = (e, t) => {
  var n;
  return ((n = t == null ? void 0 : t.class) == null ? void 0 : n.defaultRenderer) === "dagre-wrapper" ? !1 : e.match(/^\s*classDiagram/) !== null;
}, kle = (e, t) => {
  var n;
  return e.match(/^\s*classDiagram/) !== null && ((n = t == null ? void 0 : t.class) == null ? void 0 : n.defaultRenderer) === "dagre-wrapper" ? !0 : e.match(/^\s*classDiagram-v2/) !== null;
}, I5 = "classid-";
let N5 = [], Pn = {}, h2 = [], L8 = 0, _p = [];
const sd = (e) => de.sanitizeText(e, J()), wle = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, kp = function(e) {
  let t = "", n = e;
  if (e.indexOf("~") > 0) {
    let r = e.split("~");
    n = r[0], t = de.sanitizeText(r[1], J());
  }
  return { className: n, type: t };
}, gk = function(e) {
  let t = kp(e);
  Pn[t.className] === void 0 && (Pn[t.className] = {
    id: t.className,
    type: t.type,
    cssClasses: [],
    methods: [],
    members: [],
    annotations: [],
    domId: I5 + t.className + "-" + L8
  }, L8++);
}, oQ = function(e) {
  const t = Object.keys(Pn);
  for (const n of t)
    if (Pn[n].id === e)
      return Pn[n].domId;
}, Sle = function() {
  N5 = [], Pn = {}, h2 = [], _p = [], _p.push(lQ), _i();
}, Cle = function(e) {
  return Pn[e];
}, Tle = function() {
  return Pn;
}, Ele = function() {
  return N5;
}, Ale = function() {
  return h2;
}, Ple = function(e) {
  B.debug("Adding relation: " + JSON.stringify(e)), gk(e.id1), gk(e.id2), e.id1 = kp(e.id1).className, e.id2 = kp(e.id2).className, e.relationTitle1 = de.sanitizeText(
    e.relationTitle1.trim(),
    J()
  ), e.relationTitle2 = de.sanitizeText(
    e.relationTitle2.trim(),
    J()
  ), N5.push(e);
}, Dle = function(e, t) {
  const n = kp(e).className;
  Pn[n].annotations.push(t);
}, aQ = function(e, t) {
  const n = kp(e).className, r = Pn[n];
  if (typeof t == "string") {
    const i = t.trim();
    i.startsWith("<<") && i.endsWith(">>") ? r.annotations.push(sd(i.substring(2, i.length - 2))) : i.indexOf(")") > 0 ? r.methods.push(sd(i)) : i && r.members.push(sd(i));
  }
}, Lle = function(e, t) {
  Array.isArray(t) && (t.reverse(), t.forEach((n) => aQ(e, n)));
}, Mle = function(e, t) {
  const n = {
    id: `note${h2.length}`,
    class: t,
    text: e
  };
  h2.push(n);
}, Rle = function(e) {
  return e.substring(0, 1) === ":" ? de.sanitizeText(e.substr(1).trim(), J()) : sd(e.trim());
}, B5 = function(e, t) {
  e.split(",").forEach(function(n) {
    let r = n;
    n[0].match(/\d/) && (r = I5 + r), Pn[r] !== void 0 && Pn[r].cssClasses.push(t);
  });
}, $le = function(e, t) {
  const n = J();
  e.split(",").forEach(function(r) {
    t !== void 0 && (Pn[r].tooltip = de.sanitizeText(t, n));
  });
}, Ile = function(e) {
  return Pn[e].tooltip;
}, Nle = function(e, t, n) {
  const r = J();
  e.split(",").forEach(function(i) {
    let s = i;
    i[0].match(/\d/) && (s = I5 + s), Pn[s] !== void 0 && (Pn[s].link = fe.formatUrl(t, r), r.securityLevel === "sandbox" ? Pn[s].linkTarget = "_top" : typeof n == "string" ? Pn[s].linkTarget = sd(n) : Pn[s].linkTarget = "_blank");
  }), B5(e, "clickable");
}, Ble = function(e, t, n) {
  e.split(",").forEach(function(r) {
    Fle(r, t, n), Pn[r].haveCallback = !0;
  }), B5(e, "clickable");
}, Fle = function(e, t, n) {
  const r = J();
  let i = e, s = oQ(i);
  if (r.securityLevel === "loose" && t !== void 0 && Pn[i] !== void 0) {
    let o = [];
    if (typeof n == "string") {
      o = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let a = 0; a < o.length; a++) {
        let l = o[a].trim();
        l.charAt(0) === '"' && l.charAt(l.length - 1) === '"' && (l = l.substr(1, l.length - 2)), o[a] = l;
      }
    }
    o.length === 0 && o.push(s), _p.push(function() {
      const a = document.querySelector(`[id="${s}"]`);
      a !== null && a.addEventListener(
        "click",
        function() {
          fe.runFunc(t, ...o);
        },
        !1
      );
    });
  }
}, Qle = function(e) {
  _p.forEach(function(t) {
    t(e);
  });
}, Zle = {
  LINE: 0,
  DOTTED_LINE: 1
}, Vle = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3,
  LOLLIPOP: 4
}, lQ = function(e) {
  let t = wt(".mermaidTooltip");
  (t._groups || t)[0][0] === null && (t = wt("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), wt(e).select("svg").selectAll("g.node").on("mouseover", function() {
    const i = wt(this);
    if (i.attr("title") === null)
      return;
    const o = this.getBoundingClientRect();
    t.transition().duration(200).style("opacity", ".9"), t.text(i.attr("title")).style("left", window.scrollX + o.left + (o.right - o.left) / 2 + "px").style("top", window.scrollY + o.top - 14 + document.body.scrollTop + "px"), t.html(t.html().replace(/&lt;br\/&gt;/g, "<br/>")), i.classed("hover", !0);
  }).on("mouseout", function() {
    t.transition().duration(500).style("opacity", 0), wt(this).classed("hover", !1);
  });
};
_p.push(lQ);
let cQ = "TB";
const Yle = () => cQ, zle = (e) => {
  cQ = e;
}, ch = {
  parseDirective: wle,
  setAccTitle: oi,
  getAccTitle: ki,
  getAccDescription: Si,
  setAccDescription: wi,
  getConfig: () => J().class,
  addClass: gk,
  bindFunctions: Qle,
  clear: Sle,
  getClass: Cle,
  getClasses: Tle,
  getNotes: Ale,
  addAnnotation: Dle,
  addNote: Mle,
  getRelations: Ele,
  addRelation: Ple,
  getDirection: Yle,
  setDirection: zle,
  addMember: aQ,
  addMembers: Lle,
  cleanupLabel: Rle,
  lineType: Zle,
  relationType: Vle,
  setClickEvent: Ble,
  setCssClass: B5,
  setLink: Nle,
  getTooltip: Ile,
  setTooltip: $le,
  lookUpDomId: oQ,
  setDiagramTitle: Is,
  getDiagramTitle: Ns
};
let M8 = 0;
const qle = function(e, t, n, r, i) {
  const s = function(x) {
    switch (x) {
      case i.db.relationType.AGGREGATION:
        return "aggregation";
      case i.db.relationType.EXTENSION:
        return "extension";
      case i.db.relationType.COMPOSITION:
        return "composition";
      case i.db.relationType.DEPENDENCY:
        return "dependency";
      case i.db.relationType.LOLLIPOP:
        return "lollipop";
    }
  };
  t.points = t.points.filter((x) => !Number.isNaN(x.y));
  const o = t.points, a = Qu().x(function(x) {
    return x.x;
  }).y(function(x) {
    return x.y;
  }).curve(lu), l = e.append("path").attr("d", a(o)).attr("id", "edge" + M8).attr("class", "relation");
  let h = "";
  r.arrowMarkerAbsolute && (h = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, h = h.replace(/\(/g, "\\("), h = h.replace(/\)/g, "\\)")), n.relation.lineType == 1 && l.attr("class", "relation dashed-line"), n.relation.lineType == 10 && l.attr("class", "relation dotted-line"), n.relation.type1 !== "none" && l.attr(
    "marker-start",
    "url(" + h + "#" + s(n.relation.type1) + "Start)"
  ), n.relation.type2 !== "none" && l.attr(
    "marker-end",
    "url(" + h + "#" + s(n.relation.type2) + "End)"
  );
  let u, f;
  const d = t.points.length;
  let p = fe.calcLabelPosition(t.points);
  u = p.x, f = p.y;
  let g, m, y, O;
  if (d % 2 !== 0 && d > 1) {
    let x = fe.calcCardinalityPosition(
      n.relation.type1 !== "none",
      t.points,
      t.points[0]
    ), _ = fe.calcCardinalityPosition(
      n.relation.type2 !== "none",
      t.points,
      t.points[d - 1]
    );
    B.debug("cardinality_1_point " + JSON.stringify(x)), B.debug("cardinality_2_point " + JSON.stringify(_)), g = x.x, m = x.y, y = _.x, O = _.y;
  }
  if (n.title !== void 0) {
    const x = e.append("g").attr("class", "classLabel"), _ = x.append("text").attr("class", "label").attr("x", u).attr("y", f).attr("fill", "red").attr("text-anchor", "middle").text(n.title);
    window.label = _;
    const w = _.node().getBBox();
    x.insert("rect", ":first-child").attr("class", "box").attr("x", w.x - r.padding / 2).attr("y", w.y - r.padding / 2).attr("width", w.width + r.padding).attr("height", w.height + r.padding);
  }
  B.info("Rendering relation " + JSON.stringify(n)), n.relationTitle1 !== void 0 && n.relationTitle1 !== "none" && e.append("g").attr("class", "cardinality").append("text").attr("class", "type1").attr("x", g).attr("y", m).attr("fill", "black").attr("font-size", "6").text(n.relationTitle1), n.relationTitle2 !== void 0 && n.relationTitle2 !== "none" && e.append("g").attr("class", "cardinality").append("text").attr("class", "type2").attr("x", y).attr("y", O).attr("fill", "black").attr("font-size", "6").text(n.relationTitle2), M8++;
}, Wle = function(e, t, n, r) {
  B.debug("Rendering class ", t, n);
  const i = t.id, s = {
    id: i,
    label: t.id,
    width: 0,
    height: 0
  }, o = e.append("g").attr("id", r.db.lookUpDomId(i)).attr("class", "classGroup");
  let a;
  t.link ? a = o.append("svg:a").attr("xlink:href", t.link).attr("target", t.linkTarget).append("text").attr("y", n.textHeight + n.padding).attr("x", 0) : a = o.append("text").attr("y", n.textHeight + n.padding).attr("x", 0);
  let l = !0;
  t.annotations.forEach(function(E) {
    const T = a.append("tspan").text("\xAB" + E + "\xBB");
    l || T.attr("dy", n.textHeight), l = !1;
  });
  let h = t.id;
  t.type !== void 0 && t.type !== "" && (h += "<" + t.type + ">");
  const u = a.append("tspan").text(h).attr("class", "title");
  l || u.attr("dy", n.textHeight);
  const f = a.node().getBBox().height, d = o.append("line").attr("x1", 0).attr("y1", n.padding + f + n.dividerMargin / 2).attr("y2", n.padding + f + n.dividerMargin / 2), p = o.append("text").attr("x", n.padding).attr("y", f + n.dividerMargin + n.textHeight).attr("fill", "white").attr("class", "classText");
  l = !0, t.members.forEach(function(E) {
    R8(p, E, l, n), l = !1;
  });
  const g = p.node().getBBox(), m = o.append("line").attr("x1", 0).attr("y1", n.padding + f + n.dividerMargin + g.height).attr("y2", n.padding + f + n.dividerMargin + g.height), y = o.append("text").attr("x", n.padding).attr("y", f + 2 * n.dividerMargin + g.height + n.textHeight).attr("fill", "white").attr("class", "classText");
  l = !0, t.methods.forEach(function(E) {
    R8(y, E, l, n), l = !1;
  });
  const O = o.node().getBBox();
  var x = " ";
  t.cssClasses.length > 0 && (x = x + t.cssClasses.join(" "));
  const w = o.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", O.width + 2 * n.padding).attr("height", O.height + n.padding + 0.5 * n.dividerMargin).attr("class", x).node().getBBox().width;
  return a.node().childNodes.forEach(function(E) {
    E.setAttribute("x", (w - E.getBBox().width) / 2);
  }), t.tooltip && a.insert("title").text(t.tooltip), d.attr("x2", w), m.attr("x2", w), s.width = w, s.height = O.height + n.padding + 0.5 * n.dividerMargin, s;
}, Ule = function(e, t, n, r) {
  B.debug("Rendering note ", t, n);
  const i = t.id, s = {
    id: i,
    text: t.text,
    width: 0,
    height: 0
  }, o = e.append("g").attr("id", i).attr("class", "classGroup");
  let a = o.append("text").attr("y", n.textHeight + n.padding).attr("x", 0);
  const l = JSON.parse(`"${t.text}"`).split(`
`);
  l.forEach(function(d) {
    B.debug(`Adding line: ${d}`), a.append("tspan").text(d).attr("class", "title").attr("dy", n.textHeight);
  });
  const h = o.node().getBBox(), f = o.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", h.width + 2 * n.padding).attr(
    "height",
    h.height + l.length * n.textHeight + n.padding + 0.5 * n.dividerMargin
  ).node().getBBox().width;
  return a.node().childNodes.forEach(function(d) {
    d.setAttribute("x", (f - d.getBBox().width) / 2);
  }), s.width = f, s.height = h.height + l.length * n.textHeight + n.padding + 0.5 * n.dividerMargin, s;
}, u2 = function(e) {
  const t = /^([#+~-])?(\w+)(~\w+~|\[])?\s+(\w+) *([$*])?$/, n = /^([#+|~-])?(\w+) *\( *(.*)\) *([$*])? *(\w*[[\]|~]*\s*\w*~?)$/;
  let r = e.match(t), i = e.match(n);
  return r && !i ? jle(r) : i ? Xle(i) : Gle(e);
}, jle = function(e) {
  let t = "", n = "";
  try {
    let r = e[1] ? e[1].trim() : "", i = e[2] ? e[2].trim() : "", s = e[3] ? Ua(e[3].trim()) : "", o = e[4] ? e[4].trim() : "", a = e[5] ? e[5].trim() : "";
    n = r + i + s + " " + o, t = F5(a);
  } catch {
    n = e;
  }
  return {
    displayText: n,
    cssStyle: t
  };
}, Xle = function(e) {
  let t = "", n = "";
  try {
    let r = e[1] ? e[1].trim() : "", i = e[2] ? e[2].trim() : "", s = e[3] ? Ua(e[3].trim()) : "", o = e[4] ? e[4].trim() : "", a = e[5] ? " : " + Ua(e[5]).trim() : "";
    n = r + i + "(" + s + ")" + a, t = F5(o);
  } catch {
    n = e;
  }
  return {
    displayText: n,
    cssStyle: t
  };
}, Gle = function(e) {
  let t = "", n = "", r = "", i = e.indexOf("("), s = e.indexOf(")");
  if (i > 1 && s > i && s <= e.length) {
    let o = "", a = "", l = e.substring(0, 1);
    l.match(/\w/) ? a = e.substring(0, i).trim() : (l.match(/[#+~-]/) && (o = l), a = e.substring(1, i).trim());
    const h = e.substring(i + 1, s);
    e.substring(s + 1, 1), n = F5(e.substring(s + 1, s + 2)), t = o + a + "(" + Ua(h.trim()) + ")", s < e.length && (r = e.substring(s + 2).trim(), r !== "" && (r = " : " + Ua(r), t += r));
  } else
    t = Ua(e);
  return {
    displayText: t,
    cssStyle: n
  };
}, R8 = function(e, t, n, r) {
  let i = u2(t);
  const s = e.append("tspan").attr("x", r.padding).text(i.displayText);
  i.cssStyle !== "" && s.attr("style", i.cssStyle), n || s.attr("dy", r.textHeight);
}, F5 = function(e) {
  switch (e) {
    case "*":
      return "font-style:italic;";
    case "$":
      return "text-decoration:underline;";
    default:
      return "";
  }
}, bx = {
  drawClass: Wle,
  drawEdge: qle,
  drawNote: Ule,
  parseMember: u2
};
let gg = {};
const b1 = 20, yf = function(e) {
  const t = Object.entries(gg).find((n) => n[1].label === e);
  if (t)
    return t[0];
}, Hle = function(e) {
  e.append("defs").append("marker").attr("id", "extensionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", "extensionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z"), e.append("defs").append("marker").attr("id", "compositionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", "compositionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", "aggregationStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", "aggregationEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", "dependencyStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, Kle = function(e, t, n, r) {
  const i = J().class;
  gg = {}, B.info("Rendering diagram " + e);
  const s = J().securityLevel;
  let o;
  s === "sandbox" && (o = wt("#i" + t));
  const a = wt(s === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), l = a.select(`[id='${t}']`);
  Hle(l);
  const h = new zn({
    multigraph: !0
  });
  h.setGraph({
    isMultiGraph: !0
  }), h.setDefaultEdgeLabel(function() {
    return {};
  });
  const u = r.db.getClasses(), f = Object.keys(u);
  for (const x of f) {
    const _ = u[x], w = bx.drawClass(l, _, i, r);
    gg[w.id] = w, h.setNode(w.id, w), B.info("Org height: " + w.height);
  }
  r.db.getRelations().forEach(function(x) {
    B.info(
      "tjoho" + yf(x.id1) + yf(x.id2) + JSON.stringify(x)
    ), h.setEdge(
      yf(x.id1),
      yf(x.id2),
      {
        relation: x
      },
      x.title || "DEFAULT"
    );
  }), r.db.getNotes().forEach(function(x) {
    B.debug(`Adding note: ${JSON.stringify(x)}`);
    const _ = bx.drawNote(l, x, i, r);
    gg[_.id] = _, h.setNode(_.id, _), x.class && x.class in u && h.setEdge(
      x.id,
      yf(x.class),
      {
        relation: {
          id1: x.id,
          id2: x.class,
          relation: {
            type1: "none",
            type2: "none",
            lineType: 10
          }
        }
      },
      "DEFAULT"
    );
  }), Wu(h), h.nodes().forEach(function(x) {
    x !== void 0 && h.node(x) !== void 0 && (B.debug("Node " + x + ": " + JSON.stringify(h.node(x))), a.select("#" + (r.db.lookUpDomId(x) || x)).attr(
      "transform",
      "translate(" + (h.node(x).x - h.node(x).width / 2) + "," + (h.node(x).y - h.node(x).height / 2) + " )"
    ));
  }), h.edges().forEach(function(x) {
    x !== void 0 && h.edge(x) !== void 0 && (B.debug("Edge " + x.v + " -> " + x.w + ": " + JSON.stringify(h.edge(x))), bx.drawEdge(l, h.edge(x), h.edge(x).relation, i, r));
  });
  const g = l.node().getBBox(), m = g.width + b1 * 2, y = g.height + b1 * 2;
  $s(l, y, m, i.useMaxWidth);
  const O = `${g.x - b1} ${g.y - b1} ${m} ${y}`;
  B.debug(`viewBox ${O}`), l.attr("viewBox", O);
}, Jle = {
  draw: Kle
}, tce = (e, t, n, r) => {
  t.forEach((i) => {
    hce[i](e, n, r);
  });
}, ece = (e, t, n) => {
  B.trace("Making markers for ", n), e.append("defs").append("marker").attr("id", t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, nce = (e, t) => {
  e.append("defs").append("marker").attr("id", t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, rce = (e, t) => {
  e.append("defs").append("marker").attr("id", t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, ice = (e, t) => {
  e.append("defs").append("marker").attr("id", t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, sce = (e, t) => {
  e.append("defs").append("marker").attr("id", t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "white").attr("cx", 6).attr("cy", 7).attr("r", 6);
}, oce = (e, t) => {
  e.append("marker").attr("id", t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 12 20").attr("refX", 10).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 0).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, ace = (e, t) => {
  e.append("marker").attr("id", t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, lce = (e, t) => {
  e.append("marker").attr("id", t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, cce = (e, t) => {
  e.append("defs").append("marker").attr("id", t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, hce = {
  extension: ece,
  composition: nce,
  aggregation: rce,
  dependency: ice,
  lollipop: sce,
  point: oce,
  circle: ace,
  cross: lce,
  barb: cce
}, uce = tce;
function fce(e, t) {
  t && e.attr("style", t);
}
function dce(e) {
  const t = wt(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), n = t.append("xhtml:div"), r = e.label, i = e.isNode ? "nodeLabel" : "edgeLabel";
  return n.html(
    '<span class="' + i + '" ' + (e.labelStyle ? 'style="' + e.labelStyle + '"' : "") + ">" + r + "</span>"
  ), fce(n, e.labelStyle), n.style("display", "inline-block"), n.style("white-space", "nowrap"), n.attr("xmlns", "http://www.w3.org/1999/xhtml"), t.node();
}
const pce = (e, t, n, r) => {
  let i = e || "";
  if (typeof i == "object" && (i = i[0]), ar(J().flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), B.info("vertexText" + i);
    const s = {
      isNode: r,
      label: uS(i).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (a) => `<i class='${a.replace(":", " ")}'></i>`
      ),
      labelStyle: t.replace("fill:", "color:")
    };
    return dce(s);
  } else {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "text");
    s.setAttribute("style", t.replace("color:", "fill:"));
    let o = [];
    typeof i == "string" ? o = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? o = i : o = [];
    for (const a of o) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), l.setAttribute("dy", "1em"), l.setAttribute("x", "0"), n ? l.setAttribute("class", "title-row") : l.setAttribute("class", "row"), l.textContent = a.trim(), s.appendChild(l);
    }
    return s;
  }
}, Kr = pce, Mr = (e, t, n, r) => {
  let i;
  n ? i = n : i = "node default";
  const s = e.insert("g").attr("class", i).attr("id", t.domId || t.id), o = s.insert("g").attr("class", "label").attr("style", t.labelStyle);
  let a;
  t.labelText === void 0 ? a = "" : a = typeof t.labelText == "string" ? t.labelText : t.labelText[0];
  const l = o.node().appendChild(
    Kr(
      Gi(uS(a), J()),
      t.labelStyle,
      !1,
      r
    )
  );
  let h = l.getBBox();
  if (ar(J().flowchart.htmlLabels)) {
    const f = l.children[0], d = wt(l);
    h = f.getBoundingClientRect(), d.attr("width", h.width), d.attr("height", h.height);
  }
  const u = t.padding / 2;
  return o.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")"), { shapeSvg: s, bbox: h, halfPadding: u, label: o };
}, Mn = (e, t) => {
  const n = t.node().getBBox();
  e.width = n.width, e.height = n.height;
};
function _a(e, t, n, r) {
  return e.insert("polygon", ":first-child").attr(
    "points",
    r.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + n / 2 + ")");
}
let Me = {}, hs = {}, hQ = {};
const gce = () => {
  hs = {}, hQ = {}, Me = {};
}, f2 = (e, t) => (B.trace("In isDecendant", t, " ", e, " = ", hs[t].includes(e)), !!hs[t].includes(e)), mce = (e, t) => (B.info("Decendants of ", t, " is ", hs[t]), B.info("Edge is ", e), e.v === t || e.w === t ? !1 : hs[t] ? hs[t].includes(e.v) || f2(e.v, t) || f2(e.w, t) || hs[t].includes(e.w) : (B.debug("Tilt, ", t, ",not in decendants"), !1)), uQ = (e, t, n, r) => {
  B.warn(
    "Copying children of ",
    e,
    "root",
    r,
    "data",
    t.node(e),
    r
  );
  const i = t.children(e) || [];
  e !== r && i.push(e), B.warn("Copying (nodes) clusterId", e, "nodes", i), i.forEach((s) => {
    if (t.children(s).length > 0)
      uQ(s, t, n, r);
    else {
      const o = t.node(s);
      B.info("cp ", s, " to ", r, " with parent ", e), n.setNode(s, o), r !== t.parent(s) && (B.warn("Setting parent", s, t.parent(s)), n.setParent(s, t.parent(s))), e !== r && s !== e ? (B.debug("Setting parent", s, e), n.setParent(s, e)) : (B.info("In copy ", e, "root", r, "data", t.node(e), r), B.debug(
        "Not Setting parent for node=",
        s,
        "cluster!==rootId",
        e !== r,
        "node!==clusterId",
        s !== e
      ));
      const a = t.edges(s);
      B.debug("Copying Edges", a), a.forEach((l) => {
        B.info("Edge", l);
        const h = t.edge(l.v, l.w, l.name);
        B.info("Edge data", h, r);
        try {
          mce(l, r) ? (B.info("Copying as ", l.v, l.w, h, l.name), n.setEdge(l.v, l.w, h, l.name), B.info("newGraph edges ", n.edges(), n.edge(n.edges()[0]))) : B.info(
            "Skipping copy of edge ",
            l.v,
            "-->",
            l.w,
            " rootId: ",
            r,
            " clusterId:",
            e
          );
        } catch (u) {
          B.error(u);
        }
      });
    }
    B.debug("Removing node", s), t.removeNode(s);
  });
}, fQ = (e, t) => {
  const n = t.children(e);
  let r = [...n];
  for (const i of n)
    hQ[i] = e, r = [...r, ...fQ(i, t)];
  return r;
}, wp = (e, t) => {
  B.trace("Searching", e);
  const n = t.children(e);
  if (B.trace("Searching children of id ", e, n), n.length < 1)
    return B.trace("This is a valid node", e), e;
  for (const r of n) {
    const i = wp(r, t);
    if (i)
      return B.trace("Found replacement for", e, " => ", i), i;
  }
}, O1 = (e) => !Me[e] || !Me[e].externalConnections ? e : Me[e] ? Me[e].id : e, yce = (e, t) => {
  if (!e || t > 10) {
    B.debug("Opting out, no graph ");
    return;
  } else
    B.debug("Opting in, graph ");
  e.nodes().forEach(function(n) {
    e.children(n).length > 0 && (B.warn(
      "Cluster identified",
      n,
      " Replacement id in edges: ",
      wp(n, e)
    ), hs[n] = fQ(n, e), Me[n] = { id: wp(n, e), clusterData: e.node(n) });
  }), e.nodes().forEach(function(n) {
    const r = e.children(n), i = e.edges();
    r.length > 0 ? (B.debug("Cluster identified", n, hs), i.forEach((s) => {
      if (s.v !== n && s.w !== n) {
        const o = f2(s.v, n), a = f2(s.w, n);
        o ^ a && (B.warn("Edge: ", s, " leaves cluster ", n), B.warn("Decendants of XXX ", n, ": ", hs[n]), Me[n].externalConnections = !0);
      }
    })) : B.debug("Not a cluster ", n, hs);
  }), e.edges().forEach(function(n) {
    const r = e.edge(n);
    B.warn("Edge " + n.v + " -> " + n.w + ": " + JSON.stringify(n)), B.warn("Edge " + n.v + " -> " + n.w + ": " + JSON.stringify(e.edge(n)));
    let i = n.v, s = n.w;
    if (B.warn(
      "Fix XXX",
      Me,
      "ids:",
      n.v,
      n.w,
      "Translating: ",
      Me[n.v],
      " --- ",
      Me[n.w]
    ), Me[n.v] && Me[n.w] && Me[n.v] === Me[n.w]) {
      B.warn("Fixing and trixing link to self - removing XXX", n.v, n.w, n.name), B.warn("Fixing and trixing - removing XXX", n.v, n.w, n.name), i = O1(n.v), s = O1(n.w), e.removeEdge(n.v, n.w, n.name);
      const o = n.w + "---" + n.v;
      e.setNode(o, {
        domId: o,
        id: o,
        labelStyle: "",
        labelText: r.label,
        padding: 0,
        shape: "labelRect",
        style: ""
      });
      const a = JSON.parse(JSON.stringify(r)), l = JSON.parse(JSON.stringify(r));
      a.label = "", a.arrowTypeEnd = "none", l.label = "", a.fromCluster = n.v, l.toCluster = n.v, e.setEdge(i, o, a, n.name + "-cyclic-special"), e.setEdge(o, s, l, n.name + "-cyclic-special");
    } else
      (Me[n.v] || Me[n.w]) && (B.warn("Fixing and trixing - removing XXX", n.v, n.w, n.name), i = O1(n.v), s = O1(n.w), e.removeEdge(n.v, n.w, n.name), i !== n.v && (r.fromCluster = n.v), s !== n.w && (r.toCluster = n.w), B.warn("Fix Replacing with XXX", i, s, n.name), e.setEdge(i, s, r, n.name));
  }), B.warn("Adjusted Graph", jo(e)), dQ(e, 0), B.trace(Me);
}, dQ = (e, t) => {
  if (B.warn("extractor - ", t, jo(e), e.children("D")), t > 10) {
    B.error("Bailing out");
    return;
  }
  let n = e.nodes(), r = !1;
  for (const i of n) {
    const s = e.children(i);
    r = r || s.length > 0;
  }
  if (!r) {
    B.debug("Done, no node has children", e.nodes());
    return;
  }
  B.debug("Nodes = ", n, t);
  for (const i of n)
    if (B.debug(
      "Extracting node",
      i,
      Me,
      Me[i] && !Me[i].externalConnections,
      !e.parent(i),
      e.node(i),
      e.children("D"),
      " Depth ",
      t
    ), !Me[i])
      B.debug("Not a cluster", i, t);
    else if (!Me[i].externalConnections && e.children(i) && e.children(i).length > 0) {
      B.warn(
        "Cluster without external connections, without a parent and with children",
        i,
        t
      );
      let o = e.graph().rankdir === "TB" ? "LR" : "TB";
      Me[i] && Me[i].clusterData && Me[i].clusterData.dir && (o = Me[i].clusterData.dir, B.warn("Fixing dir", Me[i].clusterData.dir, o));
      const a = new zn({
        multigraph: !0,
        compound: !0
      }).setGraph({
        rankdir: o,
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      B.warn("Old graph before copy", jo(e)), uQ(i, e, a, i), e.setNode(i, {
        clusterNode: !0,
        id: i,
        clusterData: Me[i].clusterData,
        labelText: Me[i].labelText,
        graph: a
      }), B.warn("New graph after copy node: (", i, ")", jo(a)), B.debug("Old graph after copy", jo(e));
    } else
      B.warn(
        "Cluster ** ",
        i,
        " **not meeting the criteria !externalConnections:",
        !Me[i].externalConnections,
        " no parent: ",
        !e.parent(i),
        " children ",
        e.children(i) && e.children(i).length > 0,
        e.children("D"),
        t
      ), B.debug(Me);
  n = e.nodes(), B.warn("New list of nodes", n);
  for (const i of n) {
    const s = e.node(i);
    B.warn(" Now next level", i, s), s.clusterNode && dQ(s.graph, t + 1);
  }
}, pQ = (e, t) => {
  if (t.length === 0)
    return [];
  let n = Object.assign(t);
  return t.forEach((r) => {
    const i = e.children(r), s = pQ(e, i);
    n = [...n, ...s];
  }), n;
}, bce = (e) => pQ(e, e.children());
function Oce(e, t) {
  return e.intersect(t);
}
function gQ(e, t, n, r) {
  var i = e.x, s = e.y, o = i - r.x, a = s - r.y, l = Math.sqrt(t * t * a * a + n * n * o * o), h = Math.abs(t * n * o / l);
  r.x < i && (h = -h);
  var u = Math.abs(t * n * a / l);
  return r.y < s && (u = -u), { x: i + h, y: s + u };
}
function xce(e, t, n) {
  return gQ(e, t, t, n);
}
function vce(e, t, n, r) {
  var i, s, o, a, l, h, u, f, d, p, g, m, y, O, x;
  if (i = t.y - e.y, o = e.x - t.x, l = t.x * e.y - e.x * t.y, d = i * n.x + o * n.y + l, p = i * r.x + o * r.y + l, !(d !== 0 && p !== 0 && $8(d, p)) && (s = r.y - n.y, a = n.x - r.x, h = r.x * n.y - n.x * r.y, u = s * e.x + a * e.y + h, f = s * t.x + a * t.y + h, !(u !== 0 && f !== 0 && $8(u, f)) && (g = i * a - s * o, g !== 0)))
    return m = Math.abs(g / 2), y = o * h - a * l, O = y < 0 ? (y - m) / g : (y + m) / g, y = s * l - i * h, x = y < 0 ? (y - m) / g : (y + m) / g, { x: O, y: x };
}
function $8(e, t) {
  return e * t > 0;
}
function _ce(e, t, n) {
  var r = e.x, i = e.y, s = [], o = Number.POSITIVE_INFINITY, a = Number.POSITIVE_INFINITY;
  typeof t.forEach == "function" ? t.forEach(function(g) {
    o = Math.min(o, g.x), a = Math.min(a, g.y);
  }) : (o = Math.min(o, t.x), a = Math.min(a, t.y));
  for (var l = r - e.width / 2 - o, h = i - e.height / 2 - a, u = 0; u < t.length; u++) {
    var f = t[u], d = t[u < t.length - 1 ? u + 1 : 0], p = vce(
      e,
      n,
      { x: l + f.x, y: h + f.y },
      { x: l + d.x, y: h + d.y }
    );
    p && s.push(p);
  }
  return s.length ? (s.length > 1 && s.sort(function(g, m) {
    var y = g.x - n.x, O = g.y - n.y, x = Math.sqrt(y * y + O * O), _ = m.x - n.x, w = m.y - n.y, E = Math.sqrt(_ * _ + w * w);
    return x < E ? -1 : x === E ? 0 : 1;
  }), s[0]) : e;
}
const kce = (e, t) => {
  var n = e.x, r = e.y, i = t.x - n, s = t.y - r, o = e.width / 2, a = e.height / 2, l, h;
  return Math.abs(s) * o > Math.abs(i) * a ? (s < 0 && (a = -a), l = s === 0 ? 0 : a * i / s, h = a) : (i < 0 && (o = -o), l = o, h = i === 0 ? 0 : o * s / i), { x: n + l, y: r + h };
}, s0 = kce, _n = {
  node: Oce,
  circle: xce,
  ellipse: gQ,
  polygon: _ce,
  rect: s0
}, wce = (e, t) => {
  const { shapeSvg: n, bbox: r, halfPadding: i } = Mr(e, t, "node " + t.classes, !0);
  B.info("Classes = ", t.classes);
  const s = n.insert("rect", ":first-child");
  return s.attr("rx", t.rx).attr("ry", t.ry).attr("x", -r.width / 2 - i).attr("y", -r.height / 2 - i).attr("width", r.width + t.padding).attr("height", r.height + t.padding), Mn(t, s), t.intersect = function(o) {
    return _n.rect(t, o);
  }, n;
}, Sce = wce, I8 = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = i + s, a = [
    { x: o / 2, y: 0 },
    { x: o, y: -o / 2 },
    { x: o / 2, y: -o },
    { x: 0, y: -o / 2 }
  ];
  B.info("Question main (Circle)");
  const l = _a(n, o, o, a);
  return l.attr("style", t.style), Mn(t, l), t.intersect = function(h) {
    return B.warn("Intersect called"), _n.polygon(t, a, h);
  }, n;
}, Cce = (e, t) => {
  const n = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), r = 28, i = [
    { x: 0, y: r / 2 },
    { x: r / 2, y: 0 },
    { x: 0, y: -r / 2 },
    { x: -r / 2, y: 0 }
  ];
  return n.insert("polygon", ":first-child").attr(
    "points",
    i.map(function(o) {
      return o.x + "," + o.y;
    }).join(" ")
  ).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), t.width = 28, t.height = 28, t.intersect = function(o) {
    return _n.circle(t, 14, o);
  }, n;
}, Tce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = 4, s = r.height + t.padding, o = s / i, a = r.width + 2 * o + t.padding, l = [
    { x: o, y: 0 },
    { x: a - o, y: 0 },
    { x: a, y: -s / 2 },
    { x: a - o, y: -s },
    { x: o, y: -s },
    { x: 0, y: -s / 2 }
  ], h = _a(n, a, s, l);
  return h.attr("style", t.style), Mn(t, h), t.intersect = function(u) {
    return _n.polygon(t, l, u);
  }, n;
}, Ece = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = [
    { x: -s / 2, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -s },
    { x: -s / 2, y: -s },
    { x: 0, y: -s / 2 }
  ];
  return _a(n, i, s, o).attr("style", t.style), t.width = i + s, t.height = s, t.intersect = function(l) {
    return _n.polygon(t, o, l);
  }, n;
}, Ace = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = [
    { x: -2 * s / 6, y: 0 },
    { x: i - s / 6, y: 0 },
    { x: i + 2 * s / 6, y: -s },
    { x: s / 6, y: -s }
  ], a = _a(n, i, s, o);
  return a.attr("style", t.style), Mn(t, a), t.intersect = function(l) {
    return _n.polygon(t, o, l);
  }, n;
}, Pce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = [
    { x: 2 * s / 6, y: 0 },
    { x: i + s / 6, y: 0 },
    { x: i - 2 * s / 6, y: -s },
    { x: -s / 6, y: -s }
  ], a = _a(n, i, s, o);
  return a.attr("style", t.style), Mn(t, a), t.intersect = function(l) {
    return _n.polygon(t, o, l);
  }, n;
}, Dce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = [
    { x: -2 * s / 6, y: 0 },
    { x: i + 2 * s / 6, y: 0 },
    { x: i - s / 6, y: -s },
    { x: s / 6, y: -s }
  ], a = _a(n, i, s, o);
  return a.attr("style", t.style), Mn(t, a), t.intersect = function(l) {
    return _n.polygon(t, o, l);
  }, n;
}, Lce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = [
    { x: s / 6, y: 0 },
    { x: i - s / 6, y: 0 },
    { x: i + 2 * s / 6, y: -s },
    { x: -2 * s / 6, y: -s }
  ], a = _a(n, i, s, o);
  return a.attr("style", t.style), Mn(t, a), t.intersect = function(l) {
    return _n.polygon(t, o, l);
  }, n;
}, Mce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = [
    { x: 0, y: 0 },
    { x: i + s / 2, y: 0 },
    { x: i, y: -s / 2 },
    { x: i + s / 2, y: -s },
    { x: 0, y: -s }
  ], a = _a(n, i, s, o);
  return a.attr("style", t.style), Mn(t, a), t.intersect = function(l) {
    return _n.polygon(t, o, l);
  }, n;
}, Rce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = i / 2, o = s / (2.5 + i / 50), a = r.height + o + t.padding, l = "M 0," + o + " a " + s + "," + o + " 0,0,0 " + i + " 0 a " + s + "," + o + " 0,0,0 " + -i + " 0 l 0," + a + " a " + s + "," + o + " 0,0,0 " + i + " 0 l 0," + -a, h = n.attr("label-offset-y", o).insert("path", ":first-child").attr("style", t.style).attr("d", l).attr("transform", "translate(" + -i / 2 + "," + -(a / 2 + o) + ")");
  return Mn(t, h), t.intersect = function(u) {
    const f = _n.rect(t, u), d = f.x - t.x;
    if (s != 0 && (Math.abs(d) < t.width / 2 || Math.abs(d) == t.width / 2 && Math.abs(f.y - t.y) > t.height / 2 - o)) {
      let p = o * o * (1 - d * d / (s * s));
      p != 0 && (p = Math.sqrt(p)), p = o - p, u.y - t.y > 0 && (p = -p), f.y += p;
    }
    return f;
  }, n;
}, $ce = (e, t) => {
  const { shapeSvg: n, bbox: r, halfPadding: i } = Mr(e, t, "node " + t.classes, !0);
  B.trace("Classes = ", t.classes);
  const s = n.insert("rect", ":first-child"), o = r.width + t.padding, a = r.height + t.padding;
  if (s.attr("class", "basic label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", -r.width / 2 - i).attr("y", -r.height / 2 - i).attr("width", o).attr("height", a), t.props) {
    const l = new Set(Object.keys(t.props));
    t.props.borders && (mQ(s, t.props.borders, o, a), l.delete("borders")), l.forEach((h) => {
      B.warn(`Unknown node property ${h}`);
    });
  }
  return Mn(t, s), t.intersect = function(l) {
    return _n.rect(t, l);
  }, n;
}, Ice = (e, t) => {
  const { shapeSvg: n } = Mr(e, t, "label", !0);
  B.trace("Classes = ", t.classes);
  const r = n.insert("rect", ":first-child"), i = 0, s = 0;
  if (r.attr("width", i).attr("height", s), n.attr("class", "label edgeLabel"), t.props) {
    const o = new Set(Object.keys(t.props));
    t.props.borders && (mQ(r, t.props.borders, i, s), o.delete("borders")), o.forEach((a) => {
      B.warn(`Unknown node property ${a}`);
    });
  }
  return Mn(t, r), t.intersect = function(o) {
    return _n.rect(t, o);
  }, n;
};
function mQ(e, t, n, r) {
  const i = [], s = (a) => {
    i.push(a, 0);
  }, o = (a) => {
    i.push(0, a);
  };
  t.includes("t") ? (B.debug("add top border"), s(n)) : o(n), t.includes("r") ? (B.debug("add right border"), s(r)) : o(r), t.includes("b") ? (B.debug("add bottom border"), s(n)) : o(n), t.includes("l") ? (B.debug("add left border"), s(r)) : o(r), e.attr("stroke-dasharray", i.join(" "));
}
const Nce = (e, t) => {
  let n;
  t.classes ? n = "node " + t.classes : n = "node default";
  const r = e.insert("g").attr("class", n).attr("id", t.domId || t.id), i = r.insert("rect", ":first-child"), s = r.insert("line"), o = r.insert("g").attr("class", "label"), a = t.labelText.flat ? t.labelText.flat() : t.labelText;
  let l = "";
  typeof a == "object" ? l = a[0] : l = a, B.info("Label text abc79", l, a, typeof a == "object");
  const h = o.node().appendChild(Kr(l, t.labelStyle, !0, !0));
  let u = { width: 0, height: 0 };
  if (ar(J().flowchart.htmlLabels)) {
    const m = h.children[0], y = wt(h);
    u = m.getBoundingClientRect(), y.attr("width", u.width), y.attr("height", u.height);
  }
  B.info("Text 2", a);
  const f = a.slice(1, a.length);
  let d = h.getBBox();
  const p = o.node().appendChild(
    Kr(f.join ? f.join("<br/>") : f, t.labelStyle, !0, !0)
  );
  if (ar(J().flowchart.htmlLabels)) {
    const m = p.children[0], y = wt(p);
    u = m.getBoundingClientRect(), y.attr("width", u.width), y.attr("height", u.height);
  }
  const g = t.padding / 2;
  return wt(p).attr(
    "transform",
    "translate( " + (u.width > d.width ? 0 : (d.width - u.width) / 2) + ", " + (d.height + g + 5) + ")"
  ), wt(h).attr(
    "transform",
    "translate( " + (u.width < d.width ? 0 : -(d.width - u.width) / 2) + ", " + 0 + ")"
  ), u = o.node().getBBox(), o.attr(
    "transform",
    "translate(" + -u.width / 2 + ", " + (-u.height / 2 - g + 3) + ")"
  ), i.attr("class", "outer title-state").attr("x", -u.width / 2 - g).attr("y", -u.height / 2 - g).attr("width", u.width + t.padding).attr("height", u.height + t.padding), s.attr("class", "divider").attr("x1", -u.width / 2 - g).attr("x2", u.width / 2 + g).attr("y1", -u.height / 2 - g + d.height + g).attr("y2", -u.height / 2 - g + d.height + g), Mn(t, i), t.intersect = function(m) {
    return _n.rect(t, m);
  }, r;
}, Bce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.height + t.padding, s = r.width + i / 4 + t.padding, o = n.insert("rect", ":first-child").attr("style", t.style).attr("rx", i / 2).attr("ry", i / 2).attr("x", -s / 2).attr("y", -i / 2).attr("width", s).attr("height", i);
  return Mn(t, o), t.intersect = function(a) {
    return _n.rect(t, a);
  }, n;
}, Fce = (e, t) => {
  const { shapeSvg: n, bbox: r, halfPadding: i } = Mr(e, t, void 0, !0), s = n.insert("circle", ":first-child");
  return s.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", r.width / 2 + i).attr("width", r.width + t.padding).attr("height", r.height + t.padding), B.info("Circle main"), Mn(t, s), t.intersect = function(o) {
    return B.info("Circle intersect", t, r.width / 2 + i, o), _n.circle(t, r.width / 2 + i, o);
  }, n;
}, Qce = (e, t) => {
  const { shapeSvg: n, bbox: r, halfPadding: i } = Mr(e, t, void 0, !0), s = 5, o = n.insert("g", ":first-child"), a = o.insert("circle"), l = o.insert("circle");
  return a.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", r.width / 2 + i + s).attr("width", r.width + t.padding + s * 2).attr("height", r.height + t.padding + s * 2), l.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", r.width / 2 + i).attr("width", r.width + t.padding).attr("height", r.height + t.padding), B.info("DoubleCircle main"), Mn(t, a), t.intersect = function(h) {
    return B.info("DoubleCircle intersect", t, r.width / 2 + i + s, h), _n.circle(t, r.width / 2 + i + s, h);
  }, n;
}, Zce = (e, t) => {
  const { shapeSvg: n, bbox: r } = Mr(e, t, void 0, !0), i = r.width + t.padding, s = r.height + t.padding, o = [
    { x: 0, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -s },
    { x: 0, y: -s },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: i + 8, y: 0 },
    { x: i + 8, y: -s },
    { x: -8, y: -s },
    { x: -8, y: 0 }
  ], a = _a(n, i, s, o);
  return a.attr("style", t.style), Mn(t, a), t.intersect = function(l) {
    return _n.polygon(t, o, l);
  }, n;
}, Vce = (e, t) => {
  const n = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), r = n.insert("circle", ":first-child");
  return r.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), Mn(t, r), t.intersect = function(i) {
    return _n.circle(t, 7, i);
  }, n;
}, N8 = (e, t, n) => {
  const r = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id);
  let i = 70, s = 10;
  n === "LR" && (i = 10, s = 70);
  const o = r.append("rect").attr("x", -1 * i / 2).attr("y", -1 * s / 2).attr("width", i).attr("height", s).attr("class", "fork-join");
  return Mn(t, o), t.height = t.height + t.padding / 2, t.width = t.width + t.padding / 2, t.intersect = function(a) {
    return _n.rect(t, a);
  }, r;
}, Yce = (e, t) => {
  const n = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), r = n.insert("circle", ":first-child"), i = n.insert("circle", ":first-child");
  return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), r.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), Mn(t, i), t.intersect = function(s) {
    return _n.circle(t, 7, s);
  }, n;
}, zce = (e, t) => {
  const n = t.padding / 2, r = 4, i = 8;
  let s;
  t.classes ? s = "node " + t.classes : s = "node default";
  const o = e.insert("g").attr("class", s).attr("id", t.domId || t.id), a = o.insert("rect", ":first-child"), l = o.insert("line"), h = o.insert("line");
  let u = 0, f = r;
  const d = o.insert("g").attr("class", "label");
  let p = 0;
  const g = t.classData.annotations && t.classData.annotations[0], m = t.classData.annotations[0] ? "\xAB" + t.classData.annotations[0] + "\xBB" : "", y = d.node().appendChild(Kr(m, t.labelStyle, !0, !0));
  let O = y.getBBox();
  if (ar(J().flowchart.htmlLabels)) {
    const R = y.children[0], A = wt(y);
    O = R.getBoundingClientRect(), A.attr("width", O.width), A.attr("height", O.height);
  }
  t.classData.annotations[0] && (f += O.height + r, u += O.width);
  let x = t.classData.id;
  t.classData.type !== void 0 && t.classData.type !== "" && (J().flowchart.htmlLabels ? x += "&lt;" + t.classData.type + "&gt;" : x += "<" + t.classData.type + ">");
  const _ = d.node().appendChild(Kr(x, t.labelStyle, !0, !0));
  wt(_).attr("class", "classTitle");
  let w = _.getBBox();
  if (ar(J().flowchart.htmlLabels)) {
    const R = _.children[0], A = wt(_);
    w = R.getBoundingClientRect(), A.attr("width", w.width), A.attr("height", w.height);
  }
  f += w.height + r, w.width > u && (u = w.width);
  const E = [];
  t.classData.members.forEach((R) => {
    const A = u2(R);
    let P = A.displayText;
    J().flowchart.htmlLabels && (P = P.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const C = d.node().appendChild(
      Kr(
        P,
        A.cssStyle ? A.cssStyle : t.labelStyle,
        !0,
        !0
      )
    );
    let k = C.getBBox();
    if (ar(J().flowchart.htmlLabels)) {
      const D = C.children[0], b = wt(C);
      k = D.getBoundingClientRect(), b.attr("width", k.width), b.attr("height", k.height);
    }
    k.width > u && (u = k.width), f += k.height + r, E.push(C);
  }), f += i;
  const T = [];
  if (t.classData.methods.forEach((R) => {
    const A = u2(R);
    let P = A.displayText;
    J().flowchart.htmlLabels && (P = P.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const C = d.node().appendChild(
      Kr(
        P,
        A.cssStyle ? A.cssStyle : t.labelStyle,
        !0,
        !0
      )
    );
    let k = C.getBBox();
    if (ar(J().flowchart.htmlLabels)) {
      const D = C.children[0], b = wt(C);
      k = D.getBoundingClientRect(), b.attr("width", k.width), b.attr("height", k.height);
    }
    k.width > u && (u = k.width), f += k.height + r, T.push(C);
  }), f += i, g) {
    let R = (u - O.width) / 2;
    wt(y).attr(
      "transform",
      "translate( " + (-1 * u / 2 + R) + ", " + -1 * f / 2 + ")"
    ), p = O.height + r;
  }
  let S = (u - w.width) / 2;
  return wt(_).attr(
    "transform",
    "translate( " + (-1 * u / 2 + S) + ", " + (-1 * f / 2 + p) + ")"
  ), p += w.height + r, l.attr("class", "divider").attr("x1", -u / 2 - n).attr("x2", u / 2 + n).attr("y1", -f / 2 - n + i + p).attr("y2", -f / 2 - n + i + p), p += i, E.forEach((R) => {
    wt(R).attr(
      "transform",
      "translate( " + -u / 2 + ", " + (-1 * f / 2 + p + i / 2) + ")"
    ), p += w.height + r;
  }), p += i, h.attr("class", "divider").attr("x1", -u / 2 - n).attr("x2", u / 2 + n).attr("y1", -f / 2 - n + i + p).attr("y2", -f / 2 - n + i + p), p += i, T.forEach((R) => {
    wt(R).attr(
      "transform",
      "translate( " + -u / 2 + ", " + (-1 * f / 2 + p) + ")"
    ), p += w.height + r;
  }), a.attr("class", "outer title-state").attr("x", -u / 2 - n).attr("y", -(f / 2) - n).attr("width", u + t.padding).attr("height", f + t.padding), Mn(t, a), t.intersect = function(R) {
    return _n.rect(t, R);
  }, o;
}, B8 = {
  rhombus: I8,
  question: I8,
  rect: $ce,
  labelRect: Ice,
  rectWithTitle: Nce,
  choice: Cce,
  circle: Fce,
  doublecircle: Qce,
  stadium: Bce,
  hexagon: Tce,
  rect_left_inv_arrow: Ece,
  lean_right: Ace,
  lean_left: Pce,
  trapezoid: Dce,
  inv_trapezoid: Lce,
  rect_right_inv_arrow: Mce,
  cylinder: Rce,
  start: Vce,
  end: Yce,
  note: Sce,
  subroutine: Zce,
  fork: N8,
  join: N8,
  class_box: zce
};
let Eh = {};
const qce = (e, t, n) => {
  let r, i;
  if (t.link) {
    let s;
    J().securityLevel === "sandbox" ? s = "_top" : t.linkTarget && (s = t.linkTarget || "_blank"), r = e.insert("svg:a").attr("xlink:href", t.link).attr("target", s), i = B8[t.shape](r, t, n);
  } else
    i = B8[t.shape](e, t, n), r = i;
  return t.tooltip && i.attr("title", t.tooltip), t.class && i.attr("class", "node default " + t.class), Eh[t.id] = r, t.haveCallback && Eh[t.id].attr("class", Eh[t.id].attr("class") + " clickable"), r;
}, Wce = (e, t) => {
  Eh[t.id] = e;
}, Uce = () => {
  Eh = {};
}, F8 = (e) => {
  const t = Eh[e.id];
  B.trace(
    "Transforming node",
    e.diff,
    e,
    "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")"
  );
  const n = 8, r = e.diff || 0;
  return e.clusterNode ? t.attr(
    "transform",
    "translate(" + (e.x + r - e.width / 2) + ", " + (e.y - e.height / 2 - n) + ")"
  ) : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"), r;
}, jce = (e, t) => {
  B.trace("Creating subgraph rect for ", t.id, t);
  const n = e.insert("g").attr("class", "cluster" + (t.class ? " " + t.class : "")).attr("id", t.id), r = n.insert("rect", ":first-child"), i = n.insert("g").attr("class", "cluster-label"), s = i.node().appendChild(Kr(t.labelText, t.labelStyle, void 0, !0));
  let o = s.getBBox();
  if (ar(J().flowchart.htmlLabels)) {
    const f = s.children[0], d = wt(s);
    o = f.getBoundingClientRect(), d.attr("width", o.width), d.attr("height", o.height);
  }
  const a = 0 * t.padding, l = a / 2, h = t.width <= o.width + a ? o.width + a : t.width;
  t.width <= o.width + a ? t.diff = (o.width - t.width) / 2 - t.padding / 2 : t.diff = -t.padding / 2, B.trace("Data ", t, JSON.stringify(t)), r.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", t.x - h / 2).attr("y", t.y - t.height / 2 - l).attr("width", h).attr("height", t.height + a), i.attr(
    "transform",
    "translate(" + (t.x - o.width / 2) + ", " + (t.y - t.height / 2) + ")"
  );
  const u = r.node().getBBox();
  return t.width = u.width, t.height = u.height, t.intersect = function(f) {
    return s0(t, f);
  }, n;
}, Xce = (e, t) => {
  const n = e.insert("g").attr("class", "note-cluster").attr("id", t.id), r = n.insert("rect", ":first-child"), i = 0 * t.padding, s = i / 2;
  r.attr("rx", t.rx).attr("ry", t.ry).attr("x", t.x - t.width / 2 - s).attr("y", t.y - t.height / 2 - s).attr("width", t.width + i).attr("height", t.height + i).attr("fill", "none");
  const o = r.node().getBBox();
  return t.width = o.width, t.height = o.height, t.intersect = function(a) {
    return s0(t, a);
  }, n;
}, Gce = (e, t) => {
  const n = e.insert("g").attr("class", t.classes).attr("id", t.id), r = n.insert("rect", ":first-child"), i = n.insert("g").attr("class", "cluster-label"), s = n.append("rect"), o = i.node().appendChild(Kr(t.labelText, t.labelStyle, void 0, !0));
  let a = o.getBBox();
  if (ar(J().flowchart.htmlLabels)) {
    const d = o.children[0], p = wt(o);
    a = d.getBoundingClientRect(), p.attr("width", a.width), p.attr("height", a.height);
  }
  a = o.getBBox();
  const l = 0 * t.padding, h = l / 2, u = t.width <= a.width + t.padding ? a.width + t.padding : t.width;
  t.width <= a.width + t.padding ? t.diff = (a.width + t.padding * 0 - t.width) / 2 : t.diff = -t.padding / 2, r.attr("class", "outer").attr("x", t.x - u / 2 - h).attr("y", t.y - t.height / 2 - h).attr("width", u + l).attr("height", t.height + l), s.attr("class", "inner").attr("x", t.x - u / 2 - h).attr("y", t.y - t.height / 2 - h + a.height - 1).attr("width", u + l).attr("height", t.height + l - a.height - 3), i.attr(
    "transform",
    "translate(" + (t.x - a.width / 2) + ", " + (t.y - t.height / 2 - t.padding / 3 + (ar(J().flowchart.htmlLabels) ? 5 : 3)) + ")"
  );
  const f = r.node().getBBox();
  return t.height = f.height, t.intersect = function(d) {
    return s0(t, d);
  }, n;
}, Hce = (e, t) => {
  const n = e.insert("g").attr("class", t.classes).attr("id", t.id), r = n.insert("rect", ":first-child"), i = 0 * t.padding, s = i / 2;
  r.attr("class", "divider").attr("x", t.x - t.width / 2 - s).attr("y", t.y - t.height / 2).attr("width", t.width + i).attr("height", t.height + i);
  const o = r.node().getBBox();
  return t.width = o.width, t.height = o.height, t.diff = -t.padding / 2, t.intersect = function(a) {
    return s0(t, a);
  }, n;
}, Kce = { rect: jce, roundedWithTitle: Gce, noteGroup: Xce, divider: Hce };
let yQ = {};
const Jce = (e, t) => {
  B.trace("Inserting cluster");
  const n = t.shape || "rect";
  yQ[t.id] = Kce[n](e, t);
}, the = () => {
  yQ = {};
};
let d2 = {}, fr = {};
const ehe = () => {
  d2 = {}, fr = {};
}, nhe = (e, t) => {
  const n = Kr(t.label, t.labelStyle), r = e.insert("g").attr("class", "edgeLabel"), i = r.insert("g").attr("class", "label");
  i.node().appendChild(n);
  let s = n.getBBox();
  if (ar(J().flowchart.htmlLabels)) {
    const a = n.children[0], l = wt(n);
    s = a.getBoundingClientRect(), l.attr("width", s.width), l.attr("height", s.height);
  }
  i.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), d2[t.id] = r, t.width = s.width, t.height = s.height;
  let o;
  if (t.startLabelLeft) {
    const a = Kr(t.startLabelLeft, t.labelStyle), l = e.insert("g").attr("class", "edgeTerminals"), h = l.insert("g").attr("class", "inner");
    o = h.node().appendChild(a);
    const u = a.getBBox();
    h.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"), fr[t.id] || (fr[t.id] = {}), fr[t.id].startLeft = l, x1(o, t.startLabelLeft);
  }
  if (t.startLabelRight) {
    const a = Kr(t.startLabelRight, t.labelStyle), l = e.insert("g").attr("class", "edgeTerminals"), h = l.insert("g").attr("class", "inner");
    o = l.node().appendChild(a), h.node().appendChild(a);
    const u = a.getBBox();
    h.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"), fr[t.id] || (fr[t.id] = {}), fr[t.id].startRight = l, x1(o, t.startLabelRight);
  }
  if (t.endLabelLeft) {
    const a = Kr(t.endLabelLeft, t.labelStyle), l = e.insert("g").attr("class", "edgeTerminals"), h = l.insert("g").attr("class", "inner");
    o = h.node().appendChild(a);
    const u = a.getBBox();
    h.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"), l.node().appendChild(a), fr[t.id] || (fr[t.id] = {}), fr[t.id].endLeft = l, x1(o, t.endLabelLeft);
  }
  if (t.endLabelRight) {
    const a = Kr(t.endLabelRight, t.labelStyle), l = e.insert("g").attr("class", "edgeTerminals"), h = l.insert("g").attr("class", "inner");
    o = h.node().appendChild(a);
    const u = a.getBBox();
    h.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"), l.node().appendChild(a), fr[t.id] || (fr[t.id] = {}), fr[t.id].endRight = l, x1(o, t.endLabelRight);
  }
  return n;
};
function x1(e, t) {
  J().flowchart.htmlLabels && e && (e.style.width = t.length * 9 + "px", e.style.height = "12px");
}
const rhe = (e, t) => {
  B.info("Moving label abc78 ", e.id, e.label, d2[e.id]);
  let n = t.updatedPath ? t.updatedPath : t.originalPath;
  if (e.label) {
    const r = d2[e.id];
    let i = e.x, s = e.y;
    if (n) {
      const o = fe.calcLabelPosition(n);
      B.info(
        "Moving label " + e.label + " from (",
        i,
        ",",
        s,
        ") to (",
        o.x,
        ",",
        o.y,
        ") abc78"
      ), t.updatedPath && (i = o.x, s = o.y);
    }
    r.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (e.startLabelLeft) {
    const r = fr[e.id].startLeft;
    let i = e.x, s = e.y;
    if (n) {
      const o = fe.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_left", n);
      i = o.x, s = o.y;
    }
    r.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (e.startLabelRight) {
    const r = fr[e.id].startRight;
    let i = e.x, s = e.y;
    if (n) {
      const o = fe.calcTerminalLabelPosition(
        e.arrowTypeStart ? 10 : 0,
        "start_right",
        n
      );
      i = o.x, s = o.y;
    }
    r.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (e.endLabelLeft) {
    const r = fr[e.id].endLeft;
    let i = e.x, s = e.y;
    if (n) {
      const o = fe.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_left", n);
      i = o.x, s = o.y;
    }
    r.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (e.endLabelRight) {
    const r = fr[e.id].endRight;
    let i = e.x, s = e.y;
    if (n) {
      const o = fe.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_right", n);
      i = o.x, s = o.y;
    }
    r.attr("transform", "translate(" + i + ", " + s + ")");
  }
}, ihe = (e, t) => {
  const n = e.x, r = e.y, i = Math.abs(t.x - n), s = Math.abs(t.y - r), o = e.width / 2, a = e.height / 2;
  return i >= o || s >= a;
}, she = (e, t, n) => {
  B.warn(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(n)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
  const r = e.x, i = e.y, s = Math.abs(r - n.x), o = e.width / 2;
  let a = n.x < t.x ? o - s : o + s;
  const l = e.height / 2, h = Math.abs(t.y - n.y), u = Math.abs(t.x - n.x);
  if (Math.abs(i - t.y) * o > Math.abs(r - t.x) * l) {
    let f = n.y < t.y ? t.y - l - i : i - l - t.y;
    a = u * f / h;
    const d = {
      x: n.x < t.x ? n.x + a : n.x - u + a,
      y: n.y < t.y ? n.y + h - f : n.y - h + f
    };
    return a === 0 && (d.x = t.x, d.y = t.y), u === 0 && (d.x = t.x), h === 0 && (d.y = t.y), B.warn(`abc89 topp/bott calc, Q ${h}, q ${f}, R ${u}, r ${a}`, d), d;
  } else {
    n.x < t.x ? a = t.x - o - r : a = r - o - t.x;
    let f = h * a / u, d = n.x < t.x ? n.x + u - a : n.x - u + a, p = n.y < t.y ? n.y + f : n.y - f;
    return B.warn(`sides calc abc89, Q ${h}, q ${f}, R ${u}, r ${a}`, { _x: d, _y: p }), a === 0 && (d = t.x, p = t.y), u === 0 && (d = t.x), h === 0 && (p = t.y), { x: d, y: p };
  }
}, Q8 = (e, t) => {
  B.warn("abc88 cutPathAtIntersect", e, t);
  let n = [], r = e[0], i = !1;
  return e.forEach((s) => {
    if (B.info("abc88 checking point", s, t), !ihe(t, s) && !i) {
      const o = she(t, r, s);
      B.warn("abc88 inside", s, r, o), B.warn("abc88 intersection", o);
      let a = !1;
      n.forEach((l) => {
        a = a || l.x === o.x && l.y === o.y;
      }), n.some((l) => l.x === o.x && l.y === o.y) ? B.warn("abc88 no intersect", o, n) : n.push(o), i = !0;
    } else
      B.warn("abc88 outside", s, r), r = s, i || n.push(s);
  }), B.warn("abc88 returning points", n), n;
}, ohe = function(e, t, n, r, i, s) {
  let o = n.points, a = !1;
  const l = s.node(t.v);
  var h = s.node(t.w);
  B.info("abc88 InsertEdge: ", n), h.intersect && l.intersect && (o = o.slice(1, n.points.length - 1), o.unshift(l.intersect(o[0])), B.info(
    "Last point",
    o[o.length - 1],
    h,
    h.intersect(o[o.length - 1])
  ), o.push(h.intersect(o[o.length - 1]))), n.toCluster && (B.info("to cluster abc88", r[n.toCluster]), o = Q8(n.points, r[n.toCluster].node), a = !0), n.fromCluster && (B.info("from cluster abc88", r[n.fromCluster]), o = Q8(o.reverse(), r[n.fromCluster].node).reverse(), a = !0);
  const u = o.filter((O) => !Number.isNaN(O.y));
  let f;
  i === "graph" || i === "flowchart" ? f = n.curve || lu : f = lu;
  const d = Qu().x(function(O) {
    return O.x;
  }).y(function(O) {
    return O.y;
  }).curve(f);
  let p;
  switch (n.thickness) {
    case "normal":
      p = "edge-thickness-normal";
      break;
    case "thick":
      p = "edge-thickness-thick";
      break;
    default:
      p = "";
  }
  switch (n.pattern) {
    case "solid":
      p += " edge-pattern-solid";
      break;
    case "dotted":
      p += " edge-pattern-dotted";
      break;
    case "dashed":
      p += " edge-pattern-dashed";
      break;
  }
  const g = e.append("path").attr("d", d(u)).attr("id", n.id).attr("class", " " + p + (n.classes ? " " + n.classes : "")).attr("style", n.style);
  let m = "";
  switch ((J().flowchart.arrowMarkerAbsolute || J().state.arrowMarkerAbsolute) && (m = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, m = m.replace(/\(/g, "\\("), m = m.replace(/\)/g, "\\)")), B.info("arrowTypeStart", n.arrowTypeStart), B.info("arrowTypeEnd", n.arrowTypeEnd), n.arrowTypeStart) {
    case "arrow_cross":
      g.attr("marker-start", "url(" + m + "#" + i + "-crossStart)");
      break;
    case "arrow_point":
      g.attr("marker-start", "url(" + m + "#" + i + "-pointStart)");
      break;
    case "arrow_barb":
      g.attr("marker-start", "url(" + m + "#" + i + "-barbStart)");
      break;
    case "arrow_circle":
      g.attr("marker-start", "url(" + m + "#" + i + "-circleStart)");
      break;
    case "aggregation":
      g.attr("marker-start", "url(" + m + "#" + i + "-aggregationStart)");
      break;
    case "extension":
      g.attr("marker-start", "url(" + m + "#" + i + "-extensionStart)");
      break;
    case "composition":
      g.attr("marker-start", "url(" + m + "#" + i + "-compositionStart)");
      break;
    case "dependency":
      g.attr("marker-start", "url(" + m + "#" + i + "-dependencyStart)");
      break;
    case "lollipop":
      g.attr("marker-start", "url(" + m + "#" + i + "-lollipopStart)");
      break;
  }
  switch (n.arrowTypeEnd) {
    case "arrow_cross":
      g.attr("marker-end", "url(" + m + "#" + i + "-crossEnd)");
      break;
    case "arrow_point":
      g.attr("marker-end", "url(" + m + "#" + i + "-pointEnd)");
      break;
    case "arrow_barb":
      g.attr("marker-end", "url(" + m + "#" + i + "-barbEnd)");
      break;
    case "arrow_circle":
      g.attr("marker-end", "url(" + m + "#" + i + "-circleEnd)");
      break;
    case "aggregation":
      g.attr("marker-end", "url(" + m + "#" + i + "-aggregationEnd)");
      break;
    case "extension":
      g.attr("marker-end", "url(" + m + "#" + i + "-extensionEnd)");
      break;
    case "composition":
      g.attr("marker-end", "url(" + m + "#" + i + "-compositionEnd)");
      break;
    case "dependency":
      g.attr("marker-end", "url(" + m + "#" + i + "-dependencyEnd)");
      break;
    case "lollipop":
      g.attr("marker-end", "url(" + m + "#" + i + "-lollipopEnd)");
      break;
  }
  let y = {};
  return a && (y.updatedPath = o), y.originalPath = n.points, y;
}, bQ = (e, t, n, r) => {
  B.info("Graph in recursive render: XXX", jo(t), r);
  const i = t.graph().rankdir;
  B.trace("Dir in recursive render - dir:", i);
  const s = e.insert("g").attr("class", "root");
  t.nodes() ? B.info("Recursive render XXX", t.nodes()) : B.info("No nodes found for", t), t.edges().length > 0 && B.trace("Recursive edges", t.edge(t.edges()[0]));
  const o = s.insert("g").attr("class", "clusters"), a = s.insert("g").attr("class", "edgePaths"), l = s.insert("g").attr("class", "edgeLabels"), h = s.insert("g").attr("class", "nodes");
  t.nodes().forEach(function(f) {
    const d = t.node(f);
    if (r !== void 0) {
      const p = JSON.parse(JSON.stringify(r.clusterData));
      B.info("Setting data for cluster XXX (", f, ") ", p, r), t.setNode(r.id, p), t.parent(f) || (B.trace("Setting parent", f, r.id), t.setParent(f, r.id, p));
    }
    if (B.info("(Insert) Node XXX" + f + ": " + JSON.stringify(t.node(f))), d && d.clusterNode) {
      B.info("Cluster identified", f, d.width, t.node(f));
      const p = bQ(h, d.graph, n, t.node(f)), g = p.elem;
      Mn(d, g), d.diff = p.diff || 0, B.info("Node bounds (abc123)", f, d, d.width, d.x, d.y), Wce(g, d), B.warn("Recursive render complete ", g, d);
    } else
      t.children(f).length > 0 ? (B.info("Cluster - the non recursive path XXX", f, d.id, d, t), B.info(wp(d.id, t)), Me[d.id] = { id: wp(d.id, t), node: d }) : (B.info("Node - the non recursive path", f, d.id, d), qce(h, t.node(f), i));
  }), t.edges().forEach(function(f) {
    const d = t.edge(f.v, f.w, f.name);
    B.info("Edge " + f.v + " -> " + f.w + ": " + JSON.stringify(f)), B.info("Edge " + f.v + " -> " + f.w + ": ", f, " ", JSON.stringify(t.edge(f))), B.info("Fix", Me, "ids:", f.v, f.w, "Translateing: ", Me[f.v], Me[f.w]), nhe(l, d);
  }), t.edges().forEach(function(f) {
    B.info("Edge " + f.v + " -> " + f.w + ": " + JSON.stringify(f));
  }), B.info("#############################################"), B.info("###                Layout                 ###"), B.info("#############################################"), B.info(t), Wu(t), B.info("Graph after layout:", jo(t));
  let u = 0;
  return bce(t).forEach(function(f) {
    const d = t.node(f);
    B.info("Position " + f + ": " + JSON.stringify(t.node(f))), B.info(
      "Position " + f + ": (" + d.x,
      "," + d.y,
      ") width: ",
      d.width,
      " height: ",
      d.height
    ), d && d.clusterNode ? F8(d) : t.children(f).length > 0 ? (Jce(o, d), Me[d.id].node = d) : F8(d);
  }), t.edges().forEach(function(f) {
    const d = t.edge(f);
    B.info("Edge " + f.v + " -> " + f.w + ": " + JSON.stringify(d), d);
    const p = ohe(a, f, d, Me, n, t);
    rhe(d, p);
  }), t.nodes().forEach(function(f) {
    const d = t.node(f);
    B.info(f, d.type, d.diff), d.type === "group" && (u = d.diff);
  }), { elem: s, diff: u };
}, Q5 = (e, t, n, r, i) => {
  uce(e, n, r, i), Uce(), ehe(), the(), gce(), B.warn("Graph at first:", jo(t)), yce(t), B.warn("Graph after:", jo(t)), bQ(e, t, r);
}, OQ = (e) => de.sanitizeText(e, J());
let xQ = {
  dividerMargin: 10,
  padding: 5,
  textHeight: 10
};
const ahe = function(e, t, n, r) {
  const i = Object.keys(e);
  B.info("keys:", i), B.info(e), i.forEach(function(s) {
    const o = e[s];
    let a = "";
    o.cssClasses.length > 0 && (a = a + " " + o.cssClasses.join(" "));
    const l = { labelStyle: "" };
    let h = o.text !== void 0 ? o.text : o.id, u = 0, f = "";
    switch (o.type) {
      case "class":
        f = "class_box";
        break;
      default:
        f = "class_box";
    }
    t.setNode(o.id, {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: OQ(h),
      classData: o,
      rx: u,
      ry: u,
      class: a,
      style: l.style,
      id: o.id,
      domId: o.domId,
      tooltip: r.db.getTooltip(o.id) || "",
      haveCallback: o.haveCallback,
      link: o.link,
      width: o.type === "group" ? 500 : void 0,
      type: o.type,
      padding: J().flowchart.padding
    }), B.info("setNode", {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: h,
      rx: u,
      ry: u,
      class: a,
      style: l.style,
      id: o.id,
      width: o.type === "group" ? 500 : void 0,
      type: o.type,
      padding: J().flowchart.padding
    });
  });
}, lhe = function(e, t, n, r) {
  B.info(e), e.forEach(function(i, s) {
    const o = i;
    let a = "";
    const l = { labelStyle: "", style: "" };
    let h = o.text, u = 0, f = "note";
    if (t.setNode(o.id, {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: OQ(h),
      noteData: o,
      rx: u,
      ry: u,
      class: a,
      style: l.style,
      id: o.id,
      domId: o.id,
      tooltip: "",
      type: "note",
      padding: J().flowchart.padding
    }), B.info("setNode", {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: h,
      rx: u,
      ry: u,
      style: l.style,
      id: o.id,
      type: "note",
      padding: J().flowchart.padding
    }), !o.class || !(o.class in r))
      return;
    const d = n + s, p = {};
    p.classes = "relation", p.pattern = "dotted", p.id = `edgeNote${d}`, p.arrowhead = "none", B.info(`Note edge: ${JSON.stringify(p)}, ${JSON.stringify(o)}`), p.startLabelRight = "", p.endLabelLeft = "", p.arrowTypeStart = "none", p.arrowTypeEnd = "none";
    let g = "fill:none", m = "";
    p.style = g, p.labelStyle = m, p.curve = ms(xQ.curve, Oi), t.setEdge(o.id, o.class, p, d);
  });
}, che = function(e, t) {
  const n = J().flowchart;
  let r = 0;
  e.forEach(function(i) {
    r++;
    const s = {};
    s.classes = "relation", s.pattern = i.relation.lineType == 1 ? "dashed" : "solid", s.id = "id" + r, i.type === "arrow_open" ? s.arrowhead = "none" : s.arrowhead = "normal", B.info(s, i), s.startLabelRight = i.relationTitle1 === "none" ? "" : i.relationTitle1, s.endLabelLeft = i.relationTitle2 === "none" ? "" : i.relationTitle2, s.arrowTypeStart = Z8(i.relation.type1), s.arrowTypeEnd = Z8(i.relation.type2);
    let o = "", a = "";
    if (i.style !== void 0) {
      const l = ul(i.style);
      o = l.style, a = l.labelStyle;
    } else
      o = "fill:none";
    s.style = o, s.labelStyle = a, i.interpolate !== void 0 ? s.curve = ms(i.interpolate, Oi) : e.defaultInterpolate !== void 0 ? s.curve = ms(e.defaultInterpolate, Oi) : s.curve = ms(n.curve, Oi), i.text = i.title, i.text === void 0 ? i.style !== void 0 && (s.arrowheadStyle = "fill: #333") : (s.arrowheadStyle = "fill: #333", s.labelpos = "c", J().flowchart.htmlLabels ? (s.labelType = "html", s.label = '<span class="edgeLabel">' + i.text + "</span>") : (s.labelType = "text", s.label = i.text.replace(de.lineBreakRegex, `
`), i.style === void 0 && (s.style = s.style || "stroke: #333; stroke-width: 1.5px;fill:none"), s.labelStyle = s.labelStyle.replace("color:", "fill:"))), t.setEdge(i.id1, i.id2, s, r);
  });
}, hhe = function(e) {
  Object.keys(e).forEach(function(n) {
    xQ[n] = e[n];
  });
}, uhe = function(e, t, n, r) {
  B.info("Drawing class - ", t);
  const i = J().flowchart, s = J().securityLevel;
  B.info("config:", i);
  const o = i.nodeSpacing || 50, a = i.rankSpacing || 50, l = new zn({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: r.db.getDirection(),
    nodesep: o,
    ranksep: a,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  }), h = r.db.getClasses(), u = r.db.getRelations(), f = r.db.getNotes();
  B.info(u), ahe(h, l, t, r), che(u, l), lhe(f, l, u.length + 1, h);
  let d;
  s === "sandbox" && (d = wt("#i" + t));
  const p = wt(s === "sandbox" ? d.nodes()[0].contentDocument.body : "body"), g = p.select(`[id="${t}"]`), m = p.select("#" + t + " g");
  if (Q5(
    m,
    l,
    ["aggregation", "extension", "composition", "dependency", "lollipop"],
    "classDiagram",
    t
  ), fe.insertTitle(g, "classTitleText", i.titleTopMargin, r.db.getDiagramTitle()), Xy(l, g, i.diagramPadding, i.useMaxWidth), !i.htmlLabels) {
    const y = s === "sandbox" ? d.nodes()[0].contentDocument : document, O = y.querySelectorAll('[id="' + t + '"] .edgeLabel .label');
    for (const x of O) {
      const _ = x.getBBox(), w = y.createElementNS("http://www.w3.org/2000/svg", "rect");
      w.setAttribute("rx", 0), w.setAttribute("ry", 0), w.setAttribute("width", _.width), w.setAttribute("height", _.height), x.insertBefore(w, x.firstChild);
    }
  }
};
function Z8(e) {
  let t;
  switch (e) {
    case 0:
      t = "aggregation";
      break;
    case 1:
      t = "extension";
      break;
    case 2:
      t = "composition";
      break;
    case 3:
      t = "dependency";
      break;
    case 4:
      t = "lollipop";
      break;
    default:
      t = "none";
  }
  return t;
}
const fhe = {
  setConf: hhe,
  draw: uhe
};
var mk = function() {
  var e = function(C, k, D, b) {
    for (D = D || {}, b = C.length; b--; D[C[b]] = k)
      ;
    return D;
  }, t = [1, 2], n = [1, 5], r = [6, 9, 11, 23, 25, 27, 29, 30, 31, 51], i = [1, 17], s = [1, 18], o = [1, 19], a = [1, 20], l = [1, 21], h = [1, 22], u = [1, 25], f = [1, 30], d = [1, 31], p = [1, 32], g = [1, 33], m = [6, 9, 11, 15, 20, 23, 25, 27, 29, 30, 31, 44, 45, 46, 47, 51], y = [1, 45], O = [30, 31, 48, 49], x = [4, 6, 9, 11, 23, 25, 27, 29, 30, 31, 51], _ = [44, 45, 46, 47], w = [22, 37], E = [1, 65], T = [1, 64], S = [22, 37, 39, 41], R = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, ER_DIAGRAM: 4, document: 5, EOF: 6, directive: 7, line: 8, SPACE: 9, statement: 10, NEWLINE: 11, openDirective: 12, typeDirective: 13, closeDirective: 14, ":": 15, argDirective: 16, entityName: 17, relSpec: 18, role: 19, BLOCK_START: 20, attributes: 21, BLOCK_STOP: 22, title: 23, title_value: 24, acc_title: 25, acc_title_value: 26, acc_descr: 27, acc_descr_value: 28, acc_descr_multiline_value: 29, ALPHANUM: 30, ENTITY_NAME: 31, attribute: 32, attributeType: 33, attributeName: 34, attributeKeyTypeList: 35, attributeComment: 36, ATTRIBUTE_WORD: 37, attributeKeyType: 38, COMMA: 39, ATTRIBUTE_KEY: 40, COMMENT: 41, cardinality: 42, relType: 43, ZERO_OR_ONE: 44, ZERO_OR_MORE: 45, ONE_OR_MORE: 46, ONLY_ONE: 47, NON_IDENTIFYING: 48, IDENTIFYING: 49, WORD: 50, open_directive: 51, type_directive: 52, arg_directive: 53, close_directive: 54, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 20: "BLOCK_START", 22: "BLOCK_STOP", 23: "title", 24: "title_value", 25: "acc_title", 26: "acc_title_value", 27: "acc_descr", 28: "acc_descr_value", 29: "acc_descr_multiline_value", 30: "ALPHANUM", 31: "ENTITY_NAME", 37: "ATTRIBUTE_WORD", 39: "COMMA", 40: "ATTRIBUTE_KEY", 41: "COMMENT", 44: "ZERO_OR_ONE", 45: "ZERO_OR_MORE", 46: "ONE_OR_MORE", 47: "ONLY_ONE", 48: "NON_IDENTIFYING", 49: "IDENTIFYING", 50: "WORD", 51: "open_directive", 52: "type_directive", 53: "arg_directive", 54: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 5], [10, 4], [10, 3], [10, 1], [10, 2], [10, 2], [10, 2], [10, 1], [17, 1], [17, 1], [21, 1], [21, 2], [32, 2], [32, 3], [32, 3], [32, 4], [33, 1], [34, 1], [35, 1], [35, 3], [38, 1], [36, 1], [18, 3], [42, 1], [42, 1], [42, 1], [42, 1], [43, 1], [43, 1], [19, 1], [19, 1], [19, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function(k, D, b, M, v, N, tt) {
      var Z = N.length - 1;
      switch (v) {
        case 1:
          break;
        case 3:
          this.$ = [];
          break;
        case 4:
          N[Z - 1].push(N[Z]), this.$ = N[Z - 1];
          break;
        case 5:
        case 6:
          this.$ = N[Z];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 12:
          M.addEntity(N[Z - 4]), M.addEntity(N[Z - 2]), M.addRelationship(N[Z - 4], N[Z], N[Z - 2], N[Z - 3]);
          break;
        case 13:
          M.addEntity(N[Z - 3]), M.addAttributes(N[Z - 3], N[Z - 1]);
          break;
        case 14:
          M.addEntity(N[Z - 2]);
          break;
        case 15:
          M.addEntity(N[Z]);
          break;
        case 16:
        case 17:
          this.$ = N[Z].trim(), M.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = N[Z].trim(), M.setAccDescription(this.$);
          break;
        case 20:
        case 43:
          this.$ = N[Z];
          break;
        case 21:
        case 41:
        case 42:
          this.$ = N[Z].replace(/"/g, "");
          break;
        case 22:
        case 30:
          this.$ = [N[Z]];
          break;
        case 23:
          N[Z].push(N[Z - 1]), this.$ = N[Z];
          break;
        case 24:
          this.$ = { attributeType: N[Z - 1], attributeName: N[Z] };
          break;
        case 25:
          this.$ = { attributeType: N[Z - 2], attributeName: N[Z - 1], attributeKeyTypeList: N[Z] };
          break;
        case 26:
          this.$ = { attributeType: N[Z - 2], attributeName: N[Z - 1], attributeComment: N[Z] };
          break;
        case 27:
          this.$ = { attributeType: N[Z - 3], attributeName: N[Z - 2], attributeKeyTypeList: N[Z - 1], attributeComment: N[Z] };
          break;
        case 28:
        case 29:
        case 32:
          this.$ = N[Z];
          break;
        case 31:
          N[Z - 2].push(N[Z]), this.$ = N[Z - 2];
          break;
        case 33:
          this.$ = N[Z].replace(/"/g, "");
          break;
        case 34:
          this.$ = { cardA: N[Z], relType: N[Z - 1], cardB: N[Z - 2] };
          break;
        case 35:
          this.$ = M.Cardinality.ZERO_OR_ONE;
          break;
        case 36:
          this.$ = M.Cardinality.ZERO_OR_MORE;
          break;
        case 37:
          this.$ = M.Cardinality.ONE_OR_MORE;
          break;
        case 38:
          this.$ = M.Cardinality.ONLY_ONE;
          break;
        case 39:
          this.$ = M.Identification.NON_IDENTIFYING;
          break;
        case 40:
          this.$ = M.Identification.IDENTIFYING;
          break;
        case 44:
          M.parseDirective("%%{", "open_directive");
          break;
        case 45:
          M.parseDirective(N[Z], "type_directive");
          break;
        case 46:
          N[Z] = N[Z].trim().replace(/'/g, '"'), M.parseDirective(N[Z], "arg_directive");
          break;
        case 47:
          M.parseDirective("}%%", "close_directive", "er");
          break;
      }
    },
    table: [{ 3: 1, 4: t, 7: 3, 12: 4, 51: n }, { 1: [3] }, e(r, [2, 3], { 5: 6 }), { 3: 7, 4: t, 7: 3, 12: 4, 51: n }, { 13: 8, 52: [1, 9] }, { 52: [2, 44] }, { 6: [1, 10], 7: 15, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: 16, 23: i, 25: s, 27: o, 29: a, 30: l, 31: h, 51: n }, { 1: [2, 2] }, { 14: 23, 15: [1, 24], 54: u }, e([15, 54], [2, 45]), e(r, [2, 8], { 1: [2, 1] }), e(r, [2, 4]), { 7: 15, 10: 26, 12: 4, 17: 16, 23: i, 25: s, 27: o, 29: a, 30: l, 31: h, 51: n }, e(r, [2, 6]), e(r, [2, 7]), e(r, [2, 11]), e(r, [2, 15], { 18: 27, 42: 29, 20: [1, 28], 44: f, 45: d, 46: p, 47: g }), { 24: [1, 34] }, { 26: [1, 35] }, { 28: [1, 36] }, e(r, [2, 19]), e(m, [2, 20]), e(m, [2, 21]), { 11: [1, 37] }, { 16: 38, 53: [1, 39] }, { 11: [2, 47] }, e(r, [2, 5]), { 17: 40, 30: l, 31: h }, { 21: 41, 22: [1, 42], 32: 43, 33: 44, 37: y }, { 43: 46, 48: [1, 47], 49: [1, 48] }, e(O, [2, 35]), e(O, [2, 36]), e(O, [2, 37]), e(O, [2, 38]), e(r, [2, 16]), e(r, [2, 17]), e(r, [2, 18]), e(x, [2, 9]), { 14: 49, 54: u }, { 54: [2, 46] }, { 15: [1, 50] }, { 22: [1, 51] }, e(r, [2, 14]), { 21: 52, 22: [2, 22], 32: 43, 33: 44, 37: y }, { 34: 53, 37: [1, 54] }, { 37: [2, 28] }, { 42: 55, 44: f, 45: d, 46: p, 47: g }, e(_, [2, 39]), e(_, [2, 40]), { 11: [1, 56] }, { 19: 57, 30: [1, 60], 31: [1, 59], 50: [1, 58] }, e(r, [2, 13]), { 22: [2, 23] }, e(w, [2, 24], { 35: 61, 36: 62, 38: 63, 40: E, 41: T }), e([22, 37, 40, 41], [2, 29]), e([30, 31], [2, 34]), e(x, [2, 10]), e(r, [2, 12]), e(r, [2, 41]), e(r, [2, 42]), e(r, [2, 43]), e(w, [2, 25], { 36: 66, 39: [1, 67], 41: T }), e(w, [2, 26]), e(S, [2, 30]), e(w, [2, 33]), e(S, [2, 32]), e(w, [2, 27]), { 38: 68, 40: E }, e(S, [2, 31])],
    defaultActions: { 5: [2, 44], 7: [2, 2], 25: [2, 47], 39: [2, 46], 45: [2, 28], 52: [2, 23] },
    parseError: function(k, D) {
      if (D.recoverable)
        this.trace(k);
      else {
        var b = new Error(k);
        throw b.hash = D, b;
      }
    },
    parse: function(k) {
      var D = this, b = [0], M = [], v = [null], N = [], tt = this.table, Z = "", z = 0, X = 0, q = 2, nt = 1, st = N.slice.call(arguments, 1), ct = Object.create(this.lexer), Y = { yy: {} };
      for (var Ct in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Ct) && (Y.yy[Ct] = this.yy[Ct]);
      ct.setInput(k, Y.yy), Y.yy.lexer = ct, Y.yy.parser = this, typeof ct.yylloc > "u" && (ct.yylloc = {});
      var H = ct.yylloc;
      N.push(H);
      var et = ct.options && ct.options.ranges;
      typeof Y.yy.parseError == "function" ? this.parseError = Y.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function U() {
        var St;
        return St = M.pop() || ct.lex() || nt, typeof St != "number" && (St instanceof Array && (M = St, St = M.pop()), St = D.symbols_[St] || St), St;
      }
      for (var W, $, F, G, I = {}, ht, L, $t, it; ; ) {
        if ($ = b[b.length - 1], this.defaultActions[$] ? F = this.defaultActions[$] : ((W === null || typeof W > "u") && (W = U()), F = tt[$] && tt[$][W]), typeof F > "u" || !F.length || !F[0]) {
          var At = "";
          it = [];
          for (ht in tt[$])
            this.terminals_[ht] && ht > q && it.push("'" + this.terminals_[ht] + "'");
          ct.showPosition ? At = "Parse error on line " + (z + 1) + `:
` + ct.showPosition() + `
Expecting ` + it.join(", ") + ", got '" + (this.terminals_[W] || W) + "'" : At = "Parse error on line " + (z + 1) + ": Unexpected " + (W == nt ? "end of input" : "'" + (this.terminals_[W] || W) + "'"), this.parseError(At, {
            text: ct.match,
            token: this.terminals_[W] || W,
            line: ct.yylineno,
            loc: H,
            expected: it
          });
        }
        if (F[0] instanceof Array && F.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + $ + ", token: " + W);
        switch (F[0]) {
          case 1:
            b.push(W), v.push(ct.yytext), N.push(ct.yylloc), b.push(F[1]), W = null, X = ct.yyleng, Z = ct.yytext, z = ct.yylineno, H = ct.yylloc;
            break;
          case 2:
            if (L = this.productions_[F[1]][1], I.$ = v[v.length - L], I._$ = {
              first_line: N[N.length - (L || 1)].first_line,
              last_line: N[N.length - 1].last_line,
              first_column: N[N.length - (L || 1)].first_column,
              last_column: N[N.length - 1].last_column
            }, et && (I._$.range = [
              N[N.length - (L || 1)].range[0],
              N[N.length - 1].range[1]
            ]), G = this.performAction.apply(I, [
              Z,
              X,
              z,
              Y.yy,
              F[1],
              v,
              N
            ].concat(st)), typeof G < "u")
              return G;
            L && (b = b.slice(0, -1 * L * 2), v = v.slice(0, -1 * L), N = N.slice(0, -1 * L)), b.push(this.productions_[F[1]][0]), v.push(I.$), N.push(I._$), $t = tt[b[b.length - 2]][b[b.length - 1]], b.push($t);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, A = function() {
    var C = {
      EOF: 1,
      parseError: function(D, b) {
        if (this.yy.parser)
          this.yy.parser.parseError(D, b);
        else
          throw new Error(D);
      },
      setInput: function(k, D) {
        return this.yy = D || this.yy || {}, this._input = k, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var k = this._input[0];
        this.yytext += k, this.yyleng++, this.offset++, this.match += k, this.matched += k;
        var D = k.match(/(?:\r\n?|\n).*/g);
        return D ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), k;
      },
      unput: function(k) {
        var D = k.length, b = k.split(/(?:\r\n?|\n)/g);
        this._input = k + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - D), this.offset -= D;
        var M = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), b.length - 1 && (this.yylineno -= b.length - 1);
        var v = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: b ? (b.length === M.length ? this.yylloc.first_column : 0) + M[M.length - b.length].length - b[0].length : this.yylloc.first_column - D
        }, this.options.ranges && (this.yylloc.range = [v[0], v[0] + this.yyleng - D]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(k) {
        this.unput(this.match.slice(k));
      },
      pastInput: function() {
        var k = this.matched.substr(0, this.matched.length - this.match.length);
        return (k.length > 20 ? "..." : "") + k.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var k = this.match;
        return k.length < 20 && (k += this._input.substr(0, 20 - k.length)), (k.substr(0, 20) + (k.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var k = this.pastInput(), D = new Array(k.length + 1).join("-");
        return k + this.upcomingInput() + `
` + D + "^";
      },
      test_match: function(k, D) {
        var b, M, v;
        if (this.options.backtrack_lexer && (v = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (v.yylloc.range = this.yylloc.range.slice(0))), M = k[0].match(/(?:\r\n?|\n).*/g), M && (this.yylineno += M.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: M ? M[M.length - 1].length - M[M.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + k[0].length
        }, this.yytext += k[0], this.match += k[0], this.matches = k, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(k[0].length), this.matched += k[0], b = this.performAction.call(this, this.yy, this, D, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), b)
          return b;
        if (this._backtrack) {
          for (var N in v)
            this[N] = v[N];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var k, D, b, M;
        this._more || (this.yytext = "", this.match = "");
        for (var v = this._currentRules(), N = 0; N < v.length; N++)
          if (b = this._input.match(this.rules[v[N]]), b && (!D || b[0].length > D[0].length)) {
            if (D = b, M = N, this.options.backtrack_lexer) {
              if (k = this.test_match(b, v[N]), k !== !1)
                return k;
              if (this._backtrack) {
                D = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return D ? (k = this.test_match(D, v[M]), k !== !1 ? k : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var D = this.next();
        return D || this.lex();
      },
      begin: function(D) {
        this.conditionStack.push(D);
      },
      popState: function() {
        var D = this.conditionStack.length - 1;
        return D > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(D) {
        return D = this.conditionStack.length - 1 - Math.abs(D || 0), D >= 0 ? this.conditionStack[D] : "INITIAL";
      },
      pushState: function(D) {
        this.begin(D);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(D, b, M, v) {
        switch (M) {
          case 0:
            return this.begin("acc_title"), 25;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 27;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return this.begin("open_directive"), 51;
          case 8:
            return this.begin("type_directive"), 52;
          case 9:
            return this.popState(), this.begin("arg_directive"), 15;
          case 10:
            return this.popState(), this.popState(), 54;
          case 11:
            return 53;
          case 12:
            break;
          case 13:
            break;
          case 14:
            return 11;
          case 15:
            break;
          case 16:
            return 9;
          case 17:
            return 31;
          case 18:
            return 50;
          case 19:
            return 4;
          case 20:
            return this.begin("block"), 20;
          case 21:
            return 39;
          case 22:
            break;
          case 23:
            return 40;
          case 24:
            return 37;
          case 25:
            return 37;
          case 26:
            return 41;
          case 27:
            break;
          case 28:
            return this.popState(), 22;
          case 29:
            return b.yytext[0];
          case 30:
            return 44;
          case 31:
            return 46;
          case 32:
            return 46;
          case 33:
            return 46;
          case 34:
            return 44;
          case 35:
            return 44;
          case 36:
            return 45;
          case 37:
            return 45;
          case 38:
            return 45;
          case 39:
            return 45;
          case 40:
            return 45;
          case 41:
            return 46;
          case 42:
            return 45;
          case 43:
            return 46;
          case 44:
            return 47;
          case 45:
            return 47;
          case 46:
            return 47;
          case 47:
            return 47;
          case 48:
            return 44;
          case 49:
            return 45;
          case 50:
            return 46;
          case 51:
            return 48;
          case 52:
            return 49;
          case 53:
            return 49;
          case 54:
            return 48;
          case 55:
            return 48;
          case 56:
            return 48;
          case 57:
            return 30;
          case 58:
            return b.yytext[0];
          case 59:
            return 6;
        }
      },
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:,)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i, /^(?:(.*?)[~](.*?)*[~])/i, /^(?:[A-Za-z_][A-Za-z0-9\-_\[\]\(\)]*)/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:one or zero\b)/i, /^(?:one or more\b)/i, /^(?:one or many\b)/i, /^(?:1\+)/i, /^(?:\|o\b)/i, /^(?:zero or one\b)/i, /^(?:zero or more\b)/i, /^(?:zero or many\b)/i, /^(?:0\+)/i, /^(?:\}o\b)/i, /^(?:many\(0\))/i, /^(?:many\(1\))/i, /^(?:many\b)/i, /^(?:\}\|)/i, /^(?:one\b)/i, /^(?:only one\b)/i, /^(?:1\b)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:to\b)/i, /^(?:optionally to\b)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:[A-Za-z][A-Za-z0-9\-_]*)/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { acc_descr_multiline: { rules: [5, 6], inclusive: !1 }, acc_descr: { rules: [3], inclusive: !1 }, acc_title: { rules: [1], inclusive: !1 }, open_directive: { rules: [8], inclusive: !1 }, type_directive: { rules: [9, 10], inclusive: !1 }, arg_directive: { rules: [10, 11], inclusive: !1 }, block: { rules: [21, 22, 23, 24, 25, 26, 27, 28, 29], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], inclusive: !0 } }
    };
    return C;
  }();
  R.lexer = A;
  function P() {
    this.yy = {};
  }
  return P.prototype = R, R.Parser = P, new P();
}();
mk.parser = mk;
const dhe = mk, phe = (e) => e.match(/^\s*erDiagram/) !== null;
let od = {}, Z5 = [];
const ghe = {
  ZERO_OR_ONE: "ZERO_OR_ONE",
  ZERO_OR_MORE: "ZERO_OR_MORE",
  ONE_OR_MORE: "ONE_OR_MORE",
  ONLY_ONE: "ONLY_ONE"
}, mhe = {
  NON_IDENTIFYING: "NON_IDENTIFYING",
  IDENTIFYING: "IDENTIFYING"
}, yhe = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, vQ = function(e) {
  return od[e] === void 0 && (od[e] = { attributes: [] }, B.info("Added new entity :", e)), od[e];
}, bhe = () => od, Ohe = function(e, t) {
  let n = vQ(e), r;
  for (r = t.length - 1; r >= 0; r--)
    n.attributes.push(t[r]), B.debug("Added attribute ", t[r].attributeName);
}, xhe = function(e, t, n, r) {
  let i = {
    entityA: e,
    roleA: t,
    entityB: n,
    relSpec: r
  };
  Z5.push(i), B.debug("Added new relationship :", i);
}, vhe = () => Z5, _he = function() {
  od = {}, Z5 = [], _i();
}, khe = {
  Cardinality: ghe,
  Identification: mhe,
  parseDirective: yhe,
  getConfig: () => J().er,
  addEntity: vQ,
  addAttributes: Ohe,
  getEntities: bhe,
  addRelationship: xhe,
  getRelationships: vhe,
  clear: _he,
  setAccTitle: oi,
  getAccTitle: ki,
  setAccDescription: wi,
  getAccDescription: Si,
  setDiagramTitle: Is,
  getDiagramTitle: Ns
}, $o = {
  ONLY_ONE_START: "ONLY_ONE_START",
  ONLY_ONE_END: "ONLY_ONE_END",
  ZERO_OR_ONE_START: "ZERO_OR_ONE_START",
  ZERO_OR_ONE_END: "ZERO_OR_ONE_END",
  ONE_OR_MORE_START: "ONE_OR_MORE_START",
  ONE_OR_MORE_END: "ONE_OR_MORE_END",
  ZERO_OR_MORE_START: "ZERO_OR_MORE_START",
  ZERO_OR_MORE_END: "ZERO_OR_MORE_END"
}, whe = function(e, t) {
  let n;
  e.append("defs").append("marker").attr("id", $o.ONLY_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M9,0 L9,18 M15,0 L15,18"), e.append("defs").append("marker").attr("id", $o.ONLY_ONE_END).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M3,0 L3,18 M9,0 L9,18"), n = e.append("defs").append("marker").attr("id", $o.ZERO_OR_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto"), n.append("circle").attr("stroke", t.stroke).attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), n.append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M9,0 L9,18"), n = e.append("defs").append("marker").attr("id", $o.ZERO_OR_ONE_END).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto"), n.append("circle").attr("stroke", t.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), n.append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M21,0 L21,18"), e.append("defs").append("marker").attr("id", $o.ONE_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), e.append("defs").append("marker").attr("id", $o.ONE_OR_MORE_END).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18"), n = e.append("defs").append("marker").attr("id", $o.ZERO_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto"), n.append("circle").attr("stroke", t.stroke).attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), n.append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18"), n = e.append("defs").append("marker").attr("id", $o.ZERO_OR_MORE_END).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto"), n.append("circle").attr("stroke", t.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), n.append("path").attr("stroke", t.stroke).attr("fill", "none").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, Io = {
  ERMarkers: $o,
  insertMarkers: whe
}, She = /[^\dA-Za-z](\W)*/g;
let Xn = {}, Sp = /* @__PURE__ */ new Map();
const Che = function(e) {
  const t = Object.keys(e);
  for (const n of t)
    Xn[n] = e[n];
}, The = (e, t, n) => {
  const r = Xn.entityPadding / 3, i = Xn.entityPadding / 3, s = Xn.fontSize * 0.85, o = t.node().getBBox(), a = [];
  let l = !1, h = !1, u = 0, f = 0, d = 0, p = 0, g = o.height + r * 2, m = 1;
  n.forEach((_) => {
    _.attributeKeyTypeList !== void 0 && _.attributeKeyTypeList.length > 0 && (l = !0), _.attributeComment !== void 0 && (h = !0);
  }), n.forEach((_) => {
    const w = `${t.node().id}-attr-${m}`;
    let E = 0;
    const T = Ua(_.attributeType), S = e.append("text").classed("er entityLabel", !0).attr("id", `${w}-type`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", J().fontFamily).style("font-size", s + "px").text(T), R = e.append("text").classed("er entityLabel", !0).attr("id", `${w}-name`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", J().fontFamily).style("font-size", s + "px").text(_.attributeName), A = {};
    A.tn = S, A.nn = R;
    const P = S.node().getBBox(), C = R.node().getBBox();
    if (u = Math.max(u, P.width), f = Math.max(f, C.width), E = Math.max(P.height, C.height), l) {
      const k = _.attributeKeyTypeList !== void 0 ? _.attributeKeyTypeList.join(",") : "", D = e.append("text").classed("er entityLabel", !0).attr("id", `${w}-key`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", J().fontFamily).style("font-size", s + "px").text(k);
      A.kn = D;
      const b = D.node().getBBox();
      d = Math.max(d, b.width), E = Math.max(E, b.height);
    }
    if (h) {
      const k = e.append("text").classed("er entityLabel", !0).attr("id", `${w}-comment`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", J().fontFamily).style("font-size", s + "px").text(_.attributeComment || "");
      A.cn = k;
      const D = k.node().getBBox();
      p = Math.max(p, D.width), E = Math.max(E, D.height);
    }
    A.height = E, a.push(A), g += E + r * 2, m += 1;
  });
  let y = 4;
  l && (y += 2), h && (y += 2);
  const O = u + f + d + p, x = {
    width: Math.max(
      Xn.minEntityWidth,
      Math.max(
        o.width + Xn.entityPadding * 2,
        O + i * y
      )
    ),
    height: n.length > 0 ? g : Math.max(Xn.minEntityHeight, o.height + Xn.entityPadding * 2)
  };
  if (n.length > 0) {
    const _ = Math.max(
      0,
      (x.width - O - i * y) / (y / 2)
    );
    t.attr(
      "transform",
      "translate(" + x.width / 2 + "," + (r + o.height / 2) + ")"
    );
    let w = o.height + r * 2, E = "attributeBoxOdd";
    a.forEach((T) => {
      const S = w + r + T.height / 2;
      T.tn.attr("transform", "translate(" + i + "," + S + ")");
      const R = e.insert("rect", "#" + T.tn.node().id).classed(`er ${E}`, !0).attr("x", 0).attr("y", w).attr("width", u + i * 2 + _).attr("height", T.height + r * 2), A = parseFloat(R.attr("x")) + parseFloat(R.attr("width"));
      T.nn.attr(
        "transform",
        "translate(" + (A + i) + "," + S + ")"
      );
      const P = e.insert("rect", "#" + T.nn.node().id).classed(`er ${E}`, !0).attr("x", A).attr("y", w).attr("width", f + i * 2 + _).attr("height", T.height + r * 2);
      let C = parseFloat(P.attr("x")) + parseFloat(P.attr("width"));
      if (l) {
        T.kn.attr(
          "transform",
          "translate(" + (C + i) + "," + S + ")"
        );
        const k = e.insert("rect", "#" + T.kn.node().id).classed(`er ${E}`, !0).attr("x", C).attr("y", w).attr("width", d + i * 2 + _).attr("height", T.height + r * 2);
        C = parseFloat(k.attr("x")) + parseFloat(k.attr("width"));
      }
      h && (T.cn.attr(
        "transform",
        "translate(" + (C + i) + "," + S + ")"
      ), e.insert("rect", "#" + T.cn.node().id).classed(`er ${E}`, "true").attr("x", C).attr("y", w).attr("width", p + i * 2 + _).attr("height", T.height + r * 2)), w += T.height + r * 2, E = E === "attributeBoxOdd" ? "attributeBoxEven" : "attributeBoxOdd";
    });
  } else
    x.height = Math.max(Xn.minEntityHeight, g), t.attr("transform", "translate(" + x.width / 2 + "," + x.height / 2 + ")");
  return x;
}, Ehe = function(e, t, n) {
  const r = Object.keys(t);
  let i;
  return r.forEach(function(s) {
    const o = Rhe(s, "entity");
    Sp.set(s, o);
    const a = e.append("g").attr("id", o);
    i = i === void 0 ? o : i;
    const l = "text-" + o, h = a.append("text").classed("er entityLabel", !0).attr("id", l).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "middle").style("font-family", J().fontFamily).style("font-size", Xn.fontSize + "px").text(s), { width: u, height: f } = The(
      a,
      h,
      t[s].attributes
    ), p = a.insert("rect", "#" + l).classed("er entityBox", !0).attr("x", 0).attr("y", 0).attr("width", u).attr("height", f).node().getBBox();
    n.setNode(o, {
      width: p.width,
      height: p.height,
      shape: "rect",
      id: o
    });
  }), i;
}, Ahe = function(e, t) {
  t.nodes().forEach(function(n) {
    n !== void 0 && t.node(n) !== void 0 && e.select("#" + n).attr(
      "transform",
      "translate(" + (t.node(n).x - t.node(n).width / 2) + "," + (t.node(n).y - t.node(n).height / 2) + " )"
    );
  });
}, _Q = function(e) {
  return (e.entityA + e.roleA + e.entityB).replace(/\s/g, "");
}, Phe = function(e, t) {
  return e.forEach(function(n) {
    t.setEdge(
      Sp.get(n.entityA),
      Sp.get(n.entityB),
      { relationship: n },
      _Q(n)
    );
  }), e;
};
let V8 = 0;
const Dhe = function(e, t, n, r, i) {
  V8++;
  const s = n.edge(
    Sp.get(t.entityA),
    Sp.get(t.entityB),
    _Q(t)
  ), o = Qu().x(function(g) {
    return g.x;
  }).y(function(g) {
    return g.y;
  }).curve(lu), a = e.insert("path", "#" + r).classed("er relationshipLine", !0).attr("d", o(s.points)).style("stroke", Xn.stroke).style("fill", "none");
  t.relSpec.relType === i.db.Identification.NON_IDENTIFYING && a.attr("stroke-dasharray", "8,8");
  let l = "";
  switch (Xn.arrowMarkerAbsolute && (l = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, l = l.replace(/\(/g, "\\("), l = l.replace(/\)/g, "\\)")), t.relSpec.cardA) {
    case i.db.Cardinality.ZERO_OR_ONE:
      a.attr("marker-end", "url(" + l + "#" + Io.ERMarkers.ZERO_OR_ONE_END + ")");
      break;
    case i.db.Cardinality.ZERO_OR_MORE:
      a.attr("marker-end", "url(" + l + "#" + Io.ERMarkers.ZERO_OR_MORE_END + ")");
      break;
    case i.db.Cardinality.ONE_OR_MORE:
      a.attr("marker-end", "url(" + l + "#" + Io.ERMarkers.ONE_OR_MORE_END + ")");
      break;
    case i.db.Cardinality.ONLY_ONE:
      a.attr("marker-end", "url(" + l + "#" + Io.ERMarkers.ONLY_ONE_END + ")");
      break;
  }
  switch (t.relSpec.cardB) {
    case i.db.Cardinality.ZERO_OR_ONE:
      a.attr(
        "marker-start",
        "url(" + l + "#" + Io.ERMarkers.ZERO_OR_ONE_START + ")"
      );
      break;
    case i.db.Cardinality.ZERO_OR_MORE:
      a.attr(
        "marker-start",
        "url(" + l + "#" + Io.ERMarkers.ZERO_OR_MORE_START + ")"
      );
      break;
    case i.db.Cardinality.ONE_OR_MORE:
      a.attr(
        "marker-start",
        "url(" + l + "#" + Io.ERMarkers.ONE_OR_MORE_START + ")"
      );
      break;
    case i.db.Cardinality.ONLY_ONE:
      a.attr("marker-start", "url(" + l + "#" + Io.ERMarkers.ONLY_ONE_START + ")");
      break;
  }
  const h = a.node().getTotalLength(), u = a.node().getPointAtLength(h * 0.5), f = "rel" + V8, p = e.append("text").classed("er relationshipLabel", !0).attr("id", f).attr("x", u.x).attr("y", u.y).style("text-anchor", "middle").style("dominant-baseline", "middle").style("font-family", J().fontFamily).style("font-size", Xn.fontSize + "px").text(t.roleA).node().getBBox();
  e.insert("rect", "#" + f).classed("er relationshipLabelBox", !0).attr("x", u.x - p.width / 2).attr("y", u.y - p.height / 2).attr("width", p.width).attr("height", p.height);
}, Lhe = function(e, t, n, r) {
  Xn = J().er, B.info("Drawing ER diagram");
  const i = J().securityLevel;
  let s;
  i === "sandbox" && (s = wt("#i" + t));
  const a = wt(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body").select(`[id='${t}']`);
  Io.insertMarkers(a, Xn);
  let l;
  l = new zn({
    multigraph: !0,
    directed: !0,
    compound: !1
  }).setGraph({
    rankdir: Xn.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const h = Ehe(a, r.db.getEntities(), l), u = Phe(r.db.getRelationships(), l);
  Wu(l), Ahe(a, l), u.forEach(function(m) {
    Dhe(a, m, l, h, r);
  });
  const f = Xn.diagramPadding;
  fe.insertTitle(a, "entityTitleText", Xn.titleTopMargin, r.db.getDiagramTitle());
  const d = a.node().getBBox(), p = d.width + f * 2, g = d.height + f * 2;
  $s(a, g, p, Xn.useMaxWidth), a.attr("viewBox", `${d.x - f} ${d.y - f} ${p} ${g}`);
}, Mhe = "28e9f9db-3c8d-5aa5-9faf-44286ae5937c";
function Rhe(e = "", t = "") {
  const n = e.replace(She, "");
  return `${Y8(t)}${Y8(n)}${fre(
    e,
    Mhe
  )}`;
}
function Y8(e = "") {
  return e.length > 0 ? `${e}-` : "";
}
const $he = {
  setConf: Che,
  draw: Lhe
};
var yk = function() {
  var e = function(Ci, Ht, se, Te) {
    for (se = se || {}, Te = Ci.length; Te--; se[Ci[Te]] = Ht)
      ;
    return se;
  }, t = [1, 9], n = [1, 7], r = [1, 6], i = [1, 8], s = [1, 20, 21, 22, 23, 38, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], o = [2, 10], a = [1, 20], l = [1, 21], h = [1, 22], u = [1, 23], f = [1, 30], d = [1, 32], p = [1, 33], g = [1, 34], m = [1, 62], y = [1, 48], O = [1, 52], x = [1, 36], _ = [1, 37], w = [1, 38], E = [1, 39], T = [1, 40], S = [1, 56], R = [1, 63], A = [1, 51], P = [1, 53], C = [1, 55], k = [1, 59], D = [1, 60], b = [1, 41], M = [1, 42], v = [1, 43], N = [1, 44], tt = [1, 61], Z = [1, 50], z = [1, 54], X = [1, 57], q = [1, 58], nt = [1, 49], st = [1, 66], ct = [1, 71], Y = [1, 20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], Ct = [1, 75], H = [1, 74], et = [1, 76], U = [20, 21, 23, 81, 82], W = [1, 99], $ = [1, 104], F = [1, 107], G = [1, 108], I = [1, 101], ht = [1, 106], L = [1, 109], $t = [1, 102], it = [1, 114], At = [1, 113], St = [1, 103], bt = [1, 105], gt = [1, 110], yt = [1, 111], dt = [1, 112], xt = [1, 115], Re = [20, 21, 22, 23, 81, 82], ye = [20, 21, 22, 23, 53, 81, 82], zt = [20, 21, 22, 23, 40, 52, 53, 55, 57, 59, 61, 63, 65, 66, 67, 69, 71, 73, 74, 76, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], Yt = [20, 21, 23], ce = [20, 21, 23, 52, 66, 67, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], Ie = [1, 12, 20, 21, 22, 23, 24, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], re = [52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], Qt = [1, 149], Lt = [1, 157], kt = [1, 158], _t = [1, 159], Et = [1, 160], pt = [1, 144], Zt = [1, 145], lt = [1, 141], Vt = [1, 152], ut = [1, 153], he = [1, 154], pe = [1, 155], be = [1, 156], Oe = [1, 161], ke = [1, 162], qt = [1, 147], ne = [1, 150], ge = [1, 146], ie = [1, 143], qn = [20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], Ji = [1, 165], qe = [20, 21, 22, 23, 26, 52, 66, 67, 91, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], ae = [20, 21, 22, 23, 24, 26, 38, 40, 41, 42, 52, 56, 58, 60, 62, 64, 66, 67, 68, 70, 72, 73, 75, 77, 81, 82, 86, 87, 88, 89, 90, 91, 92, 95, 105, 106, 109, 111, 112, 113, 114, 122, 123, 124, 125, 126, 127], fn = [12, 21, 22, 24], On = [22, 106], Qe = [1, 250], xn = [1, 245], We = [1, 246], Rn = [1, 254], kn = [1, 251], It = [1, 248], V = [1, 247], Q = [1, 249], ot = [1, 252], vt = [1, 253], Gt = [1, 255], Ce = [1, 273], Le = [20, 21, 23, 106], $e = [20, 21, 22, 23, 66, 67, 86, 102, 105, 106, 109, 110, 111, 112, 113], Ue = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, directive: 5, openDirective: 6, typeDirective: 7, closeDirective: 8, separator: 9, ":": 10, argDirective: 11, open_directive: 12, type_directive: 13, arg_directive: 14, close_directive: 15, graphConfig: 16, document: 17, line: 18, statement: 19, SEMI: 20, NEWLINE: 21, SPACE: 22, EOF: 23, GRAPH: 24, NODIR: 25, DIR: 26, FirstStmtSeperator: 27, ending: 28, endToken: 29, spaceList: 30, spaceListNewline: 31, verticeStatement: 32, styleStatement: 33, linkStyleStatement: 34, classDefStatement: 35, classStatement: 36, clickStatement: 37, subgraph: 38, text: 39, SQS: 40, SQE: 41, end: 42, direction: 43, acc_title: 44, acc_title_value: 45, acc_descr: 46, acc_descr_value: 47, acc_descr_multiline_value: 48, link: 49, node: 50, vertex: 51, AMP: 52, STYLE_SEPARATOR: 53, idString: 54, DOUBLECIRCLESTART: 55, DOUBLECIRCLEEND: 56, PS: 57, PE: 58, "(-": 59, "-)": 60, STADIUMSTART: 61, STADIUMEND: 62, SUBROUTINESTART: 63, SUBROUTINEEND: 64, VERTEX_WITH_PROPS_START: 65, ALPHA: 66, COLON: 67, PIPE: 68, CYLINDERSTART: 69, CYLINDEREND: 70, DIAMOND_START: 71, DIAMOND_STOP: 72, TAGEND: 73, TRAPSTART: 74, TRAPEND: 75, INVTRAPSTART: 76, INVTRAPEND: 77, linkStatement: 78, arrowText: 79, TESTSTR: 80, START_LINK: 81, LINK: 82, textToken: 83, STR: 84, keywords: 85, STYLE: 86, LINKSTYLE: 87, CLASSDEF: 88, CLASS: 89, CLICK: 90, DOWN: 91, UP: 92, textNoTags: 93, textNoTagsToken: 94, DEFAULT: 95, stylesOpt: 96, alphaNum: 97, CALLBACKNAME: 98, CALLBACKARGS: 99, HREF: 100, LINK_TARGET: 101, HEX: 102, numList: 103, INTERPOLATE: 104, NUM: 105, COMMA: 106, style: 107, styleComponent: 108, MINUS: 109, UNIT: 110, BRKT: 111, DOT: 112, PCT: 113, TAGSTART: 114, alphaNumToken: 115, idStringToken: 116, alphaNumStatement: 117, direction_tb: 118, direction_bt: 119, direction_rl: 120, direction_lr: 121, PUNCTUATION: 122, UNICODE_TEXT: 123, PLUS: 124, EQUALS: 125, MULT: 126, UNDERSCORE: 127, graphCodeTokens: 128, ARROW_CROSS: 129, ARROW_POINT: 130, ARROW_CIRCLE: 131, ARROW_OPEN: 132, QUOTE: 133, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 10: ":", 12: "open_directive", 13: "type_directive", 14: "arg_directive", 15: "close_directive", 20: "SEMI", 21: "NEWLINE", 22: "SPACE", 23: "EOF", 24: "GRAPH", 25: "NODIR", 26: "DIR", 38: "subgraph", 40: "SQS", 41: "SQE", 42: "end", 44: "acc_title", 45: "acc_title_value", 46: "acc_descr", 47: "acc_descr_value", 48: "acc_descr_multiline_value", 52: "AMP", 53: "STYLE_SEPARATOR", 55: "DOUBLECIRCLESTART", 56: "DOUBLECIRCLEEND", 57: "PS", 58: "PE", 59: "(-", 60: "-)", 61: "STADIUMSTART", 62: "STADIUMEND", 63: "SUBROUTINESTART", 64: "SUBROUTINEEND", 65: "VERTEX_WITH_PROPS_START", 66: "ALPHA", 67: "COLON", 68: "PIPE", 69: "CYLINDERSTART", 70: "CYLINDEREND", 71: "DIAMOND_START", 72: "DIAMOND_STOP", 73: "TAGEND", 74: "TRAPSTART", 75: "TRAPEND", 76: "INVTRAPSTART", 77: "INVTRAPEND", 80: "TESTSTR", 81: "START_LINK", 82: "LINK", 84: "STR", 86: "STYLE", 87: "LINKSTYLE", 88: "CLASSDEF", 89: "CLASS", 90: "CLICK", 91: "DOWN", 92: "UP", 95: "DEFAULT", 98: "CALLBACKNAME", 99: "CALLBACKARGS", 100: "HREF", 101: "LINK_TARGET", 102: "HEX", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "MINUS", 110: "UNIT", 111: "BRKT", 112: "DOT", 113: "PCT", 114: "TAGSTART", 118: "direction_tb", 119: "direction_bt", 120: "direction_rl", 121: "direction_lr", 122: "PUNCTUATION", 123: "UNICODE_TEXT", 124: "PLUS", 125: "EQUALS", 126: "MULT", 127: "UNDERSCORE", 129: "ARROW_CROSS", 130: "ARROW_POINT", 131: "ARROW_CIRCLE", 132: "ARROW_OPEN", 133: "QUOTE" },
    productions_: [0, [3, 1], [3, 2], [5, 4], [5, 6], [6, 1], [7, 1], [11, 1], [8, 1], [4, 2], [17, 0], [17, 2], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [16, 2], [16, 2], [16, 2], [16, 3], [28, 2], [28, 1], [29, 1], [29, 1], [29, 1], [27, 1], [27, 1], [27, 2], [31, 2], [31, 2], [31, 1], [31, 1], [30, 2], [30, 1], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 9], [19, 6], [19, 4], [19, 1], [19, 2], [19, 2], [19, 1], [9, 1], [9, 1], [9, 1], [32, 3], [32, 4], [32, 2], [32, 1], [50, 1], [50, 5], [50, 3], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 8], [51, 4], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 4], [51, 4], [51, 1], [49, 2], [49, 3], [49, 3], [49, 1], [49, 3], [78, 1], [79, 3], [39, 1], [39, 2], [39, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [93, 1], [93, 2], [35, 5], [35, 5], [36, 5], [37, 2], [37, 4], [37, 3], [37, 5], [37, 2], [37, 4], [37, 4], [37, 6], [37, 2], [37, 4], [37, 2], [37, 4], [37, 4], [37, 6], [33, 5], [33, 5], [34, 5], [34, 5], [34, 9], [34, 9], [34, 7], [34, 7], [103, 1], [103, 3], [96, 1], [96, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [94, 1], [94, 1], [94, 1], [94, 1], [54, 1], [54, 2], [97, 1], [97, 2], [117, 1], [117, 1], [117, 1], [117, 1], [43, 1], [43, 1], [43, 1], [43, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1]],
    performAction: function(Ht, se, Te, Mt, dn, K, Xu) {
      var rt = K.length - 1;
      switch (dn) {
        case 5:
          Mt.parseDirective("%%{", "open_directive");
          break;
        case 6:
          Mt.parseDirective(K[rt], "type_directive");
          break;
        case 7:
          K[rt] = K[rt].trim().replace(/'/g, '"'), Mt.parseDirective(K[rt], "arg_directive");
          break;
        case 8:
          Mt.parseDirective("}%%", "close_directive", "flowchart");
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          (!Array.isArray(K[rt]) || K[rt].length > 0) && K[rt - 1].push(K[rt]), this.$ = K[rt - 1];
          break;
        case 12:
        case 82:
        case 84:
        case 96:
        case 152:
        case 154:
        case 155:
          this.$ = K[rt];
          break;
        case 19:
          Mt.setDirection("TB"), this.$ = "TB";
          break;
        case 20:
          Mt.setDirection(K[rt - 1]), this.$ = K[rt - 1];
          break;
        case 35:
          this.$ = K[rt - 1].nodes;
          break;
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
          this.$ = [];
          break;
        case 41:
          this.$ = Mt.addSubGraph(K[rt - 6], K[rt - 1], K[rt - 4]);
          break;
        case 42:
          this.$ = Mt.addSubGraph(K[rt - 3], K[rt - 1], K[rt - 3]);
          break;
        case 43:
          this.$ = Mt.addSubGraph(void 0, K[rt - 1], void 0);
          break;
        case 45:
          this.$ = K[rt].trim(), Mt.setAccTitle(this.$);
          break;
        case 46:
        case 47:
          this.$ = K[rt].trim(), Mt.setAccDescription(this.$);
          break;
        case 51:
          Mt.addLink(K[rt - 2].stmt, K[rt], K[rt - 1]), this.$ = { stmt: K[rt], nodes: K[rt].concat(K[rt - 2].nodes) };
          break;
        case 52:
          Mt.addLink(K[rt - 3].stmt, K[rt - 1], K[rt - 2]), this.$ = { stmt: K[rt - 1], nodes: K[rt - 1].concat(K[rt - 3].nodes) };
          break;
        case 53:
          this.$ = { stmt: K[rt - 1], nodes: K[rt - 1] };
          break;
        case 54:
          this.$ = { stmt: K[rt], nodes: K[rt] };
          break;
        case 55:
          this.$ = [K[rt]];
          break;
        case 56:
          this.$ = K[rt - 4].concat(K[rt]);
          break;
        case 57:
          this.$ = [K[rt - 2]], Mt.setClass(K[rt - 2], K[rt]);
          break;
        case 58:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "square");
          break;
        case 59:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "doublecircle");
          break;
        case 60:
          this.$ = K[rt - 5], Mt.addVertex(K[rt - 5], K[rt - 2], "circle");
          break;
        case 61:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "ellipse");
          break;
        case 62:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "stadium");
          break;
        case 63:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "subroutine");
          break;
        case 64:
          this.$ = K[rt - 7], Mt.addVertex(K[rt - 7], K[rt - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[K[rt - 5], K[rt - 3]]]));
          break;
        case 65:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "cylinder");
          break;
        case 66:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "round");
          break;
        case 67:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "diamond");
          break;
        case 68:
          this.$ = K[rt - 5], Mt.addVertex(K[rt - 5], K[rt - 2], "hexagon");
          break;
        case 69:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "odd");
          break;
        case 70:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "trapezoid");
          break;
        case 71:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "inv_trapezoid");
          break;
        case 72:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "lean_right");
          break;
        case 73:
          this.$ = K[rt - 3], Mt.addVertex(K[rt - 3], K[rt - 1], "lean_left");
          break;
        case 74:
          this.$ = K[rt], Mt.addVertex(K[rt]);
          break;
        case 75:
          K[rt - 1].text = K[rt], this.$ = K[rt - 1];
          break;
        case 76:
        case 77:
          K[rt - 2].text = K[rt - 1], this.$ = K[rt - 2];
          break;
        case 78:
          this.$ = K[rt];
          break;
        case 79:
          var Ti = Mt.destructLink(K[rt], K[rt - 2]);
          this.$ = { type: Ti.type, stroke: Ti.stroke, length: Ti.length, text: K[rt - 1] };
          break;
        case 80:
          var Ti = Mt.destructLink(K[rt]);
          this.$ = { type: Ti.type, stroke: Ti.stroke, length: Ti.length };
          break;
        case 81:
          this.$ = K[rt - 1];
          break;
        case 83:
        case 97:
        case 153:
          this.$ = K[rt - 1] + "" + K[rt];
          break;
        case 98:
        case 99:
          this.$ = K[rt - 4], Mt.addClass(K[rt - 2], K[rt]);
          break;
        case 100:
          this.$ = K[rt - 4], Mt.setClass(K[rt - 2], K[rt]);
          break;
        case 101:
        case 109:
          this.$ = K[rt - 1], Mt.setClickEvent(K[rt - 1], K[rt]);
          break;
        case 102:
        case 110:
          this.$ = K[rt - 3], Mt.setClickEvent(K[rt - 3], K[rt - 2]), Mt.setTooltip(K[rt - 3], K[rt]);
          break;
        case 103:
          this.$ = K[rt - 2], Mt.setClickEvent(K[rt - 2], K[rt - 1], K[rt]);
          break;
        case 104:
          this.$ = K[rt - 4], Mt.setClickEvent(K[rt - 4], K[rt - 3], K[rt - 2]), Mt.setTooltip(K[rt - 4], K[rt]);
          break;
        case 105:
        case 111:
          this.$ = K[rt - 1], Mt.setLink(K[rt - 1], K[rt]);
          break;
        case 106:
        case 112:
          this.$ = K[rt - 3], Mt.setLink(K[rt - 3], K[rt - 2]), Mt.setTooltip(K[rt - 3], K[rt]);
          break;
        case 107:
        case 113:
          this.$ = K[rt - 3], Mt.setLink(K[rt - 3], K[rt - 2], K[rt]);
          break;
        case 108:
        case 114:
          this.$ = K[rt - 5], Mt.setLink(K[rt - 5], K[rt - 4], K[rt]), Mt.setTooltip(K[rt - 5], K[rt - 2]);
          break;
        case 115:
          this.$ = K[rt - 4], Mt.addVertex(K[rt - 2], void 0, void 0, K[rt]);
          break;
        case 116:
        case 118:
          this.$ = K[rt - 4], Mt.updateLink(K[rt - 2], K[rt]);
          break;
        case 117:
          this.$ = K[rt - 4], Mt.updateLink([K[rt - 2]], K[rt]);
          break;
        case 119:
          this.$ = K[rt - 8], Mt.updateLinkInterpolate([K[rt - 6]], K[rt - 2]), Mt.updateLink([K[rt - 6]], K[rt]);
          break;
        case 120:
          this.$ = K[rt - 8], Mt.updateLinkInterpolate(K[rt - 6], K[rt - 2]), Mt.updateLink(K[rt - 6], K[rt]);
          break;
        case 121:
          this.$ = K[rt - 6], Mt.updateLinkInterpolate([K[rt - 4]], K[rt]);
          break;
        case 122:
          this.$ = K[rt - 6], Mt.updateLinkInterpolate(K[rt - 4], K[rt]);
          break;
        case 123:
        case 125:
          this.$ = [K[rt]];
          break;
        case 124:
        case 126:
          K[rt - 2].push(K[rt]), this.$ = K[rt - 2];
          break;
        case 128:
          this.$ = K[rt - 1] + K[rt];
          break;
        case 150:
          this.$ = K[rt];
          break;
        case 151:
          this.$ = K[rt - 1] + "" + K[rt];
          break;
        case 156:
          this.$ = "v";
          break;
        case 157:
          this.$ = "-";
          break;
        case 158:
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 159:
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 160:
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 161:
          this.$ = { stmt: "dir", value: "LR" };
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 5, 12: t, 16: 4, 21: n, 22: r, 24: i }, { 1: [3] }, { 1: [2, 1] }, { 3: 10, 4: 2, 5: 3, 6: 5, 12: t, 16: 4, 21: n, 22: r, 24: i }, e(s, o, { 17: 11 }), { 7: 12, 13: [1, 13] }, { 16: 14, 21: n, 22: r, 24: i }, { 16: 15, 21: n, 22: r, 24: i }, { 25: [1, 16], 26: [1, 17] }, { 13: [2, 5] }, { 1: [2, 2] }, { 1: [2, 9], 18: 18, 19: 19, 20: a, 21: l, 22: h, 23: u, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 43: 31, 44: d, 46: p, 48: g, 50: 35, 51: 45, 52: m, 54: 46, 66: y, 67: O, 86: x, 87: _, 88: w, 89: E, 90: T, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 116: 47, 118: b, 119: M, 120: v, 121: N, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }, { 8: 64, 10: [1, 65], 15: st }, e([10, 15], [2, 6]), e(s, [2, 17]), e(s, [2, 18]), e(s, [2, 19]), { 20: [1, 68], 21: [1, 69], 22: ct, 27: 67, 30: 70 }, e(Y, [2, 11]), e(Y, [2, 12]), e(Y, [2, 13]), e(Y, [2, 14]), e(Y, [2, 15]), e(Y, [2, 16]), { 9: 72, 20: Ct, 21: H, 23: et, 49: 73, 78: 77, 81: [1, 78], 82: [1, 79] }, { 9: 80, 20: Ct, 21: H, 23: et }, { 9: 81, 20: Ct, 21: H, 23: et }, { 9: 82, 20: Ct, 21: H, 23: et }, { 9: 83, 20: Ct, 21: H, 23: et }, { 9: 84, 20: Ct, 21: H, 23: et }, { 9: 86, 20: Ct, 21: H, 22: [1, 85], 23: et }, e(Y, [2, 44]), { 45: [1, 87] }, { 47: [1, 88] }, e(Y, [2, 47]), e(U, [2, 54], { 30: 89, 22: ct }), { 22: [1, 90] }, { 22: [1, 91] }, { 22: [1, 92] }, { 22: [1, 93] }, { 26: W, 52: $, 66: F, 67: G, 84: [1, 97], 91: I, 97: 96, 98: [1, 94], 100: [1, 95], 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 98, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(Y, [2, 158]), e(Y, [2, 159]), e(Y, [2, 160]), e(Y, [2, 161]), e(Re, [2, 55], { 53: [1, 116] }), e(ye, [2, 74], { 116: 129, 40: [1, 117], 52: m, 55: [1, 118], 57: [1, 119], 59: [1, 120], 61: [1, 121], 63: [1, 122], 65: [1, 123], 66: y, 67: O, 69: [1, 124], 71: [1, 125], 73: [1, 126], 74: [1, 127], 76: [1, 128], 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }), e(zt, [2, 150]), e(zt, [2, 175]), e(zt, [2, 176]), e(zt, [2, 177]), e(zt, [2, 178]), e(zt, [2, 179]), e(zt, [2, 180]), e(zt, [2, 181]), e(zt, [2, 182]), e(zt, [2, 183]), e(zt, [2, 184]), e(zt, [2, 185]), e(zt, [2, 186]), e(zt, [2, 187]), e(zt, [2, 188]), e(zt, [2, 189]), e(zt, [2, 190]), { 9: 130, 20: Ct, 21: H, 23: et }, { 11: 131, 14: [1, 132] }, e(Yt, [2, 8]), e(s, [2, 20]), e(s, [2, 26]), e(s, [2, 27]), { 21: [1, 133] }, e(ce, [2, 34], { 30: 134, 22: ct }), e(Y, [2, 35]), { 50: 135, 51: 45, 52: m, 54: 46, 66: y, 67: O, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 116: 47, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }, e(Ie, [2, 48]), e(Ie, [2, 49]), e(Ie, [2, 50]), e(re, [2, 78], { 79: 136, 68: [1, 138], 80: [1, 137] }), { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 139, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e([52, 66, 67, 68, 80, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 80]), e(Y, [2, 36]), e(Y, [2, 37]), e(Y, [2, 38]), e(Y, [2, 39]), e(Y, [2, 40]), { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 163, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(qn, o, { 17: 164 }), e(Y, [2, 45]), e(Y, [2, 46]), e(U, [2, 53], { 52: Ji }), { 26: W, 52: $, 66: F, 67: G, 91: I, 97: 166, 102: [1, 167], 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 98, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 95: [1, 168], 103: 169, 105: [1, 170] }, { 26: W, 52: $, 66: F, 67: G, 91: I, 95: [1, 171], 97: 172, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 98, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 26: W, 52: $, 66: F, 67: G, 91: I, 97: 173, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 98, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(Yt, [2, 101], { 22: [1, 174], 99: [1, 175] }), e(Yt, [2, 105], { 22: [1, 176] }), e(Yt, [2, 109], { 115: 100, 117: 178, 22: [1, 177], 26: W, 52: $, 66: F, 67: G, 91: I, 105: ht, 106: L, 109: $t, 111: it, 112: At, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }), e(Yt, [2, 111], { 22: [1, 179] }), e(qe, [2, 152]), e(qe, [2, 154]), e(qe, [2, 155]), e(qe, [2, 156]), e(qe, [2, 157]), e(ae, [2, 162]), e(ae, [2, 163]), e(ae, [2, 164]), e(ae, [2, 165]), e(ae, [2, 166]), e(ae, [2, 167]), e(ae, [2, 168]), e(ae, [2, 169]), e(ae, [2, 170]), e(ae, [2, 171]), e(ae, [2, 172]), e(ae, [2, 173]), e(ae, [2, 174]), { 52: m, 54: 180, 66: y, 67: O, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 116: 47, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 181, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 182, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 184, 42: Et, 52: $, 57: [1, 183], 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 185, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 186, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 187, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 66: [1, 188] }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 189, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 190, 42: Et, 52: $, 66: F, 67: G, 71: [1, 191], 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 192, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 193, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 194, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(zt, [2, 151]), e(fn, [2, 3]), { 8: 195, 15: st }, { 15: [2, 7] }, e(s, [2, 28]), e(ce, [2, 33]), e(U, [2, 51], { 30: 196, 22: ct }), e(re, [2, 75], { 22: [1, 197] }), { 22: [1, 198] }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 199, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 82: [1, 200], 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(ae, [2, 82]), e(ae, [2, 84]), e(ae, [2, 140]), e(ae, [2, 141]), e(ae, [2, 142]), e(ae, [2, 143]), e(ae, [2, 144]), e(ae, [2, 145]), e(ae, [2, 146]), e(ae, [2, 147]), e(ae, [2, 148]), e(ae, [2, 149]), e(ae, [2, 85]), e(ae, [2, 86]), e(ae, [2, 87]), e(ae, [2, 88]), e(ae, [2, 89]), e(ae, [2, 90]), e(ae, [2, 91]), e(ae, [2, 92]), e(ae, [2, 93]), e(ae, [2, 94]), e(ae, [2, 95]), { 9: 203, 20: Ct, 21: H, 22: Qt, 23: et, 24: Lt, 26: kt, 38: _t, 40: [1, 202], 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 18: 18, 19: 19, 20: a, 21: l, 22: h, 23: u, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 42: [1, 204], 43: 31, 44: d, 46: p, 48: g, 50: 35, 51: 45, 52: m, 54: 46, 66: y, 67: O, 86: x, 87: _, 88: w, 89: E, 90: T, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 116: 47, 118: b, 119: M, 120: v, 121: N, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }, { 22: ct, 30: 205 }, { 22: [1, 206], 26: W, 52: $, 66: F, 67: G, 91: I, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 178, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: [1, 207] }, { 22: [1, 208] }, { 22: [1, 209], 106: [1, 210] }, e(On, [2, 123]), { 22: [1, 211] }, { 22: [1, 212], 26: W, 52: $, 66: F, 67: G, 91: I, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 178, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: [1, 213], 26: W, 52: $, 66: F, 67: G, 91: I, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 178, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 84: [1, 214] }, e(Yt, [2, 103], { 22: [1, 215] }), { 84: [1, 216], 101: [1, 217] }, { 84: [1, 218] }, e(qe, [2, 153]), { 84: [1, 219], 101: [1, 220] }, e(Re, [2, 57], { 116: 129, 52: m, 66: y, 67: O, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }), { 22: Qt, 24: Lt, 26: kt, 38: _t, 41: [1, 221], 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 56: [1, 222], 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 223, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 58: [1, 224], 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 60: [1, 225], 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 62: [1, 226], 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 64: [1, 227], 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 67: [1, 228] }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 66: F, 67: G, 70: [1, 229], 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 66: F, 67: G, 72: [1, 230], 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 231, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 41: [1, 232], 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 66: F, 67: G, 73: pt, 75: [1, 233], 77: [1, 234], 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 66: F, 67: G, 73: pt, 75: [1, 236], 77: [1, 235], 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 9: 237, 20: Ct, 21: H, 23: et }, e(U, [2, 52], { 52: Ji }), e(re, [2, 77]), e(re, [2, 76]), { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 66: F, 67: G, 68: [1, 238], 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(re, [2, 79]), e(ae, [2, 83]), { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 239, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(qn, o, { 17: 240 }), e(Y, [2, 43]), { 51: 241, 52: m, 54: 46, 66: y, 67: O, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 116: 47, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 242, 102: kn, 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 256, 102: kn, 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 257, 102: kn, 104: [1, 258], 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 259, 102: kn, 104: [1, 260], 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, { 105: [1, 261] }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 262, 102: kn, 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 263, 102: kn, 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, { 26: W, 52: $, 66: F, 67: G, 91: I, 97: 264, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 98, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(Yt, [2, 102]), { 84: [1, 265] }, e(Yt, [2, 106], { 22: [1, 266] }), e(Yt, [2, 107]), e(Yt, [2, 110]), e(Yt, [2, 112], { 22: [1, 267] }), e(Yt, [2, 113]), e(ye, [2, 58]), e(ye, [2, 59]), { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 58: [1, 268], 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(ye, [2, 66]), e(ye, [2, 61]), e(ye, [2, 62]), e(ye, [2, 63]), { 66: [1, 269] }, e(ye, [2, 65]), e(ye, [2, 67]), { 22: Qt, 24: Lt, 26: kt, 38: _t, 42: Et, 52: $, 66: F, 67: G, 72: [1, 270], 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(ye, [2, 69]), e(ye, [2, 70]), e(ye, [2, 72]), e(ye, [2, 71]), e(ye, [2, 73]), e(fn, [2, 4]), e([22, 52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 81]), { 22: Qt, 24: Lt, 26: kt, 38: _t, 41: [1, 271], 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 18: 18, 19: 19, 20: a, 21: l, 22: h, 23: u, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 42: [1, 272], 43: 31, 44: d, 46: p, 48: g, 50: 35, 51: 45, 52: m, 54: 46, 66: y, 67: O, 86: x, 87: _, 88: w, 89: E, 90: T, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 116: 47, 118: b, 119: M, 120: v, 121: N, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }, e(Re, [2, 56]), e(Yt, [2, 115], { 106: Ce }), e(Le, [2, 125], { 108: 274, 22: Qe, 66: xn, 67: We, 86: Rn, 102: kn, 105: It, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }), e($e, [2, 127]), e($e, [2, 129]), e($e, [2, 130]), e($e, [2, 131]), e($e, [2, 132]), e($e, [2, 133]), e($e, [2, 134]), e($e, [2, 135]), e($e, [2, 136]), e($e, [2, 137]), e($e, [2, 138]), e($e, [2, 139]), e(Yt, [2, 116], { 106: Ce }), e(Yt, [2, 117], { 106: Ce }), { 22: [1, 275] }, e(Yt, [2, 118], { 106: Ce }), { 22: [1, 276] }, e(On, [2, 124]), e(Yt, [2, 98], { 106: Ce }), e(Yt, [2, 99], { 106: Ce }), e(Yt, [2, 100], { 115: 100, 117: 178, 26: W, 52: $, 66: F, 67: G, 91: I, 105: ht, 106: L, 109: $t, 111: it, 112: At, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }), e(Yt, [2, 104]), { 101: [1, 277] }, { 101: [1, 278] }, { 58: [1, 279] }, { 68: [1, 280] }, { 72: [1, 281] }, { 9: 282, 20: Ct, 21: H, 23: et }, e(Y, [2, 42]), { 22: Qe, 66: xn, 67: We, 86: Rn, 102: kn, 105: It, 107: 283, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, e($e, [2, 128]), { 26: W, 52: $, 66: F, 67: G, 91: I, 97: 284, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 98, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 26: W, 52: $, 66: F, 67: G, 91: I, 97: 285, 105: ht, 106: L, 109: $t, 111: it, 112: At, 115: 100, 117: 98, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(Yt, [2, 108]), e(Yt, [2, 114]), e(ye, [2, 60]), { 22: Qt, 24: Lt, 26: kt, 38: _t, 39: 286, 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 140, 84: lt, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, e(ye, [2, 68]), e(qn, o, { 17: 287 }), e(Le, [2, 126], { 108: 274, 22: Qe, 66: xn, 67: We, 86: Rn, 102: kn, 105: It, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }), e(Yt, [2, 121], { 115: 100, 117: 178, 22: [1, 288], 26: W, 52: $, 66: F, 67: G, 91: I, 105: ht, 106: L, 109: $t, 111: it, 112: At, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }), e(Yt, [2, 122], { 115: 100, 117: 178, 22: [1, 289], 26: W, 52: $, 66: F, 67: G, 91: I, 105: ht, 106: L, 109: $t, 111: it, 112: At, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }), { 22: Qt, 24: Lt, 26: kt, 38: _t, 41: [1, 290], 42: Et, 52: $, 66: F, 67: G, 73: pt, 81: Zt, 83: 201, 85: 151, 86: Vt, 87: ut, 88: he, 89: pe, 90: be, 91: Oe, 92: ke, 94: 142, 95: qt, 105: ht, 106: L, 109: ne, 111: it, 112: At, 113: ge, 114: ie, 115: 148, 122: St, 123: bt, 124: gt, 125: yt, 126: dt, 127: xt }, { 18: 18, 19: 19, 20: a, 21: l, 22: h, 23: u, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 42: [1, 291], 43: 31, 44: d, 46: p, 48: g, 50: 35, 51: 45, 52: m, 54: 46, 66: y, 67: O, 86: x, 87: _, 88: w, 89: E, 90: T, 91: S, 95: R, 105: A, 106: P, 109: C, 111: k, 112: D, 116: 47, 118: b, 119: M, 120: v, 121: N, 122: tt, 123: Z, 124: z, 125: X, 126: q, 127: nt }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 292, 102: kn, 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, { 22: Qe, 66: xn, 67: We, 86: Rn, 96: 293, 102: kn, 105: It, 107: 243, 108: 244, 109: V, 110: Q, 111: ot, 112: vt, 113: Gt }, e(ye, [2, 64]), e(Y, [2, 41]), e(Yt, [2, 119], { 106: Ce }), e(Yt, [2, 120], { 106: Ce })],
    defaultActions: { 2: [2, 1], 9: [2, 5], 10: [2, 2], 132: [2, 7] },
    parseError: function(Ht, se) {
      if (se.recoverable)
        this.trace(Ht);
      else {
        var Te = new Error(Ht);
        throw Te.hash = se, Te;
      }
    },
    parse: function(Ht) {
      var se = this, Te = [0], Mt = [], dn = [null], K = [], Xu = this.table, rt = "", Ti = 0, dS = 0, FV = 2, pS = 1, QV = K.slice.call(arguments, 1), nr = Object.create(this.lexer), bl = { yy: {} };
      for (var ab in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ab) && (bl.yy[ab] = this.yy[ab]);
      nr.setInput(Ht, bl.yy), bl.yy.lexer = nr, bl.yy.parser = this, typeof nr.yylloc > "u" && (nr.yylloc = {});
      var lb = nr.yylloc;
      K.push(lb);
      var ZV = nr.options && nr.options.ranges;
      typeof bl.yy.parseError == "function" ? this.parseError = bl.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function VV() {
        var Ao;
        return Ao = Mt.pop() || nr.lex() || pS, typeof Ao != "number" && (Ao instanceof Array && (Mt = Ao, Ao = Mt.pop()), Ao = se.symbols_[Ao] || Ao), Ao;
      }
      for (var Wr, Ol, Ei, cb, Nc = {}, d0, Eo, gS, p0; ; ) {
        if (Ol = Te[Te.length - 1], this.defaultActions[Ol] ? Ei = this.defaultActions[Ol] : ((Wr === null || typeof Wr > "u") && (Wr = VV()), Ei = Xu[Ol] && Xu[Ol][Wr]), typeof Ei > "u" || !Ei.length || !Ei[0]) {
          var hb = "";
          p0 = [];
          for (d0 in Xu[Ol])
            this.terminals_[d0] && d0 > FV && p0.push("'" + this.terminals_[d0] + "'");
          nr.showPosition ? hb = "Parse error on line " + (Ti + 1) + `:
` + nr.showPosition() + `
Expecting ` + p0.join(", ") + ", got '" + (this.terminals_[Wr] || Wr) + "'" : hb = "Parse error on line " + (Ti + 1) + ": Unexpected " + (Wr == pS ? "end of input" : "'" + (this.terminals_[Wr] || Wr) + "'"), this.parseError(hb, {
            text: nr.match,
            token: this.terminals_[Wr] || Wr,
            line: nr.yylineno,
            loc: lb,
            expected: p0
          });
        }
        if (Ei[0] instanceof Array && Ei.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ol + ", token: " + Wr);
        switch (Ei[0]) {
          case 1:
            Te.push(Wr), dn.push(nr.yytext), K.push(nr.yylloc), Te.push(Ei[1]), Wr = null, dS = nr.yyleng, rt = nr.yytext, Ti = nr.yylineno, lb = nr.yylloc;
            break;
          case 2:
            if (Eo = this.productions_[Ei[1]][1], Nc.$ = dn[dn.length - Eo], Nc._$ = {
              first_line: K[K.length - (Eo || 1)].first_line,
              last_line: K[K.length - 1].last_line,
              first_column: K[K.length - (Eo || 1)].first_column,
              last_column: K[K.length - 1].last_column
            }, ZV && (Nc._$.range = [
              K[K.length - (Eo || 1)].range[0],
              K[K.length - 1].range[1]
            ]), cb = this.performAction.apply(Nc, [
              rt,
              dS,
              Ti,
              bl.yy,
              Ei[1],
              dn,
              K
            ].concat(QV)), typeof cb < "u")
              return cb;
            Eo && (Te = Te.slice(0, -1 * Eo * 2), dn = dn.slice(0, -1 * Eo), K = K.slice(0, -1 * Eo)), Te.push(this.productions_[Ei[1]][0]), dn.push(Nc.$), K.push(Nc._$), gS = Xu[Te[Te.length - 2]][Te[Te.length - 1]], Te.push(gS);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, ln = function() {
    var Ci = {
      EOF: 1,
      parseError: function(se, Te) {
        if (this.yy.parser)
          this.yy.parser.parseError(se, Te);
        else
          throw new Error(se);
      },
      setInput: function(Ht, se) {
        return this.yy = se || this.yy || {}, this._input = Ht, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var Ht = this._input[0];
        this.yytext += Ht, this.yyleng++, this.offset++, this.match += Ht, this.matched += Ht;
        var se = Ht.match(/(?:\r\n?|\n).*/g);
        return se ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Ht;
      },
      unput: function(Ht) {
        var se = Ht.length, Te = Ht.split(/(?:\r\n?|\n)/g);
        this._input = Ht + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - se), this.offset -= se;
        var Mt = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), Te.length - 1 && (this.yylineno -= Te.length - 1);
        var dn = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: Te ? (Te.length === Mt.length ? this.yylloc.first_column : 0) + Mt[Mt.length - Te.length].length - Te[0].length : this.yylloc.first_column - se
        }, this.options.ranges && (this.yylloc.range = [dn[0], dn[0] + this.yyleng - se]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(Ht) {
        this.unput(this.match.slice(Ht));
      },
      pastInput: function() {
        var Ht = this.matched.substr(0, this.matched.length - this.match.length);
        return (Ht.length > 20 ? "..." : "") + Ht.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var Ht = this.match;
        return Ht.length < 20 && (Ht += this._input.substr(0, 20 - Ht.length)), (Ht.substr(0, 20) + (Ht.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var Ht = this.pastInput(), se = new Array(Ht.length + 1).join("-");
        return Ht + this.upcomingInput() + `
` + se + "^";
      },
      test_match: function(Ht, se) {
        var Te, Mt, dn;
        if (this.options.backtrack_lexer && (dn = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (dn.yylloc.range = this.yylloc.range.slice(0))), Mt = Ht[0].match(/(?:\r\n?|\n).*/g), Mt && (this.yylineno += Mt.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: Mt ? Mt[Mt.length - 1].length - Mt[Mt.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Ht[0].length
        }, this.yytext += Ht[0], this.match += Ht[0], this.matches = Ht, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Ht[0].length), this.matched += Ht[0], Te = this.performAction.call(this, this.yy, this, se, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), Te)
          return Te;
        if (this._backtrack) {
          for (var K in dn)
            this[K] = dn[K];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Ht, se, Te, Mt;
        this._more || (this.yytext = "", this.match = "");
        for (var dn = this._currentRules(), K = 0; K < dn.length; K++)
          if (Te = this._input.match(this.rules[dn[K]]), Te && (!se || Te[0].length > se[0].length)) {
            if (se = Te, Mt = K, this.options.backtrack_lexer) {
              if (Ht = this.test_match(Te, dn[K]), Ht !== !1)
                return Ht;
              if (this._backtrack) {
                se = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return se ? (Ht = this.test_match(se, dn[Mt]), Ht !== !1 ? Ht : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var se = this.next();
        return se || this.lex();
      },
      begin: function(se) {
        this.conditionStack.push(se);
      },
      popState: function() {
        var se = this.conditionStack.length - 1;
        return se > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(se) {
        return se = this.conditionStack.length - 1 - Math.abs(se || 0), se >= 0 ? this.conditionStack[se] : "INITIAL";
      },
      pushState: function(se) {
        this.begin(se);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function(se, Te, Mt, dn) {
        switch (Mt) {
          case 0:
            return this.begin("open_directive"), 12;
          case 1:
            return this.begin("type_directive"), 13;
          case 2:
            return this.popState(), this.begin("arg_directive"), 10;
          case 3:
            return this.popState(), this.popState(), 15;
          case 4:
            return 14;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return this.begin("acc_title"), 44;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 46;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            this.begin("string");
            break;
          case 15:
            this.popState();
            break;
          case 16:
            return "STR";
          case 17:
            return 86;
          case 18:
            return 95;
          case 19:
            return 87;
          case 20:
            return 104;
          case 21:
            return 88;
          case 22:
            return 89;
          case 23:
            this.begin("href");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return 100;
          case 26:
            this.begin("callbackname");
            break;
          case 27:
            this.popState();
            break;
          case 28:
            this.popState(), this.begin("callbackargs");
            break;
          case 29:
            return 98;
          case 30:
            this.popState();
            break;
          case 31:
            return 99;
          case 32:
            this.begin("click");
            break;
          case 33:
            this.popState();
            break;
          case 34:
            return 90;
          case 35:
            return se.lex.firstGraph() && this.begin("dir"), 24;
          case 36:
            return se.lex.firstGraph() && this.begin("dir"), 24;
          case 37:
            return se.lex.firstGraph() && this.begin("dir"), 24;
          case 38:
            return 38;
          case 39:
            return 42;
          case 40:
            return 101;
          case 41:
            return 101;
          case 42:
            return 101;
          case 43:
            return 101;
          case 44:
            return this.popState(), 25;
          case 45:
            return this.popState(), 26;
          case 46:
            return this.popState(), 26;
          case 47:
            return this.popState(), 26;
          case 48:
            return this.popState(), 26;
          case 49:
            return this.popState(), 26;
          case 50:
            return this.popState(), 26;
          case 51:
            return this.popState(), 26;
          case 52:
            return this.popState(), 26;
          case 53:
            return this.popState(), 26;
          case 54:
            return this.popState(), 26;
          case 55:
            return 118;
          case 56:
            return 119;
          case 57:
            return 120;
          case 58:
            return 121;
          case 59:
            return 105;
          case 60:
            return 111;
          case 61:
            return 53;
          case 62:
            return 67;
          case 63:
            return 52;
          case 64:
            return 20;
          case 65:
            return 106;
          case 66:
            return 126;
          case 67:
            return 82;
          case 68:
            return 82;
          case 69:
            return 82;
          case 70:
            return 81;
          case 71:
            return 81;
          case 72:
            return 81;
          case 73:
            return 59;
          case 74:
            return 60;
          case 75:
            return 61;
          case 76:
            return 62;
          case 77:
            return 63;
          case 78:
            return 64;
          case 79:
            return 65;
          case 80:
            return 69;
          case 81:
            return 70;
          case 82:
            return 55;
          case 83:
            return 56;
          case 84:
            return 109;
          case 85:
            return 112;
          case 86:
            return 127;
          case 87:
            return 124;
          case 88:
            return 113;
          case 89:
            return 125;
          case 90:
            return 125;
          case 91:
            return 114;
          case 92:
            return 73;
          case 93:
            return 92;
          case 94:
            return "SEP";
          case 95:
            return 91;
          case 96:
            return 66;
          case 97:
            return 75;
          case 98:
            return 74;
          case 99:
            return 77;
          case 100:
            return 76;
          case 101:
            return 122;
          case 102:
            return 123;
          case 103:
            return 68;
          case 104:
            return 57;
          case 105:
            return 58;
          case 106:
            return 40;
          case 107:
            return 41;
          case 108:
            return 71;
          case 109:
            return 72;
          case 110:
            return 133;
          case 111:
            return 21;
          case 112:
            return 22;
          case 113:
            return 23;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)[^\n]*)/, /^(?:[^\}]%%[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:flowchart-elk\b)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\[)/, /^(?:\]\))/, /^(?:\[\[)/, /^(?:\]\])/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\])/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:-)/, /^(?:\.)/, /^(?:[\_])/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:[A-Za-z]+)/, /^(?:\\\])/, /^(?:\[\/)/, /^(?:\/\])/, /^(?:\[\\)/, /^(?:[!"#$%&'*+,-.`?\\_/])/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\()/, /^(?:\))/, /^(?:\[)/, /^(?:\])/, /^(?:\{)/, /^(?:\})/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
      conditions: { close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, callbackargs: { rules: [30, 31], inclusive: !1 }, callbackname: { rules: [27, 28, 29], inclusive: !1 }, href: { rules: [24, 25], inclusive: !1 }, click: { rules: [33, 34], inclusive: !1 }, vertex: { rules: [], inclusive: !1 }, dir: { rules: [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54], inclusive: !1 }, acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, string: { rules: [15, 16], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 7, 9, 11, 14, 17, 18, 19, 20, 21, 22, 23, 26, 32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], inclusive: !0 } }
    };
    return Ci;
  }();
  Ue.lexer = ln;
  function Bs() {
    this.yy = {};
  }
  return Bs.prototype = Ue, Ue.Parser = Bs, new Bs();
}();
yk.parser = yk;
const z8 = yk, Ihe = (e, t) => {
  var n, r;
  return ((n = t == null ? void 0 : t.flowchart) == null ? void 0 : n.defaultRenderer) === "dagre-wrapper" || ((r = t == null ? void 0 : t.flowchart) == null ? void 0 : r.defaultRenderer) === "elk" ? !1 : e.match(/^\s*graph/) !== null;
}, Nhe = (e, t) => {
  var n, r;
  return ((n = t == null ? void 0 : t.flowchart) == null ? void 0 : n.defaultRenderer) === "dagre-d3" || ((r = t == null ? void 0 : t.flowchart) == null ? void 0 : r.defaultRenderer) === "elk" ? !1 : e.match(/^\s*graph/) !== null ? !0 : e.match(/^\s*flowchart/) !== null;
}, Bhe = "flowchart-";
let q8 = 0, V5 = J(), cn = {}, vc = [], hh = {}, ga = [], p2 = {}, Y5 = {}, mg = 0, bk = !0, Di, Hy, Ky = [];
const Jy = (e) => de.sanitizeText(e, V5), kQ = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, o0 = function(e) {
  const t = Object.keys(cn);
  for (const n of t)
    if (cn[n].id === e)
      return cn[n].domId;
  return e;
}, wQ = function(e, t, n, r, i, s, o = {}) {
  let a, l = e;
  l !== void 0 && l.trim().length !== 0 && (cn[l] === void 0 && (cn[l] = {
    id: l,
    domId: Bhe + l + "-" + q8,
    styles: [],
    classes: []
  }), q8++, t !== void 0 ? (V5 = J(), a = Jy(t.trim()), a[0] === '"' && a[a.length - 1] === '"' && (a = a.substring(1, a.length - 1)), cn[l].text = a) : cn[l].text === void 0 && (cn[l].text = e), n !== void 0 && (cn[l].type = n), r != null && r.forEach(function(h) {
    cn[l].styles.push(h);
  }), i != null && i.forEach(function(h) {
    cn[l].classes.push(h);
  }), s !== void 0 && (cn[l].dir = s), cn[l].props === void 0 ? cn[l].props = o : o !== void 0 && Object.assign(cn[l].props, o));
}, SQ = function(e, t, n, r) {
  const o = { start: e, end: t, type: void 0, text: "" };
  r = n.text, r !== void 0 && (o.text = Jy(r.trim()), o.text[0] === '"' && o.text[o.text.length - 1] === '"' && (o.text = o.text.substring(1, o.text.length - 1))), n !== void 0 && (o.type = n.type, o.stroke = n.stroke, o.length = n.length), vc.push(o);
}, CQ = function(e, t, n, r) {
  let i, s;
  for (i = 0; i < e.length; i++)
    for (s = 0; s < t.length; s++)
      SQ(e[i], t[s], n, r);
}, TQ = function(e, t) {
  e.forEach(function(n) {
    n === "default" ? vc.defaultInterpolate = t : vc[n].interpolate = t;
  });
}, EQ = function(e, t) {
  e.forEach(function(n) {
    n === "default" ? vc.defaultStyle = t : (fe.isSubstringInArray("fill", t) === -1 && t.push("fill:none"), vc[n].style = t);
  });
}, AQ = function(e, t) {
  hh[e] === void 0 && (hh[e] = { id: e, styles: [], textStyles: [] }), t != null && t.forEach(function(n) {
    if (n.match("color")) {
      const i = n.replace("fill", "bgFill").replace("color", "fill");
      hh[e].textStyles.push(i);
    }
    hh[e].styles.push(n);
  });
}, PQ = function(e) {
  Di = e, Di.match(/.*</) && (Di = "RL"), Di.match(/.*\^/) && (Di = "BT"), Di.match(/.*>/) && (Di = "LR"), Di.match(/.*v/) && (Di = "TB"), Di === "TD" && (Di = "TB");
}, tb = function(e, t) {
  e.split(",").forEach(function(n) {
    let r = n;
    cn[r] !== void 0 && cn[r].classes.push(t), p2[r] !== void 0 && p2[r].classes.push(t);
  });
}, Fhe = function(e, t) {
  e.split(",").forEach(function(n) {
    t !== void 0 && (Y5[Hy === "gen-1" ? o0(n) : n] = Jy(t));
  });
}, Qhe = function(e, t, n) {
  let r = o0(e);
  if (J().securityLevel !== "loose" || t === void 0)
    return;
  let i = [];
  if (typeof n == "string") {
    i = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let s = 0; s < i.length; s++) {
      let o = i[s].trim();
      o.charAt(0) === '"' && o.charAt(o.length - 1) === '"' && (o = o.substr(1, o.length - 2)), i[s] = o;
    }
  }
  i.length === 0 && i.push(e), cn[e] !== void 0 && (cn[e].haveCallback = !0, Ky.push(function() {
    const s = document.querySelector(`[id="${r}"]`);
    s !== null && s.addEventListener(
      "click",
      function() {
        fe.runFunc(t, ...i);
      },
      !1
    );
  }));
}, DQ = function(e, t, n) {
  e.split(",").forEach(function(r) {
    cn[r] !== void 0 && (cn[r].link = fe.formatUrl(t, V5), cn[r].linkTarget = n);
  }), tb(e, "clickable");
}, LQ = function(e) {
  return Y5[e];
}, MQ = function(e, t, n) {
  e.split(",").forEach(function(r) {
    Qhe(r, t, n);
  }), tb(e, "clickable");
}, RQ = function(e) {
  Ky.forEach(function(t) {
    t(e);
  });
}, $Q = function() {
  return Di.trim();
}, IQ = function() {
  return cn;
}, NQ = function() {
  return vc;
}, BQ = function() {
  return hh;
}, FQ = function(e) {
  let t = wt(".mermaidTooltip");
  (t._groups || t)[0][0] === null && (t = wt("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), wt(e).select("svg").selectAll("g.node").on("mouseover", function() {
    const i = wt(this);
    if (i.attr("title") === null)
      return;
    const o = this.getBoundingClientRect();
    t.transition().duration(200).style("opacity", ".9"), t.text(i.attr("title")).style("left", window.scrollX + o.left + (o.right - o.left) / 2 + "px").style("top", window.scrollY + o.top - 14 + document.body.scrollTop + "px"), t.html(t.html().replace(/&lt;br\/&gt;/g, "<br/>")), i.classed("hover", !0);
  }).on("mouseout", function() {
    t.transition().duration(500).style("opacity", 0), wt(this).classed("hover", !1);
  });
};
Ky.push(FQ);
const QQ = function(e = "gen-1") {
  cn = {}, hh = {}, vc = [], Ky = [FQ], ga = [], p2 = {}, mg = 0, Y5 = [], bk = !0, Hy = e, _i();
}, ZQ = (e) => {
  Hy = e || "gen-2";
}, VQ = function() {
  return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
}, YQ = function(e, t, n) {
  let r = e.trim(), i = n;
  e === n && n.match(/\s/) && (r = void 0);
  function s(u) {
    const f = { boolean: {}, number: {}, string: {} }, d = [];
    let p;
    return { nodeList: u.filter(function(m) {
      const y = typeof m;
      return m.stmt && m.stmt === "dir" ? (p = m.value, !1) : m.trim() === "" ? !1 : y in f ? f[y].hasOwnProperty(m) ? !1 : f[y][m] = !0 : d.includes(m) ? !1 : d.push(m);
    }), dir: p };
  }
  let o = [];
  const { nodeList: a, dir: l } = s(o.concat.apply(o, t));
  if (o = a, Hy === "gen-1")
    for (let u = 0; u < o.length; u++)
      o[u] = o0(o[u]);
  r = r || "subGraph" + mg, i = i || "", i = Jy(i), mg = mg + 1;
  const h = { id: r, nodes: o, title: i.trim(), classes: [], dir: l };
  return B.info("Adding", h.id, h.nodes, h.dir), h.nodes = KQ(h, ga).nodes, ga.push(h), p2[r] = h, r;
}, Zhe = function(e) {
  for (const [t, n] of ga.entries())
    if (n.id === e)
      return t;
  return -1;
};
let If = -1;
const zQ = [], qQ = function(e, t) {
  const n = ga[t].nodes;
  if (If = If + 1, If > 2e3)
    return;
  if (zQ[If] = t, ga[t].id === e)
    return {
      result: !0,
      count: 0
    };
  let r = 0, i = 1;
  for (; r < n.length; ) {
    const s = Zhe(n[r]);
    if (s >= 0) {
      const o = qQ(e, s);
      if (o.result)
        return {
          result: !0,
          count: i + o.count
        };
      i = i + o.count;
    }
    r = r + 1;
  }
  return {
    result: !1,
    count: i
  };
}, WQ = function(e) {
  return zQ[e];
}, UQ = function() {
  If = -1, ga.length > 0 && qQ("none", ga.length - 1);
}, jQ = function() {
  return ga;
}, XQ = () => bk ? (bk = !1, !0) : !1, Vhe = (e) => {
  let t = e.trim(), n = "arrow_open";
  switch (t[0]) {
    case "<":
      n = "arrow_point", t = t.slice(1);
      break;
    case "x":
      n = "arrow_cross", t = t.slice(1);
      break;
    case "o":
      n = "arrow_circle", t = t.slice(1);
      break;
  }
  let r = "normal";
  return t.includes("=") && (r = "thick"), t.includes(".") && (r = "dotted"), { type: n, stroke: r };
}, Yhe = (e, t) => {
  const n = t.length;
  let r = 0;
  for (let i = 0; i < n; ++i)
    t[i] === e && ++r;
  return r;
}, zhe = (e) => {
  const t = e.trim();
  let n = t.slice(0, -1), r = "arrow_open";
  switch (t.slice(-1)) {
    case "x":
      r = "arrow_cross", t[0] === "x" && (r = "double_" + r, n = n.slice(1));
      break;
    case ">":
      r = "arrow_point", t[0] === "<" && (r = "double_" + r, n = n.slice(1));
      break;
    case "o":
      r = "arrow_circle", t[0] === "o" && (r = "double_" + r, n = n.slice(1));
      break;
  }
  let i = "normal", s = n.length - 1;
  n[0] === "=" && (i = "thick");
  let o = Yhe(".", n);
  return o && (i = "dotted", s = o), { type: r, stroke: i, length: s };
}, GQ = (e, t) => {
  const n = zhe(e);
  let r;
  if (t) {
    if (r = Vhe(t), r.stroke !== n.stroke)
      return { type: "INVALID", stroke: "INVALID" };
    if (r.type === "arrow_open")
      r.type = n.type;
    else {
      if (r.type !== n.type)
        return { type: "INVALID", stroke: "INVALID" };
      r.type = "double_" + r.type;
    }
    return r.type === "double_arrow" && (r.type = "double_arrow_point"), r.length = n.length, r;
  }
  return n;
}, HQ = (e, t) => {
  let n = !1;
  return e.forEach((r) => {
    r.nodes.indexOf(t) >= 0 && (n = !0);
  }), n;
}, KQ = (e, t) => {
  const n = [];
  return e.nodes.forEach((r, i) => {
    HQ(t, r) || n.push(e.nodes[i]);
  }), { nodes: n };
}, JQ = {
  firstGraph: XQ
}, js = {
  parseDirective: kQ,
  defaultConfig: () => mu.flowchart,
  setAccTitle: oi,
  getAccTitle: ki,
  getAccDescription: Si,
  setAccDescription: wi,
  addVertex: wQ,
  lookUpDomId: o0,
  addLink: CQ,
  updateLinkInterpolate: TQ,
  updateLink: EQ,
  addClass: AQ,
  setDirection: PQ,
  setClass: tb,
  setTooltip: Fhe,
  getTooltip: LQ,
  setClickEvent: MQ,
  setLink: DQ,
  bindFunctions: RQ,
  getDirection: $Q,
  getVertices: IQ,
  getEdges: NQ,
  getClasses: BQ,
  clear: QQ,
  setGen: ZQ,
  defaultStyle: VQ,
  addSubGraph: YQ,
  getDepthFirstPos: WQ,
  indexNodes: UQ,
  getSubGraphs: jQ,
  destructLink: GQ,
  lex: JQ,
  exists: HQ,
  makeUniq: KQ,
  setDiagramTitle: Is,
  getDiagramTitle: Ns
}, vge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addClass: AQ,
  addLink: CQ,
  addSingleLink: SQ,
  addSubGraph: YQ,
  addVertex: wQ,
  bindFunctions: RQ,
  clear: QQ,
  default: js,
  defaultStyle: VQ,
  destructLink: GQ,
  firstGraph: XQ,
  getClasses: BQ,
  getDepthFirstPos: WQ,
  getDirection: $Q,
  getEdges: NQ,
  getSubGraphs: jQ,
  getTooltip: LQ,
  getVertices: IQ,
  indexNodes: UQ,
  lex: JQ,
  lookUpDomId: o0,
  parseDirective: kQ,
  setClass: tb,
  setClickEvent: MQ,
  setDirection: PQ,
  setGen: ZQ,
  setLink: DQ,
  updateLink: EQ,
  updateLinkInterpolate: TQ
}, Symbol.toStringTag, { value: "Module" }));
function tZ(e, t, n) {
  const r = t.width, i = t.height, s = (r + i) * 0.9, o = [
    { x: s / 2, y: 0 },
    { x: s, y: -s / 2 },
    { x: s / 2, y: -s },
    { x: 0, y: -s / 2 }
  ], a = ka(e, s, s, o);
  return n.intersect = function(l) {
    return To(n, o, l);
  }, a;
}
function eZ(e, t, n) {
  const i = t.height, s = i / 4, o = t.width + 2 * s, a = [
    { x: s, y: 0 },
    { x: o - s, y: 0 },
    { x: o, y: -i / 2 },
    { x: o - s, y: -i },
    { x: s, y: -i },
    { x: 0, y: -i / 2 }
  ], l = ka(e, o, i, a);
  return n.intersect = function(h) {
    return To(n, a, h);
  }, l;
}
function nZ(e, t, n) {
  const r = t.width, i = t.height, s = [
    { x: -i / 2, y: 0 },
    { x: r, y: 0 },
    { x: r, y: -i },
    { x: -i / 2, y: -i },
    { x: 0, y: -i / 2 }
  ], o = ka(e, r, i, s);
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function rZ(e, t, n) {
  const r = t.width, i = t.height, s = [
    { x: -2 * i / 6, y: 0 },
    { x: r - i / 6, y: 0 },
    { x: r + 2 * i / 6, y: -i },
    { x: i / 6, y: -i }
  ], o = ka(e, r, i, s);
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function iZ(e, t, n) {
  const r = t.width, i = t.height, s = [
    { x: 2 * i / 6, y: 0 },
    { x: r + i / 6, y: 0 },
    { x: r - 2 * i / 6, y: -i },
    { x: -i / 6, y: -i }
  ], o = ka(e, r, i, s);
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function sZ(e, t, n) {
  const r = t.width, i = t.height, s = [
    { x: -2 * i / 6, y: 0 },
    { x: r + 2 * i / 6, y: 0 },
    { x: r - i / 6, y: -i },
    { x: i / 6, y: -i }
  ], o = ka(e, r, i, s);
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function oZ(e, t, n) {
  const r = t.width, i = t.height, s = [
    { x: i / 6, y: 0 },
    { x: r - i / 6, y: 0 },
    { x: r + 2 * i / 6, y: -i },
    { x: -2 * i / 6, y: -i }
  ], o = ka(e, r, i, s);
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function aZ(e, t, n) {
  const r = t.width, i = t.height, s = [
    { x: 0, y: 0 },
    { x: r + i / 2, y: 0 },
    { x: r, y: -i / 2 },
    { x: r + i / 2, y: -i },
    { x: 0, y: -i }
  ], o = ka(e, r, i, s);
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function lZ(e, t, n) {
  const r = t.height, i = t.width + r / 4, s = e.insert("rect", ":first-child").attr("rx", r / 2).attr("ry", r / 2).attr("x", -i / 2).attr("y", -r / 2).attr("width", i).attr("height", r);
  return n.intersect = function(o) {
    return x5(n, o);
  }, s;
}
function cZ(e, t, n) {
  const r = t.width, i = t.height, s = [
    { x: 0, y: 0 },
    { x: r, y: 0 },
    { x: r, y: -i },
    { x: 0, y: -i },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: r + 8, y: 0 },
    { x: r + 8, y: -i },
    { x: -8, y: -i },
    { x: -8, y: 0 }
  ], o = ka(e, r, i, s);
  return n.intersect = function(a) {
    return To(n, s, a);
  }, o;
}
function hZ(e, t, n) {
  const r = t.width, i = r / 2, s = i / (2.5 + r / 50), o = t.height + s, a = "M 0," + s + " a " + i + "," + s + " 0,0,0 " + r + " 0 a " + i + "," + s + " 0,0,0 " + -r + " 0 l 0," + o + " a " + i + "," + s + " 0,0,0 " + r + " 0 l 0," + -o, l = e.attr("label-offset-y", s).insert("path", ":first-child").attr("d", a).attr("transform", "translate(" + -r / 2 + "," + -(o / 2 + s) + ")");
  return n.intersect = function(h) {
    const u = x5(n, h), f = u.x - n.x;
    if (i != 0 && (Math.abs(f) < n.width / 2 || Math.abs(f) == n.width / 2 && Math.abs(u.y - n.y) > n.height / 2 - s)) {
      let d = s * s * (1 - f * f / (i * i));
      d != 0 && (d = Math.sqrt(d)), d = s - d, h.y - n.y > 0 && (d = -d), u.y += d;
    }
    return u;
  }, l;
}
function qhe(e) {
  e.shapes().question = tZ, e.shapes().hexagon = eZ, e.shapes().stadium = lZ, e.shapes().subroutine = cZ, e.shapes().cylinder = hZ, e.shapes().rect_left_inv_arrow = nZ, e.shapes().lean_right = rZ, e.shapes().lean_left = iZ, e.shapes().trapezoid = sZ, e.shapes().inv_trapezoid = oZ, e.shapes().rect_right_inv_arrow = aZ;
}
function Whe(e) {
  e({ question: tZ }), e({ hexagon: eZ }), e({ stadium: lZ }), e({ subroutine: cZ }), e({ cylinder: hZ }), e({ rect_left_inv_arrow: nZ }), e({ lean_right: rZ }), e({ lean_left: iZ }), e({ trapezoid: sZ }), e({ inv_trapezoid: oZ }), e({ rect_right_inv_arrow: aZ });
}
function ka(e, t, n, r) {
  return e.insert("polygon", ":first-child").attr(
    "points",
    r.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("transform", "translate(" + -t / 2 + "," + n / 2 + ")");
}
const Uhe = {
  addToRender: qhe,
  addToRenderV2: Whe
}, uZ = {}, jhe = function(e) {
  const t = Object.keys(e);
  for (const n of t)
    uZ[n] = e[n];
}, fZ = function(e, t, n, r, i, s) {
  const o = r ? r.select(`[id="${n}"]`) : wt(`[id="${n}"]`), a = i || document;
  Object.keys(e).forEach(function(h) {
    const u = e[h];
    let f = "default";
    u.classes.length > 0 && (f = u.classes.join(" "));
    const d = ul(u.styles);
    let p = u.text !== void 0 ? u.text : u.id, g;
    if (ar(J().flowchart.htmlLabels)) {
      const O = {
        label: p.replace(
          /fa[blrs]?:fa-[\w-]+/g,
          (x) => `<i class='${x.replace(":", " ")}'></i>`
        )
      };
      g = b5(o, O).node(), g.parentNode.removeChild(g);
    } else {
      const O = a.createElementNS("http://www.w3.org/2000/svg", "text");
      O.setAttribute("style", d.labelStyle.replace("color:", "fill:"));
      const x = p.split(de.lineBreakRegex);
      for (const _ of x) {
        const w = a.createElementNS("http://www.w3.org/2000/svg", "tspan");
        w.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), w.setAttribute("dy", "1em"), w.setAttribute("x", "1"), w.textContent = _, O.appendChild(w);
      }
      g = O;
    }
    let m = 0, y = "";
    switch (u.type) {
      case "round":
        m = 5, y = "rect";
        break;
      case "square":
        y = "rect";
        break;
      case "diamond":
        y = "question";
        break;
      case "hexagon":
        y = "hexagon";
        break;
      case "odd":
        y = "rect_left_inv_arrow";
        break;
      case "lean_right":
        y = "lean_right";
        break;
      case "lean_left":
        y = "lean_left";
        break;
      case "trapezoid":
        y = "trapezoid";
        break;
      case "inv_trapezoid":
        y = "inv_trapezoid";
        break;
      case "odd_right":
        y = "rect_left_inv_arrow";
        break;
      case "circle":
        y = "circle";
        break;
      case "ellipse":
        y = "ellipse";
        break;
      case "stadium":
        y = "stadium";
        break;
      case "subroutine":
        y = "subroutine";
        break;
      case "cylinder":
        y = "cylinder";
        break;
      case "group":
        y = "rect";
        break;
      default:
        y = "rect";
    }
    B.warn("Adding node", u.id, u.domId), t.setNode(s.db.lookUpDomId(u.id), {
      labelType: "svg",
      labelStyle: d.labelStyle,
      shape: y,
      label: g,
      rx: m,
      ry: m,
      class: f,
      style: d.style,
      id: s.db.lookUpDomId(u.id)
    });
  });
}, dZ = function(e, t, n) {
  let r = 0, i, s;
  if (e.defaultStyle !== void 0) {
    const o = ul(e.defaultStyle);
    i = o.style, s = o.labelStyle;
  }
  e.forEach(function(o) {
    r++;
    var a = "L-" + o.start + "-" + o.end, l = "LS-" + o.start, h = "LE-" + o.end;
    const u = {};
    o.type === "arrow_open" ? u.arrowhead = "none" : u.arrowhead = "normal";
    let f = "", d = "";
    if (o.style !== void 0) {
      const p = ul(o.style);
      f = p.style, d = p.labelStyle;
    } else
      switch (o.stroke) {
        case "normal":
          f = "fill:none", i !== void 0 && (f = i), s !== void 0 && (d = s);
          break;
        case "dotted":
          f = "fill:none;stroke-width:2px;stroke-dasharray:3;";
          break;
        case "thick":
          f = " stroke-width: 3.5px;fill:none";
          break;
      }
    u.style = f, u.labelStyle = d, o.interpolate !== void 0 ? u.curve = ms(o.interpolate, Oi) : e.defaultInterpolate !== void 0 ? u.curve = ms(e.defaultInterpolate, Oi) : u.curve = ms(uZ.curve, Oi), o.text === void 0 ? o.style !== void 0 && (u.arrowheadStyle = "fill: #333") : (u.arrowheadStyle = "fill: #333", u.labelpos = "c", ar(J().flowchart.htmlLabels) ? (u.labelType = "html", u.label = `<span id="L-${a}" class="edgeLabel L-${l}' L-${h}" style="${u.labelStyle}">${o.text.replace(
      /fa[blrs]?:fa-[\w-]+/g,
      (p) => `<i class='${p.replace(":", " ")}'></i>`
    )}</span>`) : (u.labelType = "text", u.label = o.text.replace(de.lineBreakRegex, `
`), o.style === void 0 && (u.style = u.style || "stroke: #333; stroke-width: 1.5px;fill:none"), u.labelStyle = u.labelStyle.replace("color:", "fill:"))), u.id = a, u.class = l + " " + h, u.minlen = o.length || 1, t.setEdge(n.db.lookUpDomId(o.start), n.db.lookUpDomId(o.end), u, r);
  });
}, Xhe = function(e, t) {
  B.info("Extracting classes"), t.db.clear();
  try {
    return t.parse(e), t.db.getClasses();
  } catch (n) {
    return B.error(n), {};
  }
}, Ghe = function(e, t, n, r) {
  B.info("Drawing flowchart"), r.db.clear();
  const { securityLevel: i, flowchart: s } = J();
  let o;
  i === "sandbox" && (o = wt("#i" + t));
  const a = wt(i === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), l = i === "sandbox" ? o.nodes()[0].contentDocument : document;
  try {
    r.parser.parse(e);
  } catch {
    B.debug("Parsing failed");
  }
  let h = r.db.getDirection();
  h === void 0 && (h = "TD");
  const u = s.nodeSpacing || 50, f = s.rankSpacing || 50, d = new zn({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: h,
    nodesep: u,
    ranksep: f,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let p;
  const g = r.db.getSubGraphs();
  for (let T = g.length - 1; T >= 0; T--)
    p = g[T], r.db.addVertex(p.id, p.title, "group", void 0, p.classes);
  const m = r.db.getVertices();
  B.warn("Get vertices", m);
  const y = r.db.getEdges();
  let O = 0;
  for (O = g.length - 1; O >= 0; O--) {
    p = g[O], Z3("cluster").append("text");
    for (let T = 0; T < p.nodes.length; T++)
      B.warn(
        "Setting subgraph",
        p.nodes[T],
        r.db.lookUpDomId(p.nodes[T]),
        r.db.lookUpDomId(p.id)
      ), d.setParent(r.db.lookUpDomId(p.nodes[T]), r.db.lookUpDomId(p.id));
  }
  fZ(m, d, t, a, l, r), dZ(y, d, r);
  const x = new Qre();
  Uhe.addToRender(x), x.arrows().none = function(S, R, A, P) {
    const k = S.append("marker").attr("id", R).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M 0 0 L 0 0 L 0 0 z");
    Co(k, A[P + "Style"]);
  }, x.arrows().normal = function(S, R) {
    S.append("marker").attr("id", R).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowheadPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  };
  const _ = a.select(`[id="${t}"]`), w = a.select("#" + t + " g");
  for (x(w, d), w.selectAll("g.node").attr("title", function() {
    return r.db.getTooltip(this.id);
  }), r.db.indexNodes("subGraph" + O), O = 0; O < g.length; O++)
    if (p = g[O], p.title !== "undefined") {
      const T = l.querySelectorAll(
        "#" + t + ' [id="' + r.db.lookUpDomId(p.id) + '"] rect'
      ), S = l.querySelectorAll(
        "#" + t + ' [id="' + r.db.lookUpDomId(p.id) + '"]'
      ), R = T[0].x.baseVal.value, A = T[0].y.baseVal.value, P = T[0].width.baseVal.value, k = wt(S[0]).select(".label");
      k.attr("transform", `translate(${R + P / 2}, ${A + 14})`), k.attr("id", t + "Text");
      for (let D = 0; D < p.classes.length; D++)
        S[0].classList.add(p.classes[D]);
    }
  if (!s.htmlLabels) {
    const T = l.querySelectorAll('[id="' + t + '"] .edgeLabel .label');
    for (const S of T) {
      const R = S.getBBox(), A = l.createElementNS("http://www.w3.org/2000/svg", "rect");
      A.setAttribute("rx", 0), A.setAttribute("ry", 0), A.setAttribute("width", R.width), A.setAttribute("height", R.height), S.insertBefore(A, S.firstChild);
    }
  }
  Xy(d, _, s.diagramPadding, s.useMaxWidth), Object.keys(m).forEach(function(T) {
    const S = m[T];
    if (S.link) {
      const R = a.select("#" + t + ' [id="' + r.db.lookUpDomId(T) + '"]');
      if (R) {
        const A = l.createElementNS("http://www.w3.org/2000/svg", "a");
        A.setAttributeNS("http://www.w3.org/2000/svg", "class", S.classes.join(" ")), A.setAttributeNS("http://www.w3.org/2000/svg", "href", S.link), A.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), i === "sandbox" ? A.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : S.linkTarget && A.setAttributeNS("http://www.w3.org/2000/svg", "target", S.linkTarget);
        const P = R.insert(function() {
          return A;
        }, ":first-child"), C = R.select(".label-container");
        C && P.append(function() {
          return C.node();
        });
        const k = R.select(".label");
        k && P.append(function() {
          return k.node();
        });
      }
    }
  });
}, Hhe = {
  setConf: jhe,
  addVertices: fZ,
  addEdges: dZ,
  getClasses: Xhe,
  draw: Ghe
}, pZ = {}, Khe = function(e) {
  const t = Object.keys(e);
  for (const n of t)
    pZ[n] = e[n];
}, gZ = function(e, t, n, r, i, s) {
  const o = r.select(`[id="${n}"]`);
  Object.keys(e).forEach(function(l) {
    const h = e[l];
    let u = "default";
    h.classes.length > 0 && (u = h.classes.join(" "));
    const f = ul(h.styles);
    let d = h.text !== void 0 ? h.text : h.id, p;
    if (ar(J().flowchart.htmlLabels)) {
      const y = {
        label: d.replace(
          /fa[blrs]?:fa-[\w-]+/g,
          (O) => `<i class='${O.replace(":", " ")}'></i>`
        )
      };
      p = b5(o, y).node(), p.parentNode.removeChild(p);
    } else {
      const y = i.createElementNS("http://www.w3.org/2000/svg", "text");
      y.setAttribute("style", f.labelStyle.replace("color:", "fill:"));
      const O = d.split(de.lineBreakRegex);
      for (const x of O) {
        const _ = i.createElementNS("http://www.w3.org/2000/svg", "tspan");
        _.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), _.setAttribute("dy", "1em"), _.setAttribute("x", "1"), _.textContent = x, y.appendChild(_);
      }
      p = y;
    }
    let g = 0, m = "";
    switch (h.type) {
      case "round":
        g = 5, m = "rect";
        break;
      case "square":
        m = "rect";
        break;
      case "diamond":
        m = "question";
        break;
      case "hexagon":
        m = "hexagon";
        break;
      case "odd":
        m = "rect_left_inv_arrow";
        break;
      case "lean_right":
        m = "lean_right";
        break;
      case "lean_left":
        m = "lean_left";
        break;
      case "trapezoid":
        m = "trapezoid";
        break;
      case "inv_trapezoid":
        m = "inv_trapezoid";
        break;
      case "odd_right":
        m = "rect_left_inv_arrow";
        break;
      case "circle":
        m = "circle";
        break;
      case "ellipse":
        m = "ellipse";
        break;
      case "stadium":
        m = "stadium";
        break;
      case "subroutine":
        m = "subroutine";
        break;
      case "cylinder":
        m = "cylinder";
        break;
      case "group":
        m = "rect";
        break;
      case "doublecircle":
        m = "doublecircle";
        break;
      default:
        m = "rect";
    }
    t.setNode(h.id, {
      labelStyle: f.labelStyle,
      shape: m,
      labelText: d,
      rx: g,
      ry: g,
      class: u,
      style: f.style,
      id: h.id,
      link: h.link,
      linkTarget: h.linkTarget,
      tooltip: s.db.getTooltip(h.id) || "",
      domId: s.db.lookUpDomId(h.id),
      haveCallback: h.haveCallback,
      width: h.type === "group" ? 500 : void 0,
      dir: h.dir,
      type: h.type,
      props: h.props,
      padding: J().flowchart.padding
    }), B.info("setNode", {
      labelStyle: f.labelStyle,
      shape: m,
      labelText: d,
      rx: g,
      ry: g,
      class: u,
      style: f.style,
      id: h.id,
      domId: s.db.lookUpDomId(h.id),
      width: h.type === "group" ? 500 : void 0,
      type: h.type,
      dir: h.dir,
      props: h.props,
      padding: J().flowchart.padding
    });
  });
}, mZ = function(e, t, n) {
  B.info("abc78 edges = ", e);
  let r = 0, i = {}, s, o;
  if (e.defaultStyle !== void 0) {
    const a = ul(e.defaultStyle);
    s = a.style, o = a.labelStyle;
  }
  e.forEach(function(a) {
    r++;
    var l = "L-" + a.start + "-" + a.end;
    i[l] === void 0 ? (i[l] = 0, B.info("abc78 new entry", l, i[l])) : (i[l]++, B.info("abc78 new entry", l, i[l]));
    let h = l + "-" + i[l];
    B.info("abc78 new link id to be used is", l, h, i[l]);
    var u = "LS-" + a.start, f = "LE-" + a.end;
    const d = { style: "", labelStyle: "" };
    switch (d.minlen = a.length || 1, a.type === "arrow_open" ? d.arrowhead = "none" : d.arrowhead = "normal", d.arrowTypeStart = "arrow_open", d.arrowTypeEnd = "arrow_open", a.type) {
      case "double_arrow_cross":
        d.arrowTypeStart = "arrow_cross";
      case "arrow_cross":
        d.arrowTypeEnd = "arrow_cross";
        break;
      case "double_arrow_point":
        d.arrowTypeStart = "arrow_point";
      case "arrow_point":
        d.arrowTypeEnd = "arrow_point";
        break;
      case "double_arrow_circle":
        d.arrowTypeStart = "arrow_circle";
      case "arrow_circle":
        d.arrowTypeEnd = "arrow_circle";
        break;
    }
    let p = "", g = "";
    switch (a.stroke) {
      case "normal":
        p = "fill:none;", s !== void 0 && (p = s), o !== void 0 && (g = o), d.thickness = "normal", d.pattern = "solid";
        break;
      case "dotted":
        d.thickness = "normal", d.pattern = "dotted", d.style = "fill:none;stroke-width:2px;stroke-dasharray:3;";
        break;
      case "thick":
        d.thickness = "thick", d.pattern = "solid", d.style = "stroke-width: 3.5px;fill:none;";
        break;
    }
    if (a.style !== void 0) {
      const m = ul(a.style);
      p = m.style, g = m.labelStyle;
    }
    d.style = d.style += p, d.labelStyle = d.labelStyle += g, a.interpolate !== void 0 ? d.curve = ms(a.interpolate, Oi) : e.defaultInterpolate !== void 0 ? d.curve = ms(e.defaultInterpolate, Oi) : d.curve = ms(pZ.curve, Oi), a.text === void 0 ? a.style !== void 0 && (d.arrowheadStyle = "fill: #333") : (d.arrowheadStyle = "fill: #333", d.labelpos = "c"), d.labelType = "text", d.label = a.text.replace(de.lineBreakRegex, `
`), a.style === void 0 && (d.style = d.style || "stroke: #333; stroke-width: 1.5px;fill:none;"), d.labelStyle = d.labelStyle.replace("color:", "fill:"), d.id = h, d.classes = "flowchart-link " + u + " " + f, t.setEdge(a.start, a.end, d, r);
  });
}, Jhe = function(e, t) {
  B.info("Extracting classes"), t.db.clear();
  try {
    return t.parse(e), t.db.getClasses();
  } catch {
    return;
  }
}, tue = function(e, t, n, r) {
  B.info("Drawing flowchart"), r.db.clear(), js.setGen("gen-2"), r.parser.parse(e);
  let i = r.db.getDirection();
  i === void 0 && (i = "TD");
  const { securityLevel: s, flowchart: o } = J(), a = o.nodeSpacing || 50, l = o.rankSpacing || 50;
  let h;
  s === "sandbox" && (h = wt("#i" + t));
  const u = wt(s === "sandbox" ? h.nodes()[0].contentDocument.body : "body"), f = s === "sandbox" ? h.nodes()[0].contentDocument : document, d = new zn({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: i,
    nodesep: a,
    ranksep: l,
    marginx: 0,
    marginy: 0
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let p;
  const g = r.db.getSubGraphs();
  B.info("Subgraphs - ", g);
  for (let E = g.length - 1; E >= 0; E--)
    p = g[E], B.info("Subgraph - ", p), r.db.addVertex(p.id, p.title, "group", void 0, p.classes, p.dir);
  const m = r.db.getVertices(), y = r.db.getEdges();
  B.info("Edges", y);
  let O = 0;
  for (O = g.length - 1; O >= 0; O--) {
    p = g[O], Z3("cluster").append("text");
    for (let E = 0; E < p.nodes.length; E++)
      B.info("Setting up subgraphs", p.nodes[E], p.id), d.setParent(p.nodes[E], p.id);
  }
  gZ(m, d, t, u, f, r), mZ(y, d);
  const x = u.select(`[id="${t}"]`), _ = u.select("#" + t + " g");
  if (Q5(_, d, ["point", "circle", "cross"], "flowchart", t), fe.insertTitle(x, "flowchartTitleText", o.titleTopMargin, r.db.getDiagramTitle()), Xy(d, x, o.diagramPadding, o.useMaxWidth), r.db.indexNodes("subGraph" + O), !o.htmlLabels) {
    const E = f.querySelectorAll('[id="' + t + '"] .edgeLabel .label');
    for (const T of E) {
      const S = T.getBBox(), R = f.createElementNS("http://www.w3.org/2000/svg", "rect");
      R.setAttribute("rx", 0), R.setAttribute("ry", 0), R.setAttribute("width", S.width), R.setAttribute("height", S.height), T.insertBefore(R, T.firstChild);
    }
  }
  Object.keys(m).forEach(function(E) {
    const T = m[E];
    if (T.link) {
      const S = wt("#" + t + ' [id="' + E + '"]');
      if (S) {
        const R = f.createElementNS("http://www.w3.org/2000/svg", "a");
        R.setAttributeNS("http://www.w3.org/2000/svg", "class", T.classes.join(" ")), R.setAttributeNS("http://www.w3.org/2000/svg", "href", T.link), R.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), s === "sandbox" ? R.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : T.linkTarget && R.setAttributeNS("http://www.w3.org/2000/svg", "target", T.linkTarget);
        const A = S.insert(function() {
          return R;
        }, ":first-child"), P = S.select(".label-container");
        P && A.append(function() {
          return P.node();
        });
        const C = S.select(".label");
        C && A.append(function() {
          return C.node();
        });
      }
    }
  });
}, Ox = {
  setConf: Khe,
  addVertices: gZ,
  addEdges: mZ,
  getClasses: Jhe,
  draw: tue
};
var Ok = function() {
  var e = function(R, A, P, C) {
    for (P = P || {}, C = R.length; C--; P[R[C]] = A)
      ;
    return P;
  }, t = [1, 3], n = [1, 5], r = [7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 25, 26, 28, 35, 40], i = [1, 15], s = [1, 16], o = [1, 17], a = [1, 18], l = [1, 19], h = [1, 20], u = [1, 21], f = [1, 22], d = [1, 23], p = [1, 24], g = [1, 25], m = [1, 26], y = [1, 27], O = [1, 29], x = [1, 31], _ = [1, 34], w = [5, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 25, 26, 28, 35, 40], E = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, directive: 4, gantt: 5, document: 6, EOF: 7, line: 8, SPACE: 9, statement: 10, NL: 11, dateFormat: 12, inclusiveEndDates: 13, topAxis: 14, axisFormat: 15, tickInterval: 16, excludes: 17, includes: 18, todayMarker: 19, title: 20, acc_title: 21, acc_title_value: 22, acc_descr: 23, acc_descr_value: 24, acc_descr_multiline_value: 25, section: 26, clickStatement: 27, taskTxt: 28, taskData: 29, openDirective: 30, typeDirective: 31, closeDirective: 32, ":": 33, argDirective: 34, click: 35, callbackname: 36, callbackargs: 37, href: 38, clickStatementDebug: 39, open_directive: 40, type_directive: 41, arg_directive: 42, close_directive: 43, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "gantt", 7: "EOF", 9: "SPACE", 11: "NL", 12: "dateFormat", 13: "inclusiveEndDates", 14: "topAxis", 15: "axisFormat", 16: "tickInterval", 17: "excludes", 18: "includes", 19: "todayMarker", 20: "title", 21: "acc_title", 22: "acc_title_value", 23: "acc_descr", 24: "acc_descr_value", 25: "acc_descr_multiline_value", 26: "section", 28: "taskTxt", 29: "taskData", 33: ":", 35: "click", 36: "callbackname", 37: "callbackargs", 38: "href", 40: "open_directive", 41: "type_directive", 42: "arg_directive", 43: "close_directive" },
    productions_: [0, [3, 2], [3, 3], [6, 0], [6, 2], [8, 2], [8, 1], [8, 1], [8, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [10, 2], [10, 1], [4, 4], [4, 6], [27, 2], [27, 3], [27, 3], [27, 4], [27, 3], [27, 4], [27, 2], [39, 2], [39, 3], [39, 3], [39, 4], [39, 3], [39, 4], [39, 2], [30, 1], [31, 1], [34, 1], [32, 1]],
    performAction: function(A, P, C, k, D, b, M) {
      var v = b.length - 1;
      switch (D) {
        case 2:
          return b[v - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          b[v - 1].push(b[v]), this.$ = b[v - 1];
          break;
        case 5:
        case 6:
          this.$ = b[v];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 9:
          k.setDateFormat(b[v].substr(11)), this.$ = b[v].substr(11);
          break;
        case 10:
          k.enableInclusiveEndDates(), this.$ = b[v].substr(18);
          break;
        case 11:
          k.TopAxis(), this.$ = b[v].substr(8);
          break;
        case 12:
          k.setAxisFormat(b[v].substr(11)), this.$ = b[v].substr(11);
          break;
        case 13:
          k.setTickInterval(b[v].substr(13)), this.$ = b[v].substr(13);
          break;
        case 14:
          k.setExcludes(b[v].substr(9)), this.$ = b[v].substr(9);
          break;
        case 15:
          k.setIncludes(b[v].substr(9)), this.$ = b[v].substr(9);
          break;
        case 16:
          k.setTodayMarker(b[v].substr(12)), this.$ = b[v].substr(12);
          break;
        case 17:
          k.setDiagramTitle(b[v].substr(6)), this.$ = b[v].substr(6);
          break;
        case 18:
          this.$ = b[v].trim(), k.setAccTitle(this.$);
          break;
        case 19:
        case 20:
          this.$ = b[v].trim(), k.setAccDescription(this.$);
          break;
        case 21:
          k.addSection(b[v].substr(8)), this.$ = b[v].substr(8);
          break;
        case 23:
          k.addTask(b[v - 1], b[v]), this.$ = "task";
          break;
        case 27:
          this.$ = b[v - 1], k.setClickEvent(b[v - 1], b[v], null);
          break;
        case 28:
          this.$ = b[v - 2], k.setClickEvent(b[v - 2], b[v - 1], b[v]);
          break;
        case 29:
          this.$ = b[v - 2], k.setClickEvent(b[v - 2], b[v - 1], null), k.setLink(b[v - 2], b[v]);
          break;
        case 30:
          this.$ = b[v - 3], k.setClickEvent(b[v - 3], b[v - 2], b[v - 1]), k.setLink(b[v - 3], b[v]);
          break;
        case 31:
          this.$ = b[v - 2], k.setClickEvent(b[v - 2], b[v], null), k.setLink(b[v - 2], b[v - 1]);
          break;
        case 32:
          this.$ = b[v - 3], k.setClickEvent(b[v - 3], b[v - 1], b[v]), k.setLink(b[v - 3], b[v - 2]);
          break;
        case 33:
          this.$ = b[v - 1], k.setLink(b[v - 1], b[v]);
          break;
        case 34:
        case 40:
          this.$ = b[v - 1] + " " + b[v];
          break;
        case 35:
        case 36:
        case 38:
          this.$ = b[v - 2] + " " + b[v - 1] + " " + b[v];
          break;
        case 37:
        case 39:
          this.$ = b[v - 3] + " " + b[v - 2] + " " + b[v - 1] + " " + b[v];
          break;
        case 41:
          k.parseDirective("%%{", "open_directive");
          break;
        case 42:
          k.parseDirective(b[v], "type_directive");
          break;
        case 43:
          b[v] = b[v].trim().replace(/'/g, '"'), k.parseDirective(b[v], "arg_directive");
          break;
        case 44:
          k.parseDirective("}%%", "close_directive", "gantt");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: t, 30: 4, 40: n }, { 1: [3] }, { 3: 6, 4: 2, 5: t, 30: 4, 40: n }, e(r, [2, 3], { 6: 7 }), { 31: 8, 41: [1, 9] }, { 41: [2, 41] }, { 1: [2, 1] }, { 4: 30, 7: [1, 10], 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: i, 13: s, 14: o, 15: a, 16: l, 17: h, 18: u, 19: f, 20: d, 21: p, 23: g, 25: m, 26: y, 27: 28, 28: O, 30: 4, 35: x, 40: n }, { 32: 32, 33: [1, 33], 43: _ }, e([33, 43], [2, 42]), e(r, [2, 8], { 1: [2, 2] }), e(r, [2, 4]), { 4: 30, 10: 35, 12: i, 13: s, 14: o, 15: a, 16: l, 17: h, 18: u, 19: f, 20: d, 21: p, 23: g, 25: m, 26: y, 27: 28, 28: O, 30: 4, 35: x, 40: n }, e(r, [2, 6]), e(r, [2, 7]), e(r, [2, 9]), e(r, [2, 10]), e(r, [2, 11]), e(r, [2, 12]), e(r, [2, 13]), e(r, [2, 14]), e(r, [2, 15]), e(r, [2, 16]), e(r, [2, 17]), { 22: [1, 36] }, { 24: [1, 37] }, e(r, [2, 20]), e(r, [2, 21]), e(r, [2, 22]), { 29: [1, 38] }, e(r, [2, 24]), { 36: [1, 39], 38: [1, 40] }, { 11: [1, 41] }, { 34: 42, 42: [1, 43] }, { 11: [2, 44] }, e(r, [2, 5]), e(r, [2, 18]), e(r, [2, 19]), e(r, [2, 23]), e(r, [2, 27], { 37: [1, 44], 38: [1, 45] }), e(r, [2, 33], { 36: [1, 46] }), e(w, [2, 25]), { 32: 47, 43: _ }, { 43: [2, 43] }, e(r, [2, 28], { 38: [1, 48] }), e(r, [2, 29]), e(r, [2, 31], { 37: [1, 49] }), { 11: [1, 50] }, e(r, [2, 30]), e(r, [2, 32]), e(w, [2, 26])],
    defaultActions: { 5: [2, 41], 6: [2, 1], 34: [2, 44], 43: [2, 43] },
    parseError: function(A, P) {
      if (P.recoverable)
        this.trace(A);
      else {
        var C = new Error(A);
        throw C.hash = P, C;
      }
    },
    parse: function(A) {
      var P = this, C = [0], k = [], D = [null], b = [], M = this.table, v = "", N = 0, tt = 0, Z = 2, z = 1, X = b.slice.call(arguments, 1), q = Object.create(this.lexer), nt = { yy: {} };
      for (var st in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, st) && (nt.yy[st] = this.yy[st]);
      q.setInput(A, nt.yy), nt.yy.lexer = q, nt.yy.parser = this, typeof q.yylloc > "u" && (q.yylloc = {});
      var ct = q.yylloc;
      b.push(ct);
      var Y = q.options && q.options.ranges;
      typeof nt.yy.parseError == "function" ? this.parseError = nt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Ct() {
        var $t;
        return $t = k.pop() || q.lex() || z, typeof $t != "number" && ($t instanceof Array && (k = $t, $t = k.pop()), $t = P.symbols_[$t] || $t), $t;
      }
      for (var H, et, U, W, $ = {}, F, G, I, ht; ; ) {
        if (et = C[C.length - 1], this.defaultActions[et] ? U = this.defaultActions[et] : ((H === null || typeof H > "u") && (H = Ct()), U = M[et] && M[et][H]), typeof U > "u" || !U.length || !U[0]) {
          var L = "";
          ht = [];
          for (F in M[et])
            this.terminals_[F] && F > Z && ht.push("'" + this.terminals_[F] + "'");
          q.showPosition ? L = "Parse error on line " + (N + 1) + `:
` + q.showPosition() + `
Expecting ` + ht.join(", ") + ", got '" + (this.terminals_[H] || H) + "'" : L = "Parse error on line " + (N + 1) + ": Unexpected " + (H == z ? "end of input" : "'" + (this.terminals_[H] || H) + "'"), this.parseError(L, {
            text: q.match,
            token: this.terminals_[H] || H,
            line: q.yylineno,
            loc: ct,
            expected: ht
          });
        }
        if (U[0] instanceof Array && U.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + et + ", token: " + H);
        switch (U[0]) {
          case 1:
            C.push(H), D.push(q.yytext), b.push(q.yylloc), C.push(U[1]), H = null, tt = q.yyleng, v = q.yytext, N = q.yylineno, ct = q.yylloc;
            break;
          case 2:
            if (G = this.productions_[U[1]][1], $.$ = D[D.length - G], $._$ = {
              first_line: b[b.length - (G || 1)].first_line,
              last_line: b[b.length - 1].last_line,
              first_column: b[b.length - (G || 1)].first_column,
              last_column: b[b.length - 1].last_column
            }, Y && ($._$.range = [
              b[b.length - (G || 1)].range[0],
              b[b.length - 1].range[1]
            ]), W = this.performAction.apply($, [
              v,
              tt,
              N,
              nt.yy,
              U[1],
              D,
              b
            ].concat(X)), typeof W < "u")
              return W;
            G && (C = C.slice(0, -1 * G * 2), D = D.slice(0, -1 * G), b = b.slice(0, -1 * G)), C.push(this.productions_[U[1]][0]), D.push($.$), b.push($._$), I = M[C[C.length - 2]][C[C.length - 1]], C.push(I);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, T = function() {
    var R = {
      EOF: 1,
      parseError: function(P, C) {
        if (this.yy.parser)
          this.yy.parser.parseError(P, C);
        else
          throw new Error(P);
      },
      setInput: function(A, P) {
        return this.yy = P || this.yy || {}, this._input = A, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var A = this._input[0];
        this.yytext += A, this.yyleng++, this.offset++, this.match += A, this.matched += A;
        var P = A.match(/(?:\r\n?|\n).*/g);
        return P ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), A;
      },
      unput: function(A) {
        var P = A.length, C = A.split(/(?:\r\n?|\n)/g);
        this._input = A + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - P), this.offset -= P;
        var k = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), C.length - 1 && (this.yylineno -= C.length - 1);
        var D = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: C ? (C.length === k.length ? this.yylloc.first_column : 0) + k[k.length - C.length].length - C[0].length : this.yylloc.first_column - P
        }, this.options.ranges && (this.yylloc.range = [D[0], D[0] + this.yyleng - P]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(A) {
        this.unput(this.match.slice(A));
      },
      pastInput: function() {
        var A = this.matched.substr(0, this.matched.length - this.match.length);
        return (A.length > 20 ? "..." : "") + A.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var A = this.match;
        return A.length < 20 && (A += this._input.substr(0, 20 - A.length)), (A.substr(0, 20) + (A.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var A = this.pastInput(), P = new Array(A.length + 1).join("-");
        return A + this.upcomingInput() + `
` + P + "^";
      },
      test_match: function(A, P) {
        var C, k, D;
        if (this.options.backtrack_lexer && (D = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (D.yylloc.range = this.yylloc.range.slice(0))), k = A[0].match(/(?:\r\n?|\n).*/g), k && (this.yylineno += k.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: k ? k[k.length - 1].length - k[k.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + A[0].length
        }, this.yytext += A[0], this.match += A[0], this.matches = A, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(A[0].length), this.matched += A[0], C = this.performAction.call(this, this.yy, this, P, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), C)
          return C;
        if (this._backtrack) {
          for (var b in D)
            this[b] = D[b];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var A, P, C, k;
        this._more || (this.yytext = "", this.match = "");
        for (var D = this._currentRules(), b = 0; b < D.length; b++)
          if (C = this._input.match(this.rules[D[b]]), C && (!P || C[0].length > P[0].length)) {
            if (P = C, k = b, this.options.backtrack_lexer) {
              if (A = this.test_match(C, D[b]), A !== !1)
                return A;
              if (this._backtrack) {
                P = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return P ? (A = this.test_match(P, D[k]), A !== !1 ? A : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var P = this.next();
        return P || this.lex();
      },
      begin: function(P) {
        this.conditionStack.push(P);
      },
      popState: function() {
        var P = this.conditionStack.length - 1;
        return P > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(P) {
        return P = this.conditionStack.length - 1 - Math.abs(P || 0), P >= 0 ? this.conditionStack[P] : "INITIAL";
      },
      pushState: function(P) {
        this.begin(P);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(P, C, k, D) {
        switch (k) {
          case 0:
            return this.begin("open_directive"), 40;
          case 1:
            return this.begin("type_directive"), 41;
          case 2:
            return this.popState(), this.begin("arg_directive"), 33;
          case 3:
            return this.popState(), this.popState(), 43;
          case 4:
            return 42;
          case 5:
            return this.begin("acc_title"), 21;
          case 6:
            return this.popState(), "acc_title_value";
          case 7:
            return this.begin("acc_descr"), 23;
          case 8:
            return this.popState(), "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 11;
          case 16:
            break;
          case 17:
            break;
          case 18:
            break;
          case 19:
            this.begin("href");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return 38;
          case 22:
            this.begin("callbackname");
            break;
          case 23:
            this.popState();
            break;
          case 24:
            this.popState(), this.begin("callbackargs");
            break;
          case 25:
            return 36;
          case 26:
            this.popState();
            break;
          case 27:
            return 37;
          case 28:
            this.begin("click");
            break;
          case 29:
            this.popState();
            break;
          case 30:
            return 35;
          case 31:
            return 5;
          case 32:
            return 12;
          case 33:
            return 13;
          case 34:
            return 14;
          case 35:
            return 15;
          case 36:
            return 16;
          case 37:
            return 18;
          case 38:
            return 17;
          case 39:
            return 19;
          case 40:
            return "date";
          case 41:
            return 20;
          case 42:
            return "accDescription";
          case 43:
            return 26;
          case 44:
            return 28;
          case 45:
            return 29;
          case 46:
            return 33;
          case 47:
            return 7;
          case 48:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:tickInterval\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [10, 11], inclusive: !1 }, acc_descr: { rules: [8], inclusive: !1 }, acc_title: { rules: [6], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, callbackargs: { rules: [26, 27], inclusive: !1 }, callbackname: { rules: [23, 24, 25], inclusive: !1 }, href: { rules: [20, 21], inclusive: !1 }, click: { rules: [29, 30], inclusive: !1 }, INITIAL: { rules: [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 22, 28, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48], inclusive: !0 } }
    };
    return R;
  }();
  E.lexer = T;
  function S() {
    this.yy = {};
  }
  return S.prototype = E, E.Parser = S, new S();
}();
Ok.parser = Ok;
const eue = Ok, nue = (e) => e.match(/^\s*gantt/) !== null;
ri.extend(qre);
ri.extend(Wre);
ri.extend(Ure);
let io = "", z5 = "", q5, W5 = "", a0 = [], l0 = [], U5 = {}, j5 = [], g2 = [], bu = "";
const yZ = ["active", "done", "crit", "milestone"];
let X5 = [], c0 = !1, G5 = !1, xk = 0;
const rue = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, iue = function() {
  j5 = [], g2 = [], bu = "", X5 = [], yg = 0, _k = void 0, bg = void 0, Un = [], io = "", z5 = "", q5 = void 0, W5 = "", a0 = [], l0 = [], c0 = !1, G5 = !1, xk = 0, U5 = {}, _i();
}, sue = function(e) {
  z5 = e;
}, oue = function() {
  return z5;
}, aue = function(e) {
  q5 = e;
}, lue = function() {
  return q5;
}, cue = function(e) {
  W5 = e;
}, hue = function() {
  return W5;
}, uue = function(e) {
  io = e;
}, fue = function() {
  c0 = !0;
}, due = function() {
  return c0;
}, pue = function() {
  G5 = !0;
}, gue = function() {
  return G5;
}, mue = function() {
  return io;
}, yue = function(e) {
  a0 = e.toLowerCase().split(/[\s,]+/);
}, bue = function() {
  return a0;
}, Oue = function(e) {
  l0 = e.toLowerCase().split(/[\s,]+/);
}, xue = function() {
  return l0;
}, vue = function() {
  return U5;
}, _ue = function(e) {
  bu = e, j5.push(e);
}, kue = function() {
  return j5;
}, wue = function() {
  let e = W8();
  const t = 10;
  let n = 0;
  for (; !e && n < t; )
    e = W8(), n++;
  return g2 = Un, g2;
}, bZ = function(e, t, n, r) {
  return r.includes(e.format(t.trim())) ? !1 : e.isoWeekday() >= 6 && n.includes("weekends") || n.includes(e.format("dddd").toLowerCase()) ? !0 : n.includes(e.format(t.trim()));
}, OZ = function(e, t, n, r) {
  if (!n.length || e.manualEndTime)
    return;
  let i;
  e.startTime instanceof Date ? i = ri(e.startTime) : i = ri(e.startTime, t, !0), i = i.add(1, "d");
  let s;
  e.endTime instanceof Date ? s = ri(e.endTime) : s = ri(e.endTime, t, !0);
  const [o, a] = Sue(
    i,
    s,
    t,
    n,
    r
  );
  e.endTime = o.toDate(), e.renderEndTime = a;
}, Sue = function(e, t, n, r, i) {
  let s = !1, o = null;
  for (; e <= t; )
    s || (o = t.toDate()), s = bZ(e, n, r, i), s && (t = t.add(1, "d")), e = e.add(1, "d");
  return [t, o];
}, vk = function(e, t, n) {
  n = n.trim();
  const i = /^after\s+([\d\w- ]+)/.exec(n.trim());
  if (i !== null) {
    let o = null;
    if (i[1].split(" ").forEach(function(a) {
      let l = Uu(a);
      l !== void 0 && (o ? l.endTime > o.endTime && (o = l) : o = l);
    }), o)
      return o.endTime;
    {
      const a = new Date();
      return a.setHours(0, 0, 0, 0), a;
    }
  }
  let s = ri(n, t.trim(), !0);
  if (s.isValid())
    return s.toDate();
  {
    B.debug("Invalid date:" + n), B.debug("With date format:" + t.trim());
    const o = new Date(n);
    if (o === void 0 || isNaN(o.getTime()))
      throw new Error("Invalid date:" + n);
    return o;
  }
}, xZ = function(e) {
  const t = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(e.trim());
  return t !== null ? [Number.parseFloat(t[1]), t[2]] : [NaN, "ms"];
}, vZ = function(e, t, n, r = !1) {
  n = n.trim();
  let i = ri(n, t.trim(), !0);
  if (i.isValid())
    return r && (i = i.add(1, "d")), i.toDate();
  let s = ri(e);
  const [o, a] = xZ(n);
  if (!Number.isNaN(o)) {
    const l = s.add(o, a);
    l.isValid() && (s = l);
  }
  return s.toDate();
};
let yg = 0;
const Ah = function(e) {
  return e === void 0 ? (yg = yg + 1, "task" + yg) : e;
}, Cue = function(e, t) {
  let n;
  t.substr(0, 1) === ":" ? n = t.substr(1, t.length) : n = t;
  const r = n.split(","), i = {};
  SZ(r, i, yZ);
  for (let o = 0; o < r.length; o++)
    r[o] = r[o].trim();
  let s = "";
  switch (r.length) {
    case 1:
      i.id = Ah(), i.startTime = e.endTime, s = r[0];
      break;
    case 2:
      i.id = Ah(), i.startTime = vk(void 0, io, r[0]), s = r[1];
      break;
    case 3:
      i.id = Ah(r[0]), i.startTime = vk(void 0, io, r[1]), s = r[2];
      break;
  }
  return s && (i.endTime = vZ(i.startTime, io, s, c0), i.manualEndTime = ri(s, "YYYY-MM-DD", !0).isValid(), OZ(i, io, l0, a0)), i;
}, Tue = function(e, t) {
  let n;
  t.substr(0, 1) === ":" ? n = t.substr(1, t.length) : n = t;
  const r = n.split(","), i = {};
  SZ(r, i, yZ);
  for (let s = 0; s < r.length; s++)
    r[s] = r[s].trim();
  switch (r.length) {
    case 1:
      i.id = Ah(), i.startTime = {
        type: "prevTaskEnd",
        id: e
      }, i.endTime = {
        data: r[0]
      };
      break;
    case 2:
      i.id = Ah(), i.startTime = {
        type: "getStartDate",
        startData: r[0]
      }, i.endTime = {
        data: r[1]
      };
      break;
    case 3:
      i.id = Ah(r[0]), i.startTime = {
        type: "getStartDate",
        startData: r[1]
      }, i.endTime = {
        data: r[2]
      };
      break;
  }
  return i;
};
let _k, bg, Un = [];
const _Z = {}, Eue = function(e, t) {
  const n = {
    section: bu,
    type: bu,
    processed: !1,
    manualEndTime: !1,
    renderEndTime: null,
    raw: { data: t },
    task: e,
    classes: []
  }, r = Tue(bg, t);
  n.raw.startTime = r.startTime, n.raw.endTime = r.endTime, n.id = r.id, n.prevTaskId = bg, n.active = r.active, n.done = r.done, n.crit = r.crit, n.milestone = r.milestone, n.order = xk, xk++;
  const i = Un.push(n);
  bg = n.id, _Z[n.id] = i - 1;
}, Uu = function(e) {
  const t = _Z[e];
  return Un[t];
}, Aue = function(e, t) {
  const n = {
    section: bu,
    type: bu,
    description: e,
    task: e,
    classes: []
  }, r = Cue(_k, t);
  n.startTime = r.startTime, n.endTime = r.endTime, n.id = r.id, n.active = r.active, n.done = r.done, n.crit = r.crit, n.milestone = r.milestone, _k = n, g2.push(n);
}, W8 = function() {
  const e = function(n) {
    const r = Un[n];
    let i = "";
    switch (Un[n].raw.startTime.type) {
      case "prevTaskEnd": {
        const s = Uu(r.prevTaskId);
        r.startTime = s.endTime;
        break;
      }
      case "getStartDate":
        i = vk(void 0, io, Un[n].raw.startTime.startData), i && (Un[n].startTime = i);
        break;
    }
    return Un[n].startTime && (Un[n].endTime = vZ(
      Un[n].startTime,
      io,
      Un[n].raw.endTime.data,
      c0
    ), Un[n].endTime && (Un[n].processed = !0, Un[n].manualEndTime = ri(
      Un[n].raw.endTime.data,
      "YYYY-MM-DD",
      !0
    ).isValid(), OZ(Un[n], io, l0, a0))), Un[n].processed;
  };
  let t = !0;
  for (const [n, r] of Un.entries())
    e(n), t = t && r.processed;
  return t;
}, Pue = function(e, t) {
  let n = t;
  J().securityLevel !== "loose" && (n = Oa.sanitizeUrl(t)), e.split(",").forEach(function(r) {
    Uu(r) !== void 0 && (wZ(r, () => {
      window.open(n, "_self");
    }), U5[r] = n);
  }), kZ(e, "clickable");
}, kZ = function(e, t) {
  e.split(",").forEach(function(n) {
    let r = Uu(n);
    r !== void 0 && r.classes.push(t);
  });
}, Due = function(e, t, n) {
  if (J().securityLevel !== "loose" || t === void 0)
    return;
  let r = [];
  if (typeof n == "string") {
    r = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].trim();
      o.charAt(0) === '"' && o.charAt(o.length - 1) === '"' && (o = o.substr(1, o.length - 2)), r[s] = o;
    }
  }
  r.length === 0 && r.push(e), Uu(e) !== void 0 && wZ(e, () => {
    fe.runFunc(t, ...r);
  });
}, wZ = function(e, t) {
  X5.push(
    function() {
      const n = document.querySelector(`[id="${e}"]`);
      n !== null && n.addEventListener("click", function() {
        t();
      });
    },
    function() {
      const n = document.querySelector(`[id="${e}-text"]`);
      n !== null && n.addEventListener("click", function() {
        t();
      });
    }
  );
}, Lue = function(e, t, n) {
  e.split(",").forEach(function(r) {
    Due(r, t, n);
  }), kZ(e, "clickable");
}, Mue = function(e) {
  X5.forEach(function(t) {
    t(e);
  });
}, H5 = {
  parseDirective: rue,
  getConfig: () => J().gantt,
  clear: iue,
  setDateFormat: uue,
  getDateFormat: mue,
  enableInclusiveEndDates: fue,
  endDatesAreInclusive: due,
  enableTopAxis: pue,
  topAxisEnabled: gue,
  setAxisFormat: sue,
  getAxisFormat: oue,
  setTickInterval: aue,
  getTickInterval: lue,
  setTodayMarker: cue,
  getTodayMarker: hue,
  setAccTitle: oi,
  getAccTitle: ki,
  setDiagramTitle: Is,
  getDiagramTitle: Ns,
  setAccDescription: wi,
  getAccDescription: Si,
  addSection: _ue,
  getSections: kue,
  getTasks: wue,
  addTask: Eue,
  findTaskById: Uu,
  addTaskOrg: Aue,
  setIncludes: yue,
  getIncludes: bue,
  setExcludes: Oue,
  getExcludes: xue,
  setClickEvent: Lue,
  setLink: Pue,
  getLinks: vue,
  bindFunctions: Mue,
  parseDuration: xZ,
  isInvalidDate: bZ
};
function SZ(e, t, n) {
  let r = !0;
  for (; r; )
    r = !1, n.forEach(function(i) {
      const s = "^\\s*" + i + "\\s*$", o = new RegExp(s);
      e[0].match(o) && (t[i] = !0, e.shift(1), r = !0);
    });
}
const Rue = function() {
  B.debug("Something is calling, setConf, remove the call");
};
let Lo;
const $ue = function(e, t, n, r) {
  const i = J().gantt, s = J().securityLevel;
  let o;
  s === "sandbox" && (o = wt("#i" + t));
  const a = wt(s === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), l = s === "sandbox" ? o.nodes()[0].contentDocument : document, h = l.getElementById(t);
  Lo = h.parentElement.offsetWidth, Lo === void 0 && (Lo = 1200), i.useWidth !== void 0 && (Lo = i.useWidth);
  const u = r.db.getTasks(), f = u.length * (i.barHeight + i.barGap) + 2 * i.topPadding;
  h.setAttribute("viewBox", "0 0 " + Lo + " " + f);
  const d = a.select(`[id="${t}"]`), p = tUt().domain([
    RZt(u, function(P) {
      return P.startTime;
    }),
    MZt(u, function(P) {
      return P.endTime;
    })
  ]).rangeRound([0, Lo - i.leftPadding - i.rightPadding]);
  let g = [];
  for (const P of u)
    g.push(P.type);
  const m = g;
  g = S(g);
  function y(P, C) {
    const k = P.startTime, D = C.startTime;
    let b = 0;
    return k > D ? b = 1 : k < D && (b = -1), b;
  }
  u.sort(y), O(u, Lo, f), $s(d, f, Lo, i.useMaxWidth), d.append("text").text(r.db.getDiagramTitle()).attr("x", Lo / 2).attr("y", i.titleTopMargin).attr("class", "titleText");
  function O(P, C, k) {
    const D = i.barHeight, b = D + i.barGap, M = i.topPadding, v = i.leftPadding, N = dN().domain([0, g.length]).range(["#00B9FA", "#F95002"]).interpolate(ezt);
    _(
      b,
      M,
      v,
      C,
      k,
      P,
      r.db.getExcludes(),
      r.db.getIncludes()
    ), w(v, M, C, k), x(P, b, M, v, D, N, C), E(b, M), T(v, M, C, k);
  }
  function x(P, C, k, D, b, M, v) {
    d.append("g").selectAll("rect").data(P).enter().append("rect").attr("x", 0).attr("y", function(z, X) {
      return X = z.order, X * C + k - 2;
    }).attr("width", function() {
      return v - i.rightPadding / 2;
    }).attr("height", C).attr("class", function(z) {
      for (const [X, q] of g.entries())
        if (z.type === q)
          return "section section" + X % i.numberSectionStyles;
      return "section section0";
    });
    const N = d.append("g").selectAll("rect").data(P).enter(), tt = r.db.getLinks();
    if (N.append("rect").attr("id", function(z) {
      return z.id;
    }).attr("rx", 3).attr("ry", 3).attr("x", function(z) {
      return z.milestone ? p(z.startTime) + D + 0.5 * (p(z.endTime) - p(z.startTime)) - 0.5 * b : p(z.startTime) + D;
    }).attr("y", function(z, X) {
      return X = z.order, X * C + k;
    }).attr("width", function(z) {
      return z.milestone ? b : p(z.renderEndTime || z.endTime) - p(z.startTime);
    }).attr("height", b).attr("transform-origin", function(z, X) {
      return X = z.order, (p(z.startTime) + D + 0.5 * (p(z.endTime) - p(z.startTime))).toString() + "px " + (X * C + k + 0.5 * b).toString() + "px";
    }).attr("class", function(z) {
      const X = "task";
      let q = "";
      z.classes.length > 0 && (q = z.classes.join(" "));
      let nt = 0;
      for (const [ct, Y] of g.entries())
        z.type === Y && (nt = ct % i.numberSectionStyles);
      let st = "";
      return z.active ? z.crit ? st += " activeCrit" : st = " active" : z.done ? z.crit ? st = " doneCrit" : st = " done" : z.crit && (st += " crit"), st.length === 0 && (st = " task"), z.milestone && (st = " milestone " + st), st += nt, st += " " + q, X + st;
    }), N.append("text").attr("id", function(z) {
      return z.id + "-text";
    }).text(function(z) {
      return z.task;
    }).attr("font-size", i.fontSize).attr("x", function(z) {
      let X = p(z.startTime), q = p(z.renderEndTime || z.endTime);
      z.milestone && (X += 0.5 * (p(z.endTime) - p(z.startTime)) - 0.5 * b), z.milestone && (q = X + b);
      const nt = this.getBBox().width;
      return nt > q - X ? q + nt + 1.5 * i.leftPadding > v ? X + D - 5 : q + D + 5 : (q - X) / 2 + X + D;
    }).attr("y", function(z, X) {
      return X = z.order, X * C + i.barHeight / 2 + (i.fontSize / 2 - 2) + k;
    }).attr("text-height", b).attr("class", function(z) {
      const X = p(z.startTime);
      let q = p(z.endTime);
      z.milestone && (q = X + b);
      const nt = this.getBBox().width;
      let st = "";
      z.classes.length > 0 && (st = z.classes.join(" "));
      let ct = 0;
      for (const [Ct, H] of g.entries())
        z.type === H && (ct = Ct % i.numberSectionStyles);
      let Y = "";
      return z.active && (z.crit ? Y = "activeCritText" + ct : Y = "activeText" + ct), z.done ? z.crit ? Y = Y + " doneCritText" + ct : Y = Y + " doneText" + ct : z.crit && (Y = Y + " critText" + ct), z.milestone && (Y += " milestoneText"), nt > q - X ? q + nt + 1.5 * i.leftPadding > v ? st + " taskTextOutsideLeft taskTextOutside" + ct + " " + Y : st + " taskTextOutsideRight taskTextOutside" + ct + " " + Y + " width-" + nt : st + " taskText taskText" + ct + " " + Y + " width-" + nt;
    }), J().securityLevel === "sandbox") {
      let z;
      z = wt("#i" + t);
      const X = z.nodes()[0].contentDocument;
      N.filter(function(q) {
        return tt[q.id] !== void 0;
      }).each(function(q) {
        var nt = X.querySelector("#" + q.id), st = X.querySelector("#" + q.id + "-text");
        const ct = nt.parentNode;
        var Y = X.createElement("a");
        Y.setAttribute("xlink:href", tt[q.id]), Y.setAttribute("target", "_top"), ct.appendChild(Y), Y.appendChild(nt), Y.appendChild(st);
      });
    }
  }
  function _(P, C, k, D, b, M, v, N) {
    const tt = M.reduce(
      (ct, { startTime: Y }) => ct ? Math.min(ct, Y) : Y,
      0
    ), Z = M.reduce((ct, { endTime: Y }) => ct ? Math.max(ct, Y) : Y, 0), z = r.db.getDateFormat();
    if (!tt || !Z)
      return;
    const X = [];
    let q = null, nt = ri(tt);
    for (; nt.valueOf() <= Z; )
      r.db.isInvalidDate(nt, z, v, N) ? q ? q.end = nt : q = {
        start: nt,
        end: nt
      } : q && (X.push(q), q = null), nt = nt.add(1, "d");
    d.append("g").selectAll("rect").data(X).enter().append("rect").attr("id", function(ct) {
      return "exclude-" + ct.start.format("YYYY-MM-DD");
    }).attr("x", function(ct) {
      return p(ct.start) + k;
    }).attr("y", i.gridLineStartPadding).attr("width", function(ct) {
      const Y = ct.end.add(1, "day");
      return p(Y) - p(ct.start);
    }).attr("height", b - C - i.gridLineStartPadding).attr("transform-origin", function(ct, Y) {
      return (p(ct.start) + k + 0.5 * (p(ct.end) - p(ct.start))).toString() + "px " + (Y * P + 0.5 * b).toString() + "px";
    }).attr("class", "exclude-range");
  }
  function w(P, C, k, D) {
    let b = VZt(p).tickSize(-D + C + i.gridLineStartPadding).tickFormat(Nm(r.db.getAxisFormat() || i.axisFormat || "%Y-%m-%d"));
    const v = /^([1-9]\d*)(minute|hour|day|week|month)$/.exec(
      r.db.getTickInterval() || i.tickInterval
    );
    if (v !== null) {
      const N = v[1];
      switch (v[2]) {
        case "minute":
          b.ticks(rp.every(N));
          break;
        case "hour":
          b.ticks(ip.every(N));
          break;
        case "day":
          b.ticks(pc.every(N));
          break;
        case "week":
          b.ticks(su.every(N));
          break;
        case "month":
          b.ticks(sp.every(N));
          break;
      }
    }
    if (d.append("g").attr("class", "grid").attr("transform", "translate(" + P + ", " + (D - 50) + ")").call(b).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em"), r.db.topAxisEnabled() || i.topAxis) {
      let N = ZZt(p).tickSize(-D + C + i.gridLineStartPadding).tickFormat(Nm(r.db.getAxisFormat() || i.axisFormat || "%Y-%m-%d"));
      if (v !== null) {
        const tt = v[1];
        switch (v[2]) {
          case "minute":
            N.ticks(rp.every(tt));
            break;
          case "hour":
            N.ticks(ip.every(tt));
            break;
          case "day":
            N.ticks(pc.every(tt));
            break;
          case "week":
            N.ticks(su.every(tt));
            break;
          case "month":
            N.ticks(sp.every(tt));
            break;
        }
      }
      d.append("g").attr("class", "grid").attr("transform", "translate(" + P + ", " + C + ")").call(N).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
    }
  }
  function E(P, C) {
    const k = [];
    let D = 0;
    for (const [b, M] of g.entries())
      k[b] = [M, A(M, m)];
    d.append("g").selectAll("text").data(k).enter().append(function(b) {
      const M = b[0].split(de.lineBreakRegex), v = -(M.length - 1) / 2, N = l.createElementNS("http://www.w3.org/2000/svg", "text");
      N.setAttribute("dy", v + "em");
      for (const [tt, Z] of M.entries()) {
        const z = l.createElementNS("http://www.w3.org/2000/svg", "tspan");
        z.setAttribute("alignment-baseline", "central"), z.setAttribute("x", "10"), tt > 0 && z.setAttribute("dy", "1em"), z.textContent = Z, N.appendChild(z);
      }
      return N;
    }).attr("x", 10).attr("y", function(b, M) {
      if (M > 0)
        for (let v = 0; v < M; v++)
          return D += k[M - 1][1], b[1] * P / 2 + D * P + C;
      else
        return b[1] * P / 2 + C;
    }).attr("font-size", i.sectionFontSize).attr("font-size", i.sectionFontSize).attr("class", function(b) {
      for (const [M, v] of g.entries())
        if (b[0] === v)
          return "sectionTitle sectionTitle" + M % i.numberSectionStyles;
      return "sectionTitle";
    });
  }
  function T(P, C, k, D) {
    const b = r.db.getTodayMarker();
    if (b === "off")
      return;
    const M = d.append("g").attr("class", "today"), v = new Date(), N = M.append("line");
    N.attr("x1", p(v) + P).attr("x2", p(v) + P).attr("y1", i.titleTopMargin).attr("y2", D - i.titleTopMargin).attr("class", "today"), b !== "" && N.attr("style", b.replace(/,/g, ";"));
  }
  function S(P) {
    const C = {}, k = [];
    for (let D = 0, b = P.length; D < b; ++D)
      Object.prototype.hasOwnProperty.call(C, P[D]) || (C[P[D]] = !0, k.push(P[D]));
    return k;
  }
  function R(P) {
    let C = P.length;
    const k = {};
    for (; C; )
      k[P[--C]] = (k[P[C]] || 0) + 1;
    return k;
  }
  function A(P, C) {
    return R(C)[P] || 0;
  }
}, Iue = {
  setConf: Rue,
  draw: $ue
};
var kk = function() {
  var e = function(s, o, a, l) {
    for (a = a || {}, l = s.length; l--; a[s[l]] = o)
      ;
    return a;
  }, t = [6, 9, 10], n = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, info: 4, document: 5, EOF: 6, line: 7, statement: 8, NL: 9, showInfo: 10, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "info", 6: "EOF", 9: "NL", 10: "showInfo" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 1], [7, 1], [8, 1]],
    performAction: function(o, a, l, h, u, f, d) {
      switch (f.length - 1, u) {
        case 1:
          return h;
        case 4:
          break;
        case 6:
          h.setInfo(!0);
          break;
      }
    },
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, e(t, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: 6, 9: [1, 7], 10: [1, 8] }, { 1: [2, 1] }, e(t, [2, 3]), e(t, [2, 4]), e(t, [2, 5]), e(t, [2, 6])],
    defaultActions: { 4: [2, 1] },
    parseError: function(o, a) {
      if (a.recoverable)
        this.trace(o);
      else {
        var l = new Error(o);
        throw l.hash = a, l;
      }
    },
    parse: function(o) {
      var a = this, l = [0], h = [], u = [null], f = [], d = this.table, p = "", g = 0, m = 0, y = 2, O = 1, x = f.slice.call(arguments, 1), _ = Object.create(this.lexer), w = { yy: {} };
      for (var E in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, E) && (w.yy[E] = this.yy[E]);
      _.setInput(o, w.yy), w.yy.lexer = _, w.yy.parser = this, typeof _.yylloc > "u" && (_.yylloc = {});
      var T = _.yylloc;
      f.push(T);
      var S = _.options && _.options.ranges;
      typeof w.yy.parseError == "function" ? this.parseError = w.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function R() {
        var Z;
        return Z = h.pop() || _.lex() || O, typeof Z != "number" && (Z instanceof Array && (h = Z, Z = h.pop()), Z = a.symbols_[Z] || Z), Z;
      }
      for (var A, P, C, k, D = {}, b, M, v, N; ; ) {
        if (P = l[l.length - 1], this.defaultActions[P] ? C = this.defaultActions[P] : ((A === null || typeof A > "u") && (A = R()), C = d[P] && d[P][A]), typeof C > "u" || !C.length || !C[0]) {
          var tt = "";
          N = [];
          for (b in d[P])
            this.terminals_[b] && b > y && N.push("'" + this.terminals_[b] + "'");
          _.showPosition ? tt = "Parse error on line " + (g + 1) + `:
` + _.showPosition() + `
Expecting ` + N.join(", ") + ", got '" + (this.terminals_[A] || A) + "'" : tt = "Parse error on line " + (g + 1) + ": Unexpected " + (A == O ? "end of input" : "'" + (this.terminals_[A] || A) + "'"), this.parseError(tt, {
            text: _.match,
            token: this.terminals_[A] || A,
            line: _.yylineno,
            loc: T,
            expected: N
          });
        }
        if (C[0] instanceof Array && C.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + P + ", token: " + A);
        switch (C[0]) {
          case 1:
            l.push(A), u.push(_.yytext), f.push(_.yylloc), l.push(C[1]), A = null, m = _.yyleng, p = _.yytext, g = _.yylineno, T = _.yylloc;
            break;
          case 2:
            if (M = this.productions_[C[1]][1], D.$ = u[u.length - M], D._$ = {
              first_line: f[f.length - (M || 1)].first_line,
              last_line: f[f.length - 1].last_line,
              first_column: f[f.length - (M || 1)].first_column,
              last_column: f[f.length - 1].last_column
            }, S && (D._$.range = [
              f[f.length - (M || 1)].range[0],
              f[f.length - 1].range[1]
            ]), k = this.performAction.apply(D, [
              p,
              m,
              g,
              w.yy,
              C[1],
              u,
              f
            ].concat(x)), typeof k < "u")
              return k;
            M && (l = l.slice(0, -1 * M * 2), u = u.slice(0, -1 * M), f = f.slice(0, -1 * M)), l.push(this.productions_[C[1]][0]), u.push(D.$), f.push(D._$), v = d[l[l.length - 2]][l[l.length - 1]], l.push(v);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, r = function() {
    var s = {
      EOF: 1,
      parseError: function(a, l) {
        if (this.yy.parser)
          this.yy.parser.parseError(a, l);
        else
          throw new Error(a);
      },
      setInput: function(o, a) {
        return this.yy = a || this.yy || {}, this._input = o, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var o = this._input[0];
        this.yytext += o, this.yyleng++, this.offset++, this.match += o, this.matched += o;
        var a = o.match(/(?:\r\n?|\n).*/g);
        return a ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), o;
      },
      unput: function(o) {
        var a = o.length, l = o.split(/(?:\r\n?|\n)/g);
        this._input = o + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - a), this.offset -= a;
        var h = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), l.length - 1 && (this.yylineno -= l.length - 1);
        var u = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: l ? (l.length === h.length ? this.yylloc.first_column : 0) + h[h.length - l.length].length - l[0].length : this.yylloc.first_column - a
        }, this.options.ranges && (this.yylloc.range = [u[0], u[0] + this.yyleng - a]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(o) {
        this.unput(this.match.slice(o));
      },
      pastInput: function() {
        var o = this.matched.substr(0, this.matched.length - this.match.length);
        return (o.length > 20 ? "..." : "") + o.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var o = this.match;
        return o.length < 20 && (o += this._input.substr(0, 20 - o.length)), (o.substr(0, 20) + (o.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var o = this.pastInput(), a = new Array(o.length + 1).join("-");
        return o + this.upcomingInput() + `
` + a + "^";
      },
      test_match: function(o, a) {
        var l, h, u;
        if (this.options.backtrack_lexer && (u = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (u.yylloc.range = this.yylloc.range.slice(0))), h = o[0].match(/(?:\r\n?|\n).*/g), h && (this.yylineno += h.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: h ? h[h.length - 1].length - h[h.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + o[0].length
        }, this.yytext += o[0], this.match += o[0], this.matches = o, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(o[0].length), this.matched += o[0], l = this.performAction.call(this, this.yy, this, a, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), l)
          return l;
        if (this._backtrack) {
          for (var f in u)
            this[f] = u[f];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var o, a, l, h;
        this._more || (this.yytext = "", this.match = "");
        for (var u = this._currentRules(), f = 0; f < u.length; f++)
          if (l = this._input.match(this.rules[u[f]]), l && (!a || l[0].length > a[0].length)) {
            if (a = l, h = f, this.options.backtrack_lexer) {
              if (o = this.test_match(l, u[f]), o !== !1)
                return o;
              if (this._backtrack) {
                a = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return a ? (o = this.test_match(a, u[h]), o !== !1 ? o : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var a = this.next();
        return a || this.lex();
      },
      begin: function(a) {
        this.conditionStack.push(a);
      },
      popState: function() {
        var a = this.conditionStack.length - 1;
        return a > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(a) {
        return a = this.conditionStack.length - 1 - Math.abs(a || 0), a >= 0 ? this.conditionStack[a] : "INITIAL";
      },
      pushState: function(a) {
        this.begin(a);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(a, l, h, u) {
        switch (h) {
          case 0:
            return 4;
          case 1:
            return 9;
          case 2:
            return "space";
          case 3:
            return 10;
          case 4:
            return 6;
          case 5:
            return "TXT";
        }
      },
      rules: [/^(?:info\b)/i, /^(?:[\s\n\r]+)/i, /^(?:[\s]+)/i, /^(?:showInfo\b)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5], inclusive: !0 } }
    };
    return s;
  }();
  n.lexer = r;
  function i() {
    this.yy = {};
  }
  return i.prototype = n, n.Parser = i, new i();
}();
kk.parser = kk;
const Nue = kk;
var CZ = "", TZ = !1;
const Bue = (e) => {
  B.debug("Setting message to: " + e), CZ = e;
}, Fue = () => CZ, Que = (e) => {
  TZ = e;
}, Zue = () => TZ, Vue = {
  setMessage: Bue,
  getMessage: Fue,
  setInfo: Que,
  getInfo: Zue,
  clear: _i
}, Yue = (e, t, n) => {
  try {
    B.debug(`Rendering info diagram
` + e);
    const r = J().securityLevel;
    let i;
    r === "sandbox" && (i = wt("#i" + t));
    const o = wt(r === "sandbox" ? i.nodes()[0].contentDocument.body : "body").select("#" + t);
    o.append("g").append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", "32px").style("text-anchor", "middle").text("v " + n), o.attr("height", 100), o.attr("width", 400);
  } catch (r) {
    B.error("Error while rendering info diagram"), B.error(r.message);
  }
}, zue = {
  draw: Yue
}, que = (e) => e.match(/^\s*info/) !== null;
var wk = function() {
  var e = function(T, S, R, A) {
    for (R = R || {}, A = T.length; A--; R[T[A]] = S)
      ;
    return R;
  }, t = [1, 4], n = [1, 5], r = [1, 6], i = [1, 7], s = [1, 9], o = [1, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], a = [2, 5], l = [1, 6, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], h = [26, 27, 28], u = [2, 8], f = [1, 18], d = [1, 19], p = [1, 20], g = [1, 21], m = [1, 22], y = [1, 23], O = [1, 28], x = [6, 26, 27, 28, 29], _ = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, eol: 4, directive: 5, PIE: 6, document: 7, showData: 8, line: 9, statement: 10, txt: 11, value: 12, title: 13, title_value: 14, acc_title: 15, acc_title_value: 16, acc_descr: 17, acc_descr_value: 18, acc_descr_multiline_value: 19, section: 20, openDirective: 21, typeDirective: 22, closeDirective: 23, ":": 24, argDirective: 25, NEWLINE: 26, ";": 27, EOF: 28, open_directive: 29, type_directive: 30, arg_directive: 31, close_directive: 32, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "PIE", 8: "showData", 11: "txt", 12: "value", 13: "title", 14: "title_value", 15: "acc_title", 16: "acc_title_value", 17: "acc_descr", 18: "acc_descr_value", 19: "acc_descr_multiline_value", 20: "section", 24: ":", 26: "NEWLINE", 27: ";", 28: "EOF", 29: "open_directive", 30: "type_directive", 31: "arg_directive", 32: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 3], [7, 0], [7, 2], [9, 2], [10, 0], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [5, 3], [5, 5], [4, 1], [4, 1], [4, 1], [21, 1], [22, 1], [25, 1], [23, 1]],
    performAction: function(S, R, A, P, C, k, D) {
      var b = k.length - 1;
      switch (C) {
        case 4:
          P.setShowData(!0);
          break;
        case 7:
          this.$ = k[b - 1];
          break;
        case 9:
          P.addSection(k[b - 1], P.cleanupValue(k[b]));
          break;
        case 10:
          this.$ = k[b].trim(), P.setDiagramTitle(this.$);
          break;
        case 11:
          this.$ = k[b].trim(), P.setAccTitle(this.$);
          break;
        case 12:
        case 13:
          this.$ = k[b].trim(), P.setAccDescription(this.$);
          break;
        case 14:
          P.addSection(k[b].substr(8)), this.$ = k[b].substr(8);
          break;
        case 21:
          P.parseDirective("%%{", "open_directive");
          break;
        case 22:
          P.parseDirective(k[b], "type_directive");
          break;
        case 23:
          k[b] = k[b].trim().replace(/'/g, '"'), P.parseDirective(k[b], "arg_directive");
          break;
        case 24:
          P.parseDirective("}%%", "close_directive", "pie");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: t, 21: 8, 26: n, 27: r, 28: i, 29: s }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: t, 21: 8, 26: n, 27: r, 28: i, 29: s }, { 3: 11, 4: 2, 5: 3, 6: t, 21: 8, 26: n, 27: r, 28: i, 29: s }, e(o, a, { 7: 12, 8: [1, 13] }), e(l, [2, 18]), e(l, [2, 19]), e(l, [2, 20]), { 22: 14, 30: [1, 15] }, { 30: [2, 21] }, { 1: [2, 1] }, { 1: [2, 2] }, e(h, u, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 3], 11: f, 13: d, 15: p, 17: g, 19: m, 20: y, 29: s }), e(o, a, { 7: 25 }), { 23: 26, 24: [1, 27], 32: O }, e([24, 32], [2, 22]), e(o, [2, 6]), { 4: 29, 26: n, 27: r, 28: i }, { 12: [1, 30] }, { 14: [1, 31] }, { 16: [1, 32] }, { 18: [1, 33] }, e(h, [2, 13]), e(h, [2, 14]), e(h, [2, 15]), e(h, u, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 4], 11: f, 13: d, 15: p, 17: g, 19: m, 20: y, 29: s }), e(x, [2, 16]), { 25: 34, 31: [1, 35] }, e(x, [2, 24]), e(o, [2, 7]), e(h, [2, 9]), e(h, [2, 10]), e(h, [2, 11]), e(h, [2, 12]), { 23: 36, 32: O }, { 32: [2, 23] }, e(x, [2, 17])],
    defaultActions: { 9: [2, 21], 10: [2, 1], 11: [2, 2], 35: [2, 23] },
    parseError: function(S, R) {
      if (R.recoverable)
        this.trace(S);
      else {
        var A = new Error(S);
        throw A.hash = R, A;
      }
    },
    parse: function(S) {
      var R = this, A = [0], P = [], C = [null], k = [], D = this.table, b = "", M = 0, v = 0, N = 2, tt = 1, Z = k.slice.call(arguments, 1), z = Object.create(this.lexer), X = { yy: {} };
      for (var q in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, q) && (X.yy[q] = this.yy[q]);
      z.setInput(S, X.yy), X.yy.lexer = z, X.yy.parser = this, typeof z.yylloc > "u" && (z.yylloc = {});
      var nt = z.yylloc;
      k.push(nt);
      var st = z.options && z.options.ranges;
      typeof X.yy.parseError == "function" ? this.parseError = X.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ct() {
        var ht;
        return ht = P.pop() || z.lex() || tt, typeof ht != "number" && (ht instanceof Array && (P = ht, ht = P.pop()), ht = R.symbols_[ht] || ht), ht;
      }
      for (var Y, Ct, H, et, U = {}, W, $, F, G; ; ) {
        if (Ct = A[A.length - 1], this.defaultActions[Ct] ? H = this.defaultActions[Ct] : ((Y === null || typeof Y > "u") && (Y = ct()), H = D[Ct] && D[Ct][Y]), typeof H > "u" || !H.length || !H[0]) {
          var I = "";
          G = [];
          for (W in D[Ct])
            this.terminals_[W] && W > N && G.push("'" + this.terminals_[W] + "'");
          z.showPosition ? I = "Parse error on line " + (M + 1) + `:
` + z.showPosition() + `
Expecting ` + G.join(", ") + ", got '" + (this.terminals_[Y] || Y) + "'" : I = "Parse error on line " + (M + 1) + ": Unexpected " + (Y == tt ? "end of input" : "'" + (this.terminals_[Y] || Y) + "'"), this.parseError(I, {
            text: z.match,
            token: this.terminals_[Y] || Y,
            line: z.yylineno,
            loc: nt,
            expected: G
          });
        }
        if (H[0] instanceof Array && H.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ct + ", token: " + Y);
        switch (H[0]) {
          case 1:
            A.push(Y), C.push(z.yytext), k.push(z.yylloc), A.push(H[1]), Y = null, v = z.yyleng, b = z.yytext, M = z.yylineno, nt = z.yylloc;
            break;
          case 2:
            if ($ = this.productions_[H[1]][1], U.$ = C[C.length - $], U._$ = {
              first_line: k[k.length - ($ || 1)].first_line,
              last_line: k[k.length - 1].last_line,
              first_column: k[k.length - ($ || 1)].first_column,
              last_column: k[k.length - 1].last_column
            }, st && (U._$.range = [
              k[k.length - ($ || 1)].range[0],
              k[k.length - 1].range[1]
            ]), et = this.performAction.apply(U, [
              b,
              v,
              M,
              X.yy,
              H[1],
              C,
              k
            ].concat(Z)), typeof et < "u")
              return et;
            $ && (A = A.slice(0, -1 * $ * 2), C = C.slice(0, -1 * $), k = k.slice(0, -1 * $)), A.push(this.productions_[H[1]][0]), C.push(U.$), k.push(U._$), F = D[A[A.length - 2]][A[A.length - 1]], A.push(F);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, w = function() {
    var T = {
      EOF: 1,
      parseError: function(R, A) {
        if (this.yy.parser)
          this.yy.parser.parseError(R, A);
        else
          throw new Error(R);
      },
      setInput: function(S, R) {
        return this.yy = R || this.yy || {}, this._input = S, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var S = this._input[0];
        this.yytext += S, this.yyleng++, this.offset++, this.match += S, this.matched += S;
        var R = S.match(/(?:\r\n?|\n).*/g);
        return R ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), S;
      },
      unput: function(S) {
        var R = S.length, A = S.split(/(?:\r\n?|\n)/g);
        this._input = S + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - R), this.offset -= R;
        var P = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), A.length - 1 && (this.yylineno -= A.length - 1);
        var C = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: A ? (A.length === P.length ? this.yylloc.first_column : 0) + P[P.length - A.length].length - A[0].length : this.yylloc.first_column - R
        }, this.options.ranges && (this.yylloc.range = [C[0], C[0] + this.yyleng - R]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(S) {
        this.unput(this.match.slice(S));
      },
      pastInput: function() {
        var S = this.matched.substr(0, this.matched.length - this.match.length);
        return (S.length > 20 ? "..." : "") + S.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var S = this.match;
        return S.length < 20 && (S += this._input.substr(0, 20 - S.length)), (S.substr(0, 20) + (S.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var S = this.pastInput(), R = new Array(S.length + 1).join("-");
        return S + this.upcomingInput() + `
` + R + "^";
      },
      test_match: function(S, R) {
        var A, P, C;
        if (this.options.backtrack_lexer && (C = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (C.yylloc.range = this.yylloc.range.slice(0))), P = S[0].match(/(?:\r\n?|\n).*/g), P && (this.yylineno += P.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: P ? P[P.length - 1].length - P[P.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + S[0].length
        }, this.yytext += S[0], this.match += S[0], this.matches = S, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(S[0].length), this.matched += S[0], A = this.performAction.call(this, this.yy, this, R, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), A)
          return A;
        if (this._backtrack) {
          for (var k in C)
            this[k] = C[k];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var S, R, A, P;
        this._more || (this.yytext = "", this.match = "");
        for (var C = this._currentRules(), k = 0; k < C.length; k++)
          if (A = this._input.match(this.rules[C[k]]), A && (!R || A[0].length > R[0].length)) {
            if (R = A, P = k, this.options.backtrack_lexer) {
              if (S = this.test_match(A, C[k]), S !== !1)
                return S;
              if (this._backtrack) {
                R = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return R ? (S = this.test_match(R, C[P]), S !== !1 ? S : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var R = this.next();
        return R || this.lex();
      },
      begin: function(R) {
        this.conditionStack.push(R);
      },
      popState: function() {
        var R = this.conditionStack.length - 1;
        return R > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(R) {
        return R = this.conditionStack.length - 1 - Math.abs(R || 0), R >= 0 ? this.conditionStack[R] : "INITIAL";
      },
      pushState: function(R) {
        this.begin(R);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(R, A, P, C) {
        switch (P) {
          case 0:
            return this.begin("open_directive"), 29;
          case 1:
            return this.begin("type_directive"), 30;
          case 2:
            return this.popState(), this.begin("arg_directive"), 24;
          case 3:
            return this.popState(), this.popState(), 32;
          case 4:
            return 31;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 26;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return this.begin("title"), 13;
          case 11:
            return this.popState(), "title_value";
          case 12:
            return this.begin("acc_title"), 15;
          case 13:
            return this.popState(), "acc_title_value";
          case 14:
            return this.begin("acc_descr"), 17;
          case 15:
            return this.popState(), "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            this.begin("string");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return "txt";
          case 22:
            return 6;
          case 23:
            return 8;
          case 24:
            return "value";
          case 25:
            return 28;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:[\s]+)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:pie\b)/i, /^(?:showData\b)/i, /^(?::[\s]*[\d]+(?:\.[\d]+)?)/i, /^(?:$)/i],
      conditions: { acc_descr_multiline: { rules: [17, 18], inclusive: !1 }, acc_descr: { rules: [15], inclusive: !1 }, acc_title: { rules: [13], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, title: { rules: [11], inclusive: !1 }, string: { rules: [20, 21], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 7, 8, 9, 10, 12, 14, 16, 19, 22, 23, 24, 25], inclusive: !0 } }
    };
    return T;
  }();
  _.lexer = w;
  function E() {
    this.yy = {};
  }
  return E.prototype = _, _.Parser = E, new E();
}();
wk.parser = wk;
const Wue = wk, Uue = (e) => e.match(/^\s*pie/) !== null || e.match(/^\s*bar/) !== null;
let m2 = {}, K5 = !1;
const jue = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, Xue = function(e, t) {
  e = de.sanitizeText(e, J()), m2[e] === void 0 && (m2[e] = t, B.debug("Added new section :", e));
}, Gue = () => m2, Hue = function(e) {
  K5 = e;
}, Kue = function() {
  return K5;
}, Jue = function(e) {
  return e.substring(0, 1) === ":" && (e = e.substring(1).trim()), Number(e.trim());
}, tfe = function() {
  m2 = {}, K5 = !1, _i();
}, efe = {
  parseDirective: jue,
  getConfig: () => J().pie,
  addSection: Xue,
  getSections: Gue,
  cleanupValue: Jue,
  clear: tfe,
  setAccTitle: oi,
  getAccTitle: ki,
  setDiagramTitle: Is,
  getDiagramTitle: Ns,
  setShowData: Hue,
  getShowData: Kue,
  getAccDescription: Si,
  setAccDescription: wi
};
let Mo = J(), Ro;
const bf = 450, nfe = (e, t, n, r) => {
  try {
    Mo = J(), B.debug(`Rendering info diagram
` + e);
    const x = J().securityLevel;
    let _;
    x === "sandbox" && (_ = wt("#i" + t));
    const w = wt(x === "sandbox" ? _.nodes()[0].contentDocument.body : "body"), E = x === "sandbox" ? _.nodes()[0].contentDocument : document;
    r.db.clear(), r.parser.parse(e), B.debug("Parsed info diagram");
    const T = E.getElementById(t);
    Ro = T.parentElement.offsetWidth, Ro === void 0 && (Ro = 1200), Mo.useWidth !== void 0 && (Ro = Mo.useWidth), Mo.pie.useWidth !== void 0 && (Ro = Mo.pie.useWidth);
    const S = w.select("#" + t);
    $s(S, bf, Ro, Mo.pie.useMaxWidth), T.setAttribute("viewBox", "0 0 " + Ro + " " + bf);
    var i = 40, s = 18, o = 4, a = Math.min(Ro, bf) / 2 - i, l = S.append("g").attr("transform", "translate(" + Ro / 2 + "," + bf / 2 + ")"), h = r.db.getSections(), u = 0;
    Object.keys(h).forEach(function(A) {
      u += h[A];
    });
    const R = Mo.themeVariables;
    var f = [
      R.pie1,
      R.pie2,
      R.pie3,
      R.pie4,
      R.pie5,
      R.pie6,
      R.pie7,
      R.pie8,
      R.pie9,
      R.pie10,
      R.pie11,
      R.pie12
    ], d = hN().range(f), p = Object.entries(h).map(function(A, P) {
      return {
        order: P,
        name: A[0],
        value: A[1]
      };
    }), g = dUt().value(function(A) {
      return A.value;
    }).sort(function(A, P) {
      return A.order - P.order;
    }), m = g(p), y = F_().innerRadius(0).outerRadius(a);
    l.selectAll("mySlices").data(m).enter().append("path").attr("d", y).attr("fill", function(A) {
      return d(A.data.name);
    }).attr("class", "pieCircle"), l.selectAll("mySlices").data(m).enter().append("text").text(function(A) {
      return (A.data.value / u * 100).toFixed(0) + "%";
    }).attr("transform", function(A) {
      return "translate(" + y.centroid(A) + ")";
    }).style("text-anchor", "middle").attr("class", "slice"), l.append("text").text(r.db.getDiagramTitle()).attr("x", 0).attr("y", -(bf - 50) / 2).attr("class", "pieTitleText");
    var O = l.selectAll(".legend").data(d.domain()).enter().append("g").attr("class", "legend").attr("transform", function(A, P) {
      const C = s + o, k = C * d.domain().length / 2, D = 12 * s, b = P * C - k;
      return "translate(" + D + "," + b + ")";
    });
    O.append("rect").attr("width", s).attr("height", s).style("fill", d).style("stroke", d), O.data(m).append("text").attr("x", s + o).attr("y", s - o).text(function(A) {
      return r.db.getShowData() || Mo.showData || Mo.pie.showData ? A.data.name + " [" + A.data.value + "]" : A.data.name;
    });
  } catch (x) {
    B.error("Error while rendering info diagram"), B.error(x);
  }
}, rfe = {
  draw: nfe
};
var Sk = function() {
  var e = function(Ct, H, et, U) {
    for (et = et || {}, U = Ct.length; U--; et[Ct[U]] = H)
      ;
    return et;
  }, t = [1, 3], n = [1, 5], r = [1, 6], i = [1, 7], s = [1, 8], o = [5, 6, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72], a = [1, 22], l = [2, 13], h = [1, 26], u = [1, 27], f = [1, 28], d = [1, 29], p = [1, 30], g = [1, 31], m = [1, 24], y = [1, 32], O = [1, 33], x = [1, 36], _ = [71, 72], w = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 60, 62, 71, 72], E = [1, 56], T = [1, 57], S = [1, 58], R = [1, 59], A = [1, 60], P = [1, 61], C = [1, 62], k = [62, 63], D = [1, 74], b = [1, 70], M = [1, 71], v = [1, 72], N = [1, 73], tt = [1, 75], Z = [1, 79], z = [1, 80], X = [1, 77], q = [1, 78], nt = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72], st = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, directive: 4, NEWLINE: 5, RD: 6, diagram: 7, EOF: 8, openDirective: 9, typeDirective: 10, closeDirective: 11, ":": 12, argDirective: 13, acc_title: 14, acc_title_value: 15, acc_descr: 16, acc_descr_value: 17, acc_descr_multiline_value: 18, open_directive: 19, type_directive: 20, arg_directive: 21, close_directive: 22, requirementDef: 23, elementDef: 24, relationshipDef: 25, requirementType: 26, requirementName: 27, STRUCT_START: 28, requirementBody: 29, ID: 30, COLONSEP: 31, id: 32, TEXT: 33, text: 34, RISK: 35, riskLevel: 36, VERIFYMTHD: 37, verifyType: 38, STRUCT_STOP: 39, REQUIREMENT: 40, FUNCTIONAL_REQUIREMENT: 41, INTERFACE_REQUIREMENT: 42, PERFORMANCE_REQUIREMENT: 43, PHYSICAL_REQUIREMENT: 44, DESIGN_CONSTRAINT: 45, LOW_RISK: 46, MED_RISK: 47, HIGH_RISK: 48, VERIFY_ANALYSIS: 49, VERIFY_DEMONSTRATION: 50, VERIFY_INSPECTION: 51, VERIFY_TEST: 52, ELEMENT: 53, elementName: 54, elementBody: 55, TYPE: 56, type: 57, DOCREF: 58, ref: 59, END_ARROW_L: 60, relationship: 61, LINE: 62, END_ARROW_R: 63, CONTAINS: 64, COPIES: 65, DERIVES: 66, SATISFIES: 67, VERIFIES: 68, REFINES: 69, TRACES: 70, unqString: 71, qString: 72, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 12: ":", 14: "acc_title", 15: "acc_title_value", 16: "acc_descr", 17: "acc_descr_value", 18: "acc_descr_multiline_value", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 28: "STRUCT_START", 30: "ID", 31: "COLONSEP", 33: "TEXT", 35: "RISK", 37: "VERIFYMTHD", 39: "STRUCT_STOP", 40: "REQUIREMENT", 41: "FUNCTIONAL_REQUIREMENT", 42: "INTERFACE_REQUIREMENT", 43: "PERFORMANCE_REQUIREMENT", 44: "PHYSICAL_REQUIREMENT", 45: "DESIGN_CONSTRAINT", 46: "LOW_RISK", 47: "MED_RISK", 48: "HIGH_RISK", 49: "VERIFY_ANALYSIS", 50: "VERIFY_DEMONSTRATION", 51: "VERIFY_INSPECTION", 52: "VERIFY_TEST", 53: "ELEMENT", 56: "TYPE", 58: "DOCREF", 60: "END_ARROW_L", 62: "LINE", 63: "END_ARROW_R", 64: "CONTAINS", 65: "COPIES", 66: "DERIVES", 67: "SATISFIES", 68: "VERIFIES", 69: "REFINES", 70: "TRACES", 71: "unqString", 72: "qString" },
    productions_: [0, [3, 3], [3, 2], [3, 4], [4, 3], [4, 5], [4, 2], [4, 2], [4, 1], [9, 1], [10, 1], [13, 1], [11, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [23, 5], [29, 5], [29, 5], [29, 5], [29, 5], [29, 2], [29, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [36, 1], [36, 1], [36, 1], [38, 1], [38, 1], [38, 1], [38, 1], [24, 5], [55, 5], [55, 5], [55, 2], [55, 1], [25, 5], [25, 5], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [27, 1], [27, 1], [32, 1], [32, 1], [34, 1], [34, 1], [54, 1], [54, 1], [57, 1], [57, 1], [59, 1], [59, 1]],
    performAction: function(H, et, U, W, $, F, G) {
      var I = F.length - 1;
      switch ($) {
        case 6:
          this.$ = F[I].trim(), W.setAccTitle(this.$);
          break;
        case 7:
        case 8:
          this.$ = F[I].trim(), W.setAccDescription(this.$);
          break;
        case 9:
          W.parseDirective("%%{", "open_directive");
          break;
        case 10:
          W.parseDirective(F[I], "type_directive");
          break;
        case 11:
          F[I] = F[I].trim().replace(/'/g, '"'), W.parseDirective(F[I], "arg_directive");
          break;
        case 12:
          W.parseDirective("}%%", "close_directive", "pie");
          break;
        case 13:
          this.$ = [];
          break;
        case 19:
          W.addRequirement(F[I - 3], F[I - 4]);
          break;
        case 20:
          W.setNewReqId(F[I - 2]);
          break;
        case 21:
          W.setNewReqText(F[I - 2]);
          break;
        case 22:
          W.setNewReqRisk(F[I - 2]);
          break;
        case 23:
          W.setNewReqVerifyMethod(F[I - 2]);
          break;
        case 26:
          this.$ = W.RequirementType.REQUIREMENT;
          break;
        case 27:
          this.$ = W.RequirementType.FUNCTIONAL_REQUIREMENT;
          break;
        case 28:
          this.$ = W.RequirementType.INTERFACE_REQUIREMENT;
          break;
        case 29:
          this.$ = W.RequirementType.PERFORMANCE_REQUIREMENT;
          break;
        case 30:
          this.$ = W.RequirementType.PHYSICAL_REQUIREMENT;
          break;
        case 31:
          this.$ = W.RequirementType.DESIGN_CONSTRAINT;
          break;
        case 32:
          this.$ = W.RiskLevel.LOW_RISK;
          break;
        case 33:
          this.$ = W.RiskLevel.MED_RISK;
          break;
        case 34:
          this.$ = W.RiskLevel.HIGH_RISK;
          break;
        case 35:
          this.$ = W.VerifyType.VERIFY_ANALYSIS;
          break;
        case 36:
          this.$ = W.VerifyType.VERIFY_DEMONSTRATION;
          break;
        case 37:
          this.$ = W.VerifyType.VERIFY_INSPECTION;
          break;
        case 38:
          this.$ = W.VerifyType.VERIFY_TEST;
          break;
        case 39:
          W.addElement(F[I - 3]);
          break;
        case 40:
          W.setNewElementType(F[I - 2]);
          break;
        case 41:
          W.setNewElementDocRef(F[I - 2]);
          break;
        case 44:
          W.addRelationship(F[I - 2], F[I], F[I - 4]);
          break;
        case 45:
          W.addRelationship(F[I - 2], F[I - 4], F[I]);
          break;
        case 46:
          this.$ = W.Relationships.CONTAINS;
          break;
        case 47:
          this.$ = W.Relationships.COPIES;
          break;
        case 48:
          this.$ = W.Relationships.DERIVES;
          break;
        case 49:
          this.$ = W.Relationships.SATISFIES;
          break;
        case 50:
          this.$ = W.Relationships.VERIFIES;
          break;
        case 51:
          this.$ = W.Relationships.REFINES;
          break;
        case 52:
          this.$ = W.Relationships.TRACES;
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 6: t, 9: 4, 14: n, 16: r, 18: i, 19: s }, { 1: [3] }, { 3: 10, 4: 2, 5: [1, 9], 6: t, 9: 4, 14: n, 16: r, 18: i, 19: s }, { 5: [1, 11] }, { 10: 12, 20: [1, 13] }, { 15: [1, 14] }, { 17: [1, 15] }, e(o, [2, 8]), { 20: [2, 9] }, { 3: 16, 4: 2, 6: t, 9: 4, 14: n, 16: r, 18: i, 19: s }, { 1: [2, 2] }, { 4: 21, 5: a, 7: 17, 8: l, 9: 4, 14: n, 16: r, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: h, 41: u, 42: f, 43: d, 44: p, 45: g, 53: m, 71: y, 72: O }, { 11: 34, 12: [1, 35], 22: x }, e([12, 22], [2, 10]), e(o, [2, 6]), e(o, [2, 7]), { 1: [2, 1] }, { 8: [1, 37] }, { 4: 21, 5: a, 7: 38, 8: l, 9: 4, 14: n, 16: r, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: h, 41: u, 42: f, 43: d, 44: p, 45: g, 53: m, 71: y, 72: O }, { 4: 21, 5: a, 7: 39, 8: l, 9: 4, 14: n, 16: r, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: h, 41: u, 42: f, 43: d, 44: p, 45: g, 53: m, 71: y, 72: O }, { 4: 21, 5: a, 7: 40, 8: l, 9: 4, 14: n, 16: r, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: h, 41: u, 42: f, 43: d, 44: p, 45: g, 53: m, 71: y, 72: O }, { 4: 21, 5: a, 7: 41, 8: l, 9: 4, 14: n, 16: r, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: h, 41: u, 42: f, 43: d, 44: p, 45: g, 53: m, 71: y, 72: O }, { 4: 21, 5: a, 7: 42, 8: l, 9: 4, 14: n, 16: r, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: h, 41: u, 42: f, 43: d, 44: p, 45: g, 53: m, 71: y, 72: O }, { 27: 43, 71: [1, 44], 72: [1, 45] }, { 54: 46, 71: [1, 47], 72: [1, 48] }, { 60: [1, 49], 62: [1, 50] }, e(_, [2, 26]), e(_, [2, 27]), e(_, [2, 28]), e(_, [2, 29]), e(_, [2, 30]), e(_, [2, 31]), e(w, [2, 55]), e(w, [2, 56]), e(o, [2, 4]), { 13: 51, 21: [1, 52] }, e(o, [2, 12]), { 1: [2, 3] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 8: [2, 17] }, { 8: [2, 18] }, { 28: [1, 53] }, { 28: [2, 53] }, { 28: [2, 54] }, { 28: [1, 54] }, { 28: [2, 59] }, { 28: [2, 60] }, { 61: 55, 64: E, 65: T, 66: S, 67: R, 68: A, 69: P, 70: C }, { 61: 63, 64: E, 65: T, 66: S, 67: R, 68: A, 69: P, 70: C }, { 11: 64, 22: x }, { 22: [2, 11] }, { 5: [1, 65] }, { 5: [1, 66] }, { 62: [1, 67] }, e(k, [2, 46]), e(k, [2, 47]), e(k, [2, 48]), e(k, [2, 49]), e(k, [2, 50]), e(k, [2, 51]), e(k, [2, 52]), { 63: [1, 68] }, e(o, [2, 5]), { 5: D, 29: 69, 30: b, 33: M, 35: v, 37: N, 39: tt }, { 5: Z, 39: z, 55: 76, 56: X, 58: q }, { 32: 81, 71: y, 72: O }, { 32: 82, 71: y, 72: O }, e(nt, [2, 19]), { 31: [1, 83] }, { 31: [1, 84] }, { 31: [1, 85] }, { 31: [1, 86] }, { 5: D, 29: 87, 30: b, 33: M, 35: v, 37: N, 39: tt }, e(nt, [2, 25]), e(nt, [2, 39]), { 31: [1, 88] }, { 31: [1, 89] }, { 5: Z, 39: z, 55: 90, 56: X, 58: q }, e(nt, [2, 43]), e(nt, [2, 44]), e(nt, [2, 45]), { 32: 91, 71: y, 72: O }, { 34: 92, 71: [1, 93], 72: [1, 94] }, { 36: 95, 46: [1, 96], 47: [1, 97], 48: [1, 98] }, { 38: 99, 49: [1, 100], 50: [1, 101], 51: [1, 102], 52: [1, 103] }, e(nt, [2, 24]), { 57: 104, 71: [1, 105], 72: [1, 106] }, { 59: 107, 71: [1, 108], 72: [1, 109] }, e(nt, [2, 42]), { 5: [1, 110] }, { 5: [1, 111] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [1, 112] }, { 5: [2, 32] }, { 5: [2, 33] }, { 5: [2, 34] }, { 5: [1, 113] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [2, 38] }, { 5: [1, 114] }, { 5: [2, 61] }, { 5: [2, 62] }, { 5: [1, 115] }, { 5: [2, 63] }, { 5: [2, 64] }, { 5: D, 29: 116, 30: b, 33: M, 35: v, 37: N, 39: tt }, { 5: D, 29: 117, 30: b, 33: M, 35: v, 37: N, 39: tt }, { 5: D, 29: 118, 30: b, 33: M, 35: v, 37: N, 39: tt }, { 5: D, 29: 119, 30: b, 33: M, 35: v, 37: N, 39: tt }, { 5: Z, 39: z, 55: 120, 56: X, 58: q }, { 5: Z, 39: z, 55: 121, 56: X, 58: q }, e(nt, [2, 20]), e(nt, [2, 21]), e(nt, [2, 22]), e(nt, [2, 23]), e(nt, [2, 40]), e(nt, [2, 41])],
    defaultActions: { 8: [2, 9], 10: [2, 2], 16: [2, 1], 37: [2, 3], 38: [2, 14], 39: [2, 15], 40: [2, 16], 41: [2, 17], 42: [2, 18], 44: [2, 53], 45: [2, 54], 47: [2, 59], 48: [2, 60], 52: [2, 11], 93: [2, 57], 94: [2, 58], 96: [2, 32], 97: [2, 33], 98: [2, 34], 100: [2, 35], 101: [2, 36], 102: [2, 37], 103: [2, 38], 105: [2, 61], 106: [2, 62], 108: [2, 63], 109: [2, 64] },
    parseError: function(H, et) {
      if (et.recoverable)
        this.trace(H);
      else {
        var U = new Error(H);
        throw U.hash = et, U;
      }
    },
    parse: function(H) {
      var et = this, U = [0], W = [], $ = [null], F = [], G = this.table, I = "", ht = 0, L = 0, $t = 2, it = 1, At = F.slice.call(arguments, 1), St = Object.create(this.lexer), bt = { yy: {} };
      for (var gt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, gt) && (bt.yy[gt] = this.yy[gt]);
      St.setInput(H, bt.yy), bt.yy.lexer = St, bt.yy.parser = this, typeof St.yylloc > "u" && (St.yylloc = {});
      var yt = St.yylloc;
      F.push(yt);
      var dt = St.options && St.options.ranges;
      typeof bt.yy.parseError == "function" ? this.parseError = bt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function xt() {
        var _t;
        return _t = W.pop() || St.lex() || it, typeof _t != "number" && (_t instanceof Array && (W = _t, _t = W.pop()), _t = et.symbols_[_t] || _t), _t;
      }
      for (var Re, ye, zt, Yt, ce = {}, Ie, re, Qt, Lt; ; ) {
        if (ye = U[U.length - 1], this.defaultActions[ye] ? zt = this.defaultActions[ye] : ((Re === null || typeof Re > "u") && (Re = xt()), zt = G[ye] && G[ye][Re]), typeof zt > "u" || !zt.length || !zt[0]) {
          var kt = "";
          Lt = [];
          for (Ie in G[ye])
            this.terminals_[Ie] && Ie > $t && Lt.push("'" + this.terminals_[Ie] + "'");
          St.showPosition ? kt = "Parse error on line " + (ht + 1) + `:
` + St.showPosition() + `
Expecting ` + Lt.join(", ") + ", got '" + (this.terminals_[Re] || Re) + "'" : kt = "Parse error on line " + (ht + 1) + ": Unexpected " + (Re == it ? "end of input" : "'" + (this.terminals_[Re] || Re) + "'"), this.parseError(kt, {
            text: St.match,
            token: this.terminals_[Re] || Re,
            line: St.yylineno,
            loc: yt,
            expected: Lt
          });
        }
        if (zt[0] instanceof Array && zt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ye + ", token: " + Re);
        switch (zt[0]) {
          case 1:
            U.push(Re), $.push(St.yytext), F.push(St.yylloc), U.push(zt[1]), Re = null, L = St.yyleng, I = St.yytext, ht = St.yylineno, yt = St.yylloc;
            break;
          case 2:
            if (re = this.productions_[zt[1]][1], ce.$ = $[$.length - re], ce._$ = {
              first_line: F[F.length - (re || 1)].first_line,
              last_line: F[F.length - 1].last_line,
              first_column: F[F.length - (re || 1)].first_column,
              last_column: F[F.length - 1].last_column
            }, dt && (ce._$.range = [
              F[F.length - (re || 1)].range[0],
              F[F.length - 1].range[1]
            ]), Yt = this.performAction.apply(ce, [
              I,
              L,
              ht,
              bt.yy,
              zt[1],
              $,
              F
            ].concat(At)), typeof Yt < "u")
              return Yt;
            re && (U = U.slice(0, -1 * re * 2), $ = $.slice(0, -1 * re), F = F.slice(0, -1 * re)), U.push(this.productions_[zt[1]][0]), $.push(ce.$), F.push(ce._$), Qt = G[U[U.length - 2]][U[U.length - 1]], U.push(Qt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, ct = function() {
    var Ct = {
      EOF: 1,
      parseError: function(et, U) {
        if (this.yy.parser)
          this.yy.parser.parseError(et, U);
        else
          throw new Error(et);
      },
      setInput: function(H, et) {
        return this.yy = et || this.yy || {}, this._input = H, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var H = this._input[0];
        this.yytext += H, this.yyleng++, this.offset++, this.match += H, this.matched += H;
        var et = H.match(/(?:\r\n?|\n).*/g);
        return et ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), H;
      },
      unput: function(H) {
        var et = H.length, U = H.split(/(?:\r\n?|\n)/g);
        this._input = H + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - et), this.offset -= et;
        var W = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), U.length - 1 && (this.yylineno -= U.length - 1);
        var $ = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: U ? (U.length === W.length ? this.yylloc.first_column : 0) + W[W.length - U.length].length - U[0].length : this.yylloc.first_column - et
        }, this.options.ranges && (this.yylloc.range = [$[0], $[0] + this.yyleng - et]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(H) {
        this.unput(this.match.slice(H));
      },
      pastInput: function() {
        var H = this.matched.substr(0, this.matched.length - this.match.length);
        return (H.length > 20 ? "..." : "") + H.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var H = this.match;
        return H.length < 20 && (H += this._input.substr(0, 20 - H.length)), (H.substr(0, 20) + (H.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var H = this.pastInput(), et = new Array(H.length + 1).join("-");
        return H + this.upcomingInput() + `
` + et + "^";
      },
      test_match: function(H, et) {
        var U, W, $;
        if (this.options.backtrack_lexer && ($ = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && ($.yylloc.range = this.yylloc.range.slice(0))), W = H[0].match(/(?:\r\n?|\n).*/g), W && (this.yylineno += W.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: W ? W[W.length - 1].length - W[W.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + H[0].length
        }, this.yytext += H[0], this.match += H[0], this.matches = H, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(H[0].length), this.matched += H[0], U = this.performAction.call(this, this.yy, this, et, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), U)
          return U;
        if (this._backtrack) {
          for (var F in $)
            this[F] = $[F];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var H, et, U, W;
        this._more || (this.yytext = "", this.match = "");
        for (var $ = this._currentRules(), F = 0; F < $.length; F++)
          if (U = this._input.match(this.rules[$[F]]), U && (!et || U[0].length > et[0].length)) {
            if (et = U, W = F, this.options.backtrack_lexer) {
              if (H = this.test_match(U, $[F]), H !== !1)
                return H;
              if (this._backtrack) {
                et = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return et ? (H = this.test_match(et, $[W]), H !== !1 ? H : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var et = this.next();
        return et || this.lex();
      },
      begin: function(et) {
        this.conditionStack.push(et);
      },
      popState: function() {
        var et = this.conditionStack.length - 1;
        return et > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(et) {
        return et = this.conditionStack.length - 1 - Math.abs(et || 0), et >= 0 ? this.conditionStack[et] : "INITIAL";
      },
      pushState: function(et) {
        this.begin(et);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(et, U, W, $) {
        switch (W) {
          case 0:
            return this.begin("open_directive"), 19;
          case 1:
            return this.begin("type_directive"), 20;
          case 2:
            return this.popState(), this.begin("arg_directive"), 12;
          case 3:
            return this.popState(), this.popState(), 22;
          case 4:
            return 21;
          case 5:
            return "title";
          case 6:
            return this.begin("acc_title"), 14;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 16;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 5;
          case 14:
            break;
          case 15:
            break;
          case 16:
            break;
          case 17:
            return 8;
          case 18:
            return 6;
          case 19:
            return 28;
          case 20:
            return 39;
          case 21:
            return 31;
          case 22:
            return 30;
          case 23:
            return 33;
          case 24:
            return 35;
          case 25:
            return 37;
          case 26:
            return 40;
          case 27:
            return 41;
          case 28:
            return 42;
          case 29:
            return 43;
          case 30:
            return 44;
          case 31:
            return 45;
          case 32:
            return 46;
          case 33:
            return 47;
          case 34:
            return 48;
          case 35:
            return 49;
          case 36:
            return 50;
          case 37:
            return 51;
          case 38:
            return 52;
          case 39:
            return 53;
          case 40:
            return 64;
          case 41:
            return 65;
          case 42:
            return 66;
          case 43:
            return 67;
          case 44:
            return 68;
          case 45:
            return 69;
          case 46:
            return 70;
          case 47:
            return 56;
          case 48:
            return 58;
          case 49:
            return 60;
          case 50:
            return 63;
          case 51:
            return 62;
          case 52:
            this.begin("string");
            break;
          case 53:
            this.popState();
            break;
          case 54:
            return "qString";
          case 55:
            return U.yytext = U.yytext.trim(), 71;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^\r\n\{\<\>\-\=]*)/i],
      conditions: { acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, unqString: { rules: [], inclusive: !1 }, token: { rules: [], inclusive: !1 }, string: { rules: [53, 54], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 55], inclusive: !0 } }
    };
    return Ct;
  }();
  st.lexer = ct;
  function Y() {
    this.yy = {};
  }
  return Y.prototype = st, st.Parser = Y, new Y();
}();
Sk.parser = Sk;
const ife = Sk, sfe = (e) => e.match(/^\s*requirement(Diagram)?/) !== null;
let J5 = [], Jr = {}, ad = {}, Ha = {}, ld = {};
const ofe = {
  REQUIREMENT: "Requirement",
  FUNCTIONAL_REQUIREMENT: "Functional Requirement",
  INTERFACE_REQUIREMENT: "Interface Requirement",
  PERFORMANCE_REQUIREMENT: "Performance Requirement",
  PHYSICAL_REQUIREMENT: "Physical Requirement",
  DESIGN_CONSTRAINT: "Design Constraint"
}, afe = {
  LOW_RISK: "Low",
  MED_RISK: "Medium",
  HIGH_RISK: "High"
}, lfe = {
  VERIFY_ANALYSIS: "Analysis",
  VERIFY_DEMONSTRATION: "Demonstration",
  VERIFY_INSPECTION: "Inspection",
  VERIFY_TEST: "Test"
}, cfe = {
  CONTAINS: "contains",
  COPIES: "copies",
  DERIVES: "derives",
  SATISFIES: "satisfies",
  VERIFIES: "verifies",
  REFINES: "refines",
  TRACES: "traces"
}, hfe = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, ufe = (e, t) => (ad[e] === void 0 && (ad[e] = {
  name: e,
  type: t,
  id: Jr.id,
  text: Jr.text,
  risk: Jr.risk,
  verifyMethod: Jr.verifyMethod
}), Jr = {}, ad[e]), ffe = () => ad, dfe = (e) => {
  Jr !== void 0 && (Jr.id = e);
}, pfe = (e) => {
  Jr !== void 0 && (Jr.text = e);
}, gfe = (e) => {
  Jr !== void 0 && (Jr.risk = e);
}, mfe = (e) => {
  Jr !== void 0 && (Jr.verifyMethod = e);
}, yfe = (e) => (ld[e] === void 0 && (ld[e] = {
  name: e,
  type: Ha.type,
  docRef: Ha.docRef
}, B.info("Added new requirement: ", e)), Ha = {}, ld[e]), bfe = () => ld, Ofe = (e) => {
  Ha !== void 0 && (Ha.type = e);
}, xfe = (e) => {
  Ha !== void 0 && (Ha.docRef = e);
}, vfe = (e, t, n) => {
  J5.push({
    type: e,
    src: t,
    dst: n
  });
}, _fe = () => J5, kfe = () => {
  J5 = [], Jr = {}, ad = {}, Ha = {}, ld = {}, _i();
}, wfe = {
  RequirementType: ofe,
  RiskLevel: afe,
  VerifyType: lfe,
  Relationships: cfe,
  parseDirective: hfe,
  getConfig: () => J().req,
  addRequirement: ufe,
  getRequirements: ffe,
  setNewReqId: dfe,
  setNewReqText: pfe,
  setNewReqRisk: gfe,
  setNewReqVerifyMethod: mfe,
  setAccTitle: oi,
  getAccTitle: ki,
  setAccDescription: wi,
  getAccDescription: Si,
  addElement: yfe,
  getElements: bfe,
  setNewElementType: Ofe,
  setNewElementDocRef: xfe,
  addRelationship: vfe,
  getRelationships: _fe,
  clear: kfe
}, Ck = {
  CONTAINS: "contains",
  ARROW: "arrow"
}, Sfe = (e, t) => {
  let n = e.append("defs").append("marker").attr("id", Ck.CONTAINS + "_line_ending").attr("refX", 0).attr("refY", t.line_height / 2).attr("markerWidth", t.line_height).attr("markerHeight", t.line_height).attr("orient", "auto").append("g");
  n.append("circle").attr("cx", t.line_height / 2).attr("cy", t.line_height / 2).attr("r", t.line_height / 2).attr("fill", "none"), n.append("line").attr("x1", 0).attr("x2", t.line_height).attr("y1", t.line_height / 2).attr("y2", t.line_height / 2).attr("stroke-width", 1), n.append("line").attr("y1", 0).attr("y2", t.line_height).attr("x1", t.line_height / 2).attr("x2", t.line_height / 2).attr("stroke-width", 1), e.append("defs").append("marker").attr("id", Ck.ARROW + "_line_ending").attr("refX", t.line_height).attr("refY", 0.5 * t.line_height).attr("markerWidth", t.line_height).attr("markerHeight", t.line_height).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L${t.line_height},${t.line_height / 2}
      M${t.line_height},${t.line_height / 2}
      L0,${t.line_height}`
  ).attr("stroke-width", 1);
}, EZ = {
  ReqMarkers: Ck,
  insertLineEndings: Sfe
};
let vn = {}, U8 = 0;
const AZ = (e, t) => e.insert("rect", "#" + t).attr("class", "req reqBox").attr("x", 0).attr("y", 0).attr("width", vn.rect_min_width + "px").attr("height", vn.rect_min_height + "px"), PZ = (e, t, n) => {
  let r = vn.rect_min_width / 2, i = e.append("text").attr("class", "req reqLabel reqTitle").attr("id", t).attr("x", r).attr("y", vn.rect_padding).attr("dominant-baseline", "hanging"), s = 0;
  n.forEach((h) => {
    s == 0 ? i.append("tspan").attr("text-anchor", "middle").attr("x", vn.rect_min_width / 2).attr("dy", 0).text(h) : i.append("tspan").attr("text-anchor", "middle").attr("x", vn.rect_min_width / 2).attr("dy", vn.line_height * 0.75).text(h), s++;
  });
  let o = 1.5 * vn.rect_padding, a = s * vn.line_height * 0.75, l = o + a;
  return e.append("line").attr("class", "req-title-line").attr("x1", "0").attr("x2", vn.rect_min_width).attr("y1", l).attr("y2", l), {
    titleNode: i,
    y: l
  };
}, DZ = (e, t, n, r) => {
  let i = e.append("text").attr("class", "req reqLabel").attr("id", t).attr("x", vn.rect_padding).attr("y", r).attr("dominant-baseline", "hanging"), s = 0;
  const o = 30;
  let a = [];
  return n.forEach((l) => {
    let h = l.length;
    for (; h > o && s < 3; ) {
      let u = l.substring(0, o);
      l = l.substring(o, l.length), h = l.length, a[a.length] = u, s++;
    }
    if (s == 3) {
      let u = a[a.length - 1];
      a[a.length - 1] = u.substring(0, u.length - 4) + "...";
    } else
      a[a.length] = l;
    s = 0;
  }), a.forEach((l) => {
    i.append("tspan").attr("x", vn.rect_padding).attr("dy", vn.line_height).text(l);
  }), i;
}, Cfe = (e, t, n, r) => {
  const i = t.node().getTotalLength(), s = t.node().getPointAtLength(i * 0.5), o = "rel" + U8;
  U8++;
  const l = e.append("text").attr("class", "req relationshipLabel").attr("id", o).attr("x", s.x).attr("y", s.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(r).node().getBBox();
  e.insert("rect", "#" + o).attr("class", "req reqLabelBox").attr("x", s.x - l.width / 2).attr("y", s.y - l.height / 2).attr("width", l.width).attr("height", l.height).attr("fill", "white").attr("fill-opacity", "85%");
}, Tfe = function(e, t, n, r, i) {
  const s = n.edge(Ou(t.src), Ou(t.dst)), o = Qu().x(function(l) {
    return l.x;
  }).y(function(l) {
    return l.y;
  }), a = e.insert("path", "#" + r).attr("class", "er relationshipLine").attr("d", o(s.points)).attr("fill", "none");
  t.type == i.db.Relationships.CONTAINS ? a.attr(
    "marker-start",
    "url(" + de.getUrl(vn.arrowMarkerAbsolute) + "#" + t.type + "_line_ending)"
  ) : (a.attr("stroke-dasharray", "10,7"), a.attr(
    "marker-end",
    "url(" + de.getUrl(vn.arrowMarkerAbsolute) + "#" + EZ.ReqMarkers.ARROW + "_line_ending)"
  )), Cfe(e, a, vn, `<<${t.type}>>`);
}, Efe = (e, t, n) => {
  Object.keys(e).forEach((r) => {
    let i = e[r];
    r = Ou(r), B.info("Added new requirement: ", r);
    const s = n.append("g").attr("id", r), o = "req-" + r, a = AZ(s, o);
    let l = PZ(s, r + "_title", [
      `<<${i.type}>>`,
      `${i.name}`
    ]);
    DZ(
      s,
      r + "_body",
      [
        `Id: ${i.id}`,
        `Text: ${i.text}`,
        `Risk: ${i.risk}`,
        `Verification: ${i.verifyMethod}`
      ],
      l.y
    );
    const h = a.node().getBBox();
    t.setNode(r, {
      width: h.width,
      height: h.height,
      shape: "rect",
      id: r
    });
  });
}, Afe = (e, t, n) => {
  Object.keys(e).forEach((r) => {
    let i = e[r];
    const s = Ou(r), o = n.append("g").attr("id", s), a = "element-" + s, l = AZ(o, a);
    let h = PZ(o, a + "_title", ["<<Element>>", `${r}`]);
    DZ(
      o,
      a + "_body",
      [`Type: ${i.type || "Not Specified"}`, `Doc Ref: ${i.docRef || "None"}`],
      h.y
    );
    const u = l.node().getBBox();
    t.setNode(s, {
      width: u.width,
      height: u.height,
      shape: "rect",
      id: s
    });
  });
}, Pfe = (e, t) => (e.forEach(function(n) {
  let r = Ou(n.src), i = Ou(n.dst);
  t.setEdge(r, i, { relationship: n });
}), e), Dfe = function(e, t) {
  t.nodes().forEach(function(n) {
    n !== void 0 && t.node(n) !== void 0 && (e.select("#" + n), e.select("#" + n).attr(
      "transform",
      "translate(" + (t.node(n).x - t.node(n).width / 2) + "," + (t.node(n).y - t.node(n).height / 2) + " )"
    ));
  });
}, Ou = (e) => e.replace(/\s/g, "").replace(/\./g, "_"), Lfe = (e, t, n, r) => {
  vn = J().requirement, r.db.clear(), r.parser.parse(e);
  const i = vn.securityLevel;
  let s;
  i === "sandbox" && (s = wt("#i" + t));
  const a = wt(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body").select(`[id='${t}']`);
  EZ.insertLineEndings(a, vn);
  const l = new zn({
    multigraph: !1,
    compound: !1,
    directed: !0
  }).setGraph({
    rankdir: vn.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let h = r.db.getRequirements(), u = r.db.getElements(), f = r.db.getRelationships();
  Efe(h, l, a), Afe(u, l, a), Pfe(f, l), Wu(l), Dfe(a, l), f.forEach(function(y) {
    Tfe(a, y, l, t, r);
  });
  const d = vn.rect_padding, p = a.node().getBBox(), g = p.width + d * 2, m = p.height + d * 2;
  $s(a, m, g, vn.useMaxWidth), a.attr("viewBox", `${p.x - d} ${p.y - d} ${g} ${m}`);
}, Mfe = {
  draw: Lfe
};
var Tk = function() {
  var e = function(et, U, W, $) {
    for (W = W || {}, $ = et.length; $--; W[et[$]] = U)
      ;
    return W;
  }, t = [1, 2], n = [1, 3], r = [1, 5], i = [1, 7], s = [2, 5], o = [1, 15], a = [1, 17], l = [1, 19], h = [1, 21], u = [1, 22], f = [1, 23], d = [1, 29], p = [1, 30], g = [1, 31], m = [1, 32], y = [1, 33], O = [1, 34], x = [1, 35], _ = [1, 36], w = [1, 37], E = [1, 38], T = [1, 39], S = [1, 40], R = [1, 42], A = [1, 43], P = [1, 45], C = [1, 46], k = [1, 47], D = [1, 48], b = [1, 49], M = [1, 50], v = [1, 53], N = [1, 4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 51, 52, 53, 54, 56, 57, 62, 63, 64, 65, 73, 83], tt = [4, 5, 21, 54, 56], Z = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 54, 56, 57, 62, 63, 64, 65, 73, 83], z = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 53, 54, 56, 57, 62, 63, 64, 65, 73, 83], X = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 52, 54, 56, 57, 62, 63, 64, 65, 73, 83], q = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 51, 54, 56, 57, 62, 63, 64, 65, 73, 83], nt = [71, 72, 73], st = [1, 125], ct = [1, 4, 5, 7, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 51, 52, 53, 54, 56, 57, 62, 63, 64, 65, 73, 83], Y = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NEWLINE: 5, directive: 6, SD: 7, document: 8, line: 9, statement: 10, box_section: 11, box_line: 12, participant_statement: 13, openDirective: 14, typeDirective: 15, closeDirective: 16, ":": 17, argDirective: 18, box: 19, restOfLine: 20, end: 21, signal: 22, autonumber: 23, NUM: 24, off: 25, activate: 26, actor: 27, deactivate: 28, note_statement: 29, links_statement: 30, link_statement: 31, properties_statement: 32, details_statement: 33, title: 34, legacy_title: 35, acc_title: 36, acc_title_value: 37, acc_descr: 38, acc_descr_value: 39, acc_descr_multiline_value: 40, loop: 41, rect: 42, opt: 43, alt: 44, else_sections: 45, par: 46, par_sections: 47, critical: 48, option_sections: 49, break: 50, option: 51, and: 52, else: 53, participant: 54, AS: 55, participant_actor: 56, note: 57, placement: 58, text2: 59, over: 60, actor_pair: 61, links: 62, link: 63, properties: 64, details: 65, spaceList: 66, ",": 67, left_of: 68, right_of: 69, signaltype: 70, "+": 71, "-": 72, ACTOR: 73, SOLID_OPEN_ARROW: 74, DOTTED_OPEN_ARROW: 75, SOLID_ARROW: 76, DOTTED_ARROW: 77, SOLID_CROSS: 78, DOTTED_CROSS: 79, SOLID_POINT: 80, DOTTED_POINT: 81, TXT: 82, open_directive: 83, type_directive: 84, arg_directive: 85, close_directive: 86, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 7: "SD", 17: ":", 19: "box", 20: "restOfLine", 21: "end", 23: "autonumber", 24: "NUM", 25: "off", 26: "activate", 28: "deactivate", 34: "title", 35: "legacy_title", 36: "acc_title", 37: "acc_title_value", 38: "acc_descr", 39: "acc_descr_value", 40: "acc_descr_multiline_value", 41: "loop", 42: "rect", 43: "opt", 44: "alt", 46: "par", 48: "critical", 50: "break", 51: "option", 52: "and", 53: "else", 54: "participant", 55: "AS", 56: "participant_actor", 57: "note", 60: "over", 62: "links", 63: "link", 64: "properties", 65: "details", 67: ",", 68: "left_of", 69: "right_of", 71: "+", 72: "-", 73: "ACTOR", 74: "SOLID_OPEN_ARROW", 75: "DOTTED_OPEN_ARROW", 76: "SOLID_ARROW", 77: "DOTTED_ARROW", 78: "SOLID_CROSS", 79: "DOTTED_CROSS", 80: "SOLID_POINT", 81: "DOTTED_POINT", 82: "TXT", 83: "open_directive", 84: "type_directive", 85: "arg_directive", 86: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [11, 0], [11, 2], [12, 2], [12, 1], [12, 1], [6, 4], [6, 6], [10, 1], [10, 4], [10, 2], [10, 4], [10, 3], [10, 3], [10, 2], [10, 3], [10, 3], [10, 2], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 1], [49, 1], [49, 4], [47, 1], [47, 4], [45, 1], [45, 4], [13, 5], [13, 3], [13, 5], [13, 3], [29, 4], [29, 4], [30, 3], [31, 3], [32, 3], [33, 3], [66, 2], [66, 1], [61, 3], [61, 1], [58, 1], [58, 1], [22, 5], [22, 5], [22, 4], [27, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [59, 1], [14, 1], [15, 1], [18, 1], [16, 1]],
    performAction: function(U, W, $, F, G, I, ht) {
      var L = I.length - 1;
      switch (G) {
        case 4:
          return F.apply(I[L]), I[L];
        case 5:
        case 10:
          this.$ = [];
          break;
        case 6:
        case 11:
          I[L - 1].push(I[L]), this.$ = I[L - 1];
          break;
        case 7:
        case 8:
        case 12:
        case 13:
          this.$ = I[L];
          break;
        case 9:
        case 14:
          this.$ = [];
          break;
        case 18:
          I[L - 1].unshift({ type: "boxStart", boxData: F.parseBoxData(I[L - 2]) }), I[L - 1].push({ type: "boxEnd", boxText: I[L - 2] }), this.$ = I[L - 1];
          break;
        case 20:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(I[L - 2]), sequenceIndexStep: Number(I[L - 1]), sequenceVisible: !0, signalType: F.LINETYPE.AUTONUMBER };
          break;
        case 21:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(I[L - 1]), sequenceIndexStep: 1, sequenceVisible: !0, signalType: F.LINETYPE.AUTONUMBER };
          break;
        case 22:
          this.$ = { type: "sequenceIndex", sequenceVisible: !1, signalType: F.LINETYPE.AUTONUMBER };
          break;
        case 23:
          this.$ = { type: "sequenceIndex", sequenceVisible: !0, signalType: F.LINETYPE.AUTONUMBER };
          break;
        case 24:
          this.$ = { type: "activeStart", signalType: F.LINETYPE.ACTIVE_START, actor: I[L - 1] };
          break;
        case 25:
          this.$ = { type: "activeEnd", signalType: F.LINETYPE.ACTIVE_END, actor: I[L - 1] };
          break;
        case 31:
          F.setDiagramTitle(I[L].substring(6)), this.$ = I[L].substring(6);
          break;
        case 32:
          F.setDiagramTitle(I[L].substring(7)), this.$ = I[L].substring(7);
          break;
        case 33:
          this.$ = I[L].trim(), F.setAccTitle(this.$);
          break;
        case 34:
        case 35:
          this.$ = I[L].trim(), F.setAccDescription(this.$);
          break;
        case 36:
          I[L - 1].unshift({ type: "loopStart", loopText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.LOOP_START }), I[L - 1].push({ type: "loopEnd", loopText: I[L - 2], signalType: F.LINETYPE.LOOP_END }), this.$ = I[L - 1];
          break;
        case 37:
          I[L - 1].unshift({ type: "rectStart", color: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.RECT_START }), I[L - 1].push({ type: "rectEnd", color: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.RECT_END }), this.$ = I[L - 1];
          break;
        case 38:
          I[L - 1].unshift({ type: "optStart", optText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.OPT_START }), I[L - 1].push({ type: "optEnd", optText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.OPT_END }), this.$ = I[L - 1];
          break;
        case 39:
          I[L - 1].unshift({ type: "altStart", altText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.ALT_START }), I[L - 1].push({ type: "altEnd", signalType: F.LINETYPE.ALT_END }), this.$ = I[L - 1];
          break;
        case 40:
          I[L - 1].unshift({ type: "parStart", parText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.PAR_START }), I[L - 1].push({ type: "parEnd", signalType: F.LINETYPE.PAR_END }), this.$ = I[L - 1];
          break;
        case 41:
          I[L - 1].unshift({ type: "criticalStart", criticalText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.CRITICAL_START }), I[L - 1].push({ type: "criticalEnd", signalType: F.LINETYPE.CRITICAL_END }), this.$ = I[L - 1];
          break;
        case 42:
          I[L - 1].unshift({ type: "breakStart", breakText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.BREAK_START }), I[L - 1].push({ type: "breakEnd", optText: F.parseMessage(I[L - 2]), signalType: F.LINETYPE.BREAK_END }), this.$ = I[L - 1];
          break;
        case 45:
          this.$ = I[L - 3].concat([{ type: "option", optionText: F.parseMessage(I[L - 1]), signalType: F.LINETYPE.CRITICAL_OPTION }, I[L]]);
          break;
        case 47:
          this.$ = I[L - 3].concat([{ type: "and", parText: F.parseMessage(I[L - 1]), signalType: F.LINETYPE.PAR_AND }, I[L]]);
          break;
        case 49:
          this.$ = I[L - 3].concat([{ type: "else", altText: F.parseMessage(I[L - 1]), signalType: F.LINETYPE.ALT_ELSE }, I[L]]);
          break;
        case 50:
          I[L - 3].type = "addParticipant", I[L - 3].description = F.parseMessage(I[L - 1]), this.$ = I[L - 3];
          break;
        case 51:
          I[L - 1].type = "addParticipant", this.$ = I[L - 1];
          break;
        case 52:
          I[L - 3].type = "addActor", I[L - 3].description = F.parseMessage(I[L - 1]), this.$ = I[L - 3];
          break;
        case 53:
          I[L - 1].type = "addActor", this.$ = I[L - 1];
          break;
        case 54:
          this.$ = [I[L - 1], { type: "addNote", placement: I[L - 2], actor: I[L - 1].actor, text: I[L] }];
          break;
        case 55:
          I[L - 2] = [].concat(I[L - 1], I[L - 1]).slice(0, 2), I[L - 2][0] = I[L - 2][0].actor, I[L - 2][1] = I[L - 2][1].actor, this.$ = [I[L - 1], { type: "addNote", placement: F.PLACEMENT.OVER, actor: I[L - 2].slice(0, 2), text: I[L] }];
          break;
        case 56:
          this.$ = [I[L - 1], { type: "addLinks", actor: I[L - 1].actor, text: I[L] }];
          break;
        case 57:
          this.$ = [I[L - 1], { type: "addALink", actor: I[L - 1].actor, text: I[L] }];
          break;
        case 58:
          this.$ = [I[L - 1], { type: "addProperties", actor: I[L - 1].actor, text: I[L] }];
          break;
        case 59:
          this.$ = [I[L - 1], { type: "addDetails", actor: I[L - 1].actor, text: I[L] }];
          break;
        case 62:
          this.$ = [I[L - 2], I[L]];
          break;
        case 63:
          this.$ = I[L];
          break;
        case 64:
          this.$ = F.PLACEMENT.LEFTOF;
          break;
        case 65:
          this.$ = F.PLACEMENT.RIGHTOF;
          break;
        case 66:
          this.$ = [
            I[L - 4],
            I[L - 1],
            { type: "addMessage", from: I[L - 4].actor, to: I[L - 1].actor, signalType: I[L - 3], msg: I[L] },
            { type: "activeStart", signalType: F.LINETYPE.ACTIVE_START, actor: I[L - 1] }
          ];
          break;
        case 67:
          this.$ = [
            I[L - 4],
            I[L - 1],
            { type: "addMessage", from: I[L - 4].actor, to: I[L - 1].actor, signalType: I[L - 3], msg: I[L] },
            { type: "activeEnd", signalType: F.LINETYPE.ACTIVE_END, actor: I[L - 4] }
          ];
          break;
        case 68:
          this.$ = [I[L - 3], I[L - 1], { type: "addMessage", from: I[L - 3].actor, to: I[L - 1].actor, signalType: I[L - 2], msg: I[L] }];
          break;
        case 69:
          this.$ = { type: "addParticipant", actor: I[L] };
          break;
        case 70:
          this.$ = F.LINETYPE.SOLID_OPEN;
          break;
        case 71:
          this.$ = F.LINETYPE.DOTTED_OPEN;
          break;
        case 72:
          this.$ = F.LINETYPE.SOLID;
          break;
        case 73:
          this.$ = F.LINETYPE.DOTTED;
          break;
        case 74:
          this.$ = F.LINETYPE.SOLID_CROSS;
          break;
        case 75:
          this.$ = F.LINETYPE.DOTTED_CROSS;
          break;
        case 76:
          this.$ = F.LINETYPE.SOLID_POINT;
          break;
        case 77:
          this.$ = F.LINETYPE.DOTTED_POINT;
          break;
        case 78:
          this.$ = F.parseMessage(I[L].trim().substring(1));
          break;
        case 79:
          F.parseDirective("%%{", "open_directive");
          break;
        case 80:
          F.parseDirective(I[L], "type_directive");
          break;
        case 81:
          I[L] = I[L].trim().replace(/'/g, '"'), F.parseDirective(I[L], "arg_directive");
          break;
        case 82:
          F.parseDirective("}%%", "close_directive", "sequence");
          break;
      }
    },
    table: [{ 3: 1, 4: t, 5: n, 6: 4, 7: r, 14: 6, 83: i }, { 1: [3] }, { 3: 8, 4: t, 5: n, 6: 4, 7: r, 14: 6, 83: i }, { 3: 9, 4: t, 5: n, 6: 4, 7: r, 14: 6, 83: i }, { 3: 10, 4: t, 5: n, 6: 4, 7: r, 14: 6, 83: i }, e([1, 4, 5, 19, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 54, 56, 57, 62, 63, 64, 65, 73, 83], s, { 8: 11 }), { 15: 12, 84: [1, 13] }, { 84: [2, 79] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 16: 51, 17: [1, 52], 86: v }, e([17, 86], [2, 80]), e(N, [2, 6]), { 6: 41, 10: 54, 13: 18, 14: 6, 19: l, 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, e(N, [2, 8]), e(N, [2, 9]), e(N, [2, 17]), { 20: [1, 55] }, { 5: [1, 56] }, { 5: [1, 59], 24: [1, 57], 25: [1, 58] }, { 27: 60, 73: M }, { 27: 61, 73: M }, { 5: [1, 62] }, { 5: [1, 63] }, { 5: [1, 64] }, { 5: [1, 65] }, { 5: [1, 66] }, e(N, [2, 31]), e(N, [2, 32]), { 37: [1, 67] }, { 39: [1, 68] }, e(N, [2, 35]), { 20: [1, 69] }, { 20: [1, 70] }, { 20: [1, 71] }, { 20: [1, 72] }, { 20: [1, 73] }, { 20: [1, 74] }, { 20: [1, 75] }, e(N, [2, 43]), { 27: 76, 73: M }, { 27: 77, 73: M }, { 70: 78, 74: [1, 79], 75: [1, 80], 76: [1, 81], 77: [1, 82], 78: [1, 83], 79: [1, 84], 80: [1, 85], 81: [1, 86] }, { 58: 87, 60: [1, 88], 68: [1, 89], 69: [1, 90] }, { 27: 91, 73: M }, { 27: 92, 73: M }, { 27: 93, 73: M }, { 27: 94, 73: M }, e([5, 55, 67, 74, 75, 76, 77, 78, 79, 80, 81, 82], [2, 69]), { 5: [1, 95] }, { 18: 96, 85: [1, 97] }, { 5: [2, 82] }, e(N, [2, 7]), e(tt, [2, 10], { 11: 98 }), e(N, [2, 19]), { 5: [1, 100], 24: [1, 99] }, { 5: [1, 101] }, e(N, [2, 23]), { 5: [1, 102] }, { 5: [1, 103] }, e(N, [2, 26]), e(N, [2, 27]), e(N, [2, 28]), e(N, [2, 29]), e(N, [2, 30]), e(N, [2, 33]), e(N, [2, 34]), e(Z, s, { 8: 104 }), e(Z, s, { 8: 105 }), e(Z, s, { 8: 106 }), e(z, s, { 45: 107, 8: 108 }), e(X, s, { 47: 109, 8: 110 }), e(q, s, { 49: 111, 8: 112 }), e(Z, s, { 8: 113 }), { 5: [1, 115], 55: [1, 114] }, { 5: [1, 117], 55: [1, 116] }, { 27: 120, 71: [1, 118], 72: [1, 119], 73: M }, e(nt, [2, 70]), e(nt, [2, 71]), e(nt, [2, 72]), e(nt, [2, 73]), e(nt, [2, 74]), e(nt, [2, 75]), e(nt, [2, 76]), e(nt, [2, 77]), { 27: 121, 73: M }, { 27: 123, 61: 122, 73: M }, { 73: [2, 64] }, { 73: [2, 65] }, { 59: 124, 82: st }, { 59: 126, 82: st }, { 59: 127, 82: st }, { 59: 128, 82: st }, e(ct, [2, 15]), { 16: 129, 86: v }, { 86: [2, 81] }, { 4: [1, 132], 5: [1, 134], 12: 131, 13: 133, 21: [1, 130], 54: R, 56: A }, { 5: [1, 135] }, e(N, [2, 21]), e(N, [2, 22]), e(N, [2, 24]), e(N, [2, 25]), { 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 136], 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 137], 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 138], 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 21: [1, 139] }, { 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [2, 48], 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 53: [1, 140], 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 21: [1, 141] }, { 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [2, 46], 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 52: [1, 142], 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 21: [1, 143] }, { 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [2, 44], 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 51: [1, 144], 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 4: o, 5: a, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 145], 22: 20, 23: h, 26: u, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: g, 38: m, 40: y, 41: O, 42: x, 43: _, 44: w, 46: E, 48: T, 50: S, 54: R, 56: A, 57: P, 62: C, 63: k, 64: D, 65: b, 73: M, 83: i }, { 20: [1, 146] }, e(N, [2, 51]), { 20: [1, 147] }, e(N, [2, 53]), { 27: 148, 73: M }, { 27: 149, 73: M }, { 59: 150, 82: st }, { 59: 151, 82: st }, { 59: 152, 82: st }, { 67: [1, 153], 82: [2, 63] }, { 5: [2, 56] }, { 5: [2, 78] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [2, 59] }, { 5: [1, 154] }, e(N, [2, 18]), e(tt, [2, 11]), { 13: 155, 54: R, 56: A }, e(tt, [2, 13]), e(tt, [2, 14]), e(N, [2, 20]), e(N, [2, 36]), e(N, [2, 37]), e(N, [2, 38]), e(N, [2, 39]), { 20: [1, 156] }, e(N, [2, 40]), { 20: [1, 157] }, e(N, [2, 41]), { 20: [1, 158] }, e(N, [2, 42]), { 5: [1, 159] }, { 5: [1, 160] }, { 59: 161, 82: st }, { 59: 162, 82: st }, { 5: [2, 68] }, { 5: [2, 54] }, { 5: [2, 55] }, { 27: 163, 73: M }, e(ct, [2, 16]), e(tt, [2, 12]), e(z, s, { 8: 108, 45: 164 }), e(X, s, { 8: 110, 47: 165 }), e(q, s, { 8: 112, 49: 166 }), e(N, [2, 50]), e(N, [2, 52]), { 5: [2, 66] }, { 5: [2, 67] }, { 82: [2, 62] }, { 21: [2, 49] }, { 21: [2, 47] }, { 21: [2, 45] }],
    defaultActions: { 7: [2, 79], 8: [2, 1], 9: [2, 2], 10: [2, 3], 53: [2, 82], 89: [2, 64], 90: [2, 65], 97: [2, 81], 124: [2, 56], 125: [2, 78], 126: [2, 57], 127: [2, 58], 128: [2, 59], 150: [2, 68], 151: [2, 54], 152: [2, 55], 161: [2, 66], 162: [2, 67], 163: [2, 62], 164: [2, 49], 165: [2, 47], 166: [2, 45] },
    parseError: function(U, W) {
      if (W.recoverable)
        this.trace(U);
      else {
        var $ = new Error(U);
        throw $.hash = W, $;
      }
    },
    parse: function(U) {
      var W = this, $ = [0], F = [], G = [null], I = [], ht = this.table, L = "", $t = 0, it = 0, At = 2, St = 1, bt = I.slice.call(arguments, 1), gt = Object.create(this.lexer), yt = { yy: {} };
      for (var dt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, dt) && (yt.yy[dt] = this.yy[dt]);
      gt.setInput(U, yt.yy), yt.yy.lexer = gt, yt.yy.parser = this, typeof gt.yylloc > "u" && (gt.yylloc = {});
      var xt = gt.yylloc;
      I.push(xt);
      var Re = gt.options && gt.options.ranges;
      typeof yt.yy.parseError == "function" ? this.parseError = yt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ye() {
        var pt;
        return pt = F.pop() || gt.lex() || St, typeof pt != "number" && (pt instanceof Array && (F = pt, pt = F.pop()), pt = W.symbols_[pt] || pt), pt;
      }
      for (var zt, Yt, ce, Ie, re = {}, Qt, Lt, kt, _t; ; ) {
        if (Yt = $[$.length - 1], this.defaultActions[Yt] ? ce = this.defaultActions[Yt] : ((zt === null || typeof zt > "u") && (zt = ye()), ce = ht[Yt] && ht[Yt][zt]), typeof ce > "u" || !ce.length || !ce[0]) {
          var Et = "";
          _t = [];
          for (Qt in ht[Yt])
            this.terminals_[Qt] && Qt > At && _t.push("'" + this.terminals_[Qt] + "'");
          gt.showPosition ? Et = "Parse error on line " + ($t + 1) + `:
` + gt.showPosition() + `
Expecting ` + _t.join(", ") + ", got '" + (this.terminals_[zt] || zt) + "'" : Et = "Parse error on line " + ($t + 1) + ": Unexpected " + (zt == St ? "end of input" : "'" + (this.terminals_[zt] || zt) + "'"), this.parseError(Et, {
            text: gt.match,
            token: this.terminals_[zt] || zt,
            line: gt.yylineno,
            loc: xt,
            expected: _t
          });
        }
        if (ce[0] instanceof Array && ce.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Yt + ", token: " + zt);
        switch (ce[0]) {
          case 1:
            $.push(zt), G.push(gt.yytext), I.push(gt.yylloc), $.push(ce[1]), zt = null, it = gt.yyleng, L = gt.yytext, $t = gt.yylineno, xt = gt.yylloc;
            break;
          case 2:
            if (Lt = this.productions_[ce[1]][1], re.$ = G[G.length - Lt], re._$ = {
              first_line: I[I.length - (Lt || 1)].first_line,
              last_line: I[I.length - 1].last_line,
              first_column: I[I.length - (Lt || 1)].first_column,
              last_column: I[I.length - 1].last_column
            }, Re && (re._$.range = [
              I[I.length - (Lt || 1)].range[0],
              I[I.length - 1].range[1]
            ]), Ie = this.performAction.apply(re, [
              L,
              it,
              $t,
              yt.yy,
              ce[1],
              G,
              I
            ].concat(bt)), typeof Ie < "u")
              return Ie;
            Lt && ($ = $.slice(0, -1 * Lt * 2), G = G.slice(0, -1 * Lt), I = I.slice(0, -1 * Lt)), $.push(this.productions_[ce[1]][0]), G.push(re.$), I.push(re._$), kt = ht[$[$.length - 2]][$[$.length - 1]], $.push(kt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, Ct = function() {
    var et = {
      EOF: 1,
      parseError: function(W, $) {
        if (this.yy.parser)
          this.yy.parser.parseError(W, $);
        else
          throw new Error(W);
      },
      setInput: function(U, W) {
        return this.yy = W || this.yy || {}, this._input = U, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var U = this._input[0];
        this.yytext += U, this.yyleng++, this.offset++, this.match += U, this.matched += U;
        var W = U.match(/(?:\r\n?|\n).*/g);
        return W ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), U;
      },
      unput: function(U) {
        var W = U.length, $ = U.split(/(?:\r\n?|\n)/g);
        this._input = U + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - W), this.offset -= W;
        var F = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), $.length - 1 && (this.yylineno -= $.length - 1);
        var G = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: $ ? ($.length === F.length ? this.yylloc.first_column : 0) + F[F.length - $.length].length - $[0].length : this.yylloc.first_column - W
        }, this.options.ranges && (this.yylloc.range = [G[0], G[0] + this.yyleng - W]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(U) {
        this.unput(this.match.slice(U));
      },
      pastInput: function() {
        var U = this.matched.substr(0, this.matched.length - this.match.length);
        return (U.length > 20 ? "..." : "") + U.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var U = this.match;
        return U.length < 20 && (U += this._input.substr(0, 20 - U.length)), (U.substr(0, 20) + (U.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var U = this.pastInput(), W = new Array(U.length + 1).join("-");
        return U + this.upcomingInput() + `
` + W + "^";
      },
      test_match: function(U, W) {
        var $, F, G;
        if (this.options.backtrack_lexer && (G = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (G.yylloc.range = this.yylloc.range.slice(0))), F = U[0].match(/(?:\r\n?|\n).*/g), F && (this.yylineno += F.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: F ? F[F.length - 1].length - F[F.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + U[0].length
        }, this.yytext += U[0], this.match += U[0], this.matches = U, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(U[0].length), this.matched += U[0], $ = this.performAction.call(this, this.yy, this, W, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), $)
          return $;
        if (this._backtrack) {
          for (var I in G)
            this[I] = G[I];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var U, W, $, F;
        this._more || (this.yytext = "", this.match = "");
        for (var G = this._currentRules(), I = 0; I < G.length; I++)
          if ($ = this._input.match(this.rules[G[I]]), $ && (!W || $[0].length > W[0].length)) {
            if (W = $, F = I, this.options.backtrack_lexer) {
              if (U = this.test_match($, G[I]), U !== !1)
                return U;
              if (this._backtrack) {
                W = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return W ? (U = this.test_match(W, G[F]), U !== !1 ? U : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var W = this.next();
        return W || this.lex();
      },
      begin: function(W) {
        this.conditionStack.push(W);
      },
      popState: function() {
        var W = this.conditionStack.length - 1;
        return W > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(W) {
        return W = this.conditionStack.length - 1 - Math.abs(W || 0), W >= 0 ? this.conditionStack[W] : "INITIAL";
      },
      pushState: function(W) {
        this.begin(W);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(W, $, F, G) {
        switch (F) {
          case 0:
            return this.begin("open_directive"), 83;
          case 1:
            return this.begin("type_directive"), 84;
          case 2:
            return this.popState(), this.begin("arg_directive"), 17;
          case 3:
            return this.popState(), this.popState(), 86;
          case 4:
            return 85;
          case 5:
            return 5;
          case 6:
            break;
          case 7:
            break;
          case 8:
            break;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 24;
          case 12:
            return this.begin("LINE"), 19;
          case 13:
            return this.begin("ID"), 54;
          case 14:
            return this.begin("ID"), 56;
          case 15:
            return $.yytext = $.yytext.trim(), this.begin("ALIAS"), 73;
          case 16:
            return this.popState(), this.popState(), this.begin("LINE"), 55;
          case 17:
            return this.popState(), this.popState(), 5;
          case 18:
            return this.begin("LINE"), 41;
          case 19:
            return this.begin("LINE"), 42;
          case 20:
            return this.begin("LINE"), 43;
          case 21:
            return this.begin("LINE"), 44;
          case 22:
            return this.begin("LINE"), 53;
          case 23:
            return this.begin("LINE"), 46;
          case 24:
            return this.begin("LINE"), 52;
          case 25:
            return this.begin("LINE"), 48;
          case 26:
            return this.begin("LINE"), 51;
          case 27:
            return this.begin("LINE"), 50;
          case 28:
            return this.popState(), 20;
          case 29:
            return 21;
          case 30:
            return 68;
          case 31:
            return 69;
          case 32:
            return 62;
          case 33:
            return 63;
          case 34:
            return 64;
          case 35:
            return 65;
          case 36:
            return 60;
          case 37:
            return 57;
          case 38:
            return this.begin("ID"), 26;
          case 39:
            return this.begin("ID"), 28;
          case 40:
            return 34;
          case 41:
            return 35;
          case 42:
            return this.begin("acc_title"), 36;
          case 43:
            return this.popState(), "acc_title_value";
          case 44:
            return this.begin("acc_descr"), 38;
          case 45:
            return this.popState(), "acc_descr_value";
          case 46:
            this.begin("acc_descr_multiline");
            break;
          case 47:
            this.popState();
            break;
          case 48:
            return "acc_descr_multiline_value";
          case 49:
            return 7;
          case 50:
            return 23;
          case 51:
            return 25;
          case 52:
            return 67;
          case 53:
            return 5;
          case 54:
            return $.yytext = $.yytext.trim(), 73;
          case 55:
            return 76;
          case 56:
            return 77;
          case 57:
            return 74;
          case 58:
            return 75;
          case 59:
            return 78;
          case 60:
            return 79;
          case 61:
            return 80;
          case 62:
            return 81;
          case 63:
            return 82;
          case 64:
            return 71;
          case 65:
            return 72;
          case 66:
            return 5;
          case 67:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:box\b)/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:[^\->:\n,;]+?([\-]*[^\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^\+\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]+)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [47, 48], inclusive: !1 }, acc_descr: { rules: [45], inclusive: !1 }, acc_title: { rules: [43], inclusive: !1 }, open_directive: { rules: [1, 8], inclusive: !1 }, type_directive: { rules: [2, 3, 8], inclusive: !1 }, arg_directive: { rules: [3, 4, 8], inclusive: !1 }, ID: { rules: [7, 8, 15], inclusive: !1 }, ALIAS: { rules: [7, 8, 16, 17], inclusive: !1 }, LINE: { rules: [7, 8, 28], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 8, 9, 10, 11, 12, 13, 14, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 46, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67], inclusive: !0 } }
    };
    return et;
  }();
  Y.lexer = Ct;
  function H() {
    this.yy = {};
  }
  return H.prototype = Y, Y.Parser = H, new H();
}();
Tk.parser = Tk;
const Rfe = Tk, $fe = (e) => e.match(/^\s*sequenceDiagram/) !== null;
let Of, Qa = {}, xu = [], ls = [], eb = !1, Ek, Bo;
const Ife = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, Nfe = function(e) {
  xu.push({
    name: e.text,
    wrap: e.wrap === void 0 && _c() || !!e.wrap,
    fill: e.color,
    actorKeys: []
  }), Bo = xu.slice(-1)[0];
}, Ak = function(e, t, n, r) {
  let i = Bo;
  const s = Qa[e];
  if (s) {
    if (Bo && s.box && Bo !== s.box)
      throw new Error(
        "A same participant should only be defined in one Box: " + s.name + " can't be in '" + s.box.name + "' and in '" + Bo.name + "' at the same time."
      );
    if (i = s.box ? s.box : Bo, s.box = i, s && t === s.name && n == null)
      return;
  }
  (n == null || n.text == null) && (n = { text: t, wrap: null, type: r }), (r == null || n.text == null) && (n = { text: t, wrap: null, type: r }), Qa[e] = {
    box: i,
    name: t,
    description: n.text,
    wrap: n.wrap === void 0 && _c() || !!n.wrap,
    prevActor: Of,
    links: {},
    properties: {},
    actorCnt: null,
    rectData: null,
    type: r || "participant"
  }, Of && Qa[Of] && (Qa[Of].nextActor = e), Bo && Bo.actorKeys.push(e), Of = e;
}, Bfe = (e) => {
  let t, n = 0;
  for (t = 0; t < ls.length; t++)
    ls[t].type === Cp.ACTIVE_START && ls[t].from.actor === e && n++, ls[t].type === Cp.ACTIVE_END && ls[t].from.actor === e && n--;
  return n;
}, Ffe = function(e, t, n, r) {
  ls.push({
    from: e,
    to: t,
    message: n.text,
    wrap: n.wrap === void 0 && _c() || !!n.wrap,
    answer: r
  });
}, wn = function(e, t, n = { text: void 0, wrap: void 0 }, r) {
  if (r === Cp.ACTIVE_END && Bfe(e.actor) < 1) {
    let s = new Error("Trying to inactivate an inactive participant (" + e.actor + ")");
    throw s.hash = {
      text: "->>-",
      token: "->>-",
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["'ACTIVE_PARTICIPANT'"]
    }, s;
  }
  return ls.push({
    from: e,
    to: t,
    message: n.text,
    wrap: n.wrap === void 0 && _c() || !!n.wrap,
    type: r
  }), !0;
}, Qfe = function() {
  return xu.length > 0;
}, Zfe = function() {
  return xu.some((e) => e.name);
}, Vfe = function() {
  return ls;
}, Yfe = function() {
  return xu;
}, zfe = function() {
  return Qa;
}, h0 = function(e) {
  return Qa[e];
}, qfe = function() {
  return Object.keys(Qa);
}, Wfe = function() {
  eb = !0;
}, Ufe = function() {
  eb = !1;
}, jfe = () => eb, Xfe = function(e) {
  Ek = e;
}, _c = () => Ek !== void 0 ? Ek : J().sequence.wrap, Gfe = function() {
  Qa = {}, xu = [], ls = [], eb = !1, _i();
}, Hfe = function(e) {
  const t = e.trim(), n = {
    text: t.replace(/^:?(?:no)?wrap:/, "").trim(),
    wrap: t.match(/^:?wrap:/) !== null ? !0 : t.match(/^:?nowrap:/) !== null ? !1 : void 0
  };
  return B.debug("parseMessage:", n), n;
}, Kfe = function(e) {
  const t = e.match(/^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/);
  let n = t != null && t[1] ? t[1].trim() : "transparent", r = t != null && t[2] ? t[2].trim() : void 0;
  if (window && window.CSS)
    window.CSS.supports("color", n) || (n = "transparent", r = e.trim());
  else {
    const s = new Option().style;
    s.color = n, s.color !== n && (n = "transparent", r = e.trim());
  }
  return {
    color: n,
    text: r !== void 0 ? Gi(r.replace(/^:?(?:no)?wrap:/, ""), J()) : void 0,
    wrap: r !== void 0 ? r.match(/^:?wrap:/) !== null ? !0 : r.match(/^:?nowrap:/) !== null ? !1 : void 0 : void 0
  };
}, Cp = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31
}, Jfe = {
  FILLED: 0,
  OPEN: 1
}, tde = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, LZ = function(e, t, n) {
  n.text, n.wrap === void 0 && _c() || n.wrap;
  const r = [].concat(e, e);
  ls.push({
    from: r[0],
    to: r[1],
    message: n.text,
    wrap: n.wrap === void 0 && _c() || !!n.wrap,
    type: Cp.NOTE,
    placement: t
  });
}, MZ = function(e, t) {
  const n = h0(e);
  try {
    let r = Gi(t.text, J());
    r = r.replace(/&amp;/g, "&"), r = r.replace(/&equals;/g, "=");
    const i = JSON.parse(r);
    tS(n, i);
  } catch (r) {
    B.error("error while parsing actor link text", r);
  }
}, ede = function(e, t) {
  const n = h0(e);
  try {
    const o = {};
    let a = Gi(t.text, J());
    var r = a.indexOf("@");
    a = a.replace(/&amp;/g, "&"), a = a.replace(/&equals;/g, "=");
    var i = a.slice(0, r - 1).trim(), s = a.slice(r + 1).trim();
    o[i] = s, tS(n, o);
  } catch (o) {
    B.error("error while parsing actor link text", o);
  }
};
function tS(e, t) {
  if (e.links == null)
    e.links = t;
  else
    for (let n in t)
      e.links[n] = t[n];
}
const RZ = function(e, t) {
  const n = h0(e);
  try {
    let r = Gi(t.text, J());
    const i = JSON.parse(r);
    $Z(n, i);
  } catch (r) {
    B.error("error while parsing actor properties text", r);
  }
};
function $Z(e, t) {
  if (e.properties == null)
    e.properties = t;
  else
    for (let n in t)
      e.properties[n] = t[n];
}
function nde() {
  Bo = void 0;
}
const IZ = function(e, t) {
  const n = h0(e), r = document.getElementById(t.text);
  try {
    const i = r.innerHTML, s = JSON.parse(i);
    s.properties && $Z(n, s.properties), s.links && tS(n, s.links);
  } catch (i) {
    B.error("error while parsing actor details text", i);
  }
}, rde = function(e, t) {
  if (e !== void 0 && e.properties !== void 0)
    return e.properties[t];
}, NZ = function(e) {
  if (Array.isArray(e))
    e.forEach(function(t) {
      NZ(t);
    });
  else
    switch (e.type) {
      case "sequenceIndex":
        ls.push({
          from: void 0,
          to: void 0,
          message: {
            start: e.sequenceIndex,
            step: e.sequenceIndexStep,
            visible: e.sequenceVisible
          },
          wrap: !1,
          type: e.signalType
        });
        break;
      case "addParticipant":
        Ak(e.actor, e.actor, e.description, "participant");
        break;
      case "addActor":
        Ak(e.actor, e.actor, e.description, "actor");
        break;
      case "activeStart":
        wn(e.actor, void 0, void 0, e.signalType);
        break;
      case "activeEnd":
        wn(e.actor, void 0, void 0, e.signalType);
        break;
      case "addNote":
        LZ(e.actor, e.placement, e.text);
        break;
      case "addLinks":
        MZ(e.actor, e.text);
        break;
      case "addALink":
        ede(e.actor, e.text);
        break;
      case "addProperties":
        RZ(e.actor, e.text);
        break;
      case "addDetails":
        IZ(e.actor, e.text);
        break;
      case "addMessage":
        wn(e.from, e.to, e.msg, e.signalType);
        break;
      case "boxStart":
        Nfe(e.boxData);
        break;
      case "boxEnd":
        nde();
        break;
      case "loopStart":
        wn(void 0, void 0, e.loopText, e.signalType);
        break;
      case "loopEnd":
        wn(void 0, void 0, void 0, e.signalType);
        break;
      case "rectStart":
        wn(void 0, void 0, e.color, e.signalType);
        break;
      case "rectEnd":
        wn(void 0, void 0, void 0, e.signalType);
        break;
      case "optStart":
        wn(void 0, void 0, e.optText, e.signalType);
        break;
      case "optEnd":
        wn(void 0, void 0, void 0, e.signalType);
        break;
      case "altStart":
        wn(void 0, void 0, e.altText, e.signalType);
        break;
      case "else":
        wn(void 0, void 0, e.altText, e.signalType);
        break;
      case "altEnd":
        wn(void 0, void 0, void 0, e.signalType);
        break;
      case "setAccTitle":
        oi(e.text);
        break;
      case "parStart":
        wn(void 0, void 0, e.parText, e.signalType);
        break;
      case "and":
        wn(void 0, void 0, e.parText, e.signalType);
        break;
      case "parEnd":
        wn(void 0, void 0, void 0, e.signalType);
        break;
      case "criticalStart":
        wn(void 0, void 0, e.criticalText, e.signalType);
        break;
      case "option":
        wn(void 0, void 0, e.optionText, e.signalType);
        break;
      case "criticalEnd":
        wn(void 0, void 0, void 0, e.signalType);
        break;
      case "breakStart":
        wn(void 0, void 0, e.breakText, e.signalType);
        break;
      case "breakEnd":
        wn(void 0, void 0, void 0, e.signalType);
        break;
    }
}, j8 = {
  addActor: Ak,
  addMessage: Ffe,
  addSignal: wn,
  addLinks: MZ,
  addDetails: IZ,
  addProperties: RZ,
  autoWrap: _c,
  setWrap: Xfe,
  enableSequenceNumbers: Wfe,
  disableSequenceNumbers: Ufe,
  showSequenceNumbers: jfe,
  getMessages: Vfe,
  getActors: zfe,
  getActor: h0,
  getActorKeys: qfe,
  getActorProperty: rde,
  getAccTitle: ki,
  getBoxes: Yfe,
  getDiagramTitle: Ns,
  setDiagramTitle: Is,
  parseDirective: Ife,
  getConfig: () => J().sequence,
  clear: Gfe,
  parseMessage: Hfe,
  parseBoxData: Kfe,
  LINETYPE: Cp,
  ARROWTYPE: Jfe,
  PLACEMENT: tde,
  addNote: LZ,
  setAccTitle: oi,
  apply: NZ,
  setAccDescription: wi,
  getAccDescription: Si,
  hasAtLeastOneBox: Qfe,
  hasAtLeastOneBoxWithTitle: Zfe
};
let Pk = [];
const ide = (e) => {
  Pk.push(e);
}, BZ = () => {
  Pk.forEach((e) => {
    e();
  }), Pk = [];
}, nb = function(e, t) {
  const n = e.append("rect");
  return n.attr("x", t.x), n.attr("y", t.y), n.attr("fill", t.fill), n.attr("stroke", t.stroke), n.attr("width", t.width), n.attr("height", t.height), n.attr("rx", t.rx), n.attr("ry", t.ry), t.class !== void 0 && n.attr("class", t.class), n;
}, FZ = (e, t) => {
  ide(() => {
    const n = document.querySelectorAll(e);
    n.length !== 0 && (n[0].addEventListener("mouseover", function() {
      lde("actor" + t + "_popup");
    }), n[0].addEventListener("mouseout", function() {
      cde("actor" + t + "_popup");
    }));
  });
}, sde = function(e, t, n, r, i) {
  if (t.links === void 0 || t.links === null || Object.keys(t.links).length === 0)
    return { height: 0, width: 0 };
  const s = t.links, o = t.actorCnt, a = t.rectData;
  var l = "none";
  i && (l = "block !important");
  const h = e.append("g");
  h.attr("id", "actor" + o + "_popup"), h.attr("class", "actorPopupMenu"), h.attr("display", l), FZ("#actor" + o + "_popup", o);
  var u = "";
  a.class !== void 0 && (u = " " + a.class);
  let f = a.width > n ? a.width : n;
  const d = h.append("rect");
  if (d.attr("class", "actorPopupMenuPanel" + u), d.attr("x", a.x), d.attr("y", a.height), d.attr("fill", a.fill), d.attr("stroke", a.stroke), d.attr("width", f), d.attr("height", a.height), d.attr("rx", a.rx), d.attr("ry", a.ry), s != null) {
    var p = 20;
    for (let y in s) {
      var g = h.append("a"), m = Oa.sanitizeUrl(s[y]);
      g.attr("xlink:href", m), g.attr("target", "_blank"), wde(r)(
        y,
        g,
        a.x + 10,
        a.height + p,
        f,
        20,
        { class: "actor" },
        r
      ), p += 30;
    }
  }
  return d.attr("height", p), { height: a.height + p, width: f };
}, QZ = function(e, t, n, r) {
  const i = e.append("image");
  i.attr("x", t), i.attr("y", n);
  var s = Oa.sanitizeUrl(r);
  i.attr("xlink:href", s);
}, ZZ = function(e, t, n, r) {
  const i = e.append("use");
  i.attr("x", t), i.attr("y", n);
  var s = Oa.sanitizeUrl(r);
  i.attr("xlink:href", "#" + s);
}, ode = function(e) {
  return "var pu = document.getElementById('" + e + "'); if (pu != null) { pu.style.display = 'block'; }";
}, ade = function(e) {
  return "var pu = document.getElementById('" + e + "'); if (pu != null) { pu.style.display = 'none'; }";
}, lde = function(e) {
  var t = document.getElementById(e);
  t != null && (t.style.display = "block");
}, cde = function(e) {
  var t = document.getElementById(e);
  t != null && (t.style.display = "none");
}, vu = function(e, t) {
  let n = 0, r = 0;
  const i = t.text.split(de.lineBreakRegex), [s, o] = r0(t.fontSize);
  let a = [], l = 0, h = () => t.y;
  if (t.valign !== void 0 && t.textMargin !== void 0 && t.textMargin > 0)
    switch (t.valign) {
      case "top":
      case "start":
        h = () => Math.round(t.y + t.textMargin);
        break;
      case "middle":
      case "center":
        h = () => Math.round(t.y + (n + r + t.textMargin) / 2);
        break;
      case "bottom":
      case "end":
        h = () => Math.round(
          t.y + (n + r + 2 * t.textMargin) - t.textMargin
        );
        break;
    }
  if (t.anchor !== void 0 && t.textMargin !== void 0 && t.width !== void 0)
    switch (t.anchor) {
      case "left":
      case "start":
        t.x = Math.round(t.x + t.textMargin), t.anchor = "start", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        t.x = Math.round(t.x + t.width / 2), t.anchor = "middle", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        t.x = Math.round(t.x + t.width - t.textMargin), t.anchor = "end", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
        break;
    }
  for (let [u, f] of i.entries()) {
    t.textMargin !== void 0 && t.textMargin === 0 && s !== void 0 && (l = u * s);
    const d = e.append("text");
    if (d.attr("x", t.x), d.attr("y", h()), t.anchor !== void 0 && d.attr("text-anchor", t.anchor).attr("dominant-baseline", t.dominantBaseline).attr("alignment-baseline", t.alignmentBaseline), t.fontFamily !== void 0 && d.style("font-family", t.fontFamily), o !== void 0 && d.style("font-size", o), t.fontWeight !== void 0 && d.style("font-weight", t.fontWeight), t.fill !== void 0 && d.attr("fill", t.fill), t.class !== void 0 && d.attr("class", t.class), t.dy !== void 0 ? d.attr("dy", t.dy) : l !== 0 && d.attr("dy", l), t.tspan) {
      const p = d.append("tspan");
      p.attr("x", t.x), t.fill !== void 0 && p.attr("fill", t.fill), p.text(f);
    } else
      d.text(f);
    t.valign !== void 0 && t.textMargin !== void 0 && t.textMargin > 0 && (r += (d._groups || d)[0][0].getBBox().height, n = r), a.push(d);
  }
  return a;
}, VZ = function(e, t) {
  function n(i, s, o, a, l) {
    return i + "," + s + " " + (i + o) + "," + s + " " + (i + o) + "," + (s + a - l) + " " + (i + o - l * 1.2) + "," + (s + a) + " " + i + "," + (s + a);
  }
  const r = e.append("polygon");
  return r.attr("points", n(t.x, t.y, t.width, t.height, 7)), r.attr("class", "labelBox"), t.y = t.y + t.height / 2, vu(e, t), r;
};
let Xs = -1;
const YZ = (e, t) => {
  !e.selectAll || e.selectAll(".actor-line").attr("class", "200").attr("y2", t - 55);
}, hde = function(e, t, n, r) {
  const i = t.x + t.width / 2, s = t.y + 5, o = e.append("g");
  var a = o;
  r || (Xs++, a.append("line").attr("id", "actor" + Xs).attr("x1", i).attr("y1", s).attr("x2", i).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999"), a = o.append("g"), t.actorCnt = Xs, t.links != null && (a.attr("id", "root-" + Xs), FZ("#root-" + Xs, Xs)));
  const l = rb();
  var h = "actor";
  t.properties != null && t.properties.class ? h = t.properties.class : l.fill = "#eaeaea", l.x = t.x, l.y = t.y, l.width = t.width, l.height = t.height, l.class = h, l.rx = 3, l.ry = 3;
  const u = nb(a, l);
  if (t.rectData = l, t.properties != null && t.properties.icon) {
    const d = t.properties.icon.trim();
    d.charAt(0) === "@" ? ZZ(a, l.x + l.width - 20, l.y + 10, d.substr(1)) : QZ(a, l.x + l.width - 20, l.y + 10, d);
  }
  eS(n)(
    t.description,
    a,
    l.x,
    l.y,
    l.width,
    l.height,
    { class: "actor" },
    n
  );
  let f = t.height;
  if (u.node) {
    const d = u.node().getBBox();
    t.height = d.height, f = d.height;
  }
  return f;
}, ude = function(e, t, n, r) {
  const i = t.x + t.width / 2, s = t.y + 80;
  r || (Xs++, e.append("line").attr("id", "actor" + Xs).attr("x1", i).attr("y1", s).attr("x2", i).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999"));
  const o = e.append("g");
  o.attr("class", "actor-man");
  const a = rb();
  a.x = t.x, a.y = t.y, a.fill = "#eaeaea", a.width = t.width, a.height = t.height, a.class = "actor", a.rx = 3, a.ry = 3, o.append("line").attr("id", "actor-man-torso" + Xs).attr("x1", i).attr("y1", t.y + 25).attr("x2", i).attr("y2", t.y + 45), o.append("line").attr("id", "actor-man-arms" + Xs).attr("x1", i - 18).attr("y1", t.y + 33).attr("x2", i + 18).attr("y2", t.y + 33), o.append("line").attr("x1", i - 18).attr("y1", t.y + 60).attr("x2", i).attr("y2", t.y + 45), o.append("line").attr("x1", i).attr("y1", t.y + 45).attr("x2", i + 16).attr("y2", t.y + 60);
  const l = o.append("circle");
  l.attr("cx", t.x + t.width / 2), l.attr("cy", t.y + 10), l.attr("r", 15), l.attr("width", t.width), l.attr("height", t.height);
  const h = o.node().getBBox();
  return t.height = h.height, eS(n)(
    t.description,
    o,
    a.x,
    a.y + 35,
    a.width,
    a.height,
    { class: "actor" },
    n
  ), t.height;
}, fde = function(e, t, n, r) {
  switch (t.type) {
    case "actor":
      return ude(e, t, n, r);
    case "participant":
      return hde(e, t, n, r);
  }
}, dde = function(e, t, n) {
  const i = e.append("g");
  zZ(i, t), t.name && eS(n)(
    t.name,
    i,
    t.x,
    t.y + (t.textMaxHeight || 0) / 2,
    t.width,
    0,
    { class: "text" },
    n
  ), i.lower();
}, pde = function(e) {
  return e.append("g");
}, gde = function(e, t, n, r, i) {
  const s = rb(), o = t.anchored;
  s.x = t.startx, s.y = t.starty, s.class = "activation" + i % 3, s.width = t.stopx - t.startx, s.height = n - t.starty, nb(o, s);
}, mde = function(e, t, n, r) {
  const {
    boxMargin: i,
    boxTextMargin: s,
    labelBoxHeight: o,
    labelBoxWidth: a,
    messageFontFamily: l,
    messageFontSize: h,
    messageFontWeight: u
  } = r, f = e.append("g"), d = function(m, y, O, x) {
    return f.append("line").attr("x1", m).attr("y1", y).attr("x2", O).attr("y2", x).attr("class", "loopLine");
  };
  d(t.startx, t.starty, t.stopx, t.starty), d(t.stopx, t.starty, t.stopx, t.stopy), d(t.startx, t.stopy, t.stopx, t.stopy), d(t.startx, t.starty, t.startx, t.stopy), t.sections !== void 0 && t.sections.forEach(function(m) {
    d(t.startx, m.y, t.stopx, m.y).style(
      "stroke-dasharray",
      "3, 3"
    );
  });
  let p = Dk();
  p.text = n, p.x = t.startx, p.y = t.starty, p.fontFamily = l, p.fontSize = h, p.fontWeight = u, p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.width = a || 50, p.height = o || 20, p.textMargin = s, p.class = "labelText", VZ(f, p), p = Dk(), p.text = t.title, p.x = t.startx + a / 2 + (t.stopx - t.startx) / 2, p.y = t.starty + i + s, p.anchor = "middle", p.valign = "middle", p.textMargin = s, p.class = "loopText", p.fontFamily = l, p.fontSize = h, p.fontWeight = u, p.wrap = !0;
  let g = vu(f, p);
  return t.sectionTitles !== void 0 && t.sectionTitles.forEach(function(m, y) {
    if (m.message) {
      p.text = m.message, p.x = t.startx + (t.stopx - t.startx) / 2, p.y = t.sections[y].y + i + s, p.class = "loopText", p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.fontFamily = l, p.fontSize = h, p.fontWeight = u, p.wrap = t.wrap, g = vu(f, p);
      let O = Math.round(
        g.map((x) => (x._groups || x)[0][0].getBBox().height).reduce((x, _) => x + _)
      );
      t.sections[y].height += O - (i + s);
    }
  }), t.height = Math.round(t.stopy - t.starty), f;
}, zZ = function(e, t) {
  nb(e, {
    x: t.startx,
    y: t.starty,
    width: t.stopx - t.startx,
    height: t.stopy - t.starty,
    fill: t.fill,
    stroke: t.stroke,
    class: "rect"
  }).lower();
}, yde = function(e) {
  e.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, bde = function(e) {
  e.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, Ode = function(e) {
  e.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, xde = function(e) {
  e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, vde = function(e) {
  e.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, _de = function(e) {
  e.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, kde = function(e) {
  e.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 4).attr("refY", 5).append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1pt").attr("d", "M 1,2 L 6,7 M 6,2 L 1,7");
}, Dk = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: !0,
    valign: void 0
  };
}, rb = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, eS = function() {
  function e(i, s, o, a, l, h, u) {
    const f = s.append("text").attr("x", o + l / 2).attr("y", a + h / 2 + 5).style("text-anchor", "middle").text(i);
    r(f, u);
  }
  function t(i, s, o, a, l, h, u, f) {
    const { actorFontSize: d, actorFontFamily: p, actorFontWeight: g } = f, [m, y] = r0(d), O = i.split(de.lineBreakRegex);
    for (let x = 0; x < O.length; x++) {
      const _ = x * m - m * (O.length - 1) / 2, w = s.append("text").attr("x", o + l / 2).attr("y", a).style("text-anchor", "middle").style("font-size", y).style("font-weight", g).style("font-family", p);
      w.append("tspan").attr("x", o + l / 2).attr("dy", _).text(O[x]), w.attr("y", a + h / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), r(w, u);
    }
  }
  function n(i, s, o, a, l, h, u, f) {
    const d = s.append("switch"), g = d.append("foreignObject").attr("x", o).attr("y", a).attr("width", l).attr("height", h).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), t(i, d, o, a, l, h, u, f), r(g, u);
  }
  function r(i, s) {
    for (const o in s)
      s.hasOwnProperty(o) && i.attr(o, s[o]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? n : i.textPlacement === "old" ? e : t;
  };
}(), wde = function() {
  function e(i, s, o, a, l, h, u) {
    const f = s.append("text").attr("x", o).attr("y", a).style("text-anchor", "start").text(i);
    r(f, u);
  }
  function t(i, s, o, a, l, h, u, f) {
    const { actorFontSize: d, actorFontFamily: p, actorFontWeight: g } = f, m = i.split(de.lineBreakRegex);
    for (let y = 0; y < m.length; y++) {
      const O = y * d - d * (m.length - 1) / 2, x = s.append("text").attr("x", o).attr("y", a).style("text-anchor", "start").style("font-size", d).style("font-weight", g).style("font-family", p);
      x.append("tspan").attr("x", o).attr("dy", O).text(m[y]), x.attr("y", a + h / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), r(x, u);
    }
  }
  function n(i, s, o, a, l, h, u, f) {
    const d = s.append("switch"), g = d.append("foreignObject").attr("x", o).attr("y", a).attr("width", l).attr("height", h).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), t(i, d, o, a, l, h, u, f), r(g, u);
  }
  function r(i, s) {
    for (const o in s)
      s.hasOwnProperty(o) && i.attr(o, s[o]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? n : i.textPlacement === "old" ? e : t;
  };
}(), pn = {
  drawRect: nb,
  drawText: vu,
  drawLabel: VZ,
  drawActor: fde,
  drawBox: dde,
  drawPopup: sde,
  drawImage: QZ,
  drawEmbeddedImage: ZZ,
  anchorElement: pde,
  drawActivation: gde,
  drawLoop: mde,
  drawBackgroundRect: zZ,
  insertArrowHead: xde,
  insertArrowFilledHead: vde,
  insertSequenceNumber: _de,
  insertArrowCrossHead: kde,
  insertDatabaseIcon: yde,
  insertComputerIcon: bde,
  insertClockIcon: Ode,
  getTextObj: Dk,
  getNoteRect: rb,
  popupMenu: ode,
  popdownMenu: ade,
  fixLifeLineHeights: YZ,
  sanitizeUrl: Oa.sanitizeUrl
};
let at = {};
const Tt = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: function() {
      return Math.max.apply(
        null,
        this.actors.length === 0 ? [0] : this.actors.map((e) => e.height || 0)
      ) + (this.loops.length === 0 ? 0 : this.loops.map((e) => e.height || 0).reduce((e, t) => e + t)) + (this.messages.length === 0 ? 0 : this.messages.map((e) => e.height || 0).reduce((e, t) => e + t)) + (this.notes.length === 0 ? 0 : this.notes.map((e) => e.height || 0).reduce((e, t) => e + t));
    },
    clear: function() {
      this.actors = [], this.boxes = [], this.loops = [], this.messages = [], this.notes = [];
    },
    addBox: function(e) {
      this.boxes.push(e);
    },
    addActor: function(e) {
      this.actors.push(e);
    },
    addLoop: function(e) {
      this.loops.push(e);
    },
    addMessage: function(e) {
      this.messages.push(e);
    },
    addNote: function(e) {
      this.notes.push(e);
    },
    lastActor: function() {
      return this.actors[this.actors.length - 1];
    },
    lastLoop: function() {
      return this.loops[this.loops.length - 1];
    },
    lastMessage: function() {
      return this.messages[this.messages.length - 1];
    },
    lastNote: function() {
      return this.notes[this.notes.length - 1];
    },
    actors: [],
    boxes: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: function() {
    this.sequenceItems = [], this.activations = [], this.models.clear(), this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0, WZ(J());
  },
  updateVal: function(e, t, n, r) {
    e[t] === void 0 ? e[t] = n : e[t] = r(n, e[t]);
  },
  updateBounds: function(e, t, n, r) {
    const i = this;
    let s = 0;
    function o(a) {
      return function(h) {
        s++;
        const u = i.sequenceItems.length - s + 1;
        i.updateVal(h, "starty", t - u * at.boxMargin, Math.min), i.updateVal(h, "stopy", r + u * at.boxMargin, Math.max), i.updateVal(Tt.data, "startx", e - u * at.boxMargin, Math.min), i.updateVal(Tt.data, "stopx", n + u * at.boxMargin, Math.max), a !== "activation" && (i.updateVal(h, "startx", e - u * at.boxMargin, Math.min), i.updateVal(h, "stopx", n + u * at.boxMargin, Math.max), i.updateVal(Tt.data, "starty", t - u * at.boxMargin, Math.min), i.updateVal(Tt.data, "stopy", r + u * at.boxMargin, Math.max));
      };
    }
    this.sequenceItems.forEach(o()), this.activations.forEach(o("activation"));
  },
  insert: function(e, t, n, r) {
    const i = Math.min(e, n), s = Math.max(e, n), o = Math.min(t, r), a = Math.max(t, r);
    this.updateVal(Tt.data, "startx", i, Math.min), this.updateVal(Tt.data, "starty", o, Math.min), this.updateVal(Tt.data, "stopx", s, Math.max), this.updateVal(Tt.data, "stopy", a, Math.max), this.updateBounds(i, o, s, a);
  },
  newActivation: function(e, t, n) {
    const r = n[e.from.actor], i = ib(e.from.actor).length || 0, s = r.x + r.width / 2 + (i - 1) * at.activationWidth / 2;
    this.activations.push({
      startx: s,
      starty: this.verticalPos + 2,
      stopx: s + at.activationWidth,
      stopy: void 0,
      actor: e.from.actor,
      anchored: pn.anchorElement(t)
    });
  },
  endActivation: function(e) {
    const t = this.activations.map(function(n) {
      return n.actor;
    }).lastIndexOf(e.from.actor);
    return this.activations.splice(t, 1)[0];
  },
  createLoop: function(e = { message: void 0, wrap: !1, width: void 0 }, t) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: e.message,
      wrap: e.wrap,
      width: e.width,
      height: 0,
      fill: t
    };
  },
  newLoop: function(e = { message: void 0, wrap: !1, width: void 0 }, t) {
    this.sequenceItems.push(this.createLoop(e, t));
  },
  endLoop: function() {
    return this.sequenceItems.pop();
  },
  addSectionToLoop: function(e) {
    const t = this.sequenceItems.pop();
    t.sections = t.sections || [], t.sectionTitles = t.sectionTitles || [], t.sections.push({ y: Tt.getVerticalPos(), height: 0 }), t.sectionTitles.push(e), this.sequenceItems.push(t);
  },
  bumpVerticalPos: function(e) {
    this.verticalPos = this.verticalPos + e, this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return { bounds: this.data, models: this.models };
  }
}, Sde = function(e, t) {
  Tt.bumpVerticalPos(at.boxMargin), t.height = at.boxMargin, t.starty = Tt.getVerticalPos();
  const n = pn.getNoteRect();
  n.x = t.startx, n.y = t.starty, n.width = t.width || at.width, n.class = "note";
  const r = e.append("g"), i = pn.drawRect(r, n), s = pn.getTextObj();
  s.x = t.startx, s.y = t.starty, s.width = n.width, s.dy = "1em", s.text = t.message, s.class = "noteText", s.fontFamily = at.noteFontFamily, s.fontSize = at.noteFontSize, s.fontWeight = at.noteFontWeight, s.anchor = at.noteAlign, s.textMargin = at.noteMargin, s.valign = "center";
  const o = vu(r, s), a = Math.round(
    o.map((l) => (l._groups || l)[0][0].getBBox().height).reduce((l, h) => l + h)
  );
  i.attr("height", a + 2 * at.noteMargin), t.height += a + 2 * at.noteMargin, Tt.bumpVerticalPos(a + 2 * at.noteMargin), t.stopy = t.starty + a + 2 * at.noteMargin, t.stopx = t.startx + n.width, Tt.insert(t.startx, t.starty, t.stopx, t.stopy), Tt.models.addNote(t);
}, kc = (e) => ({
  fontFamily: e.messageFontFamily,
  fontSize: e.messageFontSize,
  fontWeight: e.messageFontWeight
}), Gc = (e) => ({
  fontFamily: e.noteFontFamily,
  fontSize: e.noteFontSize,
  fontWeight: e.noteFontWeight
}), Lk = (e) => ({
  fontFamily: e.actorFontFamily,
  fontSize: e.actorFontSize,
  fontWeight: e.actorFontWeight
});
function Cde(e, t) {
  Tt.bumpVerticalPos(10);
  const { startx: n, stopx: r, message: i } = t, s = de.splitBreaks(i).length, o = fe.calculateTextDimensions(i, kc(at)), a = o.height / s;
  t.height += a, Tt.bumpVerticalPos(a);
  let l, h = o.height - 10;
  const u = o.width;
  if (n === r) {
    l = Tt.getVerticalPos() + h, at.rightAngles || (h += at.boxMargin, l = Tt.getVerticalPos() + h), h += 30;
    const f = Math.max(u / 2, at.width / 2);
    Tt.insert(
      n - f,
      Tt.getVerticalPos() - 10 + h,
      r + f,
      Tt.getVerticalPos() + 30 + h
    );
  } else
    h += at.boxMargin, l = Tt.getVerticalPos() + h, Tt.insert(n, l - 10, r, l);
  return Tt.bumpVerticalPos(h), t.height += h, t.stopy = t.starty + t.height, Tt.insert(t.fromBounds, t.starty, t.toBounds, t.stopy), l;
}
const Tde = function(e, t, n, r) {
  const { startx: i, stopx: s, starty: o, message: a, type: l, sequenceIndex: h, sequenceVisible: u } = t, f = fe.calculateTextDimensions(a, kc(at)), d = pn.getTextObj();
  d.x = i, d.y = o + 10, d.width = s - i, d.class = "messageText", d.dy = "1em", d.text = a, d.fontFamily = at.messageFontFamily, d.fontSize = at.messageFontSize, d.fontWeight = at.messageFontWeight, d.anchor = at.messageAlign, d.valign = "center", d.textMargin = at.wrapPadding, d.tspan = !1, vu(e, d);
  const p = f.width;
  let g;
  i === s ? at.rightAngles ? g = e.append("path").attr(
    "d",
    `M  ${i},${n} H ${i + Math.max(at.width / 2, p / 2)} V ${n + 25} H ${i}`
  ) : g = e.append("path").attr(
    "d",
    "M " + i + "," + n + " C " + (i + 60) + "," + (n - 10) + " " + (i + 60) + "," + (n + 30) + " " + i + "," + (n + 20)
  ) : (g = e.append("line"), g.attr("x1", i), g.attr("y1", n), g.attr("x2", s), g.attr("y2", n)), l === r.db.LINETYPE.DOTTED || l === r.db.LINETYPE.DOTTED_CROSS || l === r.db.LINETYPE.DOTTED_POINT || l === r.db.LINETYPE.DOTTED_OPEN ? (g.style("stroke-dasharray", "3, 3"), g.attr("class", "messageLine1")) : g.attr("class", "messageLine0");
  let m = "";
  at.arrowMarkerAbsolute && (m = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, m = m.replace(/\(/g, "\\("), m = m.replace(/\)/g, "\\)")), g.attr("stroke-width", 2), g.attr("stroke", "none"), g.style("fill", "none"), (l === r.db.LINETYPE.SOLID || l === r.db.LINETYPE.DOTTED) && g.attr("marker-end", "url(" + m + "#arrowhead)"), (l === r.db.LINETYPE.SOLID_POINT || l === r.db.LINETYPE.DOTTED_POINT) && g.attr("marker-end", "url(" + m + "#filled-head)"), (l === r.db.LINETYPE.SOLID_CROSS || l === r.db.LINETYPE.DOTTED_CROSS) && g.attr("marker-end", "url(" + m + "#crosshead)"), (u || at.showSequenceNumbers) && (g.attr("marker-start", "url(" + m + "#sequencenumber)"), e.append("text").attr("x", i).attr("y", n + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(h));
}, Mk = function(e, t, n, r, i, s, o) {
  if (i.hideUnusedParticipants === !0) {
    const f = /* @__PURE__ */ new Set();
    s.forEach((d) => {
      f.add(d.from), f.add(d.to);
    }), n = n.filter((d) => f.has(d));
  }
  let a = 0, l = 0, h = 0, u;
  for (const f of n) {
    const d = t[f], p = d.box;
    u && u != p && (o || Tt.models.addBox(u), l += at.boxMargin + u.margin), p && p != u && (o || (p.x = a + l, p.y = r), l += p.margin), d.width = d.width || at.width, d.height = Math.max(d.height || at.height, at.height), d.margin = d.margin || at.actorMargin, d.x = a + l, d.y = Tt.getVerticalPos();
    const g = pn.drawActor(e, d, at, o);
    h = Math.max(h, g), Tt.insert(d.x, r, d.x + d.width, d.height), a += d.width + l, d.box && (d.box.width = a + p.margin - d.box.x), l = d.margin, u = d.box, Tt.models.addActor(d);
  }
  u && !o && Tt.models.addBox(u), Tt.bumpVerticalPos(h);
}, qZ = function(e, t, n, r) {
  let i = 0, s = 0;
  for (const o of n) {
    const a = t[o], l = Pde(a), h = pn.drawPopup(
      e,
      a,
      l,
      at,
      at.forceMenus,
      r
    );
    h.height > i && (i = h.height), h.width + a.x > s && (s = h.width + a.x);
  }
  return { maxHeight: i, maxWidth: s };
}, WZ = function(e) {
  or(at, e), e.fontFamily && (at.actorFontFamily = at.noteFontFamily = at.messageFontFamily = e.fontFamily), e.fontSize && (at.actorFontSize = at.noteFontSize = at.messageFontSize = e.fontSize), e.fontWeight && (at.actorFontWeight = at.noteFontWeight = at.messageFontWeight = e.fontWeight);
}, ib = function(e) {
  return Tt.activations.filter(function(t) {
    return t.actor === e;
  });
}, X8 = function(e, t) {
  const n = t[e], r = ib(e), i = r.reduce(function(o, a) {
    return Math.min(o, a.startx);
  }, n.x + n.width / 2), s = r.reduce(function(o, a) {
    return Math.max(o, a.stopx);
  }, n.x + n.width / 2);
  return [i, s];
};
function zs(e, t, n, r, i) {
  Tt.bumpVerticalPos(n);
  let s = r;
  if (t.id && t.message && e[t.id]) {
    const o = e[t.id].width, a = kc(at);
    t.message = fe.wrapLabel(`[${t.message}]`, o - 2 * at.wrapPadding, a), t.width = o, t.wrap = !0;
    const l = fe.calculateTextDimensions(t.message, a), h = Math.max(l.height, at.labelBoxHeight);
    s = r + h, B.debug(`${h} - ${t.message}`);
  }
  i(t), Tt.bumpVerticalPos(s);
}
const Ede = function(e, t, n, r) {
  const { securityLevel: i, sequence: s } = J();
  at = s, r.db.clear(), r.parser.parse(e);
  let o;
  i === "sandbox" && (o = wt("#i" + t));
  const a = wt(i === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), l = i === "sandbox" ? o.nodes()[0].contentDocument : document;
  Tt.init(), B.debug(r.db);
  const h = i === "sandbox" ? a.select(`[id="${t}"]`) : wt(`[id="${t}"]`), u = r.db.getActors(), f = r.db.getBoxes(), d = r.db.getActorKeys(), p = r.db.getMessages(), g = r.db.getDiagramTitle(), m = r.db.hasAtLeastOneBox(), y = r.db.hasAtLeastOneBoxWithTitle(), O = Ade(u, p, r);
  at.height = Dde(u, O, f), pn.insertComputerIcon(h), pn.insertDatabaseIcon(h), pn.insertClockIcon(h), m && (Tt.bumpVerticalPos(at.boxMargin), y && Tt.bumpVerticalPos(f[0].textMaxHeight)), Mk(h, u, d, 0, at, p, !1);
  const x = Rde(p, u, O, r);
  pn.insertArrowHead(h), pn.insertArrowCrossHead(h), pn.insertArrowFilledHead(h), pn.insertSequenceNumber(h);
  function _(M, v) {
    const N = Tt.endActivation(M);
    N.starty + 18 > v && (N.starty = v - 6, v += 12), pn.drawActivation(
      h,
      N,
      v,
      at,
      ib(M.from.actor).length
    ), Tt.insert(N.startx, v - 10, N.stopx, v);
  }
  let w = 1, E = 1;
  const T = [];
  p.forEach(function(M) {
    let v, N, tt;
    switch (M.type) {
      case r.db.LINETYPE.NOTE:
        N = M.noteModel, Sde(h, N);
        break;
      case r.db.LINETYPE.ACTIVE_START:
        Tt.newActivation(M, h, u);
        break;
      case r.db.LINETYPE.ACTIVE_END:
        _(M, Tt.getVerticalPos());
        break;
      case r.db.LINETYPE.LOOP_START:
        zs(
          x,
          M,
          at.boxMargin,
          at.boxMargin + at.boxTextMargin,
          (Z) => Tt.newLoop(Z)
        );
        break;
      case r.db.LINETYPE.LOOP_END:
        v = Tt.endLoop(), pn.drawLoop(h, v, "loop", at), Tt.bumpVerticalPos(v.stopy - Tt.getVerticalPos()), Tt.models.addLoop(v);
        break;
      case r.db.LINETYPE.RECT_START:
        zs(
          x,
          M,
          at.boxMargin,
          at.boxMargin,
          (Z) => Tt.newLoop(void 0, Z.message)
        );
        break;
      case r.db.LINETYPE.RECT_END:
        v = Tt.endLoop(), pn.drawBackgroundRect(h, v), Tt.models.addLoop(v), Tt.bumpVerticalPos(v.stopy - Tt.getVerticalPos());
        break;
      case r.db.LINETYPE.OPT_START:
        zs(
          x,
          M,
          at.boxMargin,
          at.boxMargin + at.boxTextMargin,
          (Z) => Tt.newLoop(Z)
        );
        break;
      case r.db.LINETYPE.OPT_END:
        v = Tt.endLoop(), pn.drawLoop(h, v, "opt", at), Tt.bumpVerticalPos(v.stopy - Tt.getVerticalPos()), Tt.models.addLoop(v);
        break;
      case r.db.LINETYPE.ALT_START:
        zs(
          x,
          M,
          at.boxMargin,
          at.boxMargin + at.boxTextMargin,
          (Z) => Tt.newLoop(Z)
        );
        break;
      case r.db.LINETYPE.ALT_ELSE:
        zs(
          x,
          M,
          at.boxMargin + at.boxTextMargin,
          at.boxMargin,
          (Z) => Tt.addSectionToLoop(Z)
        );
        break;
      case r.db.LINETYPE.ALT_END:
        v = Tt.endLoop(), pn.drawLoop(h, v, "alt", at), Tt.bumpVerticalPos(v.stopy - Tt.getVerticalPos()), Tt.models.addLoop(v);
        break;
      case r.db.LINETYPE.PAR_START:
        zs(
          x,
          M,
          at.boxMargin,
          at.boxMargin + at.boxTextMargin,
          (Z) => Tt.newLoop(Z)
        );
        break;
      case r.db.LINETYPE.PAR_AND:
        zs(
          x,
          M,
          at.boxMargin + at.boxTextMargin,
          at.boxMargin,
          (Z) => Tt.addSectionToLoop(Z)
        );
        break;
      case r.db.LINETYPE.PAR_END:
        v = Tt.endLoop(), pn.drawLoop(h, v, "par", at), Tt.bumpVerticalPos(v.stopy - Tt.getVerticalPos()), Tt.models.addLoop(v);
        break;
      case r.db.LINETYPE.AUTONUMBER:
        w = M.message.start || w, E = M.message.step || E, M.message.visible ? r.db.enableSequenceNumbers() : r.db.disableSequenceNumbers();
        break;
      case r.db.LINETYPE.CRITICAL_START:
        zs(
          x,
          M,
          at.boxMargin,
          at.boxMargin + at.boxTextMargin,
          (Z) => Tt.newLoop(Z)
        );
        break;
      case r.db.LINETYPE.CRITICAL_OPTION:
        zs(
          x,
          M,
          at.boxMargin + at.boxTextMargin,
          at.boxMargin,
          (Z) => Tt.addSectionToLoop(Z)
        );
        break;
      case r.db.LINETYPE.CRITICAL_END:
        v = Tt.endLoop(), pn.drawLoop(h, v, "critical", at), Tt.bumpVerticalPos(v.stopy - Tt.getVerticalPos()), Tt.models.addLoop(v);
        break;
      case r.db.LINETYPE.BREAK_START:
        zs(
          x,
          M,
          at.boxMargin,
          at.boxMargin + at.boxTextMargin,
          (Z) => Tt.newLoop(Z)
        );
        break;
      case r.db.LINETYPE.BREAK_END:
        v = Tt.endLoop(), pn.drawLoop(h, v, "break", at), Tt.bumpVerticalPos(v.stopy - Tt.getVerticalPos()), Tt.models.addLoop(v);
        break;
      default:
        try {
          tt = M.msgModel, tt.starty = Tt.getVerticalPos(), tt.sequenceIndex = w, tt.sequenceVisible = r.db.showSequenceNumbers();
          const Z = Cde(h, tt);
          T.push({ messageModel: tt, lineStartY: Z }), Tt.models.addMessage(tt);
        } catch (Z) {
          B.error("error while drawing message", Z);
        }
    }
    [
      r.db.LINETYPE.SOLID_OPEN,
      r.db.LINETYPE.DOTTED_OPEN,
      r.db.LINETYPE.SOLID,
      r.db.LINETYPE.DOTTED,
      r.db.LINETYPE.SOLID_CROSS,
      r.db.LINETYPE.DOTTED_CROSS,
      r.db.LINETYPE.SOLID_POINT,
      r.db.LINETYPE.DOTTED_POINT
    ].includes(M.type) && (w = w + E);
  }), T.forEach((M) => Tde(h, M.messageModel, M.lineStartY, r)), at.mirrorActors && (Tt.bumpVerticalPos(at.boxMargin * 2), Mk(h, u, d, Tt.getVerticalPos(), at, p, !0), Tt.bumpVerticalPos(at.boxMargin), YZ(h, Tt.getVerticalPos())), Tt.models.boxes.forEach(function(M) {
    M.height = Tt.getVerticalPos() - M.y, Tt.insert(M.x, M.y, M.x + M.width, M.height), M.startx = M.x, M.starty = M.y, M.stopx = M.startx + M.width, M.stopy = M.starty + M.height, M.stroke = "rgb(0,0,0, 0.5)", pn.drawBox(h, M, at);
  }), m && Tt.bumpVerticalPos(at.boxMargin);
  const S = qZ(h, u, d, l), { bounds: R } = Tt.getBounds();
  B.debug("For line height fix Querying: #" + t + " .actor-line"), Z3("#" + t + " .actor-line").attr("y2", R.stopy);
  let P = R.stopy - R.starty;
  P < S.maxHeight && (P = S.maxHeight);
  let C = P + 2 * at.diagramMarginY;
  at.mirrorActors && (C = C - at.boxMargin + at.bottomMarginAdj);
  let k = R.stopx - R.startx;
  k < S.maxWidth && (k = S.maxWidth);
  const D = k + 2 * at.diagramMarginX;
  g && h.append("text").text(g).attr("x", (R.stopx - R.startx) / 2 - 2 * at.diagramMarginX).attr("y", -25), $s(h, C, D, at.useMaxWidth);
  const b = g ? 40 : 0;
  h.attr(
    "viewBox",
    R.startx - at.diagramMarginX + " -" + (at.diagramMarginY + b) + " " + D + " " + (C + b)
  ), B.debug("models:", Tt.models);
};
function Ade(e, t, n) {
  const r = {};
  return t.forEach(function(i) {
    if (e[i.to] && e[i.from]) {
      const s = e[i.to];
      if (i.placement === n.db.PLACEMENT.LEFTOF && !s.prevActor || i.placement === n.db.PLACEMENT.RIGHTOF && !s.nextActor)
        return;
      const o = i.placement !== void 0, a = !o, l = o ? Gc(at) : kc(at), h = i.wrap ? fe.wrapLabel(i.message, at.width - 2 * at.wrapPadding, l) : i.message, f = fe.calculateTextDimensions(h, l).width + 2 * at.wrapPadding;
      a && i.from === s.nextActor ? r[i.to] = Math.max(
        r[i.to] || 0,
        f
      ) : a && i.from === s.prevActor ? r[i.from] = Math.max(
        r[i.from] || 0,
        f
      ) : a && i.from === i.to ? (r[i.from] = Math.max(
        r[i.from] || 0,
        f / 2
      ), r[i.to] = Math.max(
        r[i.to] || 0,
        f / 2
      )) : i.placement === n.db.PLACEMENT.RIGHTOF ? r[i.from] = Math.max(
        r[i.from] || 0,
        f
      ) : i.placement === n.db.PLACEMENT.LEFTOF ? r[s.prevActor] = Math.max(
        r[s.prevActor] || 0,
        f
      ) : i.placement === n.db.PLACEMENT.OVER && (s.prevActor && (r[s.prevActor] = Math.max(
        r[s.prevActor] || 0,
        f / 2
      )), s.nextActor && (r[i.from] = Math.max(
        r[i.from] || 0,
        f / 2
      )));
    }
  }), B.debug("maxMessageWidthPerActor:", r), r;
}
const Pde = function(e) {
  let t = 0;
  const n = Lk(at);
  for (const r in e.links) {
    const s = fe.calculateTextDimensions(r, n).width + 2 * at.wrapPadding + 2 * at.boxMargin;
    t < s && (t = s);
  }
  return t;
};
function Dde(e, t, n) {
  let r = 0;
  Object.keys(e).forEach((s) => {
    const o = e[s];
    o.wrap && (o.description = fe.wrapLabel(
      o.description,
      at.width - 2 * at.wrapPadding,
      Lk(at)
    ));
    const a = fe.calculateTextDimensions(o.description, Lk(at));
    o.width = o.wrap ? at.width : Math.max(at.width, a.width + 2 * at.wrapPadding), o.height = o.wrap ? Math.max(a.height, at.height) : at.height, r = Math.max(r, o.height);
  });
  for (const s in t) {
    const o = e[s];
    if (!o)
      continue;
    const a = e[o.nextActor];
    if (!a) {
      const f = t[s] + at.actorMargin - o.width / 2;
      o.margin = Math.max(f, at.actorMargin);
      continue;
    }
    const h = t[s] + at.actorMargin - o.width / 2 - a.width / 2;
    o.margin = Math.max(h, at.actorMargin);
  }
  let i = 0;
  return n.forEach((s) => {
    const o = kc(at);
    let a = s.actorKeys.reduce((u, f) => u += e[f].width + (e[f].margin || 0), 0);
    a -= 2 * at.boxTextMargin, s.wrap && (s.name = fe.wrapLabel(s.name, a - 2 * at.wrapPadding, o));
    const l = fe.calculateTextDimensions(s.name, o);
    i = Math.max(l.height, i);
    const h = Math.max(a, l.width + 2 * at.wrapPadding);
    if (s.margin = at.boxTextMargin, a < h) {
      const u = (h - a) / 2;
      s.margin += u;
    }
  }), n.forEach((s) => s.textMaxHeight = i), Math.max(r, at.height);
}
const Lde = function(e, t, n) {
  const r = t[e.from].x, i = t[e.to].x, s = e.wrap && e.message;
  let o = fe.calculateTextDimensions(
    s ? fe.wrapLabel(e.message, at.width, Gc(at)) : e.message,
    Gc(at)
  );
  const a = {
    width: s ? at.width : Math.max(at.width, o.width + 2 * at.noteMargin),
    height: 0,
    startx: t[e.from].x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: e.message
  };
  return e.placement === n.db.PLACEMENT.RIGHTOF ? (a.width = s ? Math.max(at.width, o.width) : Math.max(
    t[e.from].width / 2 + t[e.to].width / 2,
    o.width + 2 * at.noteMargin
  ), a.startx = r + (t[e.from].width + at.actorMargin) / 2) : e.placement === n.db.PLACEMENT.LEFTOF ? (a.width = Math.max(s ? at.width : t[e.from].width / 2 + t[e.to].width / 2, o.width + 2 * at.noteMargin), a.startx = r - a.width + (t[e.from].width - at.actorMargin) / 2) : e.to === e.from ? (o = fe.calculateTextDimensions(
    s ? fe.wrapLabel(e.message, Math.max(at.width, t[e.from].width), Gc(at)) : e.message,
    Gc(at)
  ), a.width = s ? Math.max(at.width, t[e.from].width) : Math.max(t[e.from].width, at.width, o.width + 2 * at.noteMargin), a.startx = r + (t[e.from].width - a.width) / 2) : (a.width = Math.abs(r + t[e.from].width / 2 - (i + t[e.to].width / 2)) + at.actorMargin, a.startx = r < i ? r + t[e.from].width / 2 - at.actorMargin / 2 : i + t[e.to].width / 2 - at.actorMargin / 2), s && (a.message = fe.wrapLabel(
    e.message,
    a.width - 2 * at.wrapPadding,
    Gc(at)
  )), B.debug(
    `NM:[${a.startx},${a.stopx},${a.starty},${a.stopy}:${a.width},${a.height}=${e.message}]`
  ), a;
}, Mde = function(e, t, n) {
  let r = !1;
  if ([
    n.db.LINETYPE.SOLID_OPEN,
    n.db.LINETYPE.DOTTED_OPEN,
    n.db.LINETYPE.SOLID,
    n.db.LINETYPE.DOTTED,
    n.db.LINETYPE.SOLID_CROSS,
    n.db.LINETYPE.DOTTED_CROSS,
    n.db.LINETYPE.SOLID_POINT,
    n.db.LINETYPE.DOTTED_POINT
  ].includes(e.type) && (r = !0), !r)
    return {};
  const i = X8(e.from, t), s = X8(e.to, t), o = i[0] <= s[0] ? 1 : 0, a = i[0] < s[0] ? 0 : 1, l = [...i, ...s], h = Math.abs(s[a] - i[o]);
  e.wrap && e.message && (e.message = fe.wrapLabel(
    e.message,
    Math.max(h + 2 * at.wrapPadding, at.width),
    kc(at)
  ));
  const u = fe.calculateTextDimensions(e.message, kc(at));
  return {
    width: Math.max(
      e.wrap ? 0 : u.width + 2 * at.wrapPadding,
      h + 2 * at.wrapPadding,
      at.width
    ),
    height: 0,
    startx: i[o],
    stopx: s[a],
    starty: 0,
    stopy: 0,
    message: e.message,
    type: e.type,
    wrap: e.wrap,
    fromBounds: Math.min.apply(null, l),
    toBounds: Math.max.apply(null, l)
  };
}, Rde = function(e, t, n, r) {
  const i = {}, s = [];
  let o, a, l;
  return e.forEach(function(h) {
    switch (h.id = fe.random({ length: 10 }), h.type) {
      case r.db.LINETYPE.LOOP_START:
      case r.db.LINETYPE.ALT_START:
      case r.db.LINETYPE.OPT_START:
      case r.db.LINETYPE.PAR_START:
      case r.db.LINETYPE.CRITICAL_START:
      case r.db.LINETYPE.BREAK_START:
        s.push({
          id: h.id,
          msg: h.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;
      case r.db.LINETYPE.ALT_ELSE:
      case r.db.LINETYPE.PAR_AND:
      case r.db.LINETYPE.CRITICAL_OPTION:
        h.message && (o = s.pop(), i[o.id] = o, i[h.id] = o, s.push(o));
        break;
      case r.db.LINETYPE.LOOP_END:
      case r.db.LINETYPE.ALT_END:
      case r.db.LINETYPE.OPT_END:
      case r.db.LINETYPE.PAR_END:
      case r.db.LINETYPE.CRITICAL_END:
      case r.db.LINETYPE.BREAK_END:
        o = s.pop(), i[o.id] = o;
        break;
      case r.db.LINETYPE.ACTIVE_START:
        {
          const f = t[h.from ? h.from.actor : h.to.actor], d = ib(h.from ? h.from.actor : h.to.actor).length, p = f.x + f.width / 2 + (d - 1) * at.activationWidth / 2, g = {
            startx: p,
            stopx: p + at.activationWidth,
            actor: h.from.actor,
            enabled: !0
          };
          Tt.activations.push(g);
        }
        break;
      case r.db.LINETYPE.ACTIVE_END:
        {
          const f = Tt.activations.map((d) => d.actor).lastIndexOf(h.from.actor);
          delete Tt.activations.splice(f, 1)[0];
        }
        break;
    }
    h.placement !== void 0 ? (a = Lde(h, t, r), h.noteModel = a, s.forEach((f) => {
      o = f, o.from = Math.min(o.from, a.startx), o.to = Math.max(o.to, a.startx + a.width), o.width = Math.max(o.width, Math.abs(o.from - o.to)) - at.labelBoxWidth;
    })) : (l = Mde(h, t, r), h.msgModel = l, l.startx && l.stopx && s.length > 0 && s.forEach((f) => {
      if (o = f, l.startx === l.stopx) {
        const d = t[h.from], p = t[h.to];
        o.from = Math.min(
          d.x - l.width / 2,
          d.x - d.width / 2,
          o.from
        ), o.to = Math.max(p.x + l.width / 2, p.x + d.width / 2, o.to), o.width = Math.max(o.width, Math.abs(o.to - o.from)) - at.labelBoxWidth;
      } else
        o.from = Math.min(l.startx, o.from), o.to = Math.max(l.stopx, o.to), o.width = Math.max(o.width, l.width) - at.labelBoxWidth;
    }));
  }), Tt.activations = [], B.debug("Loop type widths:", i), i;
}, G8 = {
  bounds: Tt,
  drawActors: Mk,
  drawActorsPopup: qZ,
  setConf: WZ,
  draw: Ede
};
var Rk = function() {
  var e = function(z, X, q, nt) {
    for (q = q || {}, nt = z.length; nt--; q[z[nt]] = X)
      ;
    return q;
  }, t = [1, 2], n = [1, 3], r = [1, 5], i = [1, 7], s = [2, 5], o = [1, 15], a = [1, 17], l = [1, 21], h = [1, 22], u = [1, 23], f = [1, 24], d = [1, 37], p = [1, 25], g = [1, 26], m = [1, 27], y = [1, 28], O = [1, 29], x = [1, 32], _ = [1, 33], w = [1, 34], E = [1, 35], T = [1, 36], S = [1, 39], R = [1, 40], A = [1, 41], P = [1, 42], C = [1, 38], k = [1, 45], D = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], b = [1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], M = [1, 4, 5, 7, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], v = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], N = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NL: 5, directive: 6, SD: 7, document: 8, line: 9, statement: 10, classDefStatement: 11, cssClassStatement: 12, idStatement: 13, DESCR: 14, "-->": 15, HIDE_EMPTY: 16, scale: 17, WIDTH: 18, COMPOSIT_STATE: 19, STRUCT_START: 20, STRUCT_STOP: 21, STATE_DESCR: 22, AS: 23, ID: 24, FORK: 25, JOIN: 26, CHOICE: 27, CONCURRENT: 28, note: 29, notePosition: 30, NOTE_TEXT: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, classDef: 38, CLASSDEF_ID: 39, CLASSDEF_STYLEOPTS: 40, DEFAULT: 41, class: 42, CLASSENTITY_IDS: 43, STYLECLASS: 44, openDirective: 45, typeDirective: 46, closeDirective: 47, ":": 48, argDirective: 49, direction_tb: 50, direction_bt: 51, direction_rl: 52, direction_lr: 53, eol: 54, ";": 55, EDGE_STATE: 56, STYLE_SEPARATOR: 57, left_of: 58, right_of: 59, open_directive: 60, type_directive: 61, arg_directive: 62, close_directive: 63, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NL", 7: "SD", 14: "DESCR", 15: "-->", 16: "HIDE_EMPTY", 17: "scale", 18: "WIDTH", 19: "COMPOSIT_STATE", 20: "STRUCT_START", 21: "STRUCT_STOP", 22: "STATE_DESCR", 23: "AS", 24: "ID", 25: "FORK", 26: "JOIN", 27: "CHOICE", 28: "CONCURRENT", 29: "note", 31: "NOTE_TEXT", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 38: "classDef", 39: "CLASSDEF_ID", 40: "CLASSDEF_STYLEOPTS", 41: "DEFAULT", 42: "class", 43: "CLASSENTITY_IDS", 44: "STYLECLASS", 48: ":", 50: "direction_tb", 51: "direction_bt", 52: "direction_rl", 53: "direction_lr", 55: ";", 56: "EDGE_STATE", 57: "STYLE_SEPARATOR", 58: "left_of", 59: "right_of", 60: "open_directive", 61: "type_directive", 62: "arg_directive", 63: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 3], [10, 4], [10, 1], [10, 2], [10, 1], [10, 4], [10, 3], [10, 6], [10, 1], [10, 1], [10, 1], [10, 1], [10, 4], [10, 4], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [11, 3], [11, 3], [12, 3], [6, 3], [6, 5], [32, 1], [32, 1], [32, 1], [32, 1], [54, 1], [54, 1], [13, 1], [13, 1], [13, 3], [13, 3], [30, 1], [30, 1], [45, 1], [46, 1], [49, 1], [47, 1]],
    performAction: function(X, q, nt, st, ct, Y, Ct) {
      var H = Y.length - 1;
      switch (ct) {
        case 4:
          return st.setRootDoc(Y[H]), Y[H];
        case 5:
          this.$ = [];
          break;
        case 6:
          Y[H] != "nl" && (Y[H - 1].push(Y[H]), this.$ = Y[H - 1]);
          break;
        case 7:
        case 8:
          this.$ = Y[H];
          break;
        case 9:
          this.$ = "nl";
          break;
        case 12:
          this.$ = Y[H];
          break;
        case 13:
          const $ = Y[H - 1];
          $.description = st.trimColon(Y[H]), this.$ = $;
          break;
        case 14:
          this.$ = { stmt: "relation", state1: Y[H - 2], state2: Y[H] };
          break;
        case 15:
          const F = st.trimColon(Y[H]);
          this.$ = { stmt: "relation", state1: Y[H - 3], state2: Y[H - 1], description: F };
          break;
        case 19:
          this.$ = { stmt: "state", id: Y[H - 3], type: "default", description: "", doc: Y[H - 1] };
          break;
        case 20:
          var et = Y[H], U = Y[H - 2].trim();
          if (Y[H].match(":")) {
            var W = Y[H].split(":");
            et = W[0], U = [U, W[1]];
          }
          this.$ = { stmt: "state", id: et, type: "default", description: U };
          break;
        case 21:
          this.$ = { stmt: "state", id: Y[H - 3], type: "default", description: Y[H - 5], doc: Y[H - 1] };
          break;
        case 22:
          this.$ = { stmt: "state", id: Y[H], type: "fork" };
          break;
        case 23:
          this.$ = { stmt: "state", id: Y[H], type: "join" };
          break;
        case 24:
          this.$ = { stmt: "state", id: Y[H], type: "choice" };
          break;
        case 25:
          this.$ = { stmt: "state", id: st.getDividerId(), type: "divider" };
          break;
        case 26:
          this.$ = { stmt: "state", id: Y[H - 1].trim(), note: { position: Y[H - 2].trim(), text: Y[H].trim() } };
          break;
        case 30:
          this.$ = Y[H].trim(), st.setAccTitle(this.$);
          break;
        case 31:
        case 32:
          this.$ = Y[H].trim(), st.setAccDescription(this.$);
          break;
        case 33:
        case 34:
          this.$ = { stmt: "classDef", id: Y[H - 1].trim(), classes: Y[H].trim() };
          break;
        case 35:
          this.$ = { stmt: "applyClass", id: Y[H - 1].trim(), styleClass: Y[H].trim() };
          break;
        case 38:
          st.setDirection("TB"), this.$ = { stmt: "dir", value: "TB" };
          break;
        case 39:
          st.setDirection("BT"), this.$ = { stmt: "dir", value: "BT" };
          break;
        case 40:
          st.setDirection("RL"), this.$ = { stmt: "dir", value: "RL" };
          break;
        case 41:
          st.setDirection("LR"), this.$ = { stmt: "dir", value: "LR" };
          break;
        case 44:
        case 45:
          this.$ = { stmt: "state", id: Y[H].trim(), type: "default", description: "" };
          break;
        case 46:
          this.$ = { stmt: "state", id: Y[H - 2].trim(), classes: [Y[H].trim()], type: "default", description: "" };
          break;
        case 47:
          this.$ = { stmt: "state", id: Y[H - 2].trim(), classes: [Y[H].trim()], type: "default", description: "" };
          break;
        case 50:
          st.parseDirective("%%{", "open_directive");
          break;
        case 51:
          st.parseDirective(Y[H], "type_directive");
          break;
        case 52:
          Y[H] = Y[H].trim().replace(/'/g, '"'), st.parseDirective(Y[H], "arg_directive");
          break;
        case 53:
          st.parseDirective("}%%", "close_directive", "state");
          break;
      }
    },
    table: [{ 3: 1, 4: t, 5: n, 6: 4, 7: r, 45: 6, 60: i }, { 1: [3] }, { 3: 8, 4: t, 5: n, 6: 4, 7: r, 45: 6, 60: i }, { 3: 9, 4: t, 5: n, 6: 4, 7: r, 45: 6, 60: i }, { 3: 10, 4: t, 5: n, 6: 4, 7: r, 45: 6, 60: i }, e([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], s, { 8: 11 }), { 46: 12, 61: [1, 13] }, { 61: [2, 50] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: o, 5: a, 6: 30, 9: 14, 10: 16, 11: 18, 12: 19, 13: 20, 16: l, 17: h, 19: u, 22: f, 24: d, 25: p, 26: g, 27: m, 28: y, 29: O, 32: 31, 33: x, 35: _, 37: w, 38: E, 42: T, 45: 6, 50: S, 51: R, 52: A, 53: P, 56: C, 60: i }, { 47: 43, 48: [1, 44], 63: k }, e([48, 63], [2, 51]), e(D, [2, 6]), { 6: 30, 10: 46, 11: 18, 12: 19, 13: 20, 16: l, 17: h, 19: u, 22: f, 24: d, 25: p, 26: g, 27: m, 28: y, 29: O, 32: 31, 33: x, 35: _, 37: w, 38: E, 42: T, 45: 6, 50: S, 51: R, 52: A, 53: P, 56: C, 60: i }, e(D, [2, 8]), e(D, [2, 9]), e(D, [2, 10]), e(D, [2, 11]), e(D, [2, 12], { 14: [1, 47], 15: [1, 48] }), e(D, [2, 16]), { 18: [1, 49] }, e(D, [2, 18], { 20: [1, 50] }), { 23: [1, 51] }, e(D, [2, 22]), e(D, [2, 23]), e(D, [2, 24]), e(D, [2, 25]), { 30: 52, 31: [1, 53], 58: [1, 54], 59: [1, 55] }, e(D, [2, 28]), e(D, [2, 29]), { 34: [1, 56] }, { 36: [1, 57] }, e(D, [2, 32]), { 39: [1, 58], 41: [1, 59] }, { 43: [1, 60] }, e(b, [2, 44], { 57: [1, 61] }), e(b, [2, 45], { 57: [1, 62] }), e(D, [2, 38]), e(D, [2, 39]), e(D, [2, 40]), e(D, [2, 41]), e(M, [2, 36]), { 49: 63, 62: [1, 64] }, e(M, [2, 53]), e(D, [2, 7]), e(D, [2, 13]), { 13: 65, 24: d, 56: C }, e(D, [2, 17]), e(v, s, { 8: 66 }), { 24: [1, 67] }, { 24: [1, 68] }, { 23: [1, 69] }, { 24: [2, 48] }, { 24: [2, 49] }, e(D, [2, 30]), e(D, [2, 31]), { 40: [1, 70] }, { 40: [1, 71] }, { 44: [1, 72] }, { 24: [1, 73] }, { 24: [1, 74] }, { 47: 75, 63: k }, { 63: [2, 52] }, e(D, [2, 14], { 14: [1, 76] }), { 4: o, 5: a, 6: 30, 9: 14, 10: 16, 11: 18, 12: 19, 13: 20, 16: l, 17: h, 19: u, 21: [1, 77], 22: f, 24: d, 25: p, 26: g, 27: m, 28: y, 29: O, 32: 31, 33: x, 35: _, 37: w, 38: E, 42: T, 45: 6, 50: S, 51: R, 52: A, 53: P, 56: C, 60: i }, e(D, [2, 20], { 20: [1, 78] }), { 31: [1, 79] }, { 24: [1, 80] }, e(D, [2, 33]), e(D, [2, 34]), e(D, [2, 35]), e(b, [2, 46]), e(b, [2, 47]), e(M, [2, 37]), e(D, [2, 15]), e(D, [2, 19]), e(v, s, { 8: 81 }), e(D, [2, 26]), e(D, [2, 27]), { 4: o, 5: a, 6: 30, 9: 14, 10: 16, 11: 18, 12: 19, 13: 20, 16: l, 17: h, 19: u, 21: [1, 82], 22: f, 24: d, 25: p, 26: g, 27: m, 28: y, 29: O, 32: 31, 33: x, 35: _, 37: w, 38: E, 42: T, 45: 6, 50: S, 51: R, 52: A, 53: P, 56: C, 60: i }, e(D, [2, 21])],
    defaultActions: { 7: [2, 50], 8: [2, 1], 9: [2, 2], 10: [2, 3], 54: [2, 48], 55: [2, 49], 64: [2, 52] },
    parseError: function(X, q) {
      if (q.recoverable)
        this.trace(X);
      else {
        var nt = new Error(X);
        throw nt.hash = q, nt;
      }
    },
    parse: function(X) {
      var q = this, nt = [0], st = [], ct = [null], Y = [], Ct = this.table, H = "", et = 0, U = 0, W = 2, $ = 1, F = Y.slice.call(arguments, 1), G = Object.create(this.lexer), I = { yy: {} };
      for (var ht in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ht) && (I.yy[ht] = this.yy[ht]);
      G.setInput(X, I.yy), I.yy.lexer = G, I.yy.parser = this, typeof G.yylloc > "u" && (G.yylloc = {});
      var L = G.yylloc;
      Y.push(L);
      var $t = G.options && G.options.ranges;
      typeof I.yy.parseError == "function" ? this.parseError = I.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function it() {
        var Yt;
        return Yt = st.pop() || G.lex() || $, typeof Yt != "number" && (Yt instanceof Array && (st = Yt, Yt = st.pop()), Yt = q.symbols_[Yt] || Yt), Yt;
      }
      for (var At, St, bt, gt, yt = {}, dt, xt, Re, ye; ; ) {
        if (St = nt[nt.length - 1], this.defaultActions[St] ? bt = this.defaultActions[St] : ((At === null || typeof At > "u") && (At = it()), bt = Ct[St] && Ct[St][At]), typeof bt > "u" || !bt.length || !bt[0]) {
          var zt = "";
          ye = [];
          for (dt in Ct[St])
            this.terminals_[dt] && dt > W && ye.push("'" + this.terminals_[dt] + "'");
          G.showPosition ? zt = "Parse error on line " + (et + 1) + `:
` + G.showPosition() + `
Expecting ` + ye.join(", ") + ", got '" + (this.terminals_[At] || At) + "'" : zt = "Parse error on line " + (et + 1) + ": Unexpected " + (At == $ ? "end of input" : "'" + (this.terminals_[At] || At) + "'"), this.parseError(zt, {
            text: G.match,
            token: this.terminals_[At] || At,
            line: G.yylineno,
            loc: L,
            expected: ye
          });
        }
        if (bt[0] instanceof Array && bt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + St + ", token: " + At);
        switch (bt[0]) {
          case 1:
            nt.push(At), ct.push(G.yytext), Y.push(G.yylloc), nt.push(bt[1]), At = null, U = G.yyleng, H = G.yytext, et = G.yylineno, L = G.yylloc;
            break;
          case 2:
            if (xt = this.productions_[bt[1]][1], yt.$ = ct[ct.length - xt], yt._$ = {
              first_line: Y[Y.length - (xt || 1)].first_line,
              last_line: Y[Y.length - 1].last_line,
              first_column: Y[Y.length - (xt || 1)].first_column,
              last_column: Y[Y.length - 1].last_column
            }, $t && (yt._$.range = [
              Y[Y.length - (xt || 1)].range[0],
              Y[Y.length - 1].range[1]
            ]), gt = this.performAction.apply(yt, [
              H,
              U,
              et,
              I.yy,
              bt[1],
              ct,
              Y
            ].concat(F)), typeof gt < "u")
              return gt;
            xt && (nt = nt.slice(0, -1 * xt * 2), ct = ct.slice(0, -1 * xt), Y = Y.slice(0, -1 * xt)), nt.push(this.productions_[bt[1]][0]), ct.push(yt.$), Y.push(yt._$), Re = Ct[nt[nt.length - 2]][nt[nt.length - 1]], nt.push(Re);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, tt = function() {
    var z = {
      EOF: 1,
      parseError: function(q, nt) {
        if (this.yy.parser)
          this.yy.parser.parseError(q, nt);
        else
          throw new Error(q);
      },
      setInput: function(X, q) {
        return this.yy = q || this.yy || {}, this._input = X, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var X = this._input[0];
        this.yytext += X, this.yyleng++, this.offset++, this.match += X, this.matched += X;
        var q = X.match(/(?:\r\n?|\n).*/g);
        return q ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), X;
      },
      unput: function(X) {
        var q = X.length, nt = X.split(/(?:\r\n?|\n)/g);
        this._input = X + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - q), this.offset -= q;
        var st = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), nt.length - 1 && (this.yylineno -= nt.length - 1);
        var ct = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: nt ? (nt.length === st.length ? this.yylloc.first_column : 0) + st[st.length - nt.length].length - nt[0].length : this.yylloc.first_column - q
        }, this.options.ranges && (this.yylloc.range = [ct[0], ct[0] + this.yyleng - q]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(X) {
        this.unput(this.match.slice(X));
      },
      pastInput: function() {
        var X = this.matched.substr(0, this.matched.length - this.match.length);
        return (X.length > 20 ? "..." : "") + X.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var X = this.match;
        return X.length < 20 && (X += this._input.substr(0, 20 - X.length)), (X.substr(0, 20) + (X.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var X = this.pastInput(), q = new Array(X.length + 1).join("-");
        return X + this.upcomingInput() + `
` + q + "^";
      },
      test_match: function(X, q) {
        var nt, st, ct;
        if (this.options.backtrack_lexer && (ct = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (ct.yylloc.range = this.yylloc.range.slice(0))), st = X[0].match(/(?:\r\n?|\n).*/g), st && (this.yylineno += st.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: st ? st[st.length - 1].length - st[st.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + X[0].length
        }, this.yytext += X[0], this.match += X[0], this.matches = X, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(X[0].length), this.matched += X[0], nt = this.performAction.call(this, this.yy, this, q, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), nt)
          return nt;
        if (this._backtrack) {
          for (var Y in ct)
            this[Y] = ct[Y];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var X, q, nt, st;
        this._more || (this.yytext = "", this.match = "");
        for (var ct = this._currentRules(), Y = 0; Y < ct.length; Y++)
          if (nt = this._input.match(this.rules[ct[Y]]), nt && (!q || nt[0].length > q[0].length)) {
            if (q = nt, st = Y, this.options.backtrack_lexer) {
              if (X = this.test_match(nt, ct[Y]), X !== !1)
                return X;
              if (this._backtrack) {
                q = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return q ? (X = this.test_match(q, ct[st]), X !== !1 ? X : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var q = this.next();
        return q || this.lex();
      },
      begin: function(q) {
        this.conditionStack.push(q);
      },
      popState: function() {
        var q = this.conditionStack.length - 1;
        return q > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(q) {
        return q = this.conditionStack.length - 1 - Math.abs(q || 0), q >= 0 ? this.conditionStack[q] : "INITIAL";
      },
      pushState: function(q) {
        this.begin(q);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(q, nt, st, ct) {
        switch (st) {
          case 0:
            return 41;
          case 1:
            return 50;
          case 2:
            return 51;
          case 3:
            return 52;
          case 4:
            return 53;
          case 5:
            return this.begin("open_directive"), 60;
          case 6:
            return this.begin("type_directive"), 61;
          case 7:
            return this.popState(), this.begin("arg_directive"), 48;
          case 8:
            return this.popState(), this.popState(), 63;
          case 9:
            return 62;
          case 10:
            break;
          case 11:
            break;
          case 12:
            return 5;
          case 13:
            break;
          case 14:
            break;
          case 15:
            break;
          case 16:
            break;
          case 17:
            return this.pushState("SCALE"), 17;
          case 18:
            return 18;
          case 19:
            this.popState();
            break;
          case 20:
            return this.begin("acc_title"), 33;
          case 21:
            return this.popState(), "acc_title_value";
          case 22:
            return this.begin("acc_descr"), 35;
          case 23:
            return this.popState(), "acc_descr_value";
          case 24:
            this.begin("acc_descr_multiline");
            break;
          case 25:
            this.popState();
            break;
          case 26:
            return "acc_descr_multiline_value";
          case 27:
            return this.pushState("CLASSDEF"), 38;
          case 28:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 29:
            return this.popState(), this.pushState("CLASSDEFID"), 39;
          case 30:
            return this.popState(), 40;
          case 31:
            return this.pushState("CLASS"), 42;
          case 32:
            return this.popState(), this.pushState("CLASS_STYLE"), 43;
          case 33:
            return this.popState(), 44;
          case 34:
            return this.pushState("SCALE"), 17;
          case 35:
            return 18;
          case 36:
            this.popState();
            break;
          case 37:
            this.pushState("STATE");
            break;
          case 38:
            return this.popState(), nt.yytext = nt.yytext.slice(0, -8).trim(), 25;
          case 39:
            return this.popState(), nt.yytext = nt.yytext.slice(0, -8).trim(), 26;
          case 40:
            return this.popState(), nt.yytext = nt.yytext.slice(0, -10).trim(), 27;
          case 41:
            return this.popState(), nt.yytext = nt.yytext.slice(0, -8).trim(), 25;
          case 42:
            return this.popState(), nt.yytext = nt.yytext.slice(0, -8).trim(), 26;
          case 43:
            return this.popState(), nt.yytext = nt.yytext.slice(0, -10).trim(), 27;
          case 44:
            return 50;
          case 45:
            return 51;
          case 46:
            return 52;
          case 47:
            return 53;
          case 48:
            this.pushState("STATE_STRING");
            break;
          case 49:
            return this.pushState("STATE_ID"), "AS";
          case 50:
            return this.popState(), "ID";
          case 51:
            this.popState();
            break;
          case 52:
            return "STATE_DESCR";
          case 53:
            return 19;
          case 54:
            this.popState();
            break;
          case 55:
            return this.popState(), this.pushState("struct"), 20;
          case 56:
            break;
          case 57:
            return this.popState(), 21;
          case 58:
            break;
          case 59:
            return this.begin("NOTE"), 29;
          case 60:
            return this.popState(), this.pushState("NOTE_ID"), 58;
          case 61:
            return this.popState(), this.pushState("NOTE_ID"), 59;
          case 62:
            this.popState(), this.pushState("FLOATING_NOTE");
            break;
          case 63:
            return this.popState(), this.pushState("FLOATING_NOTE_ID"), "AS";
          case 64:
            break;
          case 65:
            return "NOTE_TEXT";
          case 66:
            return this.popState(), "ID";
          case 67:
            return this.popState(), this.pushState("NOTE_TEXT"), 24;
          case 68:
            return this.popState(), nt.yytext = nt.yytext.substr(2).trim(), 31;
          case 69:
            return this.popState(), nt.yytext = nt.yytext.slice(0, -8).trim(), 31;
          case 70:
            return 7;
          case 71:
            return 7;
          case 72:
            return 16;
          case 73:
            return 56;
          case 74:
            return 24;
          case 75:
            return nt.yytext = nt.yytext.trim(), 14;
          case 76:
            return 15;
          case 77:
            return 28;
          case 78:
            return 57;
          case 79:
            return 5;
          case 80:
            return "INVALID";
        }
      },
      rules: [/^(?:default\b)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:classDef\s+)/i, /^(?:DEFAULT\s+)/i, /^(?:\w+\s+)/i, /^(?:[^\n]*)/i, /^(?:class\s+)/i, /^(?:(\w+)+((,\s*\w+)*))/i, /^(?:[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?::::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { LINE: { rules: [14, 15], inclusive: !1 }, close_directive: { rules: [14, 15], inclusive: !1 }, arg_directive: { rules: [8, 9, 14, 15], inclusive: !1 }, type_directive: { rules: [7, 8, 14, 15], inclusive: !1 }, open_directive: { rules: [6, 14, 15], inclusive: !1 }, struct: { rules: [14, 15, 27, 31, 37, 44, 45, 46, 47, 56, 57, 58, 59, 73, 74, 75, 76, 77], inclusive: !1 }, FLOATING_NOTE_ID: { rules: [66], inclusive: !1 }, FLOATING_NOTE: { rules: [63, 64, 65], inclusive: !1 }, NOTE_TEXT: { rules: [68, 69], inclusive: !1 }, NOTE_ID: { rules: [67], inclusive: !1 }, NOTE: { rules: [60, 61, 62], inclusive: !1 }, CLASS_STYLE: { rules: [33], inclusive: !1 }, CLASS: { rules: [32], inclusive: !1 }, CLASSDEFID: { rules: [30], inclusive: !1 }, CLASSDEF: { rules: [28, 29], inclusive: !1 }, acc_descr_multiline: { rules: [25, 26], inclusive: !1 }, acc_descr: { rules: [23], inclusive: !1 }, acc_title: { rules: [21], inclusive: !1 }, SCALE: { rules: [18, 19, 35, 36], inclusive: !1 }, ALIAS: { rules: [], inclusive: !1 }, STATE_ID: { rules: [50], inclusive: !1 }, STATE_STRING: { rules: [51, 52], inclusive: !1 }, FORK_STATE: { rules: [], inclusive: !1 }, STATE: { rules: [14, 15, 38, 39, 40, 41, 42, 43, 48, 49, 53, 54, 55], inclusive: !1 }, ID: { rules: [14, 15], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 10, 11, 12, 13, 15, 16, 17, 20, 22, 24, 27, 31, 34, 37, 55, 59, 70, 71, 72, 73, 74, 75, 76, 78, 79, 80], inclusive: !0 } }
    };
    return z;
  }();
  N.lexer = tt;
  function Z() {
    this.yy = {};
  }
  return Z.prototype = N, N.Parser = Z, new Z();
}();
Rk.parser = Rk;
const H8 = Rk, $de = (e, t) => {
  var n;
  return ((n = t == null ? void 0 : t.state) == null ? void 0 : n.defaultRenderer) === "dagre-wrapper" ? !1 : e.match(/^\s*stateDiagram/) !== null;
}, Ide = (e, t) => {
  var n;
  return !!(e.match(/^\s*stateDiagram-v2/) !== null || e.match(/^\s*stateDiagram/) && ((n = t == null ? void 0 : t.state) == null ? void 0 : n.defaultRenderer) === "dagre-wrapper");
}, Nde = "LR", Bde = "TB", y2 = "state", nS = "relation", Fde = "classDef", Qde = "applyClass", u0 = "default", UZ = "divider", rS = "[*]", jZ = "start", XZ = rS, GZ = "end", K8 = "color", J8 = "fill", Zde = "bgFill", Vde = ",";
function HZ() {
  return {};
}
let KZ = Nde, b2 = [], cd = HZ();
const JZ = () => ({
  relations: [],
  states: {},
  documents: {}
});
let O2 = {
  root: JZ()
}, kr = O2.root, Tp = 0, t7 = 0;
const Yde = {
  LINE: 0,
  DOTTED_LINE: 1
}, zde = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
}, v1 = (e) => JSON.parse(JSON.stringify(e)), qde = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, Wde = (e) => {
  B.info("Setting root doc", e), b2 = e;
}, Ude = () => b2, Og = (e, t, n) => {
  if (t.stmt === nS)
    Og(e, t.state1, !0), Og(e, t.state2, !1);
  else if (t.stmt === y2 && (t.id === "[*]" ? (t.id = n ? e.id + "_start" : e.id + "_end", t.start = n) : t.id = t.id.trim()), t.doc) {
    const r = [];
    let i = [], s;
    for (s = 0; s < t.doc.length; s++)
      if (t.doc[s].type === UZ) {
        const o = v1(t.doc[s]);
        o.doc = v1(i), r.push(o), i = [];
      } else
        i.push(t.doc[s]);
    if (r.length > 0 && i.length > 0) {
      const o = {
        stmt: y2,
        id: SF(),
        type: "divider",
        doc: v1(i)
      };
      r.push(v1(o)), t.doc = r;
    }
    t.doc.forEach((o) => Og(t, o, !0));
  }
}, jde = () => (Og({ id: "root" }, { id: "root", doc: b2 }, !0), { id: "root", doc: b2 }), Xde = (e) => {
  let t;
  e.doc ? t = e.doc : t = e, B.info(t), tV(!0), B.info("Extract", t), t.forEach((n) => {
    switch (n.stmt) {
      case y2:
        wc(
          n.id.trim(),
          n.type,
          n.doc,
          n.description,
          n.note,
          n.classes,
          n.styles,
          n.textStyles
        );
        break;
      case nS:
        eV(n.state1, n.state2, n.description);
        break;
      case Fde:
        nV(n.id.trim(), n.classes);
        break;
      case Qde:
        iS(n.id.trim(), n.styleClass);
        break;
    }
  });
}, wc = function(e, t = u0, n = null, r = null, i = null, s = null, o = null, a = null) {
  const l = e == null ? void 0 : e.trim();
  kr.states[l] === void 0 ? (B.info("Adding state ", l, r), kr.states[l] = {
    id: l,
    descriptions: [],
    type: t,
    doc: n,
    note: i,
    classes: [],
    styles: [],
    textStyles: []
  }) : (kr.states[l].doc || (kr.states[l].doc = n), kr.states[l].type || (kr.states[l].type = t)), r && (B.info("Setting state description", l, r), typeof r == "string" && Nk(l, r.trim()), typeof r == "object" && r.forEach((h) => Nk(l, h.trim()))), i && (kr.states[l].note = i, kr.states[l].note.text = de.sanitizeText(
    kr.states[l].note.text,
    J()
  )), s && (B.info("Setting state classes", l, s), (typeof s == "string" ? [s] : s).forEach((u) => iS(l, u.trim()))), o && (B.info("Setting state styles", l, o), (typeof o == "string" ? [o] : o).forEach((u) => spe(l, u.trim()))), a && (B.info("Setting state styles", l, o), (typeof a == "string" ? [a] : a).forEach((u) => ope(l, u.trim())));
}, tV = function(e) {
  O2 = {
    root: JZ()
  }, kr = O2.root, Tp = 0, cd = HZ(), e || _i();
}, Ep = function(e) {
  return kr.states[e];
}, Gde = function() {
  return kr.states;
}, Hde = function() {
  B.info("Documents = ", O2);
}, Kde = function() {
  return kr.relations;
};
function $k(e = "") {
  let t = e;
  return e === rS && (Tp++, t = `${jZ}${Tp}`), t;
}
function Ik(e = "", t = u0) {
  return e === rS ? jZ : t;
}
function Jde(e = "") {
  let t = e;
  return e === XZ && (Tp++, t = `${GZ}${Tp}`), t;
}
function tpe(e = "", t = u0) {
  return e === XZ ? GZ : t;
}
function epe(e, t, n) {
  let r = $k(e.id.trim()), i = Ik(e.id.trim(), e.type), s = $k(t.id.trim()), o = Ik(t.id.trim(), t.type);
  wc(
    r,
    i,
    e.doc,
    e.description,
    e.note,
    e.classes,
    e.styles,
    e.textStyles
  ), wc(
    s,
    o,
    t.doc,
    t.description,
    t.note,
    t.classes,
    t.styles,
    t.textStyles
  ), kr.relations.push({
    id1: r,
    id2: s,
    relationTitle: de.sanitizeText(n, J())
  });
}
const eV = function(e, t, n) {
  if (typeof e == "object")
    epe(e, t, n);
  else {
    const r = $k(e.trim()), i = Ik(e), s = Jde(t.trim()), o = tpe(t);
    wc(r, i), wc(s, o), kr.relations.push({
      id1: r,
      id2: s,
      title: de.sanitizeText(n, J())
    });
  }
}, Nk = function(e, t) {
  const n = kr.states[e], r = t.startsWith(":") ? t.replace(":", "").trim() : t;
  n.descriptions.push(de.sanitizeText(r, J()));
}, npe = function(e) {
  return e.substring(0, 1) === ":" ? e.substr(2).trim() : e.trim();
}, rpe = () => (t7++, "divider-id-" + t7), nV = function(e, t = "") {
  cd[e] === void 0 && (cd[e] = { id: e, styles: [], textStyles: [] });
  const n = cd[e];
  t != null && t.split(Vde).forEach((r) => {
    const i = r.replace(/([^;]*);/, "$1").trim();
    if (r.match(K8)) {
      const o = i.replace(J8, Zde).replace(K8, J8);
      n.textStyles.push(o);
    }
    n.styles.push(i);
  });
}, ipe = function() {
  return cd;
}, iS = function(e, t) {
  e.split(",").forEach(function(n) {
    let r = Ep(n);
    if (r === void 0) {
      const i = n.trim();
      wc(i), r = Ep(i);
    }
    r.classes.push(t);
  });
}, spe = function(e, t) {
  const n = Ep(e);
  n !== void 0 && n.textStyles.push(t);
}, ope = function(e, t) {
  const n = Ep(e);
  n !== void 0 && n.textStyles.push(t);
}, ape = () => KZ, lpe = (e) => {
  KZ = e;
}, cpe = (e) => e && e[0] === ":" ? e.substr(1).trim() : e.trim(), Vo = {
  parseDirective: qde,
  getConfig: () => J().state,
  addState: wc,
  clear: tV,
  getState: Ep,
  getStates: Gde,
  getRelations: Kde,
  getClasses: ipe,
  getDirection: ape,
  addRelation: eV,
  getDividerId: rpe,
  setDirection: lpe,
  cleanupLabel: npe,
  lineType: Yde,
  relationType: zde,
  logDocuments: Hde,
  getRootDoc: Ude,
  setRootDoc: Wde,
  getRootDocV2: jde,
  extract: Xde,
  trimColon: cpe,
  getAccTitle: ki,
  setAccTitle: oi,
  getAccDescription: Si,
  setAccDescription: wi,
  addStyleClass: nV,
  setCssClass: iS,
  addDescription: Nk,
  setDiagramTitle: Is,
  getDiagramTitle: Ns
}, hpe = (e) => e.append("circle").attr("class", "start-state").attr("r", J().state.sizeUnit).attr("cx", J().state.padding + J().state.sizeUnit).attr("cy", J().state.padding + J().state.sizeUnit), upe = (e) => e.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", J().state.textHeight).attr("class", "divider").attr("x2", J().state.textHeight * 2).attr("y1", 0).attr("y2", 0), fpe = (e, t) => {
  const n = e.append("text").attr("x", 2 * J().state.padding).attr("y", J().state.textHeight + 2 * J().state.padding).attr("font-size", J().state.fontSize).attr("class", "state-title").text(t.id), r = n.node().getBBox();
  return e.insert("rect", ":first-child").attr("x", J().state.padding).attr("y", J().state.padding).attr("width", r.width + 2 * J().state.padding).attr("height", r.height + 2 * J().state.padding).attr("rx", J().state.radius), n;
}, dpe = (e, t) => {
  const n = function(d, p, g) {
    const m = d.append("tspan").attr("x", 2 * J().state.padding).text(p);
    g || m.attr("dy", J().state.textHeight);
  }, i = e.append("text").attr("x", 2 * J().state.padding).attr("y", J().state.textHeight + 1.3 * J().state.padding).attr("font-size", J().state.fontSize).attr("class", "state-title").text(t.descriptions[0]).node().getBBox(), s = i.height, o = e.append("text").attr("x", J().state.padding).attr(
    "y",
    s + J().state.padding * 0.4 + J().state.dividerMargin + J().state.textHeight
  ).attr("class", "state-description");
  let a = !0, l = !0;
  t.descriptions.forEach(function(d) {
    a || (n(o, d, l), l = !1), a = !1;
  });
  const h = e.append("line").attr("x1", J().state.padding).attr("y1", J().state.padding + s + J().state.dividerMargin / 2).attr("y2", J().state.padding + s + J().state.dividerMargin / 2).attr("class", "descr-divider"), u = o.node().getBBox(), f = Math.max(u.width, i.width);
  return h.attr("x2", f + 3 * J().state.padding), e.insert("rect", ":first-child").attr("x", J().state.padding).attr("y", J().state.padding).attr("width", f + 2 * J().state.padding).attr("height", u.height + s + 2 * J().state.padding).attr("rx", J().state.radius), e;
}, ppe = (e, t, n) => {
  const r = J().state.padding, i = 2 * J().state.padding, s = e.node().getBBox(), o = s.width, a = s.x, l = e.append("text").attr("x", 0).attr("y", J().state.titleShift).attr("font-size", J().state.fontSize).attr("class", "state-title").text(t.id), u = l.node().getBBox().width + i;
  let f = Math.max(u, o);
  f === o && (f = f + i);
  let d;
  const p = e.node().getBBox();
  t.doc, d = a - r, u > o && (d = (o - f) / 2 + r), Math.abs(a - p.x) < r && u > o && (d = a - (u - o) / 2);
  const g = 1 - J().state.textHeight;
  return e.insert("rect", ":first-child").attr("x", d).attr("y", g).attr("class", n ? "alt-composit" : "composit").attr("width", f).attr(
    "height",
    p.height + J().state.textHeight + J().state.titleShift + 1
  ).attr("rx", "0"), l.attr("x", d + r), u <= o && l.attr("x", a + (f - i) / 2 - u / 2 + r), e.insert("rect", ":first-child").attr("x", d).attr(
    "y",
    J().state.titleShift - J().state.textHeight - J().state.padding
  ).attr("width", f).attr("height", J().state.textHeight * 3).attr("rx", J().state.radius), e.insert("rect", ":first-child").attr("x", d).attr(
    "y",
    J().state.titleShift - J().state.textHeight - J().state.padding
  ).attr("width", f).attr("height", p.height + 3 + 2 * J().state.textHeight).attr("rx", J().state.radius), e;
}, gpe = (e) => (e.append("circle").attr("class", "end-state-outer").attr("r", J().state.sizeUnit + J().state.miniPadding).attr(
  "cx",
  J().state.padding + J().state.sizeUnit + J().state.miniPadding
).attr(
  "cy",
  J().state.padding + J().state.sizeUnit + J().state.miniPadding
), e.append("circle").attr("class", "end-state-inner").attr("r", J().state.sizeUnit).attr("cx", J().state.padding + J().state.sizeUnit + 2).attr("cy", J().state.padding + J().state.sizeUnit + 2)), mpe = (e, t) => {
  let n = J().state.forkWidth, r = J().state.forkHeight;
  if (t.parentId) {
    let i = n;
    n = r, r = i;
  }
  return e.append("rect").style("stroke", "black").style("fill", "black").attr("width", n).attr("height", r).attr("x", J().state.padding).attr("y", J().state.padding);
}, ype = (e, t, n, r) => {
  let i = 0;
  const s = r.append("text");
  s.style("text-anchor", "start"), s.attr("class", "noteText");
  let o = e.replace(/\r\n/g, "<br/>");
  o = o.replace(/\n/g, "<br/>");
  const a = o.split(de.lineBreakRegex);
  let l = 1.25 * J().state.noteMargin;
  for (const h of a) {
    const u = h.trim();
    if (u.length > 0) {
      const f = s.append("tspan");
      if (f.text(u), l === 0) {
        const d = f.node().getBBox();
        l += d.height;
      }
      i += l, f.attr("x", t + J().state.noteMargin), f.attr("y", n + i + 1.25 * J().state.noteMargin);
    }
  }
  return { textWidth: s.node().getBBox().width, textHeight: i };
}, bpe = (e, t) => {
  t.attr("class", "state-note");
  const n = t.append("rect").attr("x", 0).attr("y", J().state.padding), r = t.append("g"), { textWidth: i, textHeight: s } = ype(e, 0, 0, r);
  return n.attr("height", s + 2 * J().state.noteMargin), n.attr("width", i + J().state.noteMargin * 2), n;
}, e7 = function(e, t) {
  const n = t.id, r = {
    id: n,
    label: t.id,
    width: 0,
    height: 0
  }, i = e.append("g").attr("id", n).attr("class", "stateGroup");
  t.type === "start" && hpe(i), t.type === "end" && gpe(i), (t.type === "fork" || t.type === "join") && mpe(i, t), t.type === "note" && bpe(t.note.text, i), t.type === "divider" && upe(i), t.type === "default" && t.descriptions.length === 0 && fpe(i, t), t.type === "default" && t.descriptions.length > 0 && dpe(i, t);
  const s = i.node().getBBox();
  return r.width = s.width + 2 * J().state.padding, r.height = s.height + 2 * J().state.padding, r;
};
let n7 = 0;
const Ope = function(e, t, n) {
  const r = function(l) {
    switch (l) {
      case Vo.relationType.AGGREGATION:
        return "aggregation";
      case Vo.relationType.EXTENSION:
        return "extension";
      case Vo.relationType.COMPOSITION:
        return "composition";
      case Vo.relationType.DEPENDENCY:
        return "dependency";
    }
  };
  t.points = t.points.filter((l) => !Number.isNaN(l.y));
  const i = t.points, s = Qu().x(function(l) {
    return l.x;
  }).y(function(l) {
    return l.y;
  }).curve(lu), o = e.append("path").attr("d", s(i)).attr("id", "edge" + n7).attr("class", "transition");
  let a = "";
  if (J().state.arrowMarkerAbsolute && (a = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, a = a.replace(/\(/g, "\\("), a = a.replace(/\)/g, "\\)")), o.attr(
    "marker-end",
    "url(" + a + "#" + r(Vo.relationType.DEPENDENCY) + "End)"
  ), n.title !== void 0) {
    const l = e.append("g").attr("class", "stateLabel"), { x: h, y: u } = fe.calcLabelPosition(t.points), f = de.getRows(n.title);
    let d = 0;
    const p = [];
    let g = 0, m = 0;
    for (let x = 0; x <= f.length; x++) {
      const _ = l.append("text").attr("text-anchor", "middle").text(f[x]).attr("x", h).attr("y", u + d), w = _.node().getBBox();
      g = Math.max(g, w.width), m = Math.min(m, w.x), B.info(w.x, h, u + d), d === 0 && (d = _.node().getBBox().height, B.info("Title height", d, u)), p.push(_);
    }
    let y = d * f.length;
    if (f.length > 1) {
      const x = (f.length - 1) * d * 0.5;
      p.forEach((_, w) => _.attr("y", u + w * d - x)), y = d * f.length;
    }
    const O = l.node().getBBox();
    l.insert("rect", ":first-child").attr("class", "box").attr("x", h - g / 2 - J().state.padding / 2).attr("y", u - y / 2 - J().state.padding / 2 - 3.5).attr("width", g + J().state.padding).attr("height", y + J().state.padding), B.info(O);
  }
  n7++;
};
let di;
const xx = {}, xpe = function() {
}, vpe = function(e) {
  e.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, _pe = function(e, t, n, r) {
  di = J().state;
  const i = J().securityLevel;
  let s;
  i === "sandbox" && (s = wt("#i" + t));
  const o = wt(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body"), a = i === "sandbox" ? s.nodes()[0].contentDocument : document;
  B.debug("Rendering diagram " + e);
  const l = o.select(`[id='${t}']`);
  vpe(l), new zn({
    multigraph: !0,
    compound: !0,
    rankdir: "RL"
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const u = r.db.getRootDoc();
  rV(u, l, void 0, !1, o, a, r);
  const f = di.padding, d = l.node().getBBox(), p = d.width + f * 2, g = d.height + f * 2, m = p * 1.75;
  $s(l, g, m, di.useMaxWidth), l.attr(
    "viewBox",
    `${d.x - di.padding}  ${d.y - di.padding} ` + p + " " + g
  );
}, kpe = (e) => e ? e.length * di.fontSizeFactor : 1, rV = (e, t, n, r, i, s, o) => {
  const a = new zn({
    compound: !0,
    multigraph: !0
  });
  let l, h = !0;
  for (l = 0; l < e.length; l++)
    if (e[l].stmt === "relation") {
      h = !1;
      break;
    }
  n ? a.setGraph({
    rankdir: "LR",
    multigraph: !0,
    compound: !0,
    ranker: "tight-tree",
    ranksep: h ? 1 : di.edgeLengthFactor,
    nodeSep: h ? 1 : 50,
    isMultiGraph: !0
  }) : a.setGraph({
    rankdir: "TB",
    multigraph: !0,
    compound: !0,
    ranksep: h ? 1 : di.edgeLengthFactor,
    nodeSep: h ? 1 : 50,
    ranker: "tight-tree",
    isMultiGraph: !0
  }), a.setDefaultEdgeLabel(function() {
    return {};
  }), o.db.extract(e);
  const u = o.db.getStates(), f = o.db.getRelations(), d = Object.keys(u);
  for (const O of d) {
    const x = u[O];
    n && (x.parentId = n);
    let _;
    if (x.doc) {
      let w = t.append("g").attr("id", x.id).attr("class", "stateGroup");
      _ = rV(x.doc, w, x.id, !r, i, s, o);
      {
        w = ppe(w, x, r);
        let E = w.node().getBBox();
        _.width = E.width, _.height = E.height + di.padding / 2, xx[x.id] = { y: di.compositTitleSize };
      }
    } else
      _ = e7(t, x);
    if (x.note) {
      const w = {
        descriptions: [],
        id: x.id + "-note",
        note: x.note,
        type: "note"
      }, E = e7(t, w);
      x.note.position === "left of" ? (a.setNode(_.id + "-note", E), a.setNode(_.id, _)) : (a.setNode(_.id, _), a.setNode(_.id + "-note", E)), a.setParent(_.id, _.id + "-group"), a.setParent(_.id + "-note", _.id + "-group");
    } else
      a.setNode(_.id, _);
  }
  B.debug("Count=", a.nodeCount(), a);
  let p = 0;
  f.forEach(function(O) {
    p++, B.debug("Setting edge", O), a.setEdge(
      O.id1,
      O.id2,
      {
        relation: O,
        width: kpe(O.title),
        height: di.labelHeight * de.getRows(O.title).length,
        labelpos: "c"
      },
      "id" + p
    );
  }), Wu(a), B.debug("Graph after layout", a.nodes());
  const g = t.node();
  a.nodes().forEach(function(O) {
    O !== void 0 && a.node(O) !== void 0 ? (B.warn("Node " + O + ": " + JSON.stringify(a.node(O))), i.select("#" + g.id + " #" + O).attr(
      "transform",
      "translate(" + (a.node(O).x - a.node(O).width / 2) + "," + (a.node(O).y + (xx[O] ? xx[O].y : 0) - a.node(O).height / 2) + " )"
    ), i.select("#" + g.id + " #" + O).attr("data-x-shift", a.node(O).x - a.node(O).width / 2), s.querySelectorAll("#" + g.id + " #" + O + " .divider").forEach((_) => {
      const w = _.parentElement;
      let E = 0, T = 0;
      w && (w.parentElement && (E = w.parentElement.getBBox().width), T = parseInt(w.getAttribute("data-x-shift"), 10), Number.isNaN(T) && (T = 0)), _.setAttribute("x1", 0 - T + 8), _.setAttribute("x2", E - T - 8);
    })) : B.debug("No Node " + O + ": " + JSON.stringify(a.node(O)));
  });
  let m = g.getBBox();
  a.edges().forEach(function(O) {
    O !== void 0 && a.edge(O) !== void 0 && (B.debug("Edge " + O.v + " -> " + O.w + ": " + JSON.stringify(a.edge(O))), Ope(t, a.edge(O), a.edge(O).relation));
  }), m = g.getBBox();
  const y = {
    id: n || "root",
    label: n || "root",
    width: 0,
    height: 0
  };
  return y.width = m.width + 2 * di.padding, y.height = m.height + 2 * di.padding, B.debug("Doc rendered", y, a), y;
}, wpe = {
  setConf: xpe,
  draw: _pe
}, xg = "rect", vx = "rectWithTitle", Spe = "start", Cpe = "end", Tpe = "divider", Epe = "roundedWithTitle", Ape = "note", Ppe = "noteGroup", _u = "statediagram", Dpe = "state", Lpe = `${_u}-${Dpe}`, iV = "transition", Mpe = "note", Rpe = "note-edge", $pe = `${iV} ${Rpe}`, Ipe = `${_u}-${Mpe}`, Npe = "cluster", Bpe = `${_u}-${Npe}`, Fpe = "cluster-alt", Qpe = `${_u}-${Fpe}`, sV = "parent", oV = "note", Zpe = "state", sS = "----", Vpe = `${sS}${oV}`, r7 = `${sS}${sV}`, aV = "fill:none", lV = "fill: #333", cV = "c", hV = "text", uV = "normal";
let vg = {}, Ra = 0;
const Ype = function(e) {
  const t = Object.keys(e);
  for (const n of t)
    e[n];
}, zpe = function(e, t) {
  B.trace("Extracting classes"), t.db.clear();
  try {
    return t.parser.parse(e), t.db.extract(t.db.getRootDocV2()), t.db.getClasses();
  } catch (n) {
    return n;
  }
};
function qpe(e) {
  return e == null ? "" : e.classes ? e.classes.join(" ") : "";
}
function _x(e = "", t = 0, n = "", r = sS) {
  const i = n !== null && n.length > 0 ? `${r}${n}` : "";
  return `${Zpe}-${e}${i}-${t}`;
}
const Nf = (e, t, n, r, i, s) => {
  const o = n.id, a = qpe(r[o]);
  if (o !== "root") {
    let l = xg;
    n.start === !0 && (l = Spe), n.start === !1 && (l = Cpe), n.type !== u0 && (l = n.type), vg[o] || (vg[o] = {
      id: o,
      shape: l,
      description: de.sanitizeText(o, J()),
      classes: `${a} ${Lpe}`
    });
    const h = vg[o];
    n.description && (Array.isArray(h.description) ? (h.shape = vx, h.description.push(n.description)) : h.description.length > 0 ? (h.shape = vx, h.description === o ? h.description = [n.description] : h.description = [h.description, n.description]) : (h.shape = xg, h.description = n.description), h.description = de.sanitizeTextOrArray(h.description, J())), h.description.length === 1 && h.shape === vx && (h.shape = xg), !h.type && n.doc && (B.info("Setting cluster for ", o, Bk(n)), h.type = "group", h.dir = Bk(n), h.shape = n.type === UZ ? Tpe : Epe, h.classes = h.classes + " " + Bpe + " " + (s ? Qpe : ""));
    const u = {
      labelStyle: "",
      shape: h.shape,
      labelText: h.description,
      classes: h.classes,
      style: "",
      id: o,
      dir: h.dir,
      domId: _x(o, Ra),
      type: h.type,
      padding: 15
    };
    if (n.note) {
      const f = {
        labelStyle: "",
        shape: Ape,
        labelText: n.note.text,
        classes: Ipe,
        style: "",
        id: o + Vpe + "-" + Ra,
        domId: _x(o, Ra, oV),
        type: h.type,
        padding: 15
      }, d = {
        labelStyle: "",
        shape: Ppe,
        labelText: n.note.text,
        classes: h.classes,
        style: "",
        id: o + r7,
        domId: _x(o, Ra, sV),
        type: "group",
        padding: 0
      };
      Ra++;
      const p = o + r7;
      e.setNode(p, d), e.setNode(f.id, f), e.setNode(o, u), e.setParent(o, p), e.setParent(f.id, p);
      let g = o, m = f.id;
      n.note.position === "left of" && (g = f.id, m = o), e.setEdge(g, m, {
        arrowhead: "none",
        arrowType: "",
        style: aV,
        labelStyle: "",
        classes: $pe,
        arrowheadStyle: lV,
        labelpos: cV,
        labelType: hV,
        thickness: uV
      });
    } else
      e.setNode(o, u);
  }
  t && t.id !== "root" && (B.trace("Setting node ", o, " to be child of its parent ", t.id), e.setParent(o, t.id)), n.doc && (B.trace("Adding nodes children "), Wpe(e, n, n.doc, r, i, !s));
}, Wpe = (e, t, n, r, i, s) => {
  B.trace("items", n), n.forEach((o) => {
    switch (o.stmt) {
      case y2:
        Nf(e, t, o, r, i, s);
        break;
      case u0:
        Nf(e, t, o, r, i, s);
        break;
      case nS:
        {
          Nf(e, t, o.state1, r, i, s), Nf(e, t, o.state2, r, i, s);
          const a = {
            id: "edge" + Ra,
            arrowhead: "normal",
            arrowTypeEnd: "arrow_barb",
            style: aV,
            labelStyle: "",
            label: de.sanitizeText(o.description, J()),
            arrowheadStyle: lV,
            labelpos: cV,
            labelType: hV,
            thickness: uV,
            classes: iV
          };
          e.setEdge(o.state1.id, o.state2.id, a, Ra), Ra++;
        }
        break;
    }
  });
}, Bk = (e, t = Bde) => {
  let n = t;
  if (e.doc)
    for (let r = 0; r < e.doc.length; r++) {
      const i = e.doc[r];
      i.stmt === "dir" && (n = i.value);
    }
  return n;
}, Upe = function(e, t, n, r) {
  B.info("Drawing state diagram (v2)", t), vg = {}, r.db.getDirection();
  const { securityLevel: i, state: s } = J(), o = s.nodeSpacing || 50, a = s.rankSpacing || 50;
  B.info(r.db.getRootDocV2()), r.db.extract(r.db.getRootDocV2()), B.info(r.db.getRootDocV2());
  const l = r.db.getStates(), h = new zn({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: Bk(r.db.getRootDocV2()),
    nodesep: o,
    ranksep: a,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  Nf(h, void 0, r.db.getRootDocV2(), l, r.db, !0);
  let u;
  i === "sandbox" && (u = wt("#i" + t));
  const f = wt(i === "sandbox" ? u.nodes()[0].contentDocument.body : "body"), d = f.select(`[id="${t}"]`), p = f.select("#" + t + " g");
  Q5(p, h, ["barb"], _u, t);
  const g = 8;
  fe.insertTitle(d, "statediagramTitleText", s.titleTopMargin, r.db.getDiagramTitle());
  const m = d.node().getBBox(), y = m.width + g * 2, O = m.height + g * 2;
  d.attr("class", _u);
  const x = d.node().getBBox();
  $s(d, O, y, s.useMaxWidth);
  const _ = `${x.x - g} ${x.y - g} ${y} ${O}`;
  B.debug(`viewBox ${_}`), d.attr("viewBox", _);
  const w = document.querySelectorAll('[id="' + t + '"] .edgeLabel .label');
  for (const E of w) {
    const T = E.getBBox(), S = document.createElementNS("http://www.w3.org/2000/svg", xg);
    S.setAttribute("rx", 0), S.setAttribute("ry", 0), S.setAttribute("width", T.width), S.setAttribute("height", T.height), E.insertBefore(S, E.firstChild);
  }
}, jpe = {
  setConf: Ype,
  getClasses: zpe,
  draw: Upe
};
var Fk = function() {
  var e = function(m, y, O, x) {
    for (O = O || {}, x = m.length; x--; O[m[x]] = y)
      ;
    return O;
  }, t = [1, 2], n = [1, 5], r = [6, 9, 11, 17, 18, 20, 22, 23, 24, 26], i = [1, 15], s = [1, 16], o = [1, 17], a = [1, 18], l = [1, 19], h = [1, 20], u = [1, 24], f = [4, 6, 9, 11, 17, 18, 20, 22, 23, 24, 26], d = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, journey: 4, document: 5, EOF: 6, directive: 7, line: 8, SPACE: 9, statement: 10, NEWLINE: 11, openDirective: 12, typeDirective: 13, closeDirective: 14, ":": 15, argDirective: 16, title: 17, acc_title: 18, acc_title_value: 19, acc_descr: 20, acc_descr_value: 21, acc_descr_multiline_value: 22, section: 23, taskName: 24, taskData: 25, open_directive: 26, type_directive: 27, arg_directive: 28, close_directive: 29, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "journey", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 17: "title", 18: "acc_title", 19: "acc_title_value", 20: "acc_descr", 21: "acc_descr_value", 22: "acc_descr_multiline_value", 23: "section", 24: "taskName", 25: "taskData", 26: "open_directive", 27: "type_directive", 28: "arg_directive", 29: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function(y, O, x, _, w, E, T) {
      var S = E.length - 1;
      switch (w) {
        case 1:
          return E[S - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          E[S - 1].push(E[S]), this.$ = E[S - 1];
          break;
        case 5:
        case 6:
          this.$ = E[S];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 11:
          _.setDiagramTitle(E[S].substr(6)), this.$ = E[S].substr(6);
          break;
        case 12:
          this.$ = E[S].trim(), _.setAccTitle(this.$);
          break;
        case 13:
        case 14:
          this.$ = E[S].trim(), _.setAccDescription(this.$);
          break;
        case 15:
          _.addSection(E[S].substr(8)), this.$ = E[S].substr(8);
          break;
        case 16:
          _.addTask(E[S - 1], E[S]), this.$ = "task";
          break;
        case 18:
          _.parseDirective("%%{", "open_directive");
          break;
        case 19:
          _.parseDirective(E[S], "type_directive");
          break;
        case 20:
          E[S] = E[S].trim().replace(/'/g, '"'), _.parseDirective(E[S], "arg_directive");
          break;
        case 21:
          _.parseDirective("}%%", "close_directive", "journey");
          break;
      }
    },
    table: [{ 3: 1, 4: t, 7: 3, 12: 4, 26: n }, { 1: [3] }, e(r, [2, 3], { 5: 6 }), { 3: 7, 4: t, 7: 3, 12: 4, 26: n }, { 13: 8, 27: [1, 9] }, { 27: [2, 18] }, { 6: [1, 10], 7: 21, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: i, 18: s, 20: o, 22: a, 23: l, 24: h, 26: n }, { 1: [2, 2] }, { 14: 22, 15: [1, 23], 29: u }, e([15, 29], [2, 19]), e(r, [2, 8], { 1: [2, 1] }), e(r, [2, 4]), { 7: 21, 10: 25, 12: 4, 17: i, 18: s, 20: o, 22: a, 23: l, 24: h, 26: n }, e(r, [2, 6]), e(r, [2, 7]), e(r, [2, 11]), { 19: [1, 26] }, { 21: [1, 27] }, e(r, [2, 14]), e(r, [2, 15]), { 25: [1, 28] }, e(r, [2, 17]), { 11: [1, 29] }, { 16: 30, 28: [1, 31] }, { 11: [2, 21] }, e(r, [2, 5]), e(r, [2, 12]), e(r, [2, 13]), e(r, [2, 16]), e(f, [2, 9]), { 14: 32, 29: u }, { 29: [2, 20] }, { 11: [1, 33] }, e(f, [2, 10])],
    defaultActions: { 5: [2, 18], 7: [2, 2], 24: [2, 21], 31: [2, 20] },
    parseError: function(y, O) {
      if (O.recoverable)
        this.trace(y);
      else {
        var x = new Error(y);
        throw x.hash = O, x;
      }
    },
    parse: function(y) {
      var O = this, x = [0], _ = [], w = [null], E = [], T = this.table, S = "", R = 0, A = 0, P = 2, C = 1, k = E.slice.call(arguments, 1), D = Object.create(this.lexer), b = { yy: {} };
      for (var M in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, M) && (b.yy[M] = this.yy[M]);
      D.setInput(y, b.yy), b.yy.lexer = D, b.yy.parser = this, typeof D.yylloc > "u" && (D.yylloc = {});
      var v = D.yylloc;
      E.push(v);
      var N = D.options && D.options.ranges;
      typeof b.yy.parseError == "function" ? this.parseError = b.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function tt() {
        var et;
        return et = _.pop() || D.lex() || C, typeof et != "number" && (et instanceof Array && (_ = et, et = _.pop()), et = O.symbols_[et] || et), et;
      }
      for (var Z, z, X, q, nt = {}, st, ct, Y, Ct; ; ) {
        if (z = x[x.length - 1], this.defaultActions[z] ? X = this.defaultActions[z] : ((Z === null || typeof Z > "u") && (Z = tt()), X = T[z] && T[z][Z]), typeof X > "u" || !X.length || !X[0]) {
          var H = "";
          Ct = [];
          for (st in T[z])
            this.terminals_[st] && st > P && Ct.push("'" + this.terminals_[st] + "'");
          D.showPosition ? H = "Parse error on line " + (R + 1) + `:
` + D.showPosition() + `
Expecting ` + Ct.join(", ") + ", got '" + (this.terminals_[Z] || Z) + "'" : H = "Parse error on line " + (R + 1) + ": Unexpected " + (Z == C ? "end of input" : "'" + (this.terminals_[Z] || Z) + "'"), this.parseError(H, {
            text: D.match,
            token: this.terminals_[Z] || Z,
            line: D.yylineno,
            loc: v,
            expected: Ct
          });
        }
        if (X[0] instanceof Array && X.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + Z);
        switch (X[0]) {
          case 1:
            x.push(Z), w.push(D.yytext), E.push(D.yylloc), x.push(X[1]), Z = null, A = D.yyleng, S = D.yytext, R = D.yylineno, v = D.yylloc;
            break;
          case 2:
            if (ct = this.productions_[X[1]][1], nt.$ = w[w.length - ct], nt._$ = {
              first_line: E[E.length - (ct || 1)].first_line,
              last_line: E[E.length - 1].last_line,
              first_column: E[E.length - (ct || 1)].first_column,
              last_column: E[E.length - 1].last_column
            }, N && (nt._$.range = [
              E[E.length - (ct || 1)].range[0],
              E[E.length - 1].range[1]
            ]), q = this.performAction.apply(nt, [
              S,
              A,
              R,
              b.yy,
              X[1],
              w,
              E
            ].concat(k)), typeof q < "u")
              return q;
            ct && (x = x.slice(0, -1 * ct * 2), w = w.slice(0, -1 * ct), E = E.slice(0, -1 * ct)), x.push(this.productions_[X[1]][0]), w.push(nt.$), E.push(nt._$), Y = T[x[x.length - 2]][x[x.length - 1]], x.push(Y);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, p = function() {
    var m = {
      EOF: 1,
      parseError: function(O, x) {
        if (this.yy.parser)
          this.yy.parser.parseError(O, x);
        else
          throw new Error(O);
      },
      setInput: function(y, O) {
        return this.yy = O || this.yy || {}, this._input = y, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      input: function() {
        var y = this._input[0];
        this.yytext += y, this.yyleng++, this.offset++, this.match += y, this.matched += y;
        var O = y.match(/(?:\r\n?|\n).*/g);
        return O ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), y;
      },
      unput: function(y) {
        var O = y.length, x = y.split(/(?:\r\n?|\n)/g);
        this._input = y + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - O), this.offset -= O;
        var _ = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), x.length - 1 && (this.yylineno -= x.length - 1);
        var w = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: x ? (x.length === _.length ? this.yylloc.first_column : 0) + _[_.length - x.length].length - x[0].length : this.yylloc.first_column - O
        }, this.options.ranges && (this.yylloc.range = [w[0], w[0] + this.yyleng - O]), this.yyleng = this.yytext.length, this;
      },
      more: function() {
        return this._more = !0, this;
      },
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      less: function(y) {
        this.unput(this.match.slice(y));
      },
      pastInput: function() {
        var y = this.matched.substr(0, this.matched.length - this.match.length);
        return (y.length > 20 ? "..." : "") + y.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var y = this.match;
        return y.length < 20 && (y += this._input.substr(0, 20 - y.length)), (y.substr(0, 20) + (y.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var y = this.pastInput(), O = new Array(y.length + 1).join("-");
        return y + this.upcomingInput() + `
` + O + "^";
      },
      test_match: function(y, O) {
        var x, _, w;
        if (this.options.backtrack_lexer && (w = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (w.yylloc.range = this.yylloc.range.slice(0))), _ = y[0].match(/(?:\r\n?|\n).*/g), _ && (this.yylineno += _.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: _ ? _[_.length - 1].length - _[_.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + y[0].length
        }, this.yytext += y[0], this.match += y[0], this.matches = y, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(y[0].length), this.matched += y[0], x = this.performAction.call(this, this.yy, this, O, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), x)
          return x;
        if (this._backtrack) {
          for (var E in w)
            this[E] = w[E];
          return !1;
        }
        return !1;
      },
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var y, O, x, _;
        this._more || (this.yytext = "", this.match = "");
        for (var w = this._currentRules(), E = 0; E < w.length; E++)
          if (x = this._input.match(this.rules[w[E]]), x && (!O || x[0].length > O[0].length)) {
            if (O = x, _ = E, this.options.backtrack_lexer) {
              if (y = this.test_match(x, w[E]), y !== !1)
                return y;
              if (this._backtrack) {
                O = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return O ? (y = this.test_match(O, w[_]), y !== !1 ? y : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      lex: function() {
        var O = this.next();
        return O || this.lex();
      },
      begin: function(O) {
        this.conditionStack.push(O);
      },
      popState: function() {
        var O = this.conditionStack.length - 1;
        return O > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      topState: function(O) {
        return O = this.conditionStack.length - 1 - Math.abs(O || 0), O >= 0 ? this.conditionStack[O] : "INITIAL";
      },
      pushState: function(O) {
        this.begin(O);
      },
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(O, x, _, w) {
        switch (_) {
          case 0:
            return this.begin("open_directive"), 26;
          case 1:
            return this.begin("type_directive"), 27;
          case 2:
            return this.popState(), this.begin("arg_directive"), 15;
          case 3:
            return this.popState(), this.popState(), 29;
          case 4:
            return 28;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 11;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return 4;
          case 11:
            return 17;
          case 12:
            return this.begin("acc_title"), 18;
          case 13:
            return this.popState(), "acc_title_value";
          case 14:
            return this.begin("acc_descr"), 20;
          case 15:
            return this.popState(), "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            return 23;
          case 20:
            return 24;
          case 21:
            return 25;
          case 22:
            return 15;
          case 23:
            return 6;
          case 24:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { open_directive: { rules: [1], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, acc_descr_multiline: { rules: [17, 18], inclusive: !1 }, acc_descr: { rules: [15], inclusive: !1 }, acc_title: { rules: [13], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 19, 20, 21, 22, 23, 24], inclusive: !0 } }
    };
    return m;
  }();
  d.lexer = p;
  function g() {
    this.yy = {};
  }
  return g.prototype = d, d.Parser = g, new g();
}();
Fk.parser = Fk;
const Xpe = Fk, Gpe = (e) => e.match(/^\s*journey/) !== null;
let ku = "";
const oS = [], Ap = [], Pp = [], Hpe = function(e, t, n) {
  un.parseDirective(this, e, t, n);
}, Kpe = function() {
  oS.length = 0, Ap.length = 0, ku = "", Pp.length = 0, _i();
}, Jpe = function(e) {
  ku = e, oS.push(e);
}, t0e = function() {
  return oS;
}, e0e = function() {
  let e = i7();
  const t = 100;
  let n = 0;
  for (; !e && n < t; )
    e = i7(), n++;
  return Ap.push(...Pp), Ap;
}, n0e = function() {
  const e = [];
  return Ap.forEach((n) => {
    n.people && e.push(...n.people);
  }), [...new Set(e)].sort();
}, r0e = function(e, t) {
  const n = t.substr(1).split(":");
  let r = 0, i = [];
  n.length === 1 ? (r = Number(n[0]), i = []) : (r = Number(n[0]), i = n[1].split(","));
  const s = i.map((a) => a.trim()), o = {
    section: ku,
    type: ku,
    people: s,
    task: e,
    score: r
  };
  Pp.push(o);
}, i0e = function(e) {
  const t = {
    section: ku,
    type: ku,
    description: e,
    task: e,
    classes: []
  };
  Ap.push(t);
}, i7 = function() {
  const e = function(n) {
    return Pp[n].processed;
  };
  let t = !0;
  for (const [n, r] of Pp.entries())
    e(n), t = t && r.processed;
  return t;
}, s0e = function() {
  return n0e();
}, s7 = {
  parseDirective: Hpe,
  getConfig: () => J().journey,
  clear: Kpe,
  setDiagramTitle: Is,
  getDiagramTitle: Ns,
  setAccTitle: oi,
  getAccTitle: ki,
  setAccDescription: wi,
  getAccDescription: Si,
  addSection: Jpe,
  getSections: t0e,
  getTasks: e0e,
  addTask: r0e,
  addTaskOrg: i0e,
  getActors: s0e
}, sb = function(e, t) {
  const n = e.append("rect");
  return n.attr("x", t.x), n.attr("y", t.y), n.attr("fill", t.fill), n.attr("stroke", t.stroke), n.attr("width", t.width), n.attr("height", t.height), n.attr("rx", t.rx), n.attr("ry", t.ry), t.class !== void 0 && n.attr("class", t.class), n;
}, o0e = function(e, t) {
  const r = e.append("circle").attr("cx", t.cx).attr("cy", t.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = e.append("g");
  i.append("circle").attr("cx", t.cx - 15 / 3).attr("cy", t.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", t.cx + 15 / 3).attr("cy", t.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function s(l) {
    const h = F_().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", h).attr("transform", "translate(" + t.cx + "," + (t.cy + 2) + ")");
  }
  function o(l) {
    const h = F_().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", h).attr("transform", "translate(" + t.cx + "," + (t.cy + 7) + ")");
  }
  function a(l) {
    l.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", t.cx - 5).attr("y1", t.cy + 7).attr("x2", t.cx + 5).attr("y2", t.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return t.score > 3 ? s(i) : t.score < 3 ? o(i) : a(i), r;
}, fV = function(e, t) {
  const n = e.append("circle");
  return n.attr("cx", t.cx), n.attr("cy", t.cy), n.attr("class", "actor-" + t.pos), n.attr("fill", t.fill), n.attr("stroke", t.stroke), n.attr("r", t.r), n.class !== void 0 && n.attr("class", n.class), t.title !== void 0 && n.append("title").text(t.title), n;
}, dV = function(e, t) {
  const n = t.text.replace(/<br\s*\/?>/gi, " "), r = e.append("text");
  r.attr("x", t.x), r.attr("y", t.y), r.attr("class", "legend"), r.style("text-anchor", t.anchor), t.class !== void 0 && r.attr("class", t.class);
  const i = r.append("tspan");
  return i.attr("x", t.x + t.textMargin * 2), i.text(n), r;
}, a0e = function(e, t) {
  function n(i, s, o, a, l) {
    return i + "," + s + " " + (i + o) + "," + s + " " + (i + o) + "," + (s + a - l) + " " + (i + o - l * 1.2) + "," + (s + a) + " " + i + "," + (s + a);
  }
  const r = e.append("polygon");
  r.attr("points", n(t.x, t.y, 50, 20, 7)), r.attr("class", "labelBox"), t.y = t.y + t.labelMargin, t.x = t.x + 0.5 * t.labelMargin, dV(e, t);
}, l0e = function(e, t, n) {
  const r = e.append("g"), i = aS();
  i.x = t.x, i.y = t.y, i.fill = t.fill, i.width = n.width, i.height = n.height, i.class = "journey-section section-type-" + t.num, i.rx = 3, i.ry = 3, sb(r, i), pV(n)(
    t.text,
    r,
    i.x,
    i.y,
    i.width,
    i.height,
    { class: "journey-section section-type-" + t.num },
    n,
    t.colour
  );
};
let o7 = -1;
const c0e = function(e, t, n) {
  const r = t.x + n.width / 2, i = e.append("g");
  o7++;
  const s = 300 + 5 * 30;
  i.append("line").attr("id", "task" + o7).attr("x1", r).attr("y1", t.y).attr("x2", r).attr("y2", s).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), o0e(i, {
    cx: r,
    cy: 300 + (5 - t.score) * 30,
    score: t.score
  });
  const o = aS();
  o.x = t.x, o.y = t.y, o.fill = t.fill, o.width = n.width, o.height = n.height, o.class = "task task-type-" + t.num, o.rx = 3, o.ry = 3, sb(i, o);
  let a = t.x + 14;
  t.people.forEach((l) => {
    const h = t.actors[l].color, u = {
      cx: a,
      cy: t.y,
      r: 7,
      fill: h,
      stroke: "#000",
      title: l,
      pos: t.actors[l].position
    };
    fV(i, u), a += 10;
  }), pV(n)(
    t.task,
    i,
    o.x,
    o.y,
    o.width,
    o.height,
    { class: "task" },
    n,
    t.colour
  );
}, h0e = function(e, t) {
  sb(e, {
    x: t.startx,
    y: t.starty,
    width: t.stopx - t.startx,
    height: t.stopy - t.starty,
    fill: t.fill,
    class: "rect"
  }).lower();
}, u0e = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    "text-anchor": "start",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
}, aS = function() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, pV = function() {
  function e(i, s, o, a, l, h, u, f) {
    const d = s.append("text").attr("x", o + l / 2).attr("y", a + h / 2 + 5).style("font-color", f).style("text-anchor", "middle").text(i);
    r(d, u);
  }
  function t(i, s, o, a, l, h, u, f, d) {
    const { taskFontSize: p, taskFontFamily: g } = f, m = i.split(/<br\s*\/?>/gi);
    for (let y = 0; y < m.length; y++) {
      const O = y * p - p * (m.length - 1) / 2, x = s.append("text").attr("x", o + l / 2).attr("y", a).attr("fill", d).style("text-anchor", "middle").style("font-size", p).style("font-family", g);
      x.append("tspan").attr("x", o + l / 2).attr("dy", O).text(m[y]), x.attr("y", a + h / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), r(x, u);
    }
  }
  function n(i, s, o, a, l, h, u, f) {
    const d = s.append("switch"), g = d.append("foreignObject").attr("x", o).attr("y", a).attr("width", l).attr("height", h).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), t(i, d, o, a, l, h, u, f), r(g, u);
  }
  function r(i, s) {
    for (const o in s)
      o in s && i.attr(o, s[o]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? n : i.textPlacement === "old" ? e : t;
  };
}(), f0e = function(e) {
  e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, Dp = {
  drawRect: sb,
  drawCircle: fV,
  drawSection: l0e,
  drawText: dV,
  drawLabel: a0e,
  drawTask: c0e,
  drawBackgroundRect: h0e,
  getTextObj: u0e,
  getNoteRect: aS,
  initGraphics: f0e
}, d0e = function(e) {
  Object.keys(e).forEach(function(n) {
    ob[n] = e[n];
  });
}, Go = {};
function p0e(e) {
  const t = J().journey;
  let n = 60;
  Object.keys(Go).forEach((r) => {
    const i = Go[r].color, s = {
      cx: 20,
      cy: n,
      r: 7,
      fill: i,
      stroke: "#000",
      pos: Go[r].position
    };
    Dp.drawCircle(e, s);
    const o = {
      x: 40,
      y: n + 7,
      fill: "#666",
      text: r,
      textMargin: t.boxTextMargin | 5
    };
    Dp.drawText(e, o), n += 20;
  });
}
const ob = J().journey, Il = ob.leftMargin, g0e = function(e, t, n, r) {
  const i = J().journey;
  r.db.clear(), r.parser.parse(e + `
`);
  const s = J().securityLevel;
  let o;
  s === "sandbox" && (o = wt("#i" + t));
  const a = wt(s === "sandbox" ? o.nodes()[0].contentDocument.body : "body");
  Li.init();
  const l = a.select("#" + t);
  Dp.initGraphics(l);
  const h = r.db.getTasks(), u = r.db.getDiagramTitle(), f = r.db.getActors();
  for (const O in Go)
    delete Go[O];
  let d = 0;
  f.forEach((O) => {
    Go[O] = {
      color: i.actorColours[d % i.actorColours.length],
      position: d
    }, d++;
  }), p0e(l), Li.insert(0, 0, Il, Object.keys(Go).length * 50), m0e(l, h, 0);
  const p = Li.getBounds();
  u && l.append("text").text(u).attr("x", Il).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 25);
  const g = p.stopy - p.starty + 2 * i.diagramMarginY, m = Il + p.stopx + 2 * i.diagramMarginX;
  $s(l, g, m, i.useMaxWidth), l.append("line").attr("x1", Il).attr("y1", i.height * 4).attr("x2", m - Il - 4).attr("y2", i.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
  const y = u ? 70 : 0;
  l.attr("viewBox", `${p.startx} -25 ${m} ${g + y}`), l.attr("preserveAspectRatio", "xMinYMin meet"), l.attr("height", g + y + 25);
}, Li = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  init: function() {
    this.sequenceItems = [], this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0;
  },
  updateVal: function(e, t, n, r) {
    e[t] === void 0 ? e[t] = n : e[t] = r(n, e[t]);
  },
  updateBounds: function(e, t, n, r) {
    const i = J().journey, s = this;
    let o = 0;
    function a(l) {
      return function(u) {
        o++;
        const f = s.sequenceItems.length - o + 1;
        s.updateVal(u, "starty", t - f * i.boxMargin, Math.min), s.updateVal(u, "stopy", r + f * i.boxMargin, Math.max), s.updateVal(Li.data, "startx", e - f * i.boxMargin, Math.min), s.updateVal(Li.data, "stopx", n + f * i.boxMargin, Math.max), l !== "activation" && (s.updateVal(u, "startx", e - f * i.boxMargin, Math.min), s.updateVal(u, "stopx", n + f * i.boxMargin, Math.max), s.updateVal(Li.data, "starty", t - f * i.boxMargin, Math.min), s.updateVal(Li.data, "stopy", r + f * i.boxMargin, Math.max));
      };
    }
    this.sequenceItems.forEach(a());
  },
  insert: function(e, t, n, r) {
    const i = Math.min(e, n), s = Math.max(e, n), o = Math.min(t, r), a = Math.max(t, r);
    this.updateVal(Li.data, "startx", i, Math.min), this.updateVal(Li.data, "starty", o, Math.min), this.updateVal(Li.data, "stopx", s, Math.max), this.updateVal(Li.data, "stopy", a, Math.max), this.updateBounds(i, o, s, a);
  },
  bumpVerticalPos: function(e) {
    this.verticalPos = this.verticalPos + e, this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return this.data;
  }
}, kx = ob.sectionFills, a7 = ob.sectionColours, m0e = function(e, t, n) {
  const r = J().journey;
  let i = "";
  const s = r.height * 2 + r.diagramMarginY, o = n + s;
  let a = 0, l = "#CCC", h = "black", u = 0;
  for (const [f, d] of t.entries()) {
    if (i !== d.section) {
      l = kx[a % kx.length], u = a % kx.length, h = a7[a % a7.length];
      const g = {
        x: f * r.taskMargin + f * r.width + Il,
        y: 50,
        text: d.section,
        fill: l,
        num: u,
        colour: h
      };
      Dp.drawSection(e, g, r), i = d.section, a++;
    }
    const p = d.people.reduce((g, m) => (Go[m] && (g[m] = Go[m]), g), {});
    d.x = f * r.taskMargin + f * r.width + Il, d.y = o, d.width = r.diagramMarginX, d.height = r.diagramMarginY, d.colour = h, d.fill = l, d.num = u, d.actors = p, Dp.drawTask(e, d, r), Li.insert(d.x, d.y, d.x + d.width + r.taskMargin, 300 + 5 * 30);
  }
}, l7 = {
  setConf: d0e,
  draw: g0e
};
let c7 = {};
const y0e = function(e) {
  c7 = { ...c7, ...e };
}, b0e = (e, t, n) => {
  try {
    B.debug(`Renering svg for syntax error
`);
    const r = wt("#" + t), i = r.append("g");
    i.append("path").attr("class", "error-icon").attr(
      "d",
      "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
    ), i.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in graph"), i.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text("mermaid version " + n), r.attr("height", 100), r.attr("width", 500), r.attr("viewBox", "768 0 912 512");
  } catch (r) {
    B.error("Error while rendering info diagram"), B.error(voe(r));
  }
}, x2 = {
  setConf: y0e,
  draw: b0e
}, gV = "flowchart-elk", O0e = (e, t) => {
  var n;
  return !!(e.match(/^\s*flowchart-elk/) || e.match(/^\s*flowchart|graph/) && ((n = t == null ? void 0 : t.flowchart) == null ? void 0 : n.defaultRenderer) === "elk");
}, x0e = async () => {
  const { diagram: e } = await import("./flowchart-elk-definition-170a3958.79c5609c.js");
  return { id: gV, diagram: e };
}, v0e = {
  id: gV,
  detector: O0e,
  loader: x0e
}, _0e = v0e, mV = "timeline", k0e = (e) => e.match(/^\s*timeline/) !== null, w0e = async () => {
  const { diagram: e } = await import("./timeline-definition-8e5a9bc6.5de8f2e5.js");
  return { id: mV, diagram: e };
}, S0e = {
  id: mV,
  detector: k0e,
  loader: w0e
}, C0e = S0e, yV = "mindmap", T0e = (e) => e.match(/^\s*mindmap/) !== null, E0e = async () => {
  const { diagram: e } = await import("./mindmap-definition-44684416.00cf689c.js");
  return { id: yV, diagram: e };
}, A0e = {
  id: yV,
  detector: T0e,
  loader: E0e
}, P0e = A0e;
let h7 = !1;
const f0 = () => {
  h7 || (h7 = !0, _F(_0e, C0e, P0e), Wn(
    "error",
    {
      db: {
        clear: () => {
        }
      },
      styles: ck,
      renderer: x2,
      parser: {
        parser: { yy: {} },
        parse: () => {
        }
      },
      init: () => {
      }
    },
    (e) => e.toLowerCase().trim() === "error"
  ), Wn(
    "---",
    {
      db: {
        clear: () => {
        }
      },
      styles: ck,
      renderer: x2,
      parser: {
        parser: { yy: {} },
        parse: () => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with unindented `---` blocks"
          );
        }
      },
      init: () => null
    },
    (e) => e.toLowerCase().trimStart().startsWith("---")
  ), Wn(
    "c4",
    {
      parser: Aae,
      db: KF,
      renderer: P8,
      styles: ZF,
      init: (e) => {
        P8.setConf(e.c4);
      }
    },
    Pae
  ), Wn(
    "class",
    {
      parser: D8,
      db: ch,
      renderer: Jle,
      styles: id,
      init: (e) => {
        e.class || (e.class = {}), e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute, ch.clear();
      }
    },
    _le
  ), Wn(
    "classDiagram",
    {
      parser: D8,
      db: ch,
      renderer: fhe,
      styles: id,
      init: (e) => {
        e.class || (e.class = {}), e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute, ch.clear();
      }
    },
    kle
  ), Wn(
    "er",
    {
      parser: dhe,
      db: khe,
      renderer: $he,
      styles: RF
    },
    phe
  ), Wn(
    "gantt",
    {
      parser: eue,
      db: H5,
      renderer: Iue,
      styles: $F
    },
    nue
  ), Wn(
    "info",
    {
      parser: Nue,
      db: Vue,
      renderer: zue,
      styles: IF
    },
    que
  ), Wn(
    "pie",
    {
      parser: Wue,
      db: efe,
      renderer: rfe,
      styles: NF
    },
    Uue
  ), Wn(
    "requirement",
    {
      parser: ife,
      db: wfe,
      renderer: Mfe,
      styles: BF
    },
    sfe
  ), Wn(
    "sequence",
    {
      parser: Rfe,
      db: j8,
      renderer: G8,
      styles: FF,
      init: (e) => {
        if (e.sequence || (e.sequence = {}), e.sequence.arrowMarkerAbsolute = e.arrowMarkerAbsolute, "sequenceDiagram" in e)
          throw new Error(
            "`mermaid config.sequenceDiagram` has been renamed to `config.sequence`. Please update your mermaid config."
          );
        j8.setWrap(e.wrap), G8.setConf(e.sequence);
      }
    },
    $fe
  ), Wn(
    "state",
    {
      parser: H8,
      db: Vo,
      renderer: wpe,
      styles: Jm,
      init: (e) => {
        e.state || (e.state = {}), e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute, Vo.clear();
      }
    },
    $de
  ), Wn(
    "stateDiagram",
    {
      parser: H8,
      db: Vo,
      renderer: jpe,
      styles: Jm,
      init: (e) => {
        e.state || (e.state = {}), e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute, Vo.clear();
      }
    },
    Ide
  ), Wn(
    "journey",
    {
      parser: Xpe,
      db: s7,
      renderer: l7,
      styles: QF,
      init: (e) => {
        l7.setConf(e.journey), s7.clear();
      }
    },
    Gpe
  ), Wn(
    "flowchart",
    {
      parser: z8,
      db: js,
      renderer: Ox,
      styles: Km,
      init: (e) => {
        e.flowchart || (e.flowchart = {}), e.flowchart.arrowMarkerAbsolute = e.arrowMarkerAbsolute, Hhe.setConf(e.flowchart), js.clear(), js.setGen("gen-1");
      }
    },
    Ihe
  ), Wn(
    "flowchart-v2",
    {
      parser: z8,
      db: js,
      renderer: Ox,
      styles: Km,
      init: (e) => {
        e.flowchart || (e.flowchart = {}), e.flowchart.arrowMarkerAbsolute = e.arrowMarkerAbsolute, PF({ flowchart: { arrowMarkerAbsolute: e.arrowMarkerAbsolute } }), Ox.setConf(e.flowchart), js.clear(), js.setGen("gen-2");
      }
    },
    Nhe
  ), Wn(
    "gitGraph",
    { parser: Koe, db: bae, renderer: Cae, styles: Eae },
    Joe
  ));
};
class Qk {
  constructor(t, n) {
    var r, i;
    this.txt = t, this.type = "graph", this.detectTypeFailed = !1;
    const s = J();
    this.txt = t;
    try {
      this.type = S5(t, s);
    } catch (l) {
      this.handleError(l, n), this.type = "error", this.detectTypeFailed = !0;
    }
    const o = zF(this.type);
    B.debug("Type " + this.type), this.db = o.db, (i = (r = this.db).clear) == null || i.call(r), this.renderer = o.renderer, this.parser = o.parser;
    const a = this.parser.parse.bind(this.parser);
    this.parser.parse = (l) => a(eoe(l, this.db)), this.parser.parser.yy = this.db, o.init && (o.init(s), B.info("Initialized diagram " + this.type, s)), this.txt += `
`, this.parse(this.txt, n);
  }
  parse(t, n) {
    var r, i;
    if (this.detectTypeFailed)
      return !1;
    try {
      return t = t + `
`, (i = (r = this.db).clear) == null || i.call(r), this.parser.parse(t), !0;
    } catch (s) {
      this.handleError(s, n);
    }
    return !1;
  }
  handleError(t, n) {
    if (n === void 0)
      throw t;
    if (T5(t)) {
      n(t.str, t.hash);
      return;
    }
    n(t);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}
const lS = (e, t) => {
  const n = S5(e, J());
  try {
    zF(n);
  } catch {
    const i = ioe(n);
    if (!i)
      throw new Error(`Diagram ${n} not found.`);
    return i().then(({ diagram: s }) => (Wn(n, s, void 0), new Qk(e, t)));
  }
  return new Qk(e, t);
}, cS = Qk, D0e = "graphics-document document";
function L0e(e, t) {
  e.attr("role", D0e), Th(t) || e.attr("aria-roledescription", t);
}
function M0e(e, t, n, r) {
  if (e.insert !== void 0)
    if (t || n) {
      if (n) {
        const i = "chart-desc-" + r;
        e.attr("aria-describedby", i), e.insert("desc", ":first-child").attr("id", i).text(n);
      }
      if (t) {
        const i = "chart-title-" + r;
        e.attr("aria-labelledby", i), e.insert("title", ":first-child").attr("id", i).text(t);
      }
    } else
      return;
}
const hS = ["graph", "flowchart", "flowchart-v2", "stateDiagram", "stateDiagram-v2"], bV = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa", OV = "sandbox", xV = "loose", R0e = "http://www.w3.org/2000/svg", vV = "http://www.w3.org/1999/xlink", _V = "http://www.w3.org/1999/xhtml", $0e = "100%", I0e = "100%", N0e = "border:0;margin:0;", B0e = "margin:0", F0e = "allow-top-navigation-by-user-activation allow-popups", Q0e = 'The "iframe" tag is not supported by your browser.', kV = ["foreignobject"], wV = ["dominant-baseline"];
function Z0e(e, t) {
  return f0(), new cS(e, t).parse(e, t);
}
async function V0e(e, t) {
  return f0(), (await lS(e, t)).parse(e, t);
}
const SV = function(e) {
  let t = e;
  return t = t.replace(/style.*:\S*#.*;/g, function(n) {
    return n.substring(0, n.length - 1);
  }), t = t.replace(/classDef.*:\S*#.*;/g, function(n) {
    return n.substring(0, n.length - 1);
  }), t = t.replace(/#\w+;/g, function(n) {
    const r = n.substring(1, n.length - 1);
    return /^\+?\d+$/.test(r) ? "\uFB02\xB0\xB0" + r + "\xB6\xDF" : "\uFB02\xB0" + r + "\xB6\xDF";
  }), t;
}, uS = function(e) {
  let t = e;
  return t = t.replace(/ﬂ°°/g, "&#"), t = t.replace(/ﬂ°/g, "&"), t = t.replace(/¶ß/g, ";"), t;
}, u7 = (e, t, n = []) => `
.${e} ${t} { ${n.join(" !important; ")} !important; }`, Y0e = (e, t, n = {}) => {
  var r;
  let i = "";
  if (e.themeCSS !== void 0 && (i += `
${e.themeCSS}`), e.fontFamily !== void 0 && (i += `
:root { --mermaid-font-family: ${e.fontFamily}}`), e.altFontFamily !== void 0 && (i += `
:root { --mermaid-alt-font-family: ${e.altFontFamily}}`), !Th(n) && hS.includes(t)) {
    const l = e.htmlLabels || ((r = e.flowchart) == null ? void 0 : r.htmlLabels) ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
    for (const h in n) {
      const u = n[h];
      Th(u.styles) || l.forEach((f) => {
        i += u7(u.id, f, u.styles);
      }), Th(u.textStyles) || (i += u7(u.id, "tspan", u.textStyles));
    }
  }
  return i;
}, CV = (e, t, n, r) => {
  const i = Y0e(e, t, n), s = Yoe(t, i, e.themeVariables);
  return q_(VXt(`${r}{${s}}`), zXt);
}, TV = (e = "", t, n) => {
  let r = e;
  return !n && !t && (r = r.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#')), r = uS(r), r = r.replace(/<br>/g, "<br/>"), r;
}, EV = (e = "", t) => {
  const n = t ? t.viewBox.baseVal.height + "px" : I0e, r = btoa('<body style="' + B0e + '">' + e + "</body>");
  return `<iframe style="width:${$0e};height:${n};${N0e}" src="data:text/html;base64,${r}" sandbox="${F0e}">
  ${Q0e}
</iframe>`;
}, v2 = (e, t, n, r, i) => {
  const s = e.append("div");
  s.attr("id", n), r && s.attr("style", r);
  const o = s.append("svg").attr("id", t).attr("width", "100%").attr("xmlns", R0e);
  return i && o.attr("xmlns:xlink", i), o.append("g"), e;
};
function _2(e, t) {
  return e.append("iframe").attr("id", t).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
const AV = (e, t, n, r) => {
  var i, s, o;
  (i = e.getElementById(t)) == null || i.remove(), (s = e.getElementById(n)) == null || s.remove(), (o = e.getElementById(r)) == null || o.remove();
}, z0e = function(e, t, n, r) {
  var tt;
  var i, s, o, a;
  f0(), bp();
  const l = fe.detectInit(t);
  l && (Oc(l), E5(l));
  const h = J();
  B.debug(h), t.length > ((tt = h == null ? void 0 : h.maxTextSize) != null ? tt : 5e4) && (t = bV), t = t.replace(/\r\n?/g, `
`);
  const u = "#" + e, f = "i" + e, d = "#" + f, p = "d" + e, g = "#" + p;
  let m = wt("body");
  const y = h.securityLevel === OV, O = h.securityLevel === xV, x = h.fontFamily;
  if (r !== void 0) {
    if (r && (r.innerHTML = ""), y) {
      const Z = _2(wt(r), f);
      m = wt(Z.nodes()[0].contentDocument.body), m.node().style.margin = 0;
    } else
      m = wt(r);
    v2(m, e, p, `font-family: ${x}`, vV);
  } else {
    if (AV(document, e, p, f), y) {
      const Z = _2(wt("body"), f);
      m = wt(Z.nodes()[0].contentDocument.body), m.node().style.margin = 0;
    } else
      m = wt("body");
    v2(m, e, p);
  }
  t = SV(t);
  let _, w;
  try {
    if (_ = lS(t), "then" in _)
      throw new Error("Diagram is a promise. Use renderAsync.");
  } catch (Z) {
    _ = new cS("error"), w = Z;
  }
  const E = m.select(g).node(), T = _.type, S = E.firstChild, R = S.firstChild, A = hS.includes(T) ? _.renderer.getClasses(t, _) : {}, P = CV(
    h,
    T,
    A,
    u
  ), C = document.createElement("style");
  C.innerHTML = P, S.insertBefore(C, R);
  try {
    _.renderer.draw(t, e, Hm, _);
  } catch (Z) {
    throw x2.draw(t, e, Hm), Z;
  }
  const k = m.select(`${g} svg`), D = (s = (i = _.db).getAccTitle) == null ? void 0 : s.call(i), b = (a = (o = _.db).getAccDescription) == null ? void 0 : a.call(o);
  PV(T, k, D, b), m.select(`[id="${e}"]`).selectAll("foreignobject > *").attr("xmlns", _V);
  let M = m.select(g).node().innerHTML;
  if (B.debug("config.arrowMarkerAbsolute", h.arrowMarkerAbsolute), M = TV(M, y, ar(h.arrowMarkerAbsolute)), y) {
    const Z = m.select(g + " svg").node();
    M = EV(M, Z);
  } else
    O || (M = ap.sanitize(M, {
      ADD_TAGS: kV,
      ADD_ATTR: wV
    }));
  if (n !== void 0)
    switch (T) {
      case "flowchart":
      case "flowchart-v2":
        n(M, js.bindFunctions);
        break;
      case "gantt":
        n(M, H5.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        n(M, ch.bindFunctions);
        break;
      default:
        n(M);
    }
  else
    B.debug("CB = undefined!");
  BZ();
  const N = wt(y ? d : g).node();
  if (N && "remove" in N && N.remove(), w)
    throw w;
  return M;
}, q0e = async function(e, t, n, r) {
  var tt;
  var i, s, o, a;
  f0(), bp();
  const l = fe.detectInit(t);
  l && (Oc(l), E5(l));
  const h = J();
  B.debug(h), t.length > ((tt = h == null ? void 0 : h.maxTextSize) != null ? tt : 5e4) && (t = bV), t = t.replace(/\r\n?/g, `
`);
  const u = "#" + e, f = "i" + e, d = "#" + f, p = "d" + e, g = "#" + p;
  let m = wt("body");
  const y = h.securityLevel === OV, O = h.securityLevel === xV, x = h.fontFamily;
  if (r !== void 0) {
    if (r && (r.innerHTML = ""), y) {
      const Z = _2(wt(r), f);
      m = wt(Z.nodes()[0].contentDocument.body), m.node().style.margin = 0;
    } else
      m = wt(r);
    v2(m, e, p, `font-family: ${x}`, vV);
  } else {
    if (AV(document, e, p, f), y) {
      const Z = _2(wt("body"), f);
      m = wt(Z.nodes()[0].contentDocument.body), m.node().style.margin = 0;
    } else
      m = wt("body");
    v2(m, e, p);
  }
  t = SV(t);
  let _, w;
  try {
    _ = await lS(t);
  } catch (Z) {
    _ = new cS("error"), w = Z;
  }
  const E = m.select(g).node(), T = _.type, S = E.firstChild, R = S.firstChild, A = hS.includes(T) ? _.renderer.getClasses(t, _) : {}, P = CV(
    h,
    T,
    A,
    u
  ), C = document.createElement("style");
  C.innerHTML = P, S.insertBefore(C, R);
  try {
    await _.renderer.draw(t, e, Hm, _);
  } catch (Z) {
    throw x2.draw(t, e, Hm), Z;
  }
  const k = m.select(`${g} svg`), D = (s = (i = _.db).getAccTitle) == null ? void 0 : s.call(i), b = (a = (o = _.db).getAccDescription) == null ? void 0 : a.call(o);
  PV(T, k, D, b), m.select(`[id="${e}"]`).selectAll("foreignobject > *").attr("xmlns", _V);
  let M = m.select(g).node().innerHTML;
  if (B.debug("config.arrowMarkerAbsolute", h.arrowMarkerAbsolute), M = TV(M, y, ar(h.arrowMarkerAbsolute)), y) {
    const Z = m.select(g + " svg").node();
    M = EV(M, Z);
  } else
    O || (M = ap.sanitize(M, {
      ADD_TAGS: kV,
      ADD_ATTR: wV
    }));
  if (n !== void 0)
    switch (T) {
      case "flowchart":
      case "flowchart-v2":
        n(M, js.bindFunctions);
        break;
      case "gantt":
        n(M, H5.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        n(M, ch.bindFunctions);
        break;
      default:
        n(M);
    }
  else
    B.debug("CB = undefined!");
  BZ();
  const N = wt(y ? d : g).node();
  if (N && "remove" in N && N.remove(), w)
    throw w;
  return M;
};
function W0e(e = {}) {
  var t;
  (e == null ? void 0 : e.fontFamily) && !((t = e.themeVariables) != null && t.fontFamily) && (e.themeVariables = { fontFamily: e.fontFamily }), woe(e), (e == null ? void 0 : e.theme) && e.theme in ra ? e.themeVariables = ra[e.theme].getThemeVariables(
    e.themeVariables
  ) : e && (e.themeVariables = ra.default.getThemeVariables(e.themeVariables));
  const n = typeof e == "object" ? koe(e) : AF();
  v5(n.logLevel), f0();
}
function PV(e, t, n, r) {
  L0e(t, e), M0e(t, n, r, t.attr("id"));
}
const un = Object.freeze({
  render: z0e,
  renderAsync: q0e,
  parse: Z0e,
  parseAsync: V0e,
  parseDirective: VF,
  initialize: W0e,
  getConfig: J,
  setConfig: PF,
  getSiteConfig: AF,
  updateSiteConfig: Soe,
  reset: () => {
    bp();
  },
  globalReset: () => {
    bp(mu);
  },
  defaultConfig: mu
});
v5(J().logLevel);
bp(J());
const U0e = async function(e, t, n) {
  try {
    await LV(e, t, n);
  } catch (r) {
    B.warn("Syntax Error rendering"), T5(r) && B.warn(r.str), vi.parseError && vi.parseError(r);
  }
}, DV = (e, t, n) => {
  B.warn(e), T5(e) ? (n && n(e.str, e.hash), t.push({ ...e, message: e.str, error: e })) : (n && n(e), e instanceof Error && t.push({
    str: e.message,
    message: e.message,
    hash: e.name,
    error: e
  }));
}, j0e = function(e, t, n) {
  const r = un.getConfig();
  e && (vi.sequenceConfig = e), B.debug(`${n ? "" : "No "}Callback function found`);
  let i;
  if (t === void 0)
    i = document.querySelectorAll(".mermaid");
  else if (typeof t == "string")
    i = document.querySelectorAll(t);
  else if (t instanceof HTMLElement)
    i = [t];
  else if (t instanceof NodeList)
    i = t;
  else
    throw new Error("Invalid argument nodes for mermaid.init");
  B.debug(`Found ${i.length} diagrams`), (e == null ? void 0 : e.startOnLoad) !== void 0 && (B.debug("Start On Load: " + (e == null ? void 0 : e.startOnLoad)), un.updateSiteConfig({ startOnLoad: e == null ? void 0 : e.startOnLoad }));
  const s = new fe.initIdGenerator(r.deterministicIds, r.deterministicIDSeed);
  let o;
  const a = [];
  for (const l of Array.from(i)) {
    B.info("Rendering diagram: " + l.id);
    /*! Check if previously processed */
    if (l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const h = `mermaid-${s.next()}`;
    o = l.innerHTML, o = wI(fe.entityDecode(o)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const u = fe.detectInit(o);
    u && B.debug("Detected early reinit: ", u);
    try {
      un.render(
        h,
        o,
        (f, d) => {
          l.innerHTML = f, n !== void 0 && n(h), d && d(l);
        },
        l
      );
    } catch (f) {
      DV(f, a, vi.parseError);
    }
  }
  if (a.length > 0)
    throw a[0];
}, X0e = async (...e) => {
  B.debug(`Loading ${e.length} external diagrams`);
  const n = (await Promise.allSettled(
    e.map(async ({ id: r, detector: i, loader: s }) => {
      const { diagram: o } = await s();
      Wn(r, o, i);
    })
  )).filter((r) => r.status === "rejected");
  if (n.length > 0) {
    B.error(`Failed to load ${n.length} external diagrams`);
    for (const r of n)
      B.error(r);
    throw new Error(`Failed to load ${n.length} external diagrams`);
  }
}, LV = async function(e, t, n) {
  const r = un.getConfig();
  e && (vi.sequenceConfig = e), B.debug(`${n ? "" : "No "}Callback function found`);
  let i;
  if (t === void 0)
    i = document.querySelectorAll(".mermaid");
  else if (typeof t == "string")
    i = document.querySelectorAll(t);
  else if (t instanceof HTMLElement)
    i = [t];
  else if (t instanceof NodeList)
    i = t;
  else
    throw new Error("Invalid argument nodes for mermaid.init");
  B.debug(`Found ${i.length} diagrams`), (e == null ? void 0 : e.startOnLoad) !== void 0 && (B.debug("Start On Load: " + (e == null ? void 0 : e.startOnLoad)), un.updateSiteConfig({ startOnLoad: e == null ? void 0 : e.startOnLoad }));
  const s = new fe.initIdGenerator(r.deterministicIds, r.deterministicIDSeed);
  let o;
  const a = [];
  for (const l of Array.from(i)) {
    B.info("Rendering diagram: " + l.id);
    /*! Check if previously processed */
    if (l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const h = `mermaid-${s.next()}`;
    o = l.innerHTML, o = wI(fe.entityDecode(o)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const u = fe.detectInit(o);
    u && B.debug("Detected early reinit: ", u);
    try {
      await un.renderAsync(
        h,
        o,
        (f, d) => {
          l.innerHTML = f, n !== void 0 && n(h), d && d(l);
        },
        l
      );
    } catch (f) {
      DV(f, a, vi.parseError);
    }
  }
  if (a.length > 0)
    throw a[0];
}, G0e = function(e) {
  un.initialize(e);
}, H0e = async (e, {
  lazyLoad: t = !0
} = {}) => {
  t ? _F(...e) : await X0e(...e);
}, MV = function() {
  if (vi.startOnLoad) {
    const { startOnLoad: e } = un.getConfig();
    e && vi.init().catch((t) => B.error("Mermaid failed to initialize", t));
  }
};
if (typeof document < "u") {
  /*!
   * Wait for document loaded before starting the execution
   */
  window.addEventListener("load", MV, !1);
}
const K0e = function(e) {
  vi.parseError = e;
}, J0e = (e) => un.parse(e, vi.parseError), k2 = [];
let wx = !1;
const RV = async () => {
  if (!wx) {
    for (wx = !0; k2.length > 0; ) {
      const e = k2.shift();
      if (e)
        try {
          await e();
        } catch (t) {
          B.error("Error executing queue", t);
        }
    }
    wx = !1;
  }
}, t1e = (e) => new Promise((t, n) => {
  const r = () => new Promise((i, s) => {
    un.parseAsync(e, vi.parseError).then(
      (o) => {
        i(o), t(o);
      },
      (o) => {
        B.error("Error parsing", o), s(o), n(o);
      }
    );
  });
  k2.push(r), RV().catch(n);
}), e1e = (e, t, n, r) => new Promise((i, s) => {
  const o = () => new Promise((a, l) => {
    un.renderAsync(e, t, n, r).then(
      (h) => {
        a(h), i(h);
      },
      (h) => {
        B.error("Error parsing", h), l(h), s(h);
      }
    );
  });
  k2.push(o), RV().catch(s);
}), vi = {
  startOnLoad: !0,
  diagrams: {},
  mermaidAPI: un,
  parse: J0e,
  parseAsync: t1e,
  render: un.render,
  renderAsync: e1e,
  init: U0e,
  initThrowsErrors: j0e,
  initThrowsErrorsAsync: LV,
  registerExternalDiagrams: H0e,
  initialize: G0e,
  parseError: void 0,
  contentLoaded: MV,
  setParseErrorHandler: K0e
};
function n1e(e, t) {
  vi.initialize(Object.assign({ securityLevel: "loose" }, t));
  function n(s) {
    return s.split(/\s+/g)[0];
  }
  let r = e.renderer.rules.fence;
  function i(s, o, a, l, h) {
    let u = s[o], f = u.info.trim(), d = f ? n(f) : "";
    if (["mermaid", "{mermaid}"].indexOf(d) === -1)
      return r !== void 0 ? r(s, o, a, l, h) : "";
    let p = "", g = [];
    const m = document.createElement("div");
    document.body.appendChild(m);
    try {
      const y = "mermaid-container";
      vi.mermaidAPI.render(y, u.content, (O) => {
        let x = document.getElementById(y);
        x !== null && g.push([
          "style",
          `max-width:${x.style.maxWidth};max-height:${x.style.maxHeight}`
        ]), p = O;
      }, m);
    } catch (y) {
      return `<div class="alert alert-danger">${y}</div>`;
    } finally {
      m.remove();
    }
    return g.push(["src", `data:image/svg+xml,${encodeURIComponent(p)}`]), `<img ${h.renderAttrs({ attrs: g })}>`;
  }
  e.renderer.rules.fence = i;
}
const r1e = (e, t) => ((e == null ? void 0 : e.match(t)) || []).length, i1e = (e) => () => {
  window.myst_editor || (window.myst_editor = {}), window.myst_editor.text = e;
}, s1e = (e) => {
  const t = (n) => {
    n.clipboardData.setData("text/html", e), n.clipboardData.setData("text/plain", e), n.preventDefault();
  };
  document.addEventListener("copy", t), document.execCommand("copy"), document.removeEventListener("copy", t);
}, o1e = ({
  initialText: e,
  transforms: t,
  customRoles: n,
  preview: r
}) => {
  const [i, s] = mn(e), [o, a] = mn(!1), [l, h] = mn(!1), [u, f] = mn({
    action: (y) => {
    }
  }), [d, p] = S2((y, {
    newMarkdown: O,
    force: x = !1
  }) => {
    let _ = {};
    x || (_ = y.reduce((E, {
      hash: T,
      html: S
    }) => (E[T] = S, E), {}));
    const w = m(O, _);
    return w.length !== y.length || x ? (r.current.innerHTML = w.map((E) => `<html-chunk id="html-chunk-${E.id}">` + E.html + "</html-chunk>").join(`
`), w) : (w.filter((E, T) => E.hash !== y[T].hash).forEach((E) => r.current.querySelector("html-chunk#html-chunk-" + E.id).innerHTML = E.html), w);
  }, []), g = Dn(() => pNt({
    breaks: !0,
    linkify: !0
  }).use(RQt).use(ZQt(t)).use(zQt(n)).use(n1e), []), m = Yk((y, O = {}) => y.split(/(?=\n#{1,3} )/g).reduce(
    (x, _) => {
      const w = x.length - 1, E = x[w];
      return r1e(E, /\n```/g) % 2 != 0 ? x[w] = E + _ : x.push(_), x;
    },
    []
  ).map((x, _) => {
    const w = new OZt(x, 42).result(), E = O[w] || _I.sanitize(g.render(x));
    return {
      md: x,
      hash: w,
      id: _,
      html: E
    };
  }), [g]);
  return lr(() => o && p({
    newMarkdown: i
  }), [o]), lr(i1e(i), [i]), lr(() => {
    l && (u.action(i), h(!1));
  }, [l]), {
    set(y) {
      s(y), setTimeout(() => {
        try {
          p({
            newMarkdown: y
          });
        } catch (O) {
          console.warn(O), p({
            newMarkdown: y,
            force: !0
          });
        }
      });
    },
    get() {
      return i;
    },
    sync() {
      h(!0);
    },
    refresh() {
      p({
        newMarkdown: window.myst_editor.text,
        force: !0
      });
    },
    onSync(y) {
      f({
        action: y
      });
    },
    readyToRender() {
      a(!0);
    },
    copy() {
      s1e(m(window.myst_editor.text).map((y) => y.html).join(`
`));
    }
  };
}, ju = ue.button`
  &:focus {
    outline: 0 !important;
  }

  cursor: pointer;
  color: var(--icon-color);
  text-transform: uppercase;
  font-size: 12px;
  font-weight: bold;
  border: 1px solid var(--icon-border);
  background-color: var(--icon-bg);
  height: 40px;
  display: flex;
  justify-content: center;
  margin-top: 0px;
  align-items: center;
  padding: 0;
  transition: 0.4s ease;
  border-radius: var(--border-radius);

  &:not(:has(svg)) {
    padding: 0px 15px;
    margin: 5px;
  }
`, a1e = ue.div`
  display: flex;
  justify-content: flex-end;
  align-items: center;
`, l1e = ue(ju)`
  color: ${(e) => e.active ? "white" : "var(--icon-color)"};
  background-color: ${(e) => e.active ? "var(--icon-main-active)" : "var(--navbar-bg)"};
  width: 40px;
  border: "1px solid var(--icon-border)";
  border-left: none;
  border-radius: 0;

  &:hover {
    background-color: var(--icon-main-selected);
  }

  &:first-child {
    border-left: 1px solid var(--icon-border) !important;
    border-radius: var(--border-radius) 0 0 var(--border-radius);
    margin-left: 10px;
  }

  &:last-child {
    border-radius: 0 var(--border-radius) var(--border-radius) 0;
  }
`, c1e = ({
  buttons: e,
  initialClickedId: t = 2
}) => {
  const [n, r] = mn(t);
  return lr(() => {
    e[t].action();
  }, [t]), Kt` <${a1e}>
    ${e.map((i, s) => Kt` <${l1e}
          className="icon radio-icon"
          type="button"
          key=${i.id}
          name=${i.id}
          onClick=${() => {
    r(s), i.action();
  }}
          title=${i.tooltip}
          active=${s === n}
        >
          ${typeof i.icon == "function" ? Kt`<${i.icon} />` : Kt`<img src=${i.icon} />`}
        <//>`)}
  <//>`;
}, _1 = 4, $V = ue.div`
  width: 200px;

  .avatar {
    border-radius: 50%;
    margin-top: 5px;
    float: right;
    border: 3px solid;
    height: 35px;
    width: 35px;
    margin: 5px 0px 5px -7px;
    transition: 0.5s;

    &:hover {
      margin: 5px 0px 5px 0px;
    }

    &.placeholder {
      margin-left: -7px;
      line-height: 30px;
      color: var(--icon-color);
      border-color: var(--icon-border);
      font-style: normal;
      font-size: small;
      font-weight: 700;
      text-align: center;
      background-color: var(--icon-bg);
    }
  }
`, IV = ({
  login: e,
  color: t,
  avatarUrl: n
}) => Kt` <img src=${n} key=${e} title=${e} class="avatar" style="border-color: ${t}" />`, h1e = ({
  n: e,
  usernames: t
}) => Kt` <${$V} title=${t}>
    <span class="avatar placeholder">+${e}</span>
  <//>`, u1e = ({
  users: e
}) => Kt` <${$V}>
    ${e.length > _1 ? Kt`<${h1e}
          n=${e.length - _1}
          usernames=${e.filter((t, n) => n >= _1).map((t) => t.login).join(", ")}
        />` : ""}
    ${e.filter((t, n) => n < _1).map((t) => Kt`<${IV} ...${t} />`)}
  <//>`, f1e = ue.section`
  z-index: 2;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 10px;
  width: 450px;
  padding: 20px;
  right: 50%;
  transform: translate(50%, 0);
  top: 100%;
  position: absolute;
  background-color: var(--icon-bg);
  border: 1px solid var(--icon-border);
  border-radius: var(--border-radius);
`, d1e = ue.h3`
  color: var(--gray-900);
`, p1e = ue.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
`, f7 = ue(ju)`
  padding: 0 10px;
  margin-top: 0px;

  &:hover {
    background-color: ${(e) => e.$negative ? "var(--red-500)" : "var(--icon-main-active)"} !important;
    border: 1px solid ${(e) => e.$negative ? "var(--red-500)" : "var(--icon-main-active)"} !important;
  }
`, g1e = ({
  changeDocumentTemplate: e,
  selectedTemplate: t,
  closeModal: n
}) => Kt`
    <${f1e}>
      <${d1e}>Are you sure you want to change the current template?<//>
      <${p1e}>
        <${f7} type="button" onClick=${() => e(t)}>✓ Yes<//>
        <${f7} $negative type="button" onClick=${n}>x Cancel<//>
      <//>
    <//>
  `, m1e = ue.div`
  position: absolute;
  ${(e) => e.$orientation == "left" && Qf`
      left: 0;
    `}
  transform: ${(e) => e.$orientation == "left" ? "translateX(-105%)" : "translate(-65%, 130%)"};
`, y1e = ue.div`
  position: relative;
  background: var(--alert);
  color: var(--icon-color);
  text-align: left;
  padding: 10px 20px 10px 20px;
  border-radius: var(--border-radius);
  border: solid var(--alert);
  border-width: 1px 1px 1px 1px;
  max-height: 40px;
  top: calc(100% + 11px);
  ${(e) => e.$orientation == "bottom" && Qf`
      left: 50%;
    `}
  transform: ${(e) => e.$orientation == "left" ? "none" : "translateX(calc(50% - 14px))"};

  &::before {
    content: "";
    position: absolute;
    ${(e) => e.$orientation == "left" ? Qf`
            right: 0;
            top: 50%;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            border-left: 30px solid var(--alert);
          ` : Qf`
            left: 50%;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid var(--alert);
          `}
    transform: ${(e) => e.$orientation == "left" ? "translate(50%, -50%)" : "translate(-50%, -100%)"};
  }
`, d7 = ({
  tooltipOrientation: e,
  errorMessage: t
}) => Kt` <${m1e} $orientation=${e}>
    <${y1e} $orientation=${e}> ${t} <//>
  <//>`, b1e = ue.div`
  display: none;
  margin-left: 5px;
  margin-right: 5px;
  text-transform: uppercase;
  white-space: nowrap;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--icon-color);
  background-color: var(--icon-bg);
  width: 210%;
  z-index: 20;
`, Sx = () => Kt`<svg width="20" height="22" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M5 16L11 16" stroke="#332D37" stroke-width="1.75" />
    <path d="M1 21H10H19V12V6.5L13.5 1H1V6.5V12V21Z" stroke="#332D37" stroke-width="1.75" stroke-dasharray="6 3" />
    <path d="M5 12L15 12" stroke="#332D37" stroke-width="1.75" />
    <path d="M5 8L15 8" stroke="#332D37" stroke-width="1.75" />
  </svg> `, p7 = ue(ju)`
  width: 90%;
  color: var(--icon-color);
  border: 1px solid var(--icon-border);
  padding: 0 10px 0 10px;
  margin-top: 0px;
  text-wrap: wrap;
`, O1e = ue.div`
  position: relative;
  &:hover {
    div {
      display: inline-flex;
      flex-direction: column;
    }
  }
`, x1e = ue.div`
  display: flex;
  flex-direction: row-reverse;
  border: 1px solid var(--gray-900);
  width: inherit;
`, v1e = ue.div`
  position: absolute;
  width: 100%;
  padding-top: 5px;
`, _1e = (e) => {
  const t = ["id", "templatetext"];
  for (const n in e) {
    for (let r of t)
      e[n][r] || (e[n].errorMessage = `Configuration of template ${n} is lacking '${r}'`);
    e[n].errorMessage && console.error(e[n].errorMessage);
  }
  return e;
}, k1e = ({
  text: e,
  templatelist: t
}) => {
  const [n, r] = mn(""), [i, s] = mn({}), [o, a] = mn(null), [l, h] = mn(!1), [u, f] = mn(!1), [d, p] = mn({
    error: null,
    message: null
  }), g = (_) => _.ok ? _ : Promise.reject(`Invalid HTTP response: ${_.status}`), m = (_) => {
    r(i[_].templatetext), e.set(i[_].templatetext), e.sync(), h(!1);
  }, y = (_) => fetch(_).then(g).then((w) => w.json().catch((E) => {
    console.error(E), p({
      error: E,
      message: "Template configuration is not valid"
    });
  })).catch((w) => {
    console.warn(w), p({
      error: w,
      message: "Template configuration not found"
    });
  }), O = (_) => fetch(_).then(g).then((w) => w.text()).catch((w) => {
    throw console.error(w), new Error("Could not fetch the template");
  }), x = async (_) => {
    if (!_)
      return {};
    for (const w in _) {
      const E = _[w].templatetext;
      await O(E).then((T) => _[w].templatetext = T).catch((T) => {
        var S, R;
        return (R = (S = _[w]).errorMessage) != null ? R : S.errorMessage = T.message;
      });
    }
    return _;
  };
  return lr(() => y(t).then(_1e).then(x).then(s), []), d.error ? Kt` <${_g}
        type="button"
        template=${n}
        onMouseEnter=${() => f(!0)}
        onMouseLeave=${() => f(!1)}
      >
        <${Sx} />
      <//>
      <${u && d7} tooltipOrientation="bottom" errorMessage=${d.message} />` : Object.keys(i).length == 0 ? Kt` <${_g}
      type="button"
      title="Templates"
      template=${n}
      onMouseEnter=${() => f(!0)}
      onMouseLeave=${() => f(!1)}
    >
      <${Sx} />
    <//>` : Kt`
    ${l && Kt`<${g1e}
      selectedTemplate=${o}
      closeModal=${() => {
    h(!1), a(!1);
  }}
      changeDocumentTemplate=${m}
    />`}
    <${O1e}>
      <${_g} className="icon" title="Templates" type="button"><${Sx} /><//>
      <${v1e}>
        <${b1e}>
          ${Object.keys(i).map((_) => Kt`
              ${i[_].errorMessage ? Kt`
                    <${x1e}>
                      <${u === _ && d7} tooltipOrientation="left" errorMessage="${i[_].errorMessage}" />
                      <${p7} type="button" onMouseEnter=${() => f(_)} onMouseLeave=${() => f(!1)}
                        >${i[_].id}
                      <//>
                    <//>
                  ` : Kt`
                    <${p7}
                      type="button"
                      onClick=${() => {
    h(!0), a(_);
  }}
                      >${i[_].id}
                    <//>
                  `}
            `)}
        <//>
      <//>
    <//>
  `;
}, w1e = (e) => [...e.matchAll(/\[(.+)\]\(([^\s]+)\)/g)].reduce((t, n) => t.replace(n[0], `<a href="${n[2]}">${n[1]}</a>`), e), S1e = ue.div`
  z-index: 10;
  position: sticky;
  top: 0;
  display: flex;
  width: 100%;
  height: 60px;
  background-color: var(--navbar-bg);

  svg > path {
    stroke: var(--icon-color);
    &.inner-copy {
      transition: 0.4s ease;
      fill: var(--icon-bg);
    }
  }

  button:not(:disabled):not(view-menu):not(.radio-icon):hover {
    background-color: var(--icon-selected);
    border: 1px solid var(--icon-selected);
    .inner-copy {
      fill: var(--icon-selected);
    }
  }

  @media print {
    & {
      display: none;
    }
  }
`, C1e = ue.div`
  font-size: large;
  white-space: nowrap;
  margin-left: 10px;

  a {
    color: var(--blue-500);
  }
`, T1e = ue.div`
  width: 100%;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  margin-left: 5px;
`, E1e = ue(ju)`
  padding: 0px 15px;
  margin: 5px;
  pointer-events: none;
  background-color: var(--alert);
  border: none;
  width: fit-content;
`, A1e = ue.div`
  width: 100%;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-right: 15px;

  button[active] {
    pointer-events: none;
  }
`, _g = ue(ju)`
  color: ${(e) => e.active ? "white" : "var(--icon-color)"};
  border: ${(e) => e.active ? "1px solid var(--icon-main-active)" : "1px solid var(--icon-border)"};
  background-color: ${(e) => e.active ? "var(--icon-main-active)" : "var(--icon-bg)"};
  margin: 5px;
  width: 40px;
`, P1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22" fill="none">
    <path d="M20.35 1.78003L12.61 9.51003" stroke-width="1.75" />
    <path d="M14.88 1.08008H20.89V7.27008" stroke-width="1.75" />
    <path d="M1.42999 20.3601L9.16999 12.6301" stroke-width="1.75" />
    <path d="M6.90002 21.0601H0.890015V14.8701" stroke-width="1.75" />
  </svg>`, D1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" viewBox="0 0 23 23" fill="none">
    <path d="M21.75 1V7.66H14.9" stroke-width="1.75" />
    <path
      d="M21.65 12.5899C20.95 17.4199 16.78 21.1399 11.75 21.1399C6.23 21.1399 1.75 16.6599 1.75 11.1399C1.75 5.61989 6.23 1.13989 11.75 1.13989C16.24 1.13989 20.03 4.09989 21.3 8.16989"
      stroke-width="1.75"
    />
  </svg>`, L1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="26" height="18" viewBox="0 0 26 18" fill="none">
    <path
      d="M13.01 11.5902C14.5675 11.5902 15.83 10.3276 15.83 8.7702C15.83 7.21275 14.5675 5.9502 13.01 5.9502C11.4526 5.9502 10.1899 7.21275 10.1899 8.7702C10.1899 10.3276 11.4526 11.5902 13.01 11.5902Z"
      stroke-width="1.75"
    />
    <path
      d="M23.4301 9.80018C23.4301 9.80018 13.75 24.5402 2.58997 9.80018L1.98999 8.95018L2.59998 8.10018C2.59998 8.10018 12.2799 -6.63982 23.4399 8.10018L24.01 8.90018L23.4301 9.80018Z"
      stroke-width="1.75"
    />
  </svg>`, M1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="21" height="15" viewBox="0 0 21 15" fill="none">
    <path d="M15.31 2.8501L19.56 7.1001L15.19 11.4801" stroke-width="1.75" />
    <path d="M5.75 11.4801L1.5 7.2201L5.88 2.8501" stroke-width="1.75" />
    <path d="M12.35 0.340088L8.72 13.9901" stroke-width="1.75" />
  </svg>`, R1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="20" height="22" viewBox="0 0 20 22" fill="none">
    <path d="M13.99 1.04004H1.37V16.64H13.99V1.04004Z" stroke-width="1.75" />
    <path class="inner-copy" d="M18.63 5.51001H6.01001V21.11H18.63V5.51001Z" stroke-width="1.75" />
  </svg>`, $1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="23" height="18" viewBox="0 0 23 18" fill="none">
    <path d="M21.84 1.65015H1.83997V16.6701H21.84V1.65015Z" stroke-width="1.75" />
    <path d="M11.84 1.83008V16.6701" stroke-width="1.75" />
  </svg>`, I1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="24" height="16" viewBox="0 0 24 16" fill="none">
    <path d="M21.23 11.0801H10.29" stroke-width="1.75" />
    <path d="M17.86 6.71997L22.11 10.97L17.73 15.35" stroke-width="1.75" />
    <path d="M2.22998 5.09009H13.17" stroke-width="1.75" />
    <path d="M5.60999 9.44007L1.35999 5.19007L5.73999 0.820068" stroke-width="1.75" />
  </svg>`, N1e = () => Kt`<svg width="21" height="22" viewBox="0 0 21 22" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path stroke-width="0.2" d="M21 12.4286V11H16.7143V18.1429H18.1429V15.2857H20.2857V13.8571H18.1429V12.4286H21Z" fill="#332D37" />
    <path
      stroke-width="0.2"
      d="M13.1428 18.1429H10.2857V11H13.1428C14.3571 11 15.2857 11.9286 15.2857 13.1429V16C15.2857 17.2143 14.3571 18.1429 13.1428 18.1429ZM11.7143 16.7143H13.1428C13.5714 16.7143 13.8571 16.4286 13.8571 16V13.1429C13.8571 12.7143 13.5714 12.4286 13.1428 12.4286H11.7143V16.7143Z"
      fill="#332D37"
    />
    <path
      stroke-width="0.2"
      d="M7.42855 11H3.85712V18.1429H5.28569V16H7.42855C8.21426 16 8.85712 15.3571 8.85712 14.5714V12.4286C8.85712 11.6429 8.21426 11 7.42855 11ZM5.28569 14.5714V12.4286H7.42855V14.5714H5.28569Z"
      fill="#332D37"
    />
    <path d="M14 21H9.5H1V1H9M15 10V7.5M9 1H9.5L15 6.5V7.5M9 1V7.5H15" stroke="#332D37" stroke-width="1.75" />
  </svg> `, B1e = () => Kt` <svg xmlns="http://www.w3.org/2000/svg" width="26" height="17" viewBox="0.5 -1 17 17" fill="none">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M6.38496 5.09174C5.90507 5.09174 5.51465 5.48216 5.51465 5.96205C5.51465 6.18979 5.60412 6.41754 5.76679 6.58021C5.92947 6.74289 6.14908 6.83236 6.38496 6.83236C6.62084 6.83236 6.84045 6.74289 7.00313 6.58021C7.1658 6.41754 7.25527 6.19793 7.25527 5.96205C7.25527 5.48216 6.86485 5.09174 6.38496 5.09174Z"
      fill="#332D37"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M8.99629 5.09174C8.5164 5.09174 8.12598 5.48216 8.12598 5.96205C8.12598 6.18979 8.21545 6.41754 8.37812 6.58021C8.5408 6.74289 8.76041 6.83236 8.99629 6.83236C9.23217 6.83236 9.45178 6.74289 9.61445 6.58021C9.77713 6.41754 9.8666 6.19793 9.8666 5.96205C9.8666 5.48216 9.47618 5.09174 8.99629 5.09174Z"
      fill="#332D37"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M11.6066 5.09174C11.1267 5.09174 10.7363 5.48216 10.7363 5.96205C10.7363 6.18979 10.8258 6.41754 10.9885 6.58021C11.1511 6.74289 11.3708 6.83236 11.6066 6.83236C11.8425 6.83236 12.0621 6.74289 12.2248 6.58021C12.3875 6.41754 12.477 6.19793 12.477 5.96205C12.477 5.48216 12.0865 5.09174 11.6066 5.09174Z"
      fill="#332D37"
    />
    <path
      d="M17.1298 11.0375V0.862183H0.862305V10.8748L5.11626 10.9155L9.053 14.8522L12.884 11.0294L17.1298 11.0375Z"
      stroke="#332D37"
      stroke-width="1.5"
    />
  </svg>`, F1e = {
  fullscreen: P1e,
  "copy-html": R1e,
  refresh: D1e,
  "print-to-pdf": N1e
}, Q1e = ({
  alert: e,
  users: t,
  text: n,
  setMode: r,
  templatelist: i,
  buttons: s,
  title: o,
  collaboration: a
}) => {
  const l = Dn(() => _I.sanitize(w1e(o || ""), [])), h = [{
    id: "source",
    tooltip: "Source",
    action: () => r("Source"),
    icon: M1e
  }, {
    id: "preview",
    tooltip: "Preview",
    action: () => r("Preview"),
    icon: L1e
  }, {
    id: "both",
    tooltip: "Dual Pane",
    action: () => r("Both"),
    icon: $1e
  }, {
    id: "diff",
    tooltip: "Diff View",
    action: () => r("Diff"),
    icon: I1e
  }];
  a.resolvingCommentsEnabled && h.push({
    id: "resolved",
    tooltip: "Resolved Comments",
    action: () => r("Resolved"),
    icon: B1e
  });
  const u = Dn(() => s.map((d) => ({
    ...d,
    icon: d.icon || F1e[d.id]
  })).filter((d) => d.icon), []), f = Dn(() => s.filter((d) => d.text && d.id !== "template-manager"), []);
  return Kt` <${S1e}>
    <${T1e}>
      ${u.map((d) => Kt`
          <${_g} className="icon" type="button" key=${d.id} title=${d.tooltip} name=${d.id} onClick=${d.action}>
            ${typeof d.icon == "function" ? Kt`<${d.icon} />` : Kt`<img src=${d.icon} />`}
          <//>
        `)}
      ${s.find((d) => d.id === "template-manager") && i && Kt`<${k1e} text=${n} templatelist=${i} />`}
      ${e && Kt`<${E1e}> ${e} <//>`}
      <${C1e} dangerouslySetInnerHTML=${{
    __html: l
  }} />
    <//>
    <${A1e}>
      <${u1e} users=${t} />
      ${f.map((d) => Kt`<${ju} type="button" onClick=${d.action}>${d.text}<//>`)}

      <${c1e} buttons=${h} initialClickedId=${2} />
    <//>
  <//>`;
};
RR.prototype.watchCollabolators = function(e) {
  this.awareness.on("change", ({
    added: t,
    removed: n
  }) => {
    if (t || n) {
      let r = Array.from(this.awareness.states).map(([i, {
        user: s
      }]) => ({
        login: s.name,
        color: s.color
      })).reduce((i, s) => (i[s.login] = s, i), {});
      e(Object.values(r));
    }
  });
};
function Z1e(e) {
  if (!e.enabled)
    return {};
  const t = Dn(() => new Ru(), []), [n, r] = mn(!1), [i, s] = mn(!1), [o, a] = mn(!1);
  lr(() => {
    const f = console.error, d = (p) => p.includes("Caught error while handling a Yjs update");
    console.error = (...p) => {
      d(p[0]) && a("Collaboration error occured. Please check browser logs and restart the MyST Editor"), f(...p);
    };
  }, []);
  const l = Dn(() => {
    var d;
    const f = new RR((d = e.wsUrl) != null ? d : "ws://localhost:4444", e.room, t, {
      connect: !0,
      params: {},
      WebSocketPolyfill: WebSocket,
      awareness: new PR(t),
      maxBackoffTime: 2500
    });
    return f.awareness.setLocalStateField("user", {
      name: e.username,
      color: e.color
    }), f.ws.onerror = () => a(!0), f.on("sync", r), f.on("status", ({
      status: p
    }) => s(p == "connected")), f;
  }, []), h = Dn(() => t.getText("codemirror"), []), u = Dn(() => new Uw(h, {
    trackedOrigins: /* @__PURE__ */ new Set([l.doc.clientID, null]),
    ignoreRemoteMapChanges: !0
  }), []);
  return lr(() => !l.ws && a(!0), [i]), {
    provider: l,
    undoManager: u,
    ytext: h,
    ydoc: t,
    error: o,
    ready: n && i
  };
}
function V1e(e, t, n) {
  return !e || !t ? null : Dn(() => new Gf(e, t, n), []);
}
const Y1e = ue.p`
  font-size: 16px;
  padding: 10px 6px;
  margin-bottom: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 95%;
  min-height: 22px;
  text-decoration: ${(e) => e.orphaned ? "line-through" : "none"};
  color: ${(e) => e.orphaned ? "var(--gray-700)" : "var(--gray-900)"};

  & > span {
    display: ${(e) => e.orphaned ? "none" : "block"};
  }
`, z1e = ue.div`
  background-color: color-mix(in srgb, ${(e) => e.color}, white);
  border: 2px solid ${(e) => e.color};
  padding-top: 10px;
  margin-left: -1px;
  width: calc(100% - 2px);
`, q1e = ue.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  line-height: 22px;
  padding: 0 6px;
`, W1e = ue.h2`
  font-weight: bold;
  font-size: 12px;
  margin: 0;
`, U1e = ue.p`
  font-size: 12px;
  font-weight: 400;
  line-height: 14px;
  margin: 0;
  margin-right: 25px;
`, j1e = ue.p`
  margin: 0;
  margin-top: 3px;
  font-size: 16px;
  line-height: 22px;
  font-weight: 400;
`, g7 = ue.div`
  display: flex;
  align-items: center;

  & .avatar {
    border-radius: 50%;
    border: 3px solid;
    height: 28px;
    width: 28px;
    position: absolute;
    transform: translateX(calc(-100% - 12px));
  }
`, X1e = ue.span`
  display: block;
  background-color: color-mix(in srgb, ${(e) => e.color}, white);
  margin: 0;
  padding: 10px 6px;
  white-space: pre-wrap;
`, G1e = ue.span`
  position: absolute;
  transform: translateX(calc(-100% - 24px));
  color: var(--gray-700);
`, H1e = ue.span`
  margin-right: 6px;
  display: block;
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 10px 0;

  &:hover div {
    display: flex !important;
  }
`, K1e = ue.div`
  align-items: center;
  position: absolute;
  background-color: var(--gray-200);
  transform: translate(calc(-100% + 22px), calc(100% - 10px));
  width: max-content;
  border: 1px solid var(--gray-600);
  display: none;

  & p {
    margin: 0;
    font-size: 12px;
    color: var(--red-500);
    font-weight: 700;
  }
`, m7 = ue.button`
  background-color: transparent;
  border: none;
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 7px 18px;
  align-self: stretch;
  width: fit-content;

  &:hover {
    background-color: var(--gray-300);
  }

  &.myst-restore-btn {
    svg {
      padding-right: 10px;
    }

    p {
      color: var(--gray-900);
    }
  }
`, J1e = () => Kt`
  <svg width="20" height="5" viewBox="0 0 20 5" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M2.5 0C1.12149 0 0 1.12149 0 2.5C0 3.15421 0.257009 3.80841 0.724299 4.2757C1.19159 4.74299 1.82243 5 2.5 5C3.17757 5 3.80841 4.74299 4.2757 4.2757C4.74299 3.80841 5 3.17757 5 2.5C5 1.12149 3.8785 0 2.5 0Z"
      fill="#6C6C6C"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M10 0C8.6215 0 7.5 1.12149 7.5 2.5C7.5 3.15421 7.75701 3.80841 8.2243 4.2757C8.69159 4.74299 9.32243 5 10 5C10.6776 5 11.3084 4.74299 11.7757 4.2757C12.243 3.80841 12.5 3.17757 12.5 2.5C12.5 1.12149 11.3785 0 10 0Z"
      fill="#6C6C6C"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M17.5 0C16.1215 0 15 1.12149 15 2.5C15 3.15421 15.257 3.80841 15.7243 4.2757C16.1916 4.74299 16.8224 5 17.5 5C18.1776 5 18.8084 4.74299 19.2757 4.2757C19.743 3.80841 20 3.17757 20 2.5C20 1.12149 18.8785 0 17.5 0Z"
      fill="#6C6C6C"
    />
  </svg>
`, tge = () => Kt`
  <svg width="25" height="26" viewBox="0 0 26 21" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M7.71387 6.14294V12.5715" stroke="#E7473C" stroke-width="1.75" />
    <path d="M10.2852 6.14288V12.5715" stroke="#E7473C" stroke-width="1.75" />
    <path d="M6.42871 1H11.5716" stroke="#E7473C" stroke-width="1.75" />
    <path d="M0 2.28564H18" stroke="#E7473C" stroke-width="1.75" />
    <path d="M1.92871 2.28564L3.85728 18.3571H14.143L16.0716 2.28564" stroke="#E7473C" stroke-width="1.75" />
  </svg>
`, ege = () => Kt`
  <svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M1.00169 1V6.66103H6.82422" stroke="black" stroke-width="1.75" />
    <path
      d="M1.08493 10.8517C1.67993 14.9572 5.22444 18.1192 9.49996 18.1192C14.192 18.1192 18 14.3112 18 9.61918C18 4.92716 14.192 1.11914 9.49996 1.11914C5.68344 1.11914 2.46193 3.63515 1.38242 7.09467"
      stroke="black"
      stroke-width="1.75"
    />
  </svg>
`, nge = new Intl.RelativeTimeFormat("en", {
  style: "long"
}), rge = ({
  c: e,
  authors: t,
  ycomments: n,
  content: r
}) => {
  const [i, s] = mn({
    amount: 0,
    unit: "second"
  }), o = us(null), a = Dn(() => {
    const u = r.split(`
`), f = [];
    for (let d = 0; d < u.length; d++)
      f.length == 0 || f[f.length - 1].author.name != t.get(d + 1).name ? f.push({
        text: u[d],
        author: t.get(d + 1)
      }) : f[f.length - 1].text += `
` + u[d];
    return f;
  }, [r]);
  function l() {
    const u = Math.floor((Date.now() - e.resolvedDate) / 1e3), f = Math.floor(u / 60), d = Math.floor(f / 60), p = Math.floor(d / 24), g = Math.floor(p / 30), m = Math.floor(g / 12);
    f >= 60 && clearInterval(o.current), u < 60 ? s({
      amount: u,
      unit: "second"
    }) : f < 60 ? s({
      amount: f,
      unit: "minute"
    }) : d < 24 ? s({
      amount: d,
      unit: "hour"
    }) : p < 30 ? s({
      amount: p,
      unit: "day"
    }) : g < 12 ? s({
      amount: g,
      unit: "month"
    }) : s({
      amount: m,
      unit: "year"
    });
  }
  lr(() => (o.current = setInterval(l, 1e3), () => {
    clearInterval(o.current);
  }), []);
  const h = Dn(() => e.orphaned ? "RESTORE ORPHANED" : e.occupied ? "RESTORE AND MERGE" : "RESTORE", [e]);
  return Kt`
    <div>
      <${Y1e} orphaned=${e.orphaned}>
        <${G1e}>${e.lineNumber}<//>
        ${e.resolvedLine}
      <//>
      <${z1e} className="resolved-comment" color=${t.get(1).color}>
        <${q1e}>
          <${g7}>
            <${IV} login=${t.get(1).name} color=${t.get(1).color} avatarUrl=${t.get(1).avatar} />
            <${W1e}>${t.get(1).name}<//>
          <//>
          <${g7}>
            <${U1e}>Comment resolved by @${e.resolvedBy.name} ${nge.format(-i.amount, i.unit)}<//>
            <${H1e}>
              <${J1e} />
              <${K1e}>
                <${m7} className="myst-restore-btn" onClick=${() => n.restoreComment(e)}>
                  <${ege} />
                  <p>${h}</p>
                <//>
                <${m7} onClick=${() => n.resolver().delete(e.commentId)}>
                  <${tge} />
                  <p>DELETE</p>
                <//>
              <//>
            <//>
          <//>
        <//>
        <${j1e}> ${a.map((u) => Kt` <${X1e} color=${u.author.color}>${u.text}<//> `)} <//>
      <//>
    </div>
  `;
}, ige = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAyIDIwIDEyIiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjM4NDk2IDUuMDkxNzRDNS45MDUwNyA1LjA5MTc0IDUuNTE0NjUgNS40ODIxNiA1LjUxNDY1IDUuOTYyMDVDNS41MTQ2NSA2LjE4OTc5IDUuNjA0MTIgNi40MTc1NCA1Ljc2Njc5IDYuNTgwMjFDNS45Mjk0NyA2Ljc0Mjg5IDYuMTQ5MDggNi44MzIzNiA2LjM4NDk2IDYuODMyMzZDNi42MjA4NCA2LjgzMjM2IDYuODQwNDUgNi43NDI4OSA3LjAwMzEzIDYuNTgwMjFDNy4xNjU4IDYuNDE3NTQgNy4yNTUyNyA2LjE5NzkzIDcuMjU1MjcgNS45NjIwNUM3LjI1NTI3IDUuNDgyMTYgNi44NjQ4NSA1LjA5MTc0IDYuMzg0OTYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljk5NjI5IDUuMDkxNzRDOC41MTY0IDUuMDkxNzQgOC4xMjU5OCA1LjQ4MjE2IDguMTI1OTggNS45NjIwNUM4LjEyNTk4IDYuMTg5NzkgOC4yMTU0NSA2LjQxNzU0IDguMzc4MTIgNi41ODAyMUM4LjU0MDggNi43NDI4OSA4Ljc2MDQxIDYuODMyMzYgOC45OTYyOSA2LjgzMjM2QzkuMjMyMTcgNi44MzIzNiA5LjQ1MTc4IDYuNzQyODkgOS42MTQ0NSA2LjU4MDIxQzkuNzc3MTMgNi40MTc1NCA5Ljg2NjYgNi4xOTc5MyA5Ljg2NjYgNS45NjIwNUM5Ljg2NjYgNS40ODIxNiA5LjQ3NjE4IDUuMDkxNzQgOC45OTYyOSA1LjA5MTc0WiIgZmlsbD0iIzMzMkQzNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjYwNjYgNS4wOTE3NEMxMS4xMjY3IDUuMDkxNzQgMTAuNzM2MyA1LjQ4MjE2IDEwLjczNjMgNS45NjIwNUMxMC43MzYzIDYuMTg5NzkgMTAuODI1OCA2LjQxNzU0IDEwLjk4ODUgNi41ODAyMUMxMS4xNTExIDYuNzQyODkgMTEuMzcwOCA2LjgzMjM2IDExLjYwNjYgNi44MzIzNkMxMS44NDI1IDYuODMyMzYgMTIuMDYyMSA2Ljc0Mjg5IDEyLjIyNDggNi41ODAyMUMxMi4zODc1IDYuNDE3NTQgMTIuNDc3IDYuMTk3OTMgMTIuNDc3IDUuOTYyMDVDMTIuNDc3IDUuNDgyMTYgMTIuMDg2NSA1LjA5MTc0IDExLjYwNjYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZD0iTTE3LjEyOTggMTEuMDM3NVYwLjg2MjE4M0gwLjg2MjMwNVYxMC44NzQ4TDUuMTE2MjYgMTAuOTE1NUw5LjA1MyAxNC44NTIyTDEyLjg4NCAxMS4wMjk0TDE3LjEyOTggMTEuMDM3NVoiIHN0cm9rZT0iIzMzMkQzNyIgc3Ryb2tlLXdpZHRoPSIxLjUiLz4KPC9zdmc+", NV = ue.div`
  background-color: white;
  padding: 20px 0;
  min-height: 150px;
  border: 1px solid var(--gray-400);
  border-left: 1px solid var(--gray-600);
  box-shadow: inset 0px 0px 4px var(--gray-600);
  border-radius: var(--border-radius);
  color: var(--gray-900);

  & h1 {
    font-size: 20px;
    padding-left: 100px;
    margin-bottom: 0;
  }
`, sge = ue.hr`
  border: none;
  height: 1px;
  background-color: var(--gray-600);
  margin-top: 20px;
  margin-bottom: 0;
`, oge = ue.div`
  margin-left: 100px;
  border-left: 1px solid var(--gray-600);

  & ul,
  p {
    margin-top: 0;
  }
`, age = ue.p`
  padding: 10px 6px;

  img {
    margin: 0 5px;
    transform: translateY(20%);
  }

  span {
    color: #e7473c;
    line-height: 25px;
    font-size: 10px;
    margin: 0 5px;
  }
`;
NV.defaultProps = {
  className: "myst-resolved"
};
function Cx(e, t) {
  return e.resolvedDate - t.resolvedDate;
}
const lge = ({
  ycomments: e
}) => {
  let [t, n] = mn(e.resolver().resolved().sort(Cx)), r = Dn(() => t.reduce((s, {
    commentId: o
  }) => (s[o] = e.getTextForComment(o).toString(), s), {}), [t]), i = Dn(() => t.map((s) => e.lineAuthors(s.commentId)), [t]);
  return lr(() => {
    n(e.resolver().resolved().sort(Cx)), e.resolver().onUpdate((s) => n(s.sort(Cx)));
  }, []), Kt` <${NV}>
    <h1>Resolved comments</h1>
    <${sge} />
    <${oge}>
      ${t.length === 0 ? Kt`<${age}
            >No resolved comments yet, to resolve a comment hover over it's icon <img src=${ige} /> and click <span>RESOLVE</span><//
          >` : t.map((s, o) => Kt`<${rge}
                key=${s.commentId}
                c=${s}
                authors=${i[o]}
                ycomments=${e}
                content=${r[s.commentId]}
              />`)}
    <//>
  <//>`;
};
var b7;
(b7 = window.myst_editor) != null && b7.isFresh || (yI(), window.myst_editor = {
  isFresh: !0
});
const cge = ue.div`
  display: flex;
  flex-flow: row wrap;
  width: 100%;
  ${(e) => e.fullscreen && "position: fixed; left: 0; top: 0; z-index: 10;"}
  ${(e) => {
  switch (e.mode) {
    case "Preview":
      return ".myst-main-editor { display: none } .myst-resolved { display: none }";
    case "Source":
      return ".myst-preview { display: none } .myst-resolved { display: none }";
    case "Diff":
      return ".myst-main-editor { display: none }; .myst-preview { display: none } .myst-resolved { display: none }";
    case "Both":
      return ".myst-resolved { display: none }";
    case "Resolved":
      return ".myst-preview { display: none };";
    default:
      return "";
  }
}}
`, BV = ue.div`
  padding: 20px;
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(50%, 1fr);
  grid-template-rows: max-content;
  box-sizing: border-box;
  width: 100%;
  position: relative;
  background-color: white;
  ${(e) => e.fullscreen && "box-sizing:border-box; height: calc(100vh - 60px); overflow-y: scroll;"}
`;
BV.defaultProps = {
  className: "myst-editor-wrapper"
};
const y7 = ue.div`
  height: 40px;
  position: sticky;
  z-index: 10;
  width: 100%;
  top: 60px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: ${(e) => e.error ? "var(--red-500)" : "var(--blue-100)"};
  color: ${(e) => e.error ? "white" : "inherit"};
  font-weight: 600;
`, hge = (e) => {
  const t = (n, r, i) => {
    n.type == "rule" && (n.props[0] = n.props[0].split(",").map((s) => `${e} ${s}`).join(","));
  };
  return Object.defineProperty(t, "name", {
    value: `scope-${e}`
  }), t;
}, uge = (e) => document.documentElement.style.overflow = e ? "hidden" : "visible", xf = {
  printToPdf: {
    id: "print-to-pdf",
    tooltip: "Print document as pdf",
    action: () => window.print()
  },
  templateManager: {
    id: "template-manager"
  },
  copyHtml: {
    id: "copy-html",
    tooltip: "Copy document as HTML"
  },
  fullscreen: {
    id: "fullscreen",
    tooltip: "Fullscreen"
  },
  refresh: {
    id: "refresh",
    tooltip: "Refresh issue links"
  }
}, fge = [xf.fullscreen, xf.copyHtml, xf.refresh, xf.printToPdf, xf.templateManager], _ge = ({
  name: e = "myst_editor_textarea",
  id: t = "myst_editor_textarea",
  title: n = null,
  initialMode: r = "Both",
  initialText: i = "",
  includeButtons: s = fge,
  topbar: o = !0,
  templatelist: a,
  collaboration: l = {},
  spellcheckOpts: h = {
    dict: "en_US",
    dictionaryPath: "/dictionaries"
  },
  customRoles: u = [],
  transforms: f = [],
  getAvatar: d = (p) => `https://secure.gravatar.com/avatar/${p}?s=30&d=identicon`
}) => {
  const [p, g] = mn(r), [m, y] = mn(!1), O = us(null), x = o1e({
    initialText: i,
    transforms: f,
    customRoles: u,
    preview: O
  }), [_, w] = mn(null), [E, T] = S2((N, tt) => tt.map((Z) => ({
    ...Z,
    avatarUrl: d(Z.login)
  })), []), {
    provider: S,
    undoManager: R,
    ytext: A,
    ydoc: P,
    ready: C,
    error: k
  } = Z1e(l), D = V1e(P, S, d), b = (N, tt) => {
    w(N), setTimeout(() => w(null), tt * 1e3);
  }, M = {
    "copy-html": () => {
      x.copy(), b("copied!", 2);
    },
    fullscreen: () => y((N) => !N),
    refresh: () => {
      yI(), b("Rich links refreshed!", 1), x.refresh();
    }
  }, v = Dn(() => s.map((N) => ({
    ...N,
    action: N.action || M[N.id]
  })), []);
  return lr(() => uge(m), [m]), Kt` <div id="myst-css-namespace">
    <${Zz} stylisPlugins=${[hge("#myst-css-namespace")]}>
      <${cge} mode=${p} fullscreen=${m}>
        ${o && Kt`<${Q1e}
          ...${{
    alert: _,
    users: E,
    text: x,
    templatelist: a,
    buttons: v,
    collaboration: l,
    setMode: g,
    title: n
  }}
        />`}
        ${k && Kt`<${y7} error> ${typeof k == "string" ? k : "No connection to the collaboration server"} <//>`}
        ${l.enabled && !C && !k && Kt`<${y7}>Connecting to the collaboration server ...<//>`}
        <${BV} fullscreen=${m}>
          <${qit}
            ...${{
    mode: p,
    text: x,
    name: e,
    id: t,
    spellcheckOpts: h,
    highlights: f,
    collaboration: {
      opts: l,
      setUsers: T,
      provider: S,
      undoManager: R,
      ytext: A,
      ydoc: P,
      ready: C,
      error: k,
      ycomments: D
    }
  }}
          />
          <${NR} ref=${O} />
          ${p === "Diff" && Kt`<${GR} oldText=${i} text=${x} />`}
          ${l.commentsEnabled && l.resolvingCommentsEnabled && !k && Kt`<${lge} ycomments=${D} />`}
        <//>
      <//>
    <//>
  </div>`;
};
export {
  me as A,
  F_ as B,
  pa as C,
  Gi as D,
  xf as E,
  _ge as M,
  we as _,
  Irt as a,
  vge as b,
  E2 as c,
  fge as d,
  J as e,
  Xy as f,
  ZY as g,
  ul as h,
  uce as i,
  ar as j,
  b5 as k,
  B as l,
  Kt as m,
  de as n,
  qce as o,
  z8 as p,
  ud as q,
  ms as r,
  wt as s,
  Oi as t,
  nhe as u,
  Qu as v,
  qoe as w,
  VF as x,
  _i as y,
  oe as z
};
